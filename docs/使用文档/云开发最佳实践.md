# 云开发最佳实践

## 1. 云函数最佳实践

### 1.1 函数设计原则

#### 单一职责原则
每个云函数应该只负责一个明确的功能：
- `analysis` - 情感分析
- `chat` - 聊天处理
- `roles` - 角色管理
- `login` - 用户登录
- `user` - 用户管理

#### 函数大小控制
- 单个云函数代码不超过 500 行
- 复杂逻辑拆分为多个辅助函数
- 使用模块化设计

### 1.2 性能优化

#### 内存配置优化
```javascript
// 根据函数复杂度配置内存
const functionConfigs = {
  // 分析函数需要较大内存
  analysis: {
    memorySize: 512,
    timeout: 20
  },
  // 聊天函数中等内存
  chat: {
    memorySize: 256,
    timeout: 15
  },
  // 简单函数小内存
  login: {
    memorySize: 128,
    timeout: 5
  }
};
```

#### 冷启动优化
```javascript
// 使用全局变量缓存常用对象
let cachedDb = null;
let cachedAxios = null;

exports.main = async (event, context) => {
  // 初始化缓存
  if (!cachedDb) {
    cachedDb = cloud.database();
  }
  
  if (!cachedAxios) {
    cachedAxios = require('axios');
  }
  
  // 业务逻辑处理
  return await handleRequest(event, context);
};
```

#### 并发处理
```javascript
// 使用 Promise.all 处理并发请求
async function processMultipleRequests(requests) {
  try {
    const results = await Promise.all(
      requests.map(req => processRequest(req))
    );
    return {
      success: true,
      data: results
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
```

### 1.3 错误处理

#### 统一错误处理
```javascript
class CloudFunctionError extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = 'CloudFunctionError';
  }
}

function handleError(error) {
  console.error('云函数错误:', error);
  
  if (error instanceof CloudFunctionError) {
    return {
      success: false,
      code: error.code,
      message: error.message,
      details: error.details
    };
  }
  
  // 默认错误响应
  return {
    success: false,
    code: 'INTERNAL_ERROR',
    message: '服务器内部错误'
  };
}
```

#### 参数验证
```javascript
function validateParams(params, required) {
  const errors = [];
  
  for (const field of required) {
    if (!params[field]) {
      errors.push(`缺少必需参数: ${field}`);
    }
  }
  
  if (errors.length > 0) {
    throw new CloudFunctionError(
      '参数验证失败',
      'INVALID_PARAMS',
      { errors }
    );
  }
}
```

## 2. 数据库最佳实践

### 2.1 集合设计

#### 合理命名
- 使用小写字母和下划线
- 名称要有意义
- 避免使用保留字

```javascript
// 好的命名
const collections = {
  users: 'users',
  userProfiles: 'user_profiles',
  emotionRecords: 'emotion_records',
  chatMessages: 'chat_messages'
};

// 避免的命名
const badCollections = {
  Users: 'Users',           // 大写字母
  userData: 'user-data',     // 连字符
  temp: 'temp'              // 名称不明确
};
```

#### 数据结构设计
```javascript
// 用户数据结构
const userSchema = {
  _id: 'string',
  openid: 'string',
  nickName: 'string',
  avatarUrl: 'string',
  createTime: 'timestamp',
  lastLoginTime: 'timestamp',
  status: 'number',
  // 扩展字段
  profile: {
    gender: 'number',
    age: 'number',
    bio: 'string'
  }
};
```

### 2.2 索引优化

#### 创建必要的索引
```javascript
// 单字段索引
db.collection('users').createIndex({
  field: 'openid',
  unique: true
});

// 复合索引
db.collection('emotionRecords').createIndex({
  field: 'userId',
  props: {
    createTime: -1
  }
});

// 多字段复合索引
db.collection('messages').createIndex({
  field: 'chatId',
  props: {
    timestamp: -1,
    sender: 1
  }
});
```

#### 索引使用建议
- 为查询条件创建索引
- 为排序字段创建索引
- 避免过多索引影响写入性能
- 定期清理无用索引

### 2.3 查询优化

#### 分页查询
```javascript
async function getPaginatedData(collection, query, page = 1, pageSize = 20) {
  const skip = (page - 1) * pageSize;
  
  const result = await collection
    .where(query)
    .orderBy('createTime', 'desc')
    .skip(skip)
    .limit(pageSize)
    .get();
  
  return {
    data: result.data,
    page,
    pageSize,
    total: result.data.length
  };
}
```

#### 批量操作
```javascript
// 批量插入
async function batchInsert(collection, documents) {
  const batchSize = 20;
  const results = [];
  
  for (let i = 0; i < documents.length; i += batchSize) {
    const batch = documents.slice(i, i + batchSize);
    const result = await collection.add({
      data: batch
    });
    results.push(result);
  }
  
  return results;
}
```

## 3. 缓存策略

### 3.1 前端缓存
```javascript
// miniprogram/utils/cache.js
class FrontendCache {
  constructor() {
    this.cache = new Map();
    this.expireTime = 30 * 60 * 1000; // 30分钟
  }
  
  set(key, data, customExpireTime) {
    const expire = customExpireTime || this.expireTime;
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      expire
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > item.expire) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear() {
    this.cache.clear();
  }
  
  clearExpired() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.expire) {
        this.cache.delete(key);
      }
    }
  }
}
```

### 3.2 云函数缓存
```javascript
// 使用内存缓存（单次调用有效）
let functionCache = new Map();

function getCachedData(key, ttl = 60000) {
  const cached = functionCache.get(key);
  if (!cached) return null;
  
  if (Date.now() - cached.timestamp > ttl) {
    functionCache.delete(key);
    return null;
  }
  
  return cached.data;
}

function setCachedData(key, data, ttl = 60000) {
  functionCache.set(key, {
    data,
    timestamp: Date.now(),
    ttl
  });
}
```

## 4. 监控和日志

### 4.1 性能监控
```javascript
// miniprogram/utils/monitoring.js
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      apiCalls: [],
      functionCalls: [],
      errors: []
    };
  }
  
  logApiCall(apiName, duration, success) {
    this.metrics.apiCalls.push({
      apiName,
      duration,
      success,
      timestamp: Date.now()
    });
    
    // 如果响应时间过长，记录警告
    if (duration > 3000) {
      console.warn(`API ${apiName} 响应时间过长: ${duration}ms`);
    }
  }
  
  logFunctionCall(functionName, duration, success) {
    this.metrics.functionCalls.push({
      functionName,
      duration,
      success,
      timestamp: Date.now()
    });
  }
  
  logError(error, context) {
    this.metrics.errors.push({
      error: error.message,
      context,
      timestamp: Date.now()
    });
  }
  
  getReport() {
    const now = Date.now();
    const lastHour = now - 60 * 60 * 1000;
    
    return {
      apiCalls: this.metrics.apiCalls.filter(call => call.timestamp > lastHour),
      functionCalls: this.metrics.functionCalls.filter(call => call.timestamp > lastHour),
      errors: this.metrics.errors.filter(error => error.timestamp > lastHour),
      summary: this.generateSummary()
    };
  }
  
  generateSummary() {
    const recentCalls = this.metrics.apiCalls.filter(
      call => call.timestamp > Date.now() - 60 * 60 * 1000
    );
    
    if (recentCalls.length === 0) {
      return {
        totalCalls: 0,
        averageResponseTime: 0,
        successRate: 0
      };
    }
    
    const totalTime = recentCalls.reduce((sum, call) => sum + call.duration, 0);
    const successfulCalls = recentCalls.filter(call => call.success).length;
    
    return {
      totalCalls: recentCalls.length,
      averageResponseTime: Math.round(totalTime / recentCalls.length),
      successRate: Math.round((successfulCalls / recentCalls.length) * 100)
    };
  }
}
```

### 4.2 日志记录
```javascript
// cloudfunctions/utils/logger.js
class Logger {
  constructor(level = 'info') {
    this.level = level;
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3
    };
  }
  
  log(level, message, meta = {}) {
    if (this.levels[level] > this.levels[this.level]) {
      return;
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...meta
    };
    
    console.log(JSON.stringify(logEntry));
  }
  
  error(message, meta = {}) {
    this.log('error', message, meta);
  }
  
  warn(message, meta = {}) {
    this.log('warn', message, meta);
  }
  
  info(message, meta = {}) {
    this.log('info', message, meta);
  }
  
  debug(message, meta = {}) {
    this.log('debug', message, meta);
  }
}

const logger = new Logger(process.env.LOG_LEVEL || 'info');
```

## 5. 安全最佳实践

### 5.1 输入验证
```javascript
function sanitizeInput(input) {
  if (typeof input === 'string') {
    // 移除潜在的恶意字符
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .trim();
  }
  
  return input;
}

function validateEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

function validatePhoneNumber(phone) {
  const phoneRegex = /^1[3-9]\d{9}$/;
  return phoneRegex.test(phone);
}
```

### 5.2 权限控制
```javascript
// 云函数权限检查
async function checkPermission(userId, resource, action) {
  try {
    // 检查用户是否存在
    const user = await db.collection('users')
      .doc(userId)
      .get();
    
    if (!user.data) {
      throw new Error('用户不存在');
    }
    
    // 检查用户状态
    if (user.data.status !== 1) {
      throw new Error('用户已被禁用');
    }
    
    // 检查资源权限
    if (resource === 'role') {
      return await checkRolePermission(userId, action);
    }
    
    return true;
  } catch (error) {
    console.error('权限检查失败:', error);
    return false;
  }
}
```

### 5.3 数据加密
```javascript
// 敏感数据加密
const crypto = require('crypto');

function encryptData(data, key) {
  const cipher = crypto.createCipher('aes-256-cbc', key);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}

function decryptData(encrypted, key) {
  const decipher = crypto.createDecipher('aes-256-cbc', key);
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}
```

## 6. 成本优化

### 6.1 资源使用监控
```javascript
// 云函数调用次数统计
const functionStats = {
  analysis: { count: 0, totalTime: 0 },
  chat: { count: 0, totalTime: 0 },
  roles: { count: 0, totalTime: 0 }
};

function logFunctionCall(functionName, duration) {
  if (functionStats[functionName]) {
    functionStats[functionName].count++;
    functionStats[functionName].totalTime += duration;
  }
  
  // 如果调用次数过多，发送警告
  if (functionStats[functionName].count > 1000) {
    console.warn(`函数 ${functionName} 调用次数过多: ${functionStats[functionName].count}`);
  }
}
```

### 6.2 缓存优化
```javascript
// 智能缓存策略
class SmartCache {
  constructor() {
    this.cache = new Map();
    this.hitRate = 0;
    this.totalRequests = 0;
  }
  
  get(key) {
    this.totalRequests++;
    const item = this.cache.get(key);
    
    if (item && Date.now() - item.timestamp < item.ttl) {
      this.hitRate++;
      return item.data;
    }
    
    this.cache.delete(key);
    return null;
  }
  
  set(key, data, ttl = 300000) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
    
    // 如果缓存过大，清理最旧的项
    if (this.cache.size > 100) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
  }
  
  getHitRate() {
    return this.totalRequests > 0 ? this.hitRate / this.totalRequests : 0;
  }
}
```

这些最佳实践将帮助你更好地使用云开发，提高应用性能和稳定性。
# 情绪波动指数实现计划

<<<<<<< HEAD
## 一、需求分析1
=======
## 一、需求分析
>>>>>>> 699ea41fb50dadce9f994f35fc5c4a35301e4144

### 1.1 功能需求
- 根据用户的情绪历史记录，计算真实的情绪波动指数
- 替换当前硬编码的示例数据
- 显示波动指数的变化趋势（与上周对比）
- 提供波动原因的分析

### 1.2 数据来源
- 从 `emotionRecords` 集合中获取的用户情绪历史记录
- 每条记录包含情绪类型、情绪强度、创建时间等信息

### 1.3 技术要点
- 情绪波动指数的计算算法
- 时间段划分（本周、上周、上上周）
- 数据处理和可视化
- 波动原因分析逻辑

## 二、实现方案

### 2.1 情绪波动指数计算算法

我们将采用以下几个维度来计算情绪波动指数：

1. **情绪强度变化**：计算情绪强度（intensity）的标准差
2. **情绪类型多样性**：计算不同情绪类型的出现频率和转换频率
3. **情绪极性变化**：分析积极情绪和消极情绪之间的转换频率
4. **时间密度**：考虑记录的时间分布密度

综合计算公式：
```
波动指数 = (情绪强度标准差 × 0.4) + (情绪类型多样性 × 0.3) + (情绪极性变化 × 0.2) + (时间密度 × 0.1)
```

最终得分范围：0-100，分数越高表示情绪波动越大。

### 2.2 波动级别划分

根据波动指数的分值，划分为以下级别：
- 0-20：非常稳定
- 21-40：稳定
- 41-60：中等
- 61-80：波动
- 81-100：剧烈波动

### 2.3 波动原因分析

根据以下因素分析波动原因：
- 主导情绪类型
- 情绪类型变化模式
- 情绪强度变化模式
- 时间分布特征

### 2.4 时间段划分

- 本周：最近7天
- 上周：7-14天前
- 上上周：14-21天前

## 三、实现步骤

### 3.1 修改 `processEmotionData` 函数

1. 按时间段分组情绪记录
2. 计算各时间段的情绪波动指数
3. 分析波动原因
4. 更新页面数据

### 3.2 实现情绪波动指数计算函数

1. 计算情绪强度标准差
2. 计算情绪类型多样性
3. 计算情绪极性变化
4. 计算时间密度
5. 综合计算波动指数

### 3.3 实现波动原因分析函数

1. 分析主导情绪类型
2. 分析情绪类型变化模式
3. 分析情绪强度变化模式
4. 生成波动原因描述

### 3.4 更新图表数据

1. 更新波动指数柱状图数据
2. 设置适当的颜色和标签

### 3.5 更新页面显示

1. 更新波动指数值
2. 更新波动级别
3. 更新变化百分比
4. 更新波动原因描述

## 四、代码实现计划

### 4.1 添加辅助函数

```javascript
// 计算标准差
function calculateStandardDeviation(values) {
  // 实现标准差计算
}

// 计算情绪类型多样性
function calculateEmotionDiversity(records) {
  // 实现情绪类型多样性计算
}

// 计算情绪极性变化
function calculateEmotionPolarityChanges(records) {
  // 实现情绪极性变化计算
}

// 计算时间密度
function calculateTimeDensity(records) {
  // 实现时间密度计算
}

// 获取波动级别
function getVolatilityLevel(index) {
  // 根据指数返回级别
}

// 分析波动原因
function analyzeVolatilityReason(currentRecords, previousRecords) {
  // 实现波动原因分析
}
```

### 4.2 修改 `processEmotionData` 函数

```javascript
processEmotionData: function(records) {
  // 按时间段分组
  const currentWeekRecords = [];
  const lastWeekRecords = [];
  const twoWeeksAgoRecords = [];
  
  // 分组逻辑...
  
  // 计算各时间段的波动指数
  const currentVolatility = this.calculateVolatilityIndex(currentWeekRecords);
  const lastVolatility = this.calculateVolatilityIndex(lastWeekRecords);
  const twoWeeksAgoVolatility = this.calculateVolatilityIndex(twoWeeksAgoRecords);
  
  // 计算变化百分比
  const changePercent = this.calculateChangePercent(currentVolatility, lastVolatility);
  
  // 获取波动级别
  const volatilityLevel = this.getVolatilityLevel(currentVolatility);
  
  // 分析波动原因
  const volatilityReason = this.analyzeVolatilityReason(currentWeekRecords, lastWeekRecords);
  
  // 更新页面数据
  this.setData({
    volatilityIndex: {
      current: currentVolatility,
      previous: lastVolatility,
      changePercent: changePercent
    },
    volatilityLevel: volatilityLevel,
    volatilityReason: volatilityReason
  });
  
  // 更新图表数据
  this.updateVolatilityChart(twoWeeksAgoVolatility, lastVolatility, currentVolatility);
}
```

### 4.3 实现 `calculateVolatilityIndex` 函数

```javascript
calculateVolatilityIndex: function(records) {
  if (!records || records.length === 0) {
    return 0;
  }
  
  // 提取情绪强度值
  const intensities = records.map(record => record.analysis.intensity || 0.5);
  
  // 计算情绪强度标准差
  const intensityStdDev = this.calculateStandardDeviation(intensities);
  
  // 计算情绪类型多样性
  const emotionDiversity = this.calculateEmotionDiversity(records);
  
  // 计算情绪极性变化
  const polarityChanges = this.calculateEmotionPolarityChanges(records);
  
  // 计算时间密度
  const timeDensity = this.calculateTimeDensity(records);
  
  // 综合计算波动指数
  const volatilityIndex = (intensityStdDev * 0.4) + (emotionDiversity * 0.3) + 
                          (polarityChanges * 0.2) + (timeDensity * 0.1);
  
  // 将结果映射到0-100范围
  return Math.round(volatilityIndex * 100);
}
```

### 4.4 实现 `updateVolatilityChart` 函数

```javascript
updateVolatilityChart: function(twoWeeksAgo, lastWeek, currentWeek) {
  // 获取图表组件
  const volatilityChart = this.selectComponent('#volatilityChart');
  if (!volatilityChart) return;
  
  // 获取图表实例
  const chart = volatilityChart.chart;
  if (!chart) return;
  
  // 更新数据
  const option = {
    series: [{
      data: [
        {
          value: twoWeeksAgo,
          itemStyle: { color: this.getColorByValue(twoWeeksAgo) }
        },
        {
          value: lastWeek,
          itemStyle: { color: this.getColorByValue(lastWeek) }
        },
        {
          value: currentWeek,
          itemStyle: { color: this.getColorByValue(currentWeek) }
        }
      ]
    }]
  };
  
  chart.setOption(option);
}
```

## 五、测试计划

### 5.1 单元测试
- 测试各个计算函数的正确性
- 测试边界条件（无数据、单条数据等）
- 测试不同情绪模式下的计算结果

### 5.2 集成测试
- 测试完整的情绪波动指数计算流程
- 测试与页面显示的集成
- 测试与图表显示的集成

### 5.3 用户测试
- 测试不同用户情绪数据下的显示效果
- 验证波动原因分析的准确性和可理解性

## 六、实施时间表

1. **准备工作**：1天
   - 研究现有代码
   - 设计算法细节

2. **核心功能实现**：2天
   - 实现辅助函数
   - 实现波动指数计算
   - 实现波动原因分析

3. **图表和UI更新**：1天
   - 实现图表数据更新
   - 更新页面显示

4. **测试和调优**：1天
   - 进行单元测试和集成测试
   - 调整算法参数
   - 优化性能

5. **文档和部署**：1天
   - 编写文档
   - 部署和验证

**总计**：6天

## 七、风险评估与应对策略

### 7.1 数据不足风险
- **风险**：用户情绪记录数量不足，无法计算准确的波动指数
- **应对**：设置最小记录数阈值，低于阈值时显示提示信息或使用默认值

### 7.2 算法准确性风险
- **风险**：算法可能无法准确反映用户的实际情绪波动
- **应对**：进行多轮测试和调优，收集用户反馈不断改进

### 7.3 性能风险
- **风险**：大量数据计算可能影响页面性能
- **应对**：优化算法，考虑使用缓存机制，减少重复计算

### 7.4 用户理解风险
- **风险**：用户可能难以理解波动指数的含义
- **应对**：提供简明的解释和可视化展示，使用通俗易懂的语言描述波动原因

## 八、后续优化方向

1. **算法优化**：根据用户反馈和数据分析，持续优化波动指数计算算法
2. **个性化分析**：考虑用户的个人情绪基线，提供更个性化的波动分析
3. **预测功能**：基于历史数据，预测未来的情绪波动趋势
4. **建议功能**：根据波动分析，提供情绪管理建议
5. **更丰富的可视化**：增加更多可视化图表，如情绪波动热力图、情绪轨迹图等

# HeartChat 微信小程序详细开发计划

## 1. 项目概述与目标

**项目定位**：打造一款基于微信小程序云开发，结合智谱 AI (BigModel) 能力的**情感陪伴与个性化交互 AI 聊天机器人**。通过动态收集用户数据（情绪、兴趣、行为），构建持续进化的用户画像，提供拟人化、富有情感洞察的对话体验，并帮助用户提升自我认知。

**核心目标**：
- **短期**：实现基于智谱 AI 的核心对话功能，集成实时情绪分析与动态响应，完成基本的用户界面和流程。
- **中期**：完善情绪历史记录、每日报告功能，优化用户体验，提供角色定制能力。
- **长期**：构建深入的用户画像分析（如年度总结、兴趣图谱），探索社交或更多增值服务的可能性。

## 2. 技术栈

- **前端框架**：微信小程序原生框架
- **状态管理**：原生 `globalData`, 事件总线 (`wx.event`) 或轻量级状态管理库
- **后端服务**：微信小程序云开发 (云函数、云数据库、云存储)
- **AI 能力**：智谱 AI 开放平台 (开发阶段统一使用 **GLM-4-Flash** 模型进行对话与基础分析；使用 **Embedding-3** 模型进行文本向量化，支持聚类分析、兴趣分析、用户画像构建等；备选能力包括 Fine-tuning, Knowledge Base 等)
- **UI 风格**：参考 iOS Human Interface Guidelines (HIG)，结合微信小程序设计规范，实现简洁、现代的界面。
- **主要语言**：JavaScript (ES6+)

## 3. 开发阶段与任务分解

我们将遵循 `开发文档.md` 中建议的流程，并结合原型图和 AI 能力进行细化。

### 阶段一：基础框架与核心登录 (优先级: 高)

**目标**: 搭建项目基础结构，配置云开发环境，实现用户微信授权登录流程。

**涉及页面/组件/云函数/数据库**:
- 页面: `pages/welcome/welcome`, `pages/home/home` (基础布局)
- 组件: `components/tab-bar/` (若自定义), `components/user-avatar/` (基础)
- 云函数: `cloudfunctions/login/`
- 数据库集合: `users`

**主要任务**:
1.  **项目初始化**:
    *   创建小程序项目，初始化 Git 仓库。
    *   配置 `project.config.json`，启用云开发。
    *   创建云开发环境，记录环境 ID。
    *   按照 `开发文档.md` 规划创建项目目录结构。
    *   初始化 `app.js`，引入云开发初始化代码。
2.  **全局配置 (`app.json`)**:
    *   配置 `pages` 数组，包含 `welcome`, `home` 等初始页面。
    *   配置 `window` 样式（导航栏颜色、背景色等），参考整体 UI 风格。
    *   配置 `tabBar` (若使用原生)，包含"首页"、"情绪记录"、"我的"等 Tab，图标和文字参考 `home.html` 及 `原型设计说明.md`。若使用自定义 TabBar，则创建 `components/tab-bar/`。
    *   配置 `subpackages` 分包结构 (参考 `开发文档.md`)。
3.  **欢迎/登录页面 (`pages/welcome/`)**:
    *   实现 `welcome.wxml` 结构，参考 `原型设计图/welcome.html`，包含应用 Logo、标语、登录按钮。
    *   实现 `welcome.wxss` 样式，遵循 iOS 风格，简洁美观。
    *   实现 `welcome.js` 逻辑：
        *   检查用户是否已登录 (如检查本地存储的 token 或 userinfo)。若已登录，跳转到 `home` 页。
        *   处理"微信登录"按钮点击事件 (`bindtap`)。
        *   调用 `wx.getUserProfile` 获取用户信息 (头像、昵称)。**注意处理用户拒绝授权的情况。**
        *   调用 `wx.login` 获取 code。
        *   调用 `login` 云函数，传递 code 和用户信息。
        *   处理云函数返回结果，保存用户信息和登录状态 (如 `openid`, `session_key` 或自定义登录态)，跳转到 `home` 页。
        *   **(@dependency)** 依赖 `login` 云函数。
4.  **登录云函数 (`cloudfunctions/login/`)**:
    *   接收 `code` 和 `userInfo`。
    *   调用微信接口 `auth.code2Session` 获取 `openid` 和 `session_key`。
    *   根据 `openid` 查询 `users` 集合，判断用户是否存在。
    *   若用户不存在，创建新用户记录，保存 `openid`、`userInfo` (昵称、头像、性别等)、`create_time`。
    *   若用户存在，更新 `last_login_time` 和 `userInfo` (如果允许更新)。
    *   **(@architecture)** 返回 `openid` 及用户在数据库中的信息给小程序端。可以考虑生成自定义登录态返回。
    *   **(@dependency)** 依赖 `users` 数据库集合。
5.  **用户数据库集合 (`users`)**:
    *   在云开发控制台创建 `users` 集合。
    *   根据 `开发文档.md` 定义字段 (_id, openid, nickname, avatar_url, gender, create_time, last_login_time, status 等)。
    *   设置合适的数据库权限规则 (例如，用户只能读写自己的信息)。
6.  **主页 (`pages/home/`)**:
    *   实现 `home.wxml` 基础结构，参考 `原型设计图/home.html`，包含顶部用户信息区域、功能入口卡片区域。
    *   实现 `home.wxss` 样式。
    *   实现 `home.js` 逻辑：
        *   在 `onLoad` 或 `onShow` 中获取并显示当前用户信息。
        *   处理功能入口卡片的点击事件，跳转到相应页面 (如 `role-select`)。
7.  **工具函数 (`utils/`)**:
    *   创建 `utils/auth.js`, 封装检查登录状态、保存/获取用户信息的函数。
    *   创建 `utils/api.js`, 封装调用云函数的基础方法。

### 阶段二：角色选择与 AI 对话基础 (优先级: 高)

**目标**: 实现 AI 角色列表展示与选择，搭建聊天界面，对接智谱 AI 实现基础对话功能。

**涉及页面/组件/云函数/数据库**:
- 页面: `pages/role-select/role-select`, `packageChat/pages/chat/chat`
- 组件: `components/role-card/`, `components/chat-bubble/`, `components/chat-input/`
- 云函数: `cloudfunctions/role/`, `cloudfunctions/chat/`
- 数据库集合: `roles`, `chats`, `messages`

**主要任务**:
1.  **角色数据库集合 (`roles`)**:
    *   创建 `roles` 集合。
    *   根据 `开发文档.md` 定义字段 (_id, name, avatar, description, tags, prompt, creator_id, is_system, create_time 等)。
    *   预置几个系统角色数据，包含精心设计的 `prompt`，用于指导智谱 AI 的行为。
    *   设置数据库权限 (例如，普通用户只读，管理员可写)。
2.  **角色管理云函数 (`cloudfunctions/role/`)**:
    *   实现获取角色列表的功能 (默认获取系统角色)。
    *   允许按需扩展，支持获取用户自定义角色、角色详情等。
    *   **(@dependency)** 依赖 `roles` 数据库集合。
3.  **角色选择页面 (`pages/role-select/`)**:
    *   实现 `role-select.wxml` 结构，参考 `原型设计图/role-select.html`，使用 `wx:for` 循环展示角色列表。
    *   实现 `role-select.wxss` 样式，卡片式布局，参考 `role-card` 组件设计。
    *   实现 `role-select.js` 逻辑：
        *   在 `onLoad` 中调用 `role` 云函数获取角色列表。
        *   处理角色卡片的点击事件，记录用户选择的角色 ID，并跳转到 `chat` 页面，传递 `role_id`。
    *   **(@dependency)** 依赖 `role` 云函数和 `role-card` 组件。
4.  **角色卡片组件 (`components/role-card/`)**:
    *   实现组件结构和样式，参考 `原型设计图/role-select.html` 中的卡片样式，包含头像、名称、描述、标签等。
    *   接收角色数据作为 `properties`。
    *   触发点击事件 (`bind:tap`) 并传递角色 ID。
5.  **聊天数据库集合 (`chats`, `messages`)**:
    *   创建 `chats` 集合，字段参考 `开发文档.md` (_id, user_id, role_id, role_name, create_time, last_message_time, message_count)。
    *   创建 `messages` 集合，字段参考 `开发文档.md` (_id, chat_id, sender_type, content, timestamp, emotion_type[可选], emotion_id[可选])。
    *   设置数据库权限。
6.  **聊天页面 (`packageChat/pages/chat/`)**:
    *   实现 `chat.wxml` 结构，参考 `原型设计图/chat.html`，包含顶部角色信息、中部消息展示区域 (使用 `scroll-view`)、底部输入区域 (使用 `chat-input` 组件)。
    *   实现 `chat.wxss` 样式，区分用户和 AI 的气泡。
    *   实现 `chat.js` 逻辑：
        *   在 `onLoad` 中接收传递的 `role_id`，获取并显示角色信息。
        *   加载历史消息 (调用 `chat` 云函数)。**(@architecture)** 需要实现分页加载。
        *   监听 `chat-input` 组件的发送事件。
        *   发送消息时：
            *   将用户消息展示在界面上。
            *   调用 `chat` 云函数，传递用户输入内容、`chat_id` (如果已有)、`role_id`。
            *   显示 AI 回复中状态。
        *   处理 `chat` 云函数返回的 AI 回复，将其展示在界面上。
        *   **(@architecture)** 实现滚动到底部逻辑。
    *   **(@dependency)** 依赖 `chat` 云函数, `chat-bubble`, `chat-input` 组件。
7.  **聊天气泡组件 (`components/chat-bubble/`)**:
    *   实现组件结构和样式，参考 `原型设计图/chat.html`，区分用户和 AI 样式 (如背景色、对齐方式)。
    *   接收消息内容、发送者类型等作为 `properties`。
8.  **聊天输入组件 (`components/chat-input/`)**:
    *   实现组件结构和样式，参考 `原型设计图/chat.html`，包含 `input` 或 `textarea`、发送按钮。
    *   实现 `value` 绑定和输入事件处理。
    *   触发发送事件 (`bind:send`) 并传递输入内容。
9.  **聊天云函数 (`cloudfunctions/chat/`)**:
    *   **核心功能**: 接收用户消息，调用智谱 AI，返回回复。
    *   **输入**: `userId`, `roleId`, `userMessage`, `chatId` (可选, 用于加载历史或续写)。
    *   **逻辑**:
        *   验证输入参数。
        *   **(@security) 配置 API Key**: 从云函数**环境变量**或安全的配置文件（需加入 `.gitignore`）中读取智谱 AI API Key。**严禁将 API Key 硬编码在代码中！**
        *   根据 `roleId` 从 `roles` 集合获取角色的 `prompt`。
        *   **(@architecture)** 加载最近的对话历史 (从 `messages` 集合查询，限制数量以防 token 超限，需考虑免费版/VIP版的差异化限制，但**现阶段统一按较短限制处理**)。
        *   组装发送给智谱 AI API 的 `messages` 数组 (包含系统 `prompt`、历史消息、当前用户消息)。
        *   **(@dependency)** 调用智谱 AI API，**指定模型为 `glm-4.5-flash`**。参考[智谱 API 文档](https://www.bigmodel.cn/dev/api/normal-model/glm-4)。
        *   获取 AI 回复内容。
        *   **(@architecture)** 保存用户消息和 AI 回复到 `messages` 集合，关联 `chat_id` (如果 `chatId` 为空，则先创建 `chats` 记录)。更新 `chats` 集合的 `last_message_time` 和 `message_count`。
        *   返回 AI 回复内容给小程序端。
    *   **扩展功能**: 实现获取历史消息的接口 (支持分页)。
    *   **(@dependency)** 依赖 `roles`, `chats`, `messages` 数据库集合，依赖智谱 AI API。

### 阶段三：情绪感知与实时分析 (优先级: 中)

**目标**: 在聊天过程中实时分析用户情绪，并将结果用于动态响应或展示。

**涉及页面/组件/云函数/数据库**:
- 页面: `packageChat/pages/emotion-analysis/emotion-analysis` (基础)
- 组件: `components/emotion-card/`, `components/emotion-chart/` (基础)
- 云函数: `cloudfunctions/analysis/` (或在 `chat` 函数中集成)
- 数据库集合: `emotion_records`

**主要任务**:
1.  **情绪记录数据库集合 (`emotion_records`)**:
    *   创建 `emotion_records` 集合。
    *   根据 `开发文档.md` 定义字段 (_id, user_id, message_id, chat_id, emotion_type, emotion_intensity, keywords, timestamp, suggestions[可选])。
    *   设置数据库权限。
2.  **情绪分析集成**:
    *   **策略**: 采用**每轮对话分析**策略。分析当前用户发送的消息，并将分析结果作为参考信息提供给 AI，以影响其下一轮回复。
    *   **方案选择**: 推荐采用**方案 B (集成到 `chat` 云函数)**，在调用智谱 AI 生成回复的同时进行情绪分析，减少 API 调用次数。备选方案是使用独立的云函数或外部 API (如百度云情绪分析)。
    *   **实现 (以方案 B 为例)**:
        *   修改 `chat` 云函数的 `Prompt`，增加指令，要求 GLM-4-Flash 在生成回复的同时，分析用户最后一句话的情绪，并在回复的 JSON 中包含 `emotion` 字段（值为预定义的情绪标签，如：开心、悲伤、焦虑、平静、愤怒等）。例如：`"请分析用户最后一句话的主要情绪，并在你的回复 JSON 中包含 'emotion' 字段。"`
        *   在调用智谱 AI API (`glm-4.5-flash`) 时，考虑使用 `response_format: { "type": "json_object" }` (JSON 模式) 以确保获取结构化输出。
        *   解析 AI 返回的 JSON，提取回复内容 (`reply`) 和情绪标签 (`emotion`)。
        *   **(@architecture) 将情绪反馈给 AI**: 在下一次调用 `chat` 云函数与该用户继续对话时，将本次分析出的 `emotion` 标签作为参考信息，通过特定的 `system` 消息添加到发送给 GLM-4-Flash 的 `messages` 数组中。例如：`{"role": "system", "content": "参考信息：用户上一轮的情绪识别为 '[识别出的情绪标签]'，请在本次回复中适当考虑这一点。"}` 或者直接优化角色的 Prompt 让其能自主处理情绪。
        *   将情绪信息 (emotion_type, message_id, chat_id, user_id, timestamp) 保存到 `emotion_records` 集合。
        *   **(@future_optimization)** 未来可以考虑使用 **Embedding-3** 对带有情绪标签的用户消息文本进行向量化，存储向量。这可以支持更高级的情绪模式分析，例如：
            *   通过聚类分析相似情绪状态下的对话内容。
            *   计算不同时间段情绪向量的相似性。
    *   **备用方案**: 保留百度云情绪分析 API 作为特定场景下或性能要求较高时的备选方案。
3.  **情绪分析页面 (`packageChat/pages/emotion-analysis/`)**:
    *   实现 `emotion-analysis.wxml` 基础结构，参考 `原型设计图/emotion-analysis.html`，用于展示单次对话或某条消息的情绪分析结果。
    *   实现 `emotion-analysis.wxss` 样式。
    *   实现 `emotion-analysis.js` 逻辑：
        *   接收 `message_id` 或 `chat_id` 作为参数。
        *   调用云函数 (可能是 `analysis` 或 `chat` 的新接口) 获取对应的情绪分析结果。
        *   展示情绪类型、关键词 (如果 AI 能提供)、情绪强度 (如果 AI 能提供)。
4.  **情绪卡片/图表组件 (基础)**:
    *   `components/emotion-card/`: 实现基础样式，展示情绪类型和图标。
    *   `components/emotion-chart/`: 实现简单的图表占位或基础展示 (如文字显示情绪)。

### 阶段四：情绪历史与报告 (优先级: 中)

**目标**: 提供情绪变化的可视化历史记录和周期性总结报告。

**涉及页面/组件/云函数**:
- 页面: `packageEmotion/pages/emotion-history/emotion-history`, `packageEmotion/pages/daily-report/daily-report`
- 组件: `components/emotion-chart/` (完善)
- 云函数: `cloudfunctions/analysis/` (扩展接口)

**主要任务**:
1.  **情绪历史页面 (`packageEmotion/pages/emotion-history/`)**:
    *   实现 `emotion-history.wxml` 结构，参考 `原型设计图/emotion-history.html`，包含日期筛选器、情绪趋势图表区域、情绪记录列表。
    *   实现 `emotion-history.wxss` 样式。
    *   实现 `emotion-history.js` 逻辑：
        *   调用云函数获取指定时间段的情绪记录。
        *   将数据传递给 `emotion-chart` 组件绘制趋势图。
        *   展示情绪记录列表。
    *   **(@dependency)** 依赖 `analysis` 云函数 (获取历史接口) 和 `emotion-chart` 组件。
2.  **每日心情报告页面 (`packageEmotion/pages/daily-report/`)**:
    *   实现 `daily-report.wxml` 结构，参考 `原型设计图/daily-report.html`，展示总结文字、情绪分布图、关键词等。
    *   实现 `daily-report.wxss` 样式。
    *   实现 `daily-report.js` 逻辑：
        *   调用云函数获取指定日期的心情报告数据。
        *   展示报告内容。
    *   **(@dependency)** 依赖 `analysis` 云函数 (生成报告接口)。
3.  **情绪图表组件 (`components/emotion-chart/`) (完善)**:
    *   集成图表库 (如 ECharts for WeChat)。
    *   实现绘制情绪趋势线图的功能。
    *   实现绘制情绪分布饼图/柱状图的功能。
    *   处理数据加载和空状态。
4.  **分析云函数 (`cloudfunctions/analysis/`) (扩展)**:
    *   **获取情绪历史接口**:
        *   输入: `userId`, `startDate`, `endDate`。
        *   逻辑: 查询 `emotion_records` 集合，按时间范围筛选并排序。
        *   输出: 情绪记录列表。
    *   **生成每日报告接口**:
        *   输入: `userId`, `date`。
        *   逻辑:
            *   查询指定日期内的 `emotion_records`（**如果已实现，包含文本 Embedding 向量**）。
            *   聚合统计情绪分布。
            *   **(可选) 基于 Embedding 进行聚类**: 如果有足够的情绪记录和向量，可以进行聚类分析，发现当天主要的情绪聚类或异常点。
            *   **(可选)** 将当日相关消息内容或情绪记录，调用智谱 AI (GLM-4-Flash) 进行总结、提取关键词、生成个性化建议。**(可以结合 Embedding 聚类的结果进行更精准的总结)**。
        *   输出: 报告数据 (总结文字, 情绪分布数据, 关键词列表, **(可选) 情绪聚类洞察** 等)。

### 阶段五：用户中心与设置 (优先级: 低)

**目标**: 实现用户个人资料管理、应用设置和使用统计展示。

**涉及页面/组件/云函数/数据库**:
- 页面: `packageUser/pages/profile/profile`, `packageUser/pages/settings/settings`
- 组件: `components/user-avatar/` (完善)
- 云函数: `cloudfunctions/user/`
- 数据库集合: `users`, `user_stats` (或扩展 `users`)

**主要任务**:
1.  **用户统计数据库集合 (`user_stats`)**:
    *   创建 `user_stats` 集合或在 `users` 集合中添加统计字段。
    *   字段参考 `开发文档.md` (total_chats, total_messages, emotion_records_count 等)。
    *   **(@architecture)** 这些统计数据可以在相关操作时 (如发送消息、记录情绪) 通过数据库原子操作更新，或者通过定时触发器定期计算。
2.  **个人资料页面 (`packageUser/pages/profile/`)**:
    *   实现 `profile.wxml` 结构，参考 `原型设计图/profile.html`，展示头像、昵称、使用统计等。
    *   实现 `profile.wxss` 样式。
    *   实现 `profile.js` 逻辑：
        *   获取并显示用户信息和统计数据 (调用 `user` 云函数)。
        *   (可选) 提供编辑昵称、头像的功能。
    *   **(@dependency)** 依赖 `user` 云函数。
3.  **设置页面 (`packageUser/pages/settings/`)**:
    *   实现 `settings.wxml` 结构，参考 `原型设计图/settings.html`，提供通知、隐私等设置项。
    *   实现 `settings.wxss` 样式。
    *   实现 `settings.js` 逻辑，处理设置项的更改和保存 (可能需要 `user` 云函数支持)。
4.  **用户管理云函数 (`cloudfunctions/user/`)**:
    *   **获取用户信息接口**: 返回用户的基本信息和统计数据。
    *   **更新用户信息接口**: 允许用户更新昵称、头像等。
    *   **更新用户设置接口**: 保存用户的偏好设置。
    *   **(@dependency)** 依赖 `users`, `user_stats` 数据库集合。
5.  **用户头像组件 (`components/user-avatar/`) (完善)**:
    *   支持展示不同尺寸的头像。
    *   处理默认头像和图片加载失败的情况。

## 4. UI/UX 注意事项

- **一致性**: 严格遵循 iOS HIG 和微信小程序设计规范，保持界面元素、字体、颜色、间距的一致性。参考 `docs/design/` 下的规则文档。
- **简洁性**: 界面布局清晰，避免信息过载。使用留白，突出核心内容。
- **反馈**: 对用户的操作（点击、加载、错误等）提供及时的视觉反馈 (如 Toast, Loading, 模态框)。
- **导航**: 使用清晰的 TabBar 和页面层级，确保用户容易找到所需功能。
- **性能**: 优化图片大小，使用骨架屏或 Loading 动画减少等待焦虑，关键路径避免耗时操作。
- **可访问性**: 考虑使用 `aria-label` 等属性，适配读屏软件，确保色彩对比度。(参考 `design/accessibility_mp.mdc`)

## 5. 测试计划

- **单元测试**: 对 `utils/` 下的工具函数和部分云函数的纯逻辑部分编写单元测试。
- **集成测试**: 测试小程序端与云函数、云函数与数据库、云函数与智谱 AI API 之间的交互。
- **UI 测试**: 使用微信开发者工具进行界面预览和调试，在不同尺寸的模拟器和真机上测试显示效果和响应式布局。
- **功能测试**: 根据需求文档和原型图，对每个功能点进行手动测试，覆盖正常流程和边界条件。
- **性能测试**: 使用开发者工具的 Audits 面板进行性能评分，关注启动耗时、页面渲染时间、内存占用等。
- **兼容性测试**: 在主流 iOS 和 Android 机型上进行测试。

## 6. 部署计划

- **开发环境**: 使用独立的云开发环境进行开发和测试。
- **代码管理**: 遵循 `docs/global/git_workflow.md`，使用特性分支进行开发，通过 Pull Request 合并到主分支。
- **版本发布**:
    *   在微信开发者工具中上传代码。
    *   提交审核，填写版本信息。
    *   审核通过后，选择全量发布或灰度发布。
- **监控**: 关注小程序后台和云开发控制台的错误日志和性能监控数据。

## 7. 后续迭代方向

- **深化 AI 能力应用**:
    *   **基于 Embedding 的个性化**: 全面利用 **Embedding-3** 构建的用户兴趣画像和情绪模式，实现：
        *   更精准的内容推荐（结合知识库）。
        *   动态调整 AI 对话风格以匹配用户兴趣和情绪状态。
        *   计算用户间相似度，支持潜在的社交功能。
    *   **引入更高级或专用模型**: 评估 GLM-4、Emohaa 等模型在特定场景下的效果提升，并设计付费方案。
    *   **Fine-tuning**: 针对核心用户群体或特定场景进行模型微调。
- 社交功能：允许用户分享心情报告或匿名交流。
- **优化与增强**：
    *   引入更高级的 AI 模型 (如 GLM-4) 或特定模型 (如 Emohaa - 如果适合情感支持场景，需评估 [Emohaa API](https://www.bigmodel.cn/dev/api/super-humanoid/emohaa)) 来提升对话质量和情感理解能力，并考虑引入付费机制。

## 6.1 用户兴趣分析与内容推荐 (核心技术: Embedding-3)

**目标**: 结构化地分析用户对话内容，提取并量化用户兴趣点，构建用户兴趣画像，为未来的个性化推荐和用户理解奠定基础。

**触发时机**: 可以在用户完成一整轮对话后触发，或者**更优的方式是：定期（例如每天或每几天）对用户的近期对话进行批量分析**。

**实现方式**:
1.  创建云函数 (例如 `interest_analysis`)，负责处理兴趣分析任务。
2.  **数据准备**: 获取用户在指定时间段内的对话消息 (用户发送的内容)。可以进行适当的预处理（如去停用词，但对于现代 Embedding 模型可能非必需）。
3.  **调用 Embedding-3**: 将筛选出的用户对话文本片段**调用智谱 AI 的 Embedding-3 API**，获取每个片段的语义向量。
4.  **兴趣向量存储**: 将生成的 Embedding 向量与对应的用户 ID、时间戳、原始文本片段（可选）等信息，存储到专门的数据库集合中（例如 `user_interest_vectors`）。
5.  **兴趣分析与画像构建 (后端处理)**:
    *   **兴趣聚类**: 定期对某个用户的兴趣向量进行**聚类分析** (如 K-Means)，自动发现用户的主要兴趣簇。
    *   **兴趣标签匹配**: 可以预定义一个兴趣标签库 (如"电影"、"音乐"、"旅行"、"心理学"等)，并将这些标签也通过 Embedding-3 向量化。通过计算用户对话向量与标签向量的**余弦相似度**，为用户打上相关的兴趣标签及置信度。
    *   **用户兴趣画像向量**: 可以通过聚合（如加权平均）用户的兴趣向量，形成一个代表该用户整体兴趣的**用户画像向量**，存储在 `users` 或 `user_profile` 集合中。
6.  **关键词提取的补充**: Embedding 本身不直接提取关键词，但可以在 GLM-4-Flash 提取关键词后，使用 Embedding 计算关键词与原文的语义相关度，进行筛选和排序。或者，直接将聚类中心或兴趣标签作为用户的"关键词"。
7.  **内容推荐 (后续迭代)**:
    *   基于用户的兴趣标签推荐相关内容。
    *   基于用户画像向量，计算用户与其他用户或内容的相似度，进行协同过滤或基于内容的推荐。
    *   结合知识库 (`Knowledge Base`)，将用户的兴趣向量与知识库条目的向量进行匹配，推荐相关知识。
8.  **备用方案**: HanLP 或 GLM-4-Flash 提取关键词/主题可以作为 Embedding 分析的补充或在数据量不足时的备选。

**成本与复杂性考量**: Embedding-3 API 调用有成本。基于 Embedding 的分析需要更复杂的后端数据处理和可能的算法实现（如聚类）。

---

**本文档将作为项目开发的主要依据，并会根据开发进度和实际情况进行动态更新。** 
3.4.2 用户画像构建算法
用户画像构建是心语精灵的重要功能，通过分析用户的对话内容、情感数据和行为特征，构建动态进化的用户兴趣和性格特征画像。本节详细介绍用户画像构建算法的设计与实现。

用户画像模型设计
心语精灵的用户画像模型包含两个核心维度：兴趣画像和性格特征画像，共同构成对用户的全面理解。

兴趣画像模型
兴趣画像主要通过提取用户对话中的关键词和主题，识别用户关注的领域和话题：

兴趣类别：将用户兴趣分为多个类别，如学习、工作、娱乐、社交、健康、家庭等
兴趣标签：每个类别下包含多个具体的兴趣标签
权重系统：为每个兴趣标签分配权重，反映用户对该兴趣的关注度
时间衰减：引入时间衰减因子，使近期表达的兴趣具有更高权重
兴趣画像的数据结构设计如下：
// 兴趣画像数据结构
const interestProfile = {
  userId: "string",           // 用户ID
  keywords: [                 // 关键词列表
    {
      word: "string",         // 关键词
      weight: number,         // 权重(0.0-1.0)
      count: number,          // 出现次数
      lastMentioned: Date     // 最后提及时间
    }
  ],
  categories: [               // 兴趣分类
    {
      name: "string",         // 分类名称
      weight: number,         // 权重(0.0-1.0)
      keywords: ["string"]    // 关联关键词
    }
  ],
  updateTime: Date            // 更新时间
};
性格特征画像模型
性格特征画像基于用户的情感表达模式、语言风格和交互行为，描述用户的性格特点：

情感倾向：用户倾向于表达的情感类型和强度
表达风格：用户的语言表达特点，如简洁/详细、正式/随意等
社交特征：用户的社交偏好和互动方式
决策风格：用户的决策倾向，如理性/感性、谨慎/冒险等
性格特征画像的数据结构设计如下：
// 性格特征画像数据结构
const personalityProfile = {
  userId: "string",           // 用户ID
  emotionalTendency: {        // 情感倾向
    dominant: "string",       // 主导情绪
    intensity: number,        // 情绪强度
    stability: number,        // 情绪稳定性
    positivity: number        // 积极性倾向
  },
  expressionStyle: {          // 表达风格
    verbosity: number,        // 话语冗长度
    formality: number,        // 正式程度
    complexity: number,       // 复杂度
    creativity: number        // 创造性
  },
  socialTraits: {             // 社交特征
    openness: number,         // 开放性
    engagement: number,       // 参与度
    responsiveness: number    // 响应性
  },
  decisionStyle: {            // 决策风格
    rational: number,         // 理性程度
    cautious: number,         // 谨慎程度
    independent: number       // 独立性
  },
  updateTime: Date            // 更新时间
};
用户画像构建算法流程
心语精灵的用户画像构建算法包括以下核心步骤：

1. 数据收集与预处理
用户画像构建首先需要收集和预处理用户数据：
// 用户数据收集
async function collectUserData(userId, timeWindow = 30) {
  try {
    const db = cloud.database();
    const _ = db.command;
    const now = new Date();
    const startTime = new Date(now.getTime() - timeWindow * 24 * 60 * 60 * 1000); // 过去30天
    
    // 收集用户消息
    const messagesResult = await db.collection('messages')
      .where({
        userId: userId,
        sender: 'user',
        createTime: _.gte(startTime)
      })
      .orderBy('createTime', 'desc')
      .get();
    
    // 收集情感记录
    const emotionsResult = await db.collection('emotionRecords')
      .where({
        userId: userId,
        timestamp: _.gte(startTime)
      })
      .orderBy('timestamp', 'desc')
      .get();
    
    // 收集用户行为数据
    const behaviorsResult = await db.collection('userBehaviors')
      .where({
        userId: userId,
        timestamp: _.gte(startTime)
      })
      .orderBy('timestamp', 'desc')
      .get();
    
    return {
      messages: messagesResult.data || [],
      emotions: emotionsResult.data || [],
      behaviors: behaviorsResult.data || []
    };
  } catch (error) {
    console.error('收集用户数据失败:', error);
    return {
      messages: [],
      emotions: [],
      behaviors: []
    };
  }
}

// 数据预处理
function preprocessUserData(data) {
  // 处理消息数据
  const processedMessages = data.messages.map(msg => ({
    content: msg.content,
    timestamp: msg.createTime,
    chatId: msg.chatId,
    messageId: msg._id
  }));
  
  // 处理情感数据
  const processedEmotions = data.emotions.map(emotion => ({
    type: emotion.primary,
    secondary: emotion.secondary,
    intensity: emotion.intensity,
    keywords: emotion.keywords || [],
    timestamp: emotion.timestamp
  }));
  
  // 处理行为数据
  const processedBehaviors = data.behaviors.map(behavior => ({
    type: behavior.type,
    target: behavior.target,
    duration: behavior.duration,
    timestamp: behavior.timestamp
  }));
  
  return {
    messages: processedMessages,
    emotions: processedEmotions,
    behaviors: processedBehaviors
  };
}
数据收集和预处理步骤确保了用户画像构建的数据基础，包括用户的消息内容、情感记录和行为数据。

2. 关键词提取与分类
用户兴趣画像构建的核心是关键词提取与分类：
// 关键词提取
async function extractKeywords(messages, maxKeywords = 100) {
  // 合并所有消息内容
  const allContent = messages.map(msg => msg.content).join(' ');
  
  // 构建关键词提取提示词
  const prompt = `
从以下文本中提取最重要的关键词或短语，按重要性排序：
文本：${allContent}

请返回JSON格式：
{
  "keywords": [
    {"word": "关键词1", "weight": 0.9},
    {"word": "关键词2", "weight": 0.8},
    ...
  ]
}

最多返回${maxKeywords}个关键词。
`;

  try {
    // 调用大语言模型提取关键词
    const result = await callLLMForKeywords(prompt);
    return result.keywords || [];
  } catch (error) {
    console.error('关键词提取失败:', error);
    return [];
  }
}

// 关键词分类
async function classifyKeywords(keywords) {
  // 预定义的兴趣类别
  const predefinedCategories = [
    '学习', '工作', '娱乐', '社交', '健康', '家庭', '艺术', 
    '科技', '体育', '旅行', '美食', '时尚', '金融', '其他'
  ];
  
  // 构建分类提示词
  const prompt = `
请将以下关键词分类到这些类别中：${predefinedCategories.join('、')}
关键词：${keywords.map(k => k.word).join('、')}

请返回JSON格式：
{
  "分类结果": [
    {"keyword": "关键词1", "category": "类别1"},
    {"keyword": "关键词2", "category": "类别2"},
    ...
  ]
}
`;

  try {
    // 调用大语言模型进行分类
    const result = await callLLMForClassification(prompt);
    return result.分类结果 || [];
  } catch (error) {
    console.error('关键词分类失败:', error);
    return [];
  }
}
关键词提取和分类步骤通过大语言模型的能力，从用户消息中提取关键词并将其分类到预定义的兴趣类别中。

3. 词向量生成与聚类分析
为了更精确地理解用户兴趣，心语精灵实现了基于词向量的聚类分析：
// 词向量生成
async function generateWordEmbeddings(keywords) {
  try {
    // 批量处理，每批20个关键词
    const batchSize = 20;
    const batches = [];
    
    for (let i = 0; i < keywords.length; i += batchSize) {
      batches.push(keywords.slice(i, i + batchSize));
    }
    
    // 并行处理每批关键词
    const allEmbeddings = [];
    for (const batch of batches) {
      const batchPromises = batch.map(async keyword => {
        const response = await callZhipuAPI('embeddings', {
          model: 'embedding-3',
          input: keyword.word
        });
        
        return {
          word: keyword.word,
          weight: keyword.weight,
          embedding: response.data[0].embedding
        };
      });
      
      const batchResults = await Promise.all(batchPromises);
      allEmbeddings.push(...batchResults);
      
      // 避免API限流，批次间添加延迟
      if (batches.indexOf(batch) < batches.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    return allEmbeddings;
  } catch (error) {
    console.error('生成词向量失败:', error);
    return [];
  }
}

// K-means聚类算法
function kMeansClustering(vectors, k, maxIterations = 100) {
  // 初始化聚类中心
  let centroids = initializeCentroids(vectors, k);
  let clusters = new Array(k).fill().map(() => []);
  let iterations = 0;
  let changed = true;
  
  while (changed && iterations < maxIterations) {
    // 清空聚类
    clusters = new Array(k).fill().map(() => []);
    
    // 分配向量到最近的聚类
    for (let i = 0; i < vectors.length; i++) {
      const vector = vectors[i];
      let minDistance = Infinity;
      let clusterIndex = 0;
      
      for (let j = 0; j < k; j++) {
        const distance = calculateDistance(vector.embedding, centroids[j]);
        if (distance < minDistance) {
          minDistance = distance;
          clusterIndex = j;
        }
      }
      
      clusters[clusterIndex].push({
        word: vector.word,
        weight: vector.weight,
        embedding: vector.embedding
      });
    }
    
    // 更新聚类中心
    changed = false;
    for (let i = 0; i < k; i++) {
      if (clusters[i].length > 0) {
        const newCentroid = calculateCentroid(clusters[i].map(item => item.embedding));
        if (!equals(newCentroid, centroids[i])) {
          centroids[i] = newCentroid;
          changed = true;
        }
      }
    }
    
    iterations++;
  }
  
  return clusters;
}

// 计算向量距离
function calculateDistance(vec1, vec2) {
  let sum = 0;
  for (let i = 0; i < vec1.length; i++) {
    sum += Math.pow(vec1[i] - vec2[i], 2);
  }
  return Math.sqrt(sum);
}

// 计算聚类中心
function calculateCentroid(vectors) {
  const dimensions = vectors[0].length;
  const centroid = new Array(dimensions).fill(0);
  
  for (let i = 0; i < vectors.length; i++) {
    for (let j = 0; j < dimensions; j++) {
      centroid[j] += vectors[i][j];
    }
  }
  
  for (let j = 0; j < dimensions; j++) {
    centroid[j] /= vectors.length;
  }
  
  return centroid;
}词向量生成和聚类分析步骤通过智谱AI的Embedding-3模型将关键词转换为向量表示，然后使用K-means聚类算法发现关键词之间的语义关联，形成更有意义的兴趣群组。

4. 兴趣标签生成
基于关键词提取、分类和聚类结果，生成用户的兴趣标签
// 兴趣标签生成
function generateInterestTags(classifiedKeywords, clusters) {
  // 按类别组织关键词
  const categorizedKeywords = {};
  classifiedKeywords.forEach(item => {
    if (!categorizedKeywords[item.category]) {
      categorizedKeywords[item.category] = [];
    }
    categorizedKeywords[item.category].push(item.keyword);
  });
  
  // 计算类别权重
  const categories = Object.keys(categorizedKeywords).map(category => {
    const keywords = categorizedKeywords[category];
    
    // 计算该类别的总权重
    let totalWeight = 0;
    keywords.forEach(keyword => {
      const keywordObj = classifiedKeywords.find(k => k.keyword === keyword);
      if (keywordObj && keywordObj.weight) {
        totalWeight += keywordObj.weight;
      }
    });
    
    return {
      name: category,
      weight: totalWeight / keywords.length, // 平均权重
      keywords: keywords
    };
  });
  
  // 按权重排序
  categories.sort((a, b) => b.weight - a.weight);
  
  // 从聚类结果中提取主题
  const clusterThemes = clusters.map(cluster => {
    // 按权重排序聚类中的关键词
    cluster.sort((a, b) => b.weight - a.weight);
    
    // 取前5个关键词作为主题代表
    const topKeywords = cluster.slice(0, 5).map(item => item.word);
    
    // 计算主题权重（聚类中所有关键词的平均权重）
    const themeWeight = cluster.reduce((sum, item) => sum + item.weight, 0) / cluster.length;
    
    return {
      keywords: topKeywords,
      weight: themeWeight
    };
  });
  
  return {
    categories: categories,
    themes: clusterThemes
  };
}兴趣标签生成步骤将分类和聚类结果整合，生成用户的兴趣类别和主题，形成完整的兴趣画像。

5. 性格特征分析
基于用户的情感数据和行为特征，分析用户的性格特点：// 情感倾向分析
function analyzeEmotionalTendency(emotions) {
  // 如果没有情感数据，返回默认值
  if (!emotions || emotions.length === 0) {
    return {
      dominant: 'neutral',
      intensity: 0.5,
      stability: 0.5,
      positivity: 0.5
    };
  }
  
  // 统计各情感类型的出现次数和强度
  const emotionStats = {
    joy: { count: 0, totalIntensity: 0 },
    sadness: { count: 0, totalIntensity: 0 },
    anger: { count: 0, totalIntensity: 0 },
    fear: { count: 0, totalIntensity: 0 },
    surprise: { count: 0, totalIntensity: 0 },
    disgust: { count: 0, totalIntensity: 0 },
    neutral: { count: 0, totalIntensity: 0 }
  };
  
  emotions.forEach(emotion => {
    if (emotionStats[emotion.type]) {
      emotionStats[emotion.type].count++;
      emotionStats[emotion.type].totalIntensity += emotion.intensity;
    }
  });
  
  // 计算各情感类型的平均强度
  Object.keys(emotionStats).forEach(type => {
    if (emotionStats[type].count > 0) {
      emotionStats[type].avgIntensity = emotionStats[type].totalIntensity / emotionStats[type].count;
    } else {
      emotionStats[type].avgIntensity = 0;
    }
  });
  
  // 确定主导情绪
  let dominant = 'neutral';
  let maxCount = 0;
  Object.keys(emotionStats).forEach(type => {
    if (emotionStats[type].count > maxCount) {
      maxCount = emotionStats[type].count;
      dominant = type;
    }
  });
  
  // 计算情绪强度（主导情绪的平均强度）
  const intensity = emotionStats[dominant].avgIntensity || 0.5;
  
  // 计算情绪稳定性（情绪变化的标准差）
  const intensities = emotions.map(e => e.intensity);
  const stabilityValue = 1 - calculateStandardDeviation(intensities);
  const stability = Math.max(0, Math.min(1, stabilityValue));
  
  // 计算积极性倾向（积极情绪vs消极情绪的比例）
  const positiveCount = emotionStats.joy.count + emotionStats.surprise.count;
  const negativeCount = emotionStats.sadness.count + emotionStats.anger.count + 
                        emotionStats.fear.count + emotionStats.disgust.count;
  const totalCount = positiveCount + negativeCount + emotionStats.neutral.count;
  
  let positivity = 0.5;
  if (totalCount > 0) {
    positivity = (positiveCount + emotionStats.neutral.count * 0.5) / totalCount;
  }
  
  return {
    dominant,
    intensity,
    stability,
    positivity
  };
}

// 表达风格分析
function analyzeExpressionStyle(messages) {
  // 如果没有消息数据，返回默认值
  if (!messages || messages.length === 0) {
    return {
      verbosity: 0.5,
      formality: 0.5,
      complexity: 0.5,
      creativity: 0.5
    };
  }
  
  // 计算平均消息长度
  const totalLength = messages.reduce((sum, msg) => sum + msg.content.length, 0);
  const avgLength = totalLength / messages.length;
  
  // 计算话语冗长度（归一化到0-1范围）
  const verbosity = Math.min(1, avgLength / 100);
  
  // 分析正式程度（基于标点、缩写、表情符号等）
  let formalCount = 0;
  let informalCount = 0;
  
  messages.forEach(msg => {
    // 正式语言特征
    formalCount += (msg.content.match(/[。，；：""（）？！]/g) || []).length;
    
    // 非正式语言特征
    informalCount += (msg.content.match(/[,.;:()!?]/g) || []).length;
// 用户画像更新
async function updateUserProfile(userId, interestTags, personalityTraits) {
  try {
    const db = cloud.database();
    const _ = db.command;
    
    // 查询现有用户画像
    const profileResult = await db.collection('userInterests')
      .where({ userId: userId })
      .get();
    
    if (profileResult.data.length > 0) {
      // 更新现有画像
      const profileId = profileResult.data[0]._id;
      const existingKeywords = profileResult.data[0].keywords || [];
      const existingCategories = profileResult.data[0].categories || [];
      
      // 合并关键词
      const mergedKeywords = mergeKeywords(existingKeywords, interestTags.keywords);
      
      // 合并类别
      const mergedCategories = mergeCategories(existingCategories, interestTags.categories);
      
      // 更新用户画像
      await db.collection('userInterests').doc(profileId).update({
        data: {
          keywords: mergedKeywords,
          categories: mergedCategories,
          personality: personalityTraits,
          updateTime: db.serverDate()
        }
      });
    } else {
      // 创建新画像
      await db.collection('userInterests').add({
        data: {
          userId: userId,
          keywords: interestTags.keywords,
          categories: interestTags.categories,
          personality: personalityTraits,
          createTime: db.serverDate(),
          updateTime: db.serverDate()
        }
      });
    }
    
    return true;
  } catch (error) {
    console.error('更新用户画像失败:', error);
    return false;
  }
}

// 合并关键词
function mergeKeywords(existing, newKeywords) {
  // 创建关键词映射
  const keywordMap = {};
  
  // 添加现有关键词
  existing.forEach(keyword => {
    keywordMap[keyword.word] = {
      word: keyword.word,
      weight: keyword.weight,
      count: keyword.count || 1,
      lastMentioned: keyword.lastMentioned
    };
  });
  
  // 合并新关键词
  newKeywords.forEach(keyword => {
    if (keywordMap[keyword.word]) {
      // 更新现有关键词
      const existing = keywordMap[keyword.word];
      
      // 应用时间衰减
      const daysSinceLastMention = existing.lastMentioned ? 
        (new Date() - new Date(existing.lastMentioned)) / (1000 * 60 * 60 * 24) : 0;
      const decayFactor = Math.max(0.5, Math.exp(-0.05 * daysSinceLastMention));
      
      // 更新权重（新权重占比更高）
      keywordMap[keyword.word].weight = (existing.weight * decayFactor * 0.7) + (keyword.weight * 0.3);
      keywordMap[keyword.word].count = (existing.count || 1) + 1;
      keywordMap[keyword.word].lastMentioned = new Date();
    } else {
      // 添加新关键词
      keywordMap[keyword.word] = {
        word: keyword.word,
        weight: keyword.weight,
        count: 1,
        lastMentioned: new Date()
      };
    }
  });
  
  // 转换回数组并按权重排序
  return Object.values(keywordMap)
    .sort((a, b) => b.weight - a.weight)
    .slice(0, 200); // 限制关键词数量
}

// 合并类别
function mergeCategories(existing, newCategories) {
  // 创建类别映射
  const categoryMap = {};
  
  // 添加现有类别
  existing.forEach(category => {
    categoryMap[category.name] = {
      name: category.name,
      weight: category.weight,
      keywords: category.keywords || []
    };
  });
  
  // 合并新类别
  newCategories.forEach(category => {
    if (categoryMap[category.name]) {
      // 更新现有类别
      const existing = categoryMap[category.name];
      
      // 更新权重（新权重占比更高）
      categoryMap[category.name].weight = (existing.weight * 0.7) + (category.weight * 0.3);
      
      // 合并关键词
      const keywordSet = new Set([...existing.keywords, ...category.keywords]);
      categoryMap[category.name].keywords = Array.from(keywordSet);
    } else {
      // 添加新类别
      categoryMap[category.name] = {
        name: category.name,
        weight: category.weight,
        keywords: category.keywords || []
      };
    }
  });
  
  // 转换回数组并按权重排序
  return Object.values(categoryMap)
    .sort((a, b) => b.weight - a.weight);
}用户画像更新步骤实现了画像的动态演进，通过时间衰减因子和权重更新机制，使画像能够反映用户兴趣的变化。

用户画像应用
心语精灵的用户画像在以下场景中发挥重要作用：

1. 个性化对话生成
用户画像用于增强AI角色的对话生成，使回复更加个性化：// 个性化对话生成
function enhancePromptWithUserProfile(basePrompt, userProfile) {
  if (!userProfile) return basePrompt;
  
  // 提取用户兴趣
  let interestsText = '';
  if (userProfile.categories && userProfile.categories.length > 0) {
    const topCategories = userProfile.categories.slice(0, 3);
    interestsText = `用户的主要兴趣领域：${topCategories.map(c => c.name).join('、')}。`;
    
    // 添加具体兴趣点
    const interestDetails = topCategories.map(category => {
      const topKeywords = category.keywords.slice(0, 5).join('、');
      return `在${category.name}方面，用户关注：${topKeywords}`;
    }).join('；');
    
    if (interestDetails) {
      interestsText += interestDetails + '。';
    }
  }
  
  // 提取性格特征
  let personalityText = '';
  if (userProfile.personality) {
    const p = userProfile.personality;
    
    // 情感倾向
    if (p.emotionalTendency) {
      const et = p.emotionalTendency;
      personalityText += `用户的情感倾向：主要表现${et.dominant}情绪，`;
      personalityText += et.stability > 0.7 ? '情绪较为稳定，' : '情绪波动较大，';
      personalityText += et.positivity > 0.7 ? '倾向于表达积极情绪。' : 
                         et.positivity < 0.3 ? '倾向于表达消极情绪。' : '积极消极情绪表达平衡。';
    }
    
    // 表达风格
    if (p.expressionStyle) {
      const es = p.expressionStyle;
      personalityText += `用户的表达风格：`;
      personalityText += es.verbosity > 0.7 ? '表达详细，' : es.verbosity < 0.3 ? '表达简洁，' : '表达适中，';
      personalityText += es.formality > 0.7 ? '语言较为正式，' : es.formality < 0.3 ? '语言较为随意，' : '语言正式度适中，';
      personalityText += es.creativity > 0.7 ? '表达富有创造性。' : '表达较为常规。';
    }
    
    // 决策风格
    if (p.decisionStyle) {
      const ds = p.decisionStyle;
      personalityText += `用户的决策风格：`;
      personalityText += ds.rational > 0.7 ? '偏重理性分析，' : ds.rational < 0.3 ? '偏重情感直觉，' : '理性情感平衡，';
      personalityText += ds.cautious > 0.7 ? '决策谨慎，' : ds.cautious < 0.3 ? '决策果断，' : '谨慎度适中，';
      personalityText += ds.independent > 0.7 ? '主见较强。' : ds.independent < 0.3 ? '乐于听取建议。' : '适度参考他人意见。';
    }
  }
  
  // 增强提示词
  let enhancedPrompt = basePrompt;
  
  if (interestsText || personalityText) {
    enhancedPrompt += '\n\n用户画像信息：\n';
    if (interestsText) enhancedPrompt += interestsText + '\n';
    if (personalityText) enhancedPrompt += personalityText;
  }
  
  return enhancedPrompt;
}2. 情感反馈个性化
用户画像用于个性化情感反馈和建议：// 个性化情感反馈
function personalizeEmotionFeedback(baseAnalysis, userProfile) {
  if (!userProfile || !userProfile.personality) return baseAnalysis;
  
  const p = userProfile.personality;
  let personalizedSuggestions = [];
  
  // 根据用户性格特征个性化建议
  if (baseAnalysis.primary === 'sadness' || baseAnalysis.primary === 'fear') {
    // 对于悲伤或恐惧情绪
    if (p.emotionalTendency && p.emotionalTendency.stability < 0.4) {
      // 情绪不稳定的用户
      personalizedSuggestions.push('尝试进行深呼吸练习，帮助稳定情绪');
    }
    
    if (p.decisionStyle && p.decisionStyle.rational > 0.7) {
      // 理性用户
      personalizedSuggestions.push('列出当前情况的积极方面，进行理性分析');
    } else if (p.decisionStyle && p.decisionStyle.rational < 0.3) {
      // 感性用户
      personalizedSuggestions.push('通过艺术创作或音乐表达你的情感');
    }
  } else if (baseAnalysis.primary === 'anger') {
    // 对于愤怒情绪
    if (p.expressionStyle && p.expressionStyle.verbosity > 0.7) {
      // 表达详细的用户
      personalizedSuggestions.push('写下你的感受和想法，帮助理清思路');
    } else {
      // 表达简洁的用户
      personalizedSuggestions.push('尝试进行体育活动，释放情绪');
    }
  }
  
  // 合并建议
  if (personalizedSuggestions.length > 0) {
    baseAnalysis.suggestions = [...personalizedSuggestions, ...baseAnalysis.suggestions];
  }
  
  return baseAnalysis;
}3. 内容推荐
用户画像用于个性化内容推荐，如角色推荐、话题建议等：// 基于用户画像的角色推荐
async function recommendRoles(userProfile) {
  try {
    const db = cloud.database();
    
    // 如果没有用户画像，返回热门角色
    if (!userProfile || !userProfile.categories || userProfile.categories.length === 0) {
      return await getPopularRoles();
    }
    
    // 提取用户兴趣类别
    const userCategories = userProfile.categories.map(c => c.name);
    
    // 查询匹配用户兴趣的角色
    const rolesResult = await db.collection('roles')
      .where({
        category: db.command.in(userCategories),
        is_public: true
      })
      .limit(5)
      .get();
    
    // 如果找到匹配的角色，返回结果
    if (rolesResult.data.length > 0) {
      return rolesResult.data;
    }
    
    // 如果没有找到匹配的角色，返回热门角色
    return await getPopularRoles();
  } catch (error) {
    console.error('角色推荐失败:', error);
    return [];
  }
}

// 获取热门角色
async function getPopularRoles() {
  try {
    const db = cloud.database();
    
    const rolesResult = await db.collection('roles')
      .where({
        is_system: true,
        is_public: true
      })
      .orderBy('usage_count', 'desc')
      .limit(5)
      .get();
    
    return rolesResult.data;
  } catch (error) {
    console.error('获取热门角色失败:', error);
    return [];
  }
}通过以上用户画像构建算法的设计与实现，心语精灵能够深入理解用户的兴趣和性格特征，为用户提供个性化的情感陪伴和情商提升服务。

算法优化与改进
为提高用户画像构建的准确性和效率，心语精灵实现了以下优化策略：

1. 增量更新机制
实现了用户画像的增量更新机制，避免每次都重新构建整个画像：// 增量更新用户画像
async function incrementalUpdateUserProfile(userId, newMessages, newEmotions) {
  try {
    // 提取新消息的关键词
    const newKeywords = await extractKeywords(newMessages);
    
    // 对新关键词进行分类
    const classifiedKeywords = await classifyKeywords(newKeywords);
    
    // 生成新的兴趣标签
    const newInterestTags = {
      keywords: newKeywords,
      categories: processClassifiedKeywords(classifiedKeywords)
    };
    
    // 分析新的情感数据
    const emotionalTendency = analyzeEmotionalTendency(newEmotions);
    
    // 分析新的表达风格
    const expressionStyle = analyzeExpressionStyle(newMessages);
    
    // 构建新的性格特征
    const newPersonalityTraits = {
      emotionalTendency,
      expressionStyle
    };
    
    // 更新用户画像
    await updateUserProfile(userId, newInterestTags, newPersonalityTraits);
    
    return true;
  } catch (error) {
    console.error('增量更新用户画像失败:', error);
    return false;
  }
}

// 处理分类后的关键词
function processClassifiedKeywords(classifiedKeywords) {
  // 按类别组织关键词
  const categorizedKeywords = {};
  classifiedKeywords.forEach(item => {
    if (!categorizedKeywords[item.category]) {
      categorizedKeywords[item.category] = [];
    }
    categorizedKeywords[item.category].push(item.keyword);
  });
  
  // 转换为类别数组
  return Object.keys(categorizedKeywords).map(category => ({
    name: category,
    keywords: categorizedKeywords[category],
    weight: 0.7 // 新类别的初始权重
  }));
}增量更新机制大幅减少了计算资源消耗，提高了系统响应速度。

2. 批处理优化
实现了批处理机制，提高大量数据处理的效率：// 批处理用户画像更新
async function batchProcessUserProfiles(userIds) {
  // 每批处理的用户数
  const batchSize = 5;
  const batches = [];
  
  // 分批
  for (let i = 0; i < userIds.length; i += batchSize) {
    batches.push(userIds.slice(i, i + batchSize));
  }
  
  // 处理每批用户
  for (const batch of batches) {
    const batchPromises = batch.map(userId => processUserProfile(userId));
    await Promise.all(batchPromises);
    
    // 批次间添加延迟，避免资源竞争
    if (batches.indexOf(batch) < batches.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
}

// 处理单个用户的画像
async function processUserProfile(userId) {
  try {
    // 收集用户数据
    const userData = await collectUserData(userId);
    
    // 预处理数据
    const processedData = preprocessUserData(userData);
    
    // 构建用户画像
    await buildUserProfile(userId, processedData);
    
    return true;
  } catch (error) {
    console.error(`处理用户${userId}的画像失败:`, error);
    return false;
  }
}批处理优化使系统能够高效处理多用户的画像更新，适用于定期批量更新场景。

3. 缓存机制
实现了用户画像的缓存机制，减少数据库访问：// 用户画像缓存
const userProfileCache = {
  profiles: new Map(),
  maxSize: 100,
  expirationTime: 30 * 60 * 1000, // 30分钟
  
  // 获取缓存
  async get(userId) {
    const cachedProfile = this.profiles.get(userId);
    
    // 如果缓存存在且未过期，返回缓存
    if (cachedProfile && (Date.now() - cachedProfile.timestamp) < this.expirationTime) {
      return cachedProfile.profile;
    }
    
    // 缓存不存在或已过期，从数据库获取
    try {
      const db = cloud.database();
      const profileResult = await db.collection('userInterests')
        .where({ userId: userId })
        .get();
      
      if (profileResult.data.length > 0) {
        const profile = profileResult.data[0];
        
        // 更新缓存
        this.set(userId, profile);
        
        return profile;
      }
      
      return null;
    } catch (error) {
      console.error('从数据库获取用户画像失败:', error);
      return null;
    }
  },
  
  // 设置缓存
  set(userId, profile) {
    // 如果缓存已满，删除最早的条目
    if (this.profiles.size >= this.maxSize) {
      const oldestKey = this.getOldestKey();
      if (oldestKey) {
        this.profiles.delete(oldestKey);
      }
    }
    
    // 添加到缓存
    this.profiles.set(userId, {
      profile: profile,
      timestamp: Date.now()
    });
  },
  
  // 获取最早的缓存键
  getOldestKey() {
    let oldestKey = null;
    let oldestTime = Infinity;
    
    for (const [key, value] of this.profiles.entries()) {
      if (value.timestamp < oldestTime) {
        oldestTime = value.timestamp;
        oldestKey = key;
      }
    }
    
    return oldestKey;
  },
  
  // 清除缓存
  clear(userId) {
    if (userId) {
      this.profiles.delete(userId);
    } else {
      this.profiles.clear();
    }
  }
};缓存机制减少了数据库访问次数，提高了系统响应速度，特别是在高频访问场景下。

4. 算法精度优化
通过调整算法参数和模型提示词，提高了用户画像构建的精度：// 优化关键词提取提示词
function getOptimizedKeywordPrompt(text) {
  return `
从以下文本中提取最重要的关键词或短语，关注能够反映用户兴趣、爱好、关注点的词语。
请特别注意：
1. 提取具体的兴趣点（如"古典音乐"、"机器学习"），而非一般性词汇
2. 关注名词短语和专有名词，它们通常更能代表兴趣
3. 考虑用户反复提及的话题
4. 忽略情感词汇和一般性动词

文本：${text}

请返回JSON格式：
{
  "keywords": [
    {"word": "关键词1", "weight": 0.9, "reason": "简短说明为何这是重要关键词"},
    {"word": "关键词2", "weight": 0.8, "reason": "简短说明为何这是重要关键词"},
    ...
  ]
}

最多返回15个最重要的关键词。
`;
}

// 优化关键词分类提示词
function getOptimizedClassificationPrompt(keywords) {
  return `
请将以下关键词分类到这些类别中：学习、工作、娱乐、社交、健康、家庭、艺术、科技、体育、旅行、美食、时尚、金融、哲学、其他

关键词：${keywords.map(k => k.word).join('、')}

分类规则：
1. 每个关键词只能属于一个最匹配的类别
2. 如果关键词可能属于多个类别，选择最主要的一个
3. 只有当关键词不属于任何预定义类别时，才归为"其他"
4. 尽量避免将过多关键词归为同一类别

请返回JSON格式：
{
  "分类结果": [
    {"keyword": "关键词1", "category": "类别1", "confidence": 0.9},
    {"keyword": "关键词2", "category": "类别2", "confidence": 0.8},
    ...
  ]
}

confidence表示分类的确信度，范围0.0-1.0。
`;
}优化后的提示词更加精确地引导大语言模型提取和分类关键词，提高了用户画像的准确性。

用户画像评估与验证
为确保用户画像的准确性和有效性，心语精灵实现了以下评估和验证机制：

1. 画像准确性评估
通过与用户的显式反馈进行对比，评估用户画像的准确性：// 用户画像准确性评估
async function evaluateProfileAccuracy(userId, userFeedback) {
  try {
    // 获取用户画像
    const userProfile = await userProfileCache.get(userId);
    if (!userProfile) return null;
    
    // 计算兴趣类别匹配度
    let categoryMatchCount = 0;
    if (userProfile.categories && userFeedback.interests) {
      const profileCategories = userProfile.categories.map(c => c.name);
      userFeedback.interests.forEach(interest => {
        if (profileCategories.includes(interest)) {
          categoryMatchCount++;
        }
      });
    }
    
    const categoryAccuracy = userFeedback.interests.length > 0 ? 
      categoryMatchCount / userFeedback.interests.length : 0;
    
    // 计算性格特征匹配度
    let personalityMatchCount = 0;
    let personalityTotalCount = 0;
    
    if (userProfile.personality && userFeedback.personality) {
      // 评估情感倾向
      if (userProfile.personality.emotionalTendency && userFeedback.personality.emotionalTendency) {
        personalityTotalCount += 3; // 三个特征
        
        if (userProfile.personality.emotionalTendency.dominant === userFeedback.personality.emotionalTendency.dominant) {
          personalityMatchCount++;
        }
        
        if (Math.abs(userProfile.personality.emotionalTendency.stability - userFeedback.personality.emotionalTendency.stability) <= 0.2) {
          personalityMatchCount++;
        }
        
        if (Math.abs(userProfile.personality.emotionalTendency.positivity - userFeedback.personality.emotionalTendency.positivity) <= 0.2) {
          personalityMatchCount++;
        }
      }
      
      // 评估表达风格
      // ... 类似的评估逻辑
    }
    
    const personalityAccuracy = personalityTotalCount > 0 ? 
      personalityMatchCount / personalityTotalCount : 0;
    
    // 计算总体准确性
    const overallAccuracy = (categoryAccuracy + personalityAccuracy) / 2;
    
    return {
      categoryAccuracy,
      personalityAccuracy,
      overallAccuracy
    };
  } catch (error) {
    console.error('评估用户画像准确性失败:', error);
    return null;
  }
}画像准确性评估通过与用户的显式反馈进行对比，计算兴趣类别和性格特征的匹配度，为画像优化提供依据。

2. 画像有效性验证
通过A/B测试验证用户画像对系统性能的影响：// 用户画像有效性验证
async function validateProfileEffectiveness(testGroup, controlGroup) {
  try {
    const db = cloud.database();
    const _ = db.command;
    
    // 收集测试组数据（使用用户画像）
    const testGroupData = await db.collection('userFeedback')
      .where({
        userId: _.in(testGroup),
        feedbackTime: _.gte(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)) // 最近一周
      })
      .get();
    
    // 收集对照组数据（不使用用户画像）
    const controlGroupData = await db.collection('userFeedback')
      .where({
        userId: _.in(controlGroup),
        feedbackTime: _.gte(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)) // 最近一周
      })
      .get();
    
    // 计算测试组指标
    const testGroupMetrics = calculateGroupMetrics(testGroupData.data);
    
    // 计算对照组指标
    const controlGroupMetrics = calculateGroupMetrics(controlGroupData.data);
    
    // 比较两组指标
    return {
      testGroup: testGroupMetrics,
      controlGroup: controlGroupMetrics,
      improvement: {
        satisfaction: testGroupMetrics.satisfaction - controlGroupMetrics.satisfaction,
        relevance: testGroupMetrics.relevance - controlGroupMetrics.relevance,
        engagement: testGroupMetrics.engagement - controlGroupMetrics.engagement
      }
    };
  } catch (error) {
    console.error('验证用户画像有效性失败:', error);
    return null;
  }
}

// 计算组指标
function calculateGroupMetrics(feedbackData) {
  if (!feedbackData || feedbackData.length === 0) {
    return {
      satisfaction: 0,
      relevance: 0,
      engagement: 0
    };
  }
  
  // 计算满意度
  const satisfactionSum = feedbackData.reduce((sum, item) => sum + (item.satisfaction || 0), 0);
  const satisfaction = satisfactionSum / feedbackData.length;
  
  // 计算相关性
  const relevanceSum = feedbackData.reduce((sum, item) => sum + (item.relevance || 0), 0);
  const relevance = relevanceSum / feedbackData.length;
  
  // 计算参与度
  const engagementSum = feedbackData.reduce((sum, item) => sum + (item.engagement || 0), 0);
  const engagement = engagementSum / feedbackData.length;
  
  return {
    satisfaction,
    relevance,
    engagement
  };
}画像有效性验证通过A/B测试比较使用用户画像和不使用用户画像的系统性能差异，验证用户画像的实际效果。

通过以上用户画像构建算法的设计与实现，心语精灵能够深入理解用户的兴趣和性格特征，为用户提供个性化的情感陪伴和情商提升服务，实现了情感陪伴和情商提升的核心功能。
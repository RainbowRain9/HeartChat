HeartChat\
├── cloudfunctions
│   ├── analysis
│   │   ├── aiModelService.js
│   │   ├── aiModelService_part2.js
│   │   ├── aiModelService_part3.js
│   │   ├── bigmodel.js
│   │   ├── geminiModel.js
│   │   ├── index.js
│   │   ├── keywordClassifier.js
│   │   ├── keywordEmotionLinker.js
│   │   ├── keywords.js
│   │   ├── package.json
│   │   ├── test.js
│   │   └── userInterestAnalyzer.js
│   ├── chat
│   │   ├── aiModelService.js
│   │   ├── bigmodel.js
│   │   ├── geminiModel.js
│   │   ├── index.js
│   │   └── package.json
│   ├── clearDatabase
│   │   ├── index.js
│   │   └── package.json
│   ├── emotion
│   │   ├── index.js
│   │   └── package.json
│   ├── generateDailyReports
│   │   ├── config.json
│   │   ├── index.js
│   │   └── package.json
│   ├── getEmotionRecords
│   │   ├── index.js
│   │   └── package.json
│   ├── getIflytekSttUrl
│   │   ├── index.js
│   │   └── package.json
│   ├── getRoleInfo
│   │   ├── index.js
│   │   └── package.json
│   ├── httpRequest
│   │   ├── index.js
│   │   ├── package.json
│   │   └── test.js
│   ├── initReportCollections
│   │   ├── index.js
│   │   └── package.json
│   ├── login
│   │   ├── index.js
│   │   └── package.json
│   ├── roles
│   │   ├── index.js
│   │   ├── init-roles.js
│   │   ├── memoryManager.js
│   │   ├── package.json
│   │   ├── promptGenerator.js
│   │   ├── test-zhipu.js
│   │   └── userPerception.js
│   ├── testDatabase
│   │   ├── index.js
│   │   └── package.json
│   └── user
│       ├── createIndexes.js
│       ├── index.js
│       ├── package.json
│       ├── userInterests.js
│       └── userPerception_new.js
├── miniprogram
│   ├── components
│   │   ├── chat-bubble
│   │   ├── chat-input
│   │   ├── emotion-analysis
│   │   │   ├── emotion-analysis.js
│   │   │   ├── emotion-analysis.json
│   │   │   ├── emotion-analysis.wxml
│   │   │   └── emotion-analysis.wxss
│   │   ├── emotion-card
│   │   │   ├── index.json
│   │   │   ├── index.ts
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── emotion-dashboard
│   │   │   ├── emotion-dashboard.js
│   │   │   ├── emotion-dashboard.json
│   │   │   ├── emotion-dashboard.wxml
│   │   │   └── emotion-dashboard.wxss
│   │   ├── emotion-history
│   │   │   ├── emotion-history.js
│   │   │   ├── emotion-history.json
│   │   │   ├── emotion-history.wxml
│   │   │   └── emotion-history.wxss
│   │   ├── emotion-panel
│   │   │   ├── emotion-panel.js
│   │   │   ├── emotion-panel.json
│   │   │   ├── emotion-panel.wxml
│   │   │   └── emotion-panel.wxss
│   │   ├── emotion-pie
│   │   │   ├── emotion-pie.js
│   │   │   ├── emotion-pie.json
│   │   │   ├── emotion-pie.wxml
│   │   │   └── emotion-pie.wxss
│   │   ├── interest-tag-cloud
│   │   │   ├── interest-tag-cloud.js
│   │   │   ├── interest-tag-cloud.json
│   │   │   ├── interest-tag-cloud.wxml
│   │   │   └── interest-tag-cloud.wxss
│   │   ├── login
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── model-selector
│   │   │   ├── model-selector.js
│   │   │   ├── model-selector.json
│   │   │   ├── model-selector.wxml
│   │   │   └── model-selector.wxss
│   │   ├── role-card
│   │   │   ├── role-card.js
│   │   │   ├── role-card.json
│   │   │   ├── role-card.wxml
│   │   │   └── role-card.wxss
│   │   └── structured-role-card
│   ├── config
│   │   └── index.js
│   ├── packageChat
│   │   ├── components
│   │   │   ├── chat-bubble
│   │   │   │   ├── index.js
│   │   │   │   ├── index.json
│   │   │   │   ├── index.wxml
│   │   │   │   └── index.wxss
│   │   │   └── chat-input
│   │   │       ├── index.js
│   │   │       ├── index.json
│   │   │       ├── index.wxml
│   │   │       └── index.wxss
│   │   └── pages
│   │       ├── chat
│   │       │   ├── chat.js
│   │       │   ├── chat.json
│   │       │   ├── chat.wxml
│   │       │   └── chat.wxss
│   │       └── emotion-analysis
│   │           ├── emotion-analysis.js
│   │           ├── emotion-analysis.json
│   │           ├── emotion-analysis.wxml
│   │           └── emotion-analysis.wxss
│   ├── packageEmotion
│   │   └── pages
│   │       ├── daily-report
│   │       │   ├── daily-report.js
│   │       │   ├── daily-report.json
│   │       │   ├── daily-report.wxml
│   │       │   └── daily-report.wxss
│   │       └── emotion-history
│   │           ├── emotion-history.js
│   │           ├── emotion-history.json
│   │           ├── emotion-history.plan.md
│   │           ├── emotion-history.wxml
│   │           └── emotion-history.wxss
│   ├── pages
│   │   ├── agreement
│   │   │   ├── agreement-common.wxss
│   │   │   ├── agreement.wxss
│   │   │   ├── privacy.js
│   │   │   ├── privacy.json
│   │   │   ├── privacy.ts
│   │   │   ├── privacy.wxml
│   │   │   ├── privacy.wxss
│   │   │   ├── service.js
│   │   │   ├── service.json
│   │   │   ├── service.ts
│   │   │   ├── service.wxml
│   │   │   └── service.wxss
│   │   ├── home
│   │   │   ├── home.js
│   │   │   ├── home.json
│   │   │   ├── home.wxml
│   │   │   └── home.wxss
│   │   ├── keywordTest
│   │   │   ├── keywordTest.js
│   │   │   ├── keywordTest.json
│   │   │   ├── keywordTest.wxml
│   │   │   └── keywordTest.wxss
│   │   ├── prompt-editor
│   │   │   ├── prompt-editor.js
│   │   │   ├── prompt-editor.json
│   │   │   ├── prompt-editor.wxml
│   │   │   └── prompt-editor.wxss
│   │   ├── role-detail
│   │   ├── role-editor
│   │   │   ├── index.js
│   │   │   ├── index.json
│   │   │   ├── index.wxml
│   │   │   └── index.wxss
│   │   ├── role-select
│   │   │   ├── role-select.js
│   │   │   ├── role-select.json
│   │   │   ├── role-select.wxml
│   │   │   └── role-select.wxss
│   │   ├── role-templates
│   │   ├── settings
│   │   │   ├── model-comparison
│   │   │   └── model-settings
│   │   ├── test-gemini
│   │   │   ├── test-gemini.js
│   │   │   ├── test-gemini.json
│   │   │   ├── test-gemini.wxml
│   │   │   └── test-gemini.wxss
│   │   ├── user
│   │   │   ├── profile
│   │   │   │   ├── profile.js
│   │   │   │   ├── profile.json
│   │   │   │   ├── profile.wxml
│   │   │   │   └── profile.wxss
│   │   │   ├── user.js
│   │   │   ├── user.json
│   │   │   ├── user.wxml
│   │   │   └── user.wxss
│   │   └── welcome
│   │       ├── welcome.js
│   │       ├── welcome.json
│   │       ├── welcome.wxml
│   │       └── welcome.wxss
│   ├── services
│   │   ├── chatCacheService.js
│   │   ├── cloudFuncCaller.js
│   │   ├── emotionService.js
│   │   ├── eventBus.js
│   │   ├── focusAnalysisService.js
│   │   ├── imageService.js
│   │   ├── keywordService.js
│   │   ├── modelService.js
│   │   ├── personalityService.js
│   │   ├── reportService.js
│   │   ├── userInterestsService.js
│   │   ├── userService.js
│   │   └── voiceService.js
│   ├── styles
│   │   └── iconfont.wxss
│   ├── utils
│   │   ├── auth.js
│   │   ├── date.js
│   │   ├── emotion.js
│   │   ├── format.js
│   │   ├── imageService.js
│   │   ├── request.js
│   │   ├── stats.js
│   │   └── storage.js
│   ├── app.js
│   ├── app.json
│   ├── app.wxss
│   ├── sitemap.json
│   └── theme.json
├── package.json
└── project.config.json

*#*#*cloudfunctions\analysis\aiModelService.js*#*#*begin*#*#*
/**
 * AI模型服务
 * 提供统一的AI模型调用接口，支持多种AI模型平台
 *
 * @architecture 该模块实现了统一的AI模型调用接口，支持智谱AI、Google Gemini等多种模型平台
 * @dependency axios HTTP请求库
 * @history 2025-05-15 初始版本
 */

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 导入axios
const axios = require('axios');

// 先定义辅助函数，稍后导入子模块

// 模型平台配置
const MODEL_PLATFORMS = {
  // 智谱AI
  ZHIPU: {
    name: '智谱AI',
    baseUrl: 'https://open.bigmodel.cn/api/paas/v4',
    apiKeyEnv: 'ZHIPU_API_KEY',
    defaultModel: 'glm-4-flash',
    embeddingModel: 'embedding-3',
    models: ['glm-4-flash', 'glm-4'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions',
      embedding: '/embeddings'
    }
  },
  // Google Gemini
  GEMINI: {
    name: 'Google Gemini',
    baseUrl: 'https://apiv2.aliyahzombie.top',
    apiKeyEnv: 'GEMINI_API_KEY',
    defaultModel: 'gemini-2.5-flash-preview-04-17',
    models: ['gemini-2.5-flash-preview-04-17'],
    authType: 'Bearer',
    endpoints: {
      chat: '/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent'
    }
  },
  // WHIMSY
  WHIMSY: {
    name: 'Whimsy',
    baseUrl: 'https://doi9.top/v1',
    apiKeyEnv: 'WHIMSY_API_KEY',
    defaultModel: 'gemini-2.5-flash-preview-04-17-non-thinking',
    models: ['gemini-2.5-pro-preview-05-06', 'gemini-2.5-flash-preview-04-17-non-thinking', 'gemini-2.5-flash-preview-04-17'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions'
    }
  },
  // Crond API
  CROND: {
    name: 'Crond API',
    baseUrl: 'https://new.crond.dev/v1',
    apiKeyEnv: 'CROND_API_KEY',
    defaultModel: 'gpt-4o-mini',
    models: ['gpt-4o-mini', 'deepseek-v3', 'o3-mini'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions'
    }
  },
  // CloseAI
  CLOSEAI: {
    name: 'CloseAI',
    baseUrl: 'https://api.closeai.im/v1',
    apiKeyEnv: 'CLOSEAI_API_KEY',
    defaultModel: 'deepseek-ai/DeepSeek-V3-0324',
    models: ['deepseek-ai/DeepSeek-V3-0324'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions'
    }
  }
};

/**
 * 延迟函数
 * @param {number} ms 延迟毫秒数
 * @returns {Promise} 延迟Promise
 */
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * 获取API密钥
 * @param {string} platformKey 平台键名
 * @returns {string} API密钥
 */
function getApiKey(platformKey) {
  const platform = MODEL_PLATFORMS[platformKey];
  if (!platform) {
    throw new Error(`未知的平台: ${platformKey}`);
  }

  const apiKey = process.env[platform.apiKeyEnv];
  if (!apiKey) {
    throw new Error(`未设置${platform.apiKeyEnv}环境变量`);
  }

  return apiKey;
}

/**
 * 获取平台配置
 * @param {string} platformKey 平台键名
 * @returns {Object} 平台配置
 */
function getPlatformConfig(platformKey) {
  const platform = MODEL_PLATFORMS[platformKey];
  if (!platform) {
    throw new Error(`未知的平台: ${platformKey}`);
  }

  return platform;
}

/**
 * 调用AI模型API
 * @param {Object} params 请求参数
 * @param {string} platformKey 平台键名
 * @param {number} retryCount 重试次数，默认为3
 * @param {number} retryDelay 重试延迟，默认为1000ms
 * @returns {Promise<Object>} API响应
 */
async function callModelApi(params, platformKey, retryCount = 3, retryDelay = 1000) {
  try {
    // 获取平台配置
    const platform = getPlatformConfig(platformKey);

    // 获取API密钥
    const apiKey = getApiKey(platformKey);

    // 构建请求URL和请求体
    let url, requestBody, headers;

    if (platformKey === 'GEMINI') {
      // Gemini特殊处理
      url = `${platform.baseUrl}/v1beta/models/${params.model || platform.defaultModel}:generateContent?key=${apiKey}`;

      requestBody = {
        contents: params.contents,
        generationConfig: {
          temperature: params.temperature || 0.3,
          topP: params.topP || 0.8,
          topK: params.topK || 40,
          maxOutputTokens: params.maxOutputTokens || 2048
        }
      };

      headers = {
        'Content-Type': 'application/json'
      };
    } else if (platformKey === 'OPENAI' || platformKey === 'CROND' || platformKey === 'CLOSEAI') {
      // OpenAI, Crond API, CloseAI 标准处理
      url = `${platform.baseUrl}${params.endpoint || platform.endpoints.chat}`;

      requestBody = {
        model: params.model || platform.defaultModel,
        messages: params.body?.messages || [],
        temperature: params.temperature || 0.3,
        max_tokens: params.max_tokens || 2048,
        top_p: params.top_p || 0.8,
        frequency_penalty: params.frequency_penalty || 0,
        presence_penalty: params.presence_penalty || 0
      };

      if (params.body?.response_format) {
        requestBody.response_format = params.body.response_format;
      }

      headers = {
        'Content-Type': 'application/json',
        'Authorization': `${platform.authType} ${apiKey}`
      };
    } else {
      // 智谱AI等其他处理
      url = `${platform.baseUrl}${params.endpoint || platform.endpoints.chat}`;

      requestBody = {
        model: params.model || platform.defaultModel,
        ...params.body
      };

      headers = {
        'Content-Type': 'application/json',
        'Authorization': `${platform.authType} ${apiKey}`
      };
    }

    if (isDev) {
      console.log(`调用${platform.name} API, 请求体:`, JSON.stringify(requestBody, null, 2));
    }

    console.log('发送请求到:', url);

    try {
      // 发送请求
      const response = await axios({
        method: 'POST',
        url: url,
        headers: headers,
        data: requestBody
      });

      // 检查响应状态
      if (response.status !== 200) {
        console.error(`${platform.name} API返回错误状态码:`, response.status);
        throw new Error(`${platform.name} API调用失败: 状态码 ${response.status}`);
      }

      // 获取响应数据
      return response.data;
    } catch (error) {
      // 处理429错误（请求过多）
      if (error.response && error.response.status === 429 && retryCount > 0) {
        console.log(`遇到429错误，等待${retryDelay}ms后重试，剩余重试次数: ${retryCount-1}`);

        // 等待一段时间后重试
        await delay(retryDelay);

        // 递归调用自身，减少重试次数，增加延迟时间
        return callModelApi(params, platformKey, retryCount - 1, retryDelay * 2);
      }

      // 其他错误或重试次数用完，抛出异常
      throw error;
    }
  } catch (error) {
    console.error(`调用${platformKey} API失败:`, error);
    throw error;
  }
}

/**
 * 分析文本情感
 * @param {string} text 待分析文本
 * @param {Array} history 历史消息记录
 * @param {Object} options 选项，包括平台和模型
 * @returns {Promise<Object>} 情感分析结果
 */
async function analyzeEmotion(text, history = [], options = {}) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 获取平台和模型
    const platformKey = options.platform || 'GEMINI';
    const platform = getPlatformConfig(platformKey);
    const modelName = options.model || platform.defaultModel;

    if (platformKey === 'GEMINI') {
      // Gemini特殊处理
      // 构建提示词
      let prompt = `你是一个专业且富有同理心的情感分析助手。请细致分析以下文本，并可选择性地参考之前的对话上下文（如果提供），以JSON格式返回全面的情感分析结果。

文本内容: "${text}"

返回的JSON对象应包含以下字段：
- primary_emotion: (String) 检测到的主要情感类型，必须使用中文表达 (例如: "焦虑", "喜悦", "愤怒", "平静", "悲伤", "惊讶", "厌恶", "期待", "紧迫", "失望", "疲惫" 等)。
- secondary_emotions: (Array<String>) 检测到的次要情感，必须使用中文表达（最多2个，按强度排序，如果没有则为空数组 []）。
- intensity: (Float) 主要情感的强度，范围 0.0 (几乎没有) 到 1.0 (非常强烈)。
- valence: (Float) 情感的愉悦度/极性，范围 -1.0 (非常负面) 到 1.0 (非常正面)，0.0 代表中性。
- arousal: (Float) 情感的激动/唤醒水平，范围 0.0 (非常平静/低能量) 到 1.0 (非常激动/高能量)。
- trend: (String) 与上一轮分析相比的情绪变化趋势，必须使用中文表达 ("上升", "下降", "稳定")。如果无法判断或无上一轮数据，则为 "未知"。请同时提供英文字段名 trend_en ("rising", "falling", "stable", "unknown")。
- attention_level: (String) 估计的用户在对话中的注意力或投入程度，必须使用中文表达 ("高", "中", "低")。请同时提供英文字段名 attention_level_en ("high", "medium", "low")。
- radar_dimensions: (Object) 针对以下维度的评分估计 (范围 0.0 到 1.0): {"trust": Float (信任度), "openness": Float (开放度), "resistance": Float (抗拒/防御), "stress": Float (压力水平), "control": Float (控制感/确定性)}。请根据对话内容合理估计。
- topic_keywords: (Array<String>) 与当前讨论**主题**相关的关键词，必须使用中文表达，最多5个，按重要性排序。
- emotion_triggers: (Array<String>) 最可能引发当前主要情感的用户文本中的关键词或短语，必须使用中文表达，最多3个。
- suggestions: (Array<String>) 基于当前情感、主题和维度分析，提供1-3条具体、可行的建议策略或共情回应，必须使用中文表达。
- summary: (String) 用一句中文简洁地总结用户当前的情感状态、可能的原因以及关键特征。

请确保输出是严格的JSON格式。如果某些字段无法可靠判断，可以使用合理的默认值（如 intensity: 0.5, valence: 0.0, arousal: 0.5, trend: "未知", attention_level: "中", radar_dimensions 各项为 0.5）或返回空数组/null（对于 secondary_emotions, emotion_triggers）。

重要提示：所有文本字段必须使用中文返回，不要使用英文。这对于前端显示和情感颜色分类至关重要。`;

      // 如果有历史消息，添加到prompt中
      if (Array.isArray(history) && history.length > 0) {
        // 最多添加5条历史消息作为上下文
        const contextMessages = history.slice(-5);
        let contextText = "\n\n对话历史上下文:\n";

        contextMessages.forEach(msg => {
          if (msg.role && msg.content) {
            contextText += `${msg.role === 'user' ? '用户' : 'AI'}: ${msg.content}\n`;
          }
        });

        prompt += contextText;
      }

      // 构建请求内容
      const contents = [
        {
          role: 'user',
          parts: [{ text: prompt }]
        }
      ];

      // 调用Gemini API
      const response = await callModelApi({
        model: modelName,
        contents: contents,
        temperature: 0.3,
        maxOutputTokens: 2048
      }, platformKey);

      // 解析API响应
      if (response && response.candidates && response.candidates.length > 0) {
        try {
          // 尝试解析JSON响应
          const candidate = response.candidates[0];
          if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
            const content = candidate.content.parts[0].text;
            // 提取JSON部分
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            const jsonStr = jsonMatch ? jsonMatch[0] : content;
            const result = JSON.parse(jsonStr);

            // 构建标准化的返回结果
            return {
              success: true,
              result: {
                // 兼容旧版字段
                type: result.primary_emotion || result.emotion_type || '平静',
                intensity: result.intensity || 0.5,
                keywords: result.topic_keywords || result.keywords || [],
                suggestions: result.suggestions || [],
                report: result.summary || result.report || '无法生成情感报告',
                originalText: text,
                // 新增字段
                primary_emotion: result.primary_emotion || result.emotion_type || '平静',
                secondary_emotions: result.secondary_emotions || [],
                valence: result.valence || 0.0,
                arousal: result.arousal || 0.5,
                trend: result.trend || '未知',
                trend_en: result.trend_en || 'unknown',
                attention_level: result.attention_level || '中',
                attention_level_en: result.attention_level_en || 'medium',
                radar_dimensions: result.radar_dimensions || {
                  trust: 0.5,
                  openness: 0.5,
                  resistance: 0.5,
                  stress: 0.5,
                  control: 0.5
                },
                topic_keywords: result.topic_keywords || [],
                emotion_triggers: result.emotion_triggers || [],
                summary: result.summary || result.report || '无法生成情感报告'
              },
              usage: response.usageMetadata || { promptTokenCount: 0, candidatesTokenCount: 0, totalTokenCount: 0 }
            };
          }
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析情感分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的情感分析结果为空'
      };
    } else if (platformKey === 'OPENAI' || platformKey === 'CROND' || platformKey === 'CLOSEAI') {
      // OpenAI, Crond API, CloseAI 处理
      // 构建消息数组
      const messages = [
        {
          role: 'system',
          content: `你是一个专业且富有同理心的情感分析助手。请细致分析用户最新输入的文本，并可选择性地参考之前的对话上下文（如果提供），以JSON格式返回全面的情感分析结果。
          返回的JSON对象应包含以下字段：
          - primary_emotion: (String) 检测到的主要情感类型，必须使用中文表达 (例如: "焦虑", "喜悦", "愤怒", "平静", "悲伤", "惊讶", "厌恶", "期待", "紧迫", "失望", "疲惫" 等)。
          - secondary_emotions: (Array<String>) 检测到的次要情感，必须使用中文表达（最多2个，按强度排序，如果没有则为空数组 []）。
          - intensity: (Float) 主要情感的强度，范围 0.0 (几乎没有) 到 1.0 (非常强烈)。
          - valence: (Float) 情感的愉悦度/极性，范围 -1.0 (非常负面) 到 1.0 (非常正面)，0.0 代表中性。
          - arousal: (Float) 情感的激动/唤醒水平，范围 0.0 (非常平静/低能量) 到 1.0 (非常激动/高能量)。
          - trend: (String) 与上一轮分析相比的情绪变化趋势，必须使用中文表达 ("上升", "下降", "稳定")。如果无法判断或无上一轮数据，则为 "未知"。请同时提供英文字段名 trend_en ("rising", "falling", "stable", "unknown")。
          - attention_level: (String) 估计的用户在对话中的注意力或投入程度，必须使用中文表达 ("高", "中", "低")。请同时提供英文字段名 attention_level_en ("high", "medium", "low")。
          - radar_dimensions: (Object) 针对以下维度的评分估计 (范围 0.0 到 1.0): {"trust": Float (信任度), "openness": Float (开放度), "resistance": Float (抗拒/防御), "stress": Float (压力水平), "control": Float (控制感/确定性)}。请根据对话内容合理估计。
          - topic_keywords: (Array<String>) 与当前讨论**主题**相关的关键词，必须使用中文表达，最多5个，按重要性排序。
          - emotion_triggers: (Array<String>) 最可能引发当前主要情感的用户文本中的关键词或短语，必须使用中文表达，最多3个。
          - suggestions: (Array<String>) 基于当前情感、主题和维度分析，提供1-3条具体、可行的建议策略或共情回应，必须使用中文表达。
          - summary: (String) 用一句中文简洁地总结用户当前的情感状态、可能的原因以及关键特征。

          请确保输出是严格的JSON格式。如果某些字段无法可靠判断，可以使用合理的默认值（如 intensity: 0.5, valence: 0.0, arousal: 0.5, trend: "未知", attention_level: "中", radar_dimensions 各项为 0.5）或返回空数组/null（对于 secondary_emotions, emotion_triggers）。

          重要提示：所有文本字段必须使用中文返回，不要使用英文。这对于前端显示和情感颜色分类至关重要。`
        }
      ];

      // 如果有历史消息，添加到messages中
      if (Array.isArray(history) && history.length > 0) {
        // 最多添加5条历史消息作为上下文
        const contextMessages = history.slice(-5);
        contextMessages.forEach(msg => {
          if (msg.role && msg.content) {
            messages.push({
              role: msg.role,
              content: msg.content
            });
          }
        });
      }

      // 添加当前用户消息
      messages.push({
        role: 'user',
        content: text
      });

      // 调用API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: messages,
          temperature: 0.3,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 构建标准化的返回结果
          return {
            success: true,
            result: {
              // 兼容旧版字段
              type: result.primary_emotion || result.emotion_type || '平静',
              intensity: result.intensity || 0.5,
              keywords: result.topic_keywords || result.keywords || [],
              suggestions: result.suggestions || [],
              report: result.summary || result.report || '无法生成情感报告',
              originalText: text,
              // 新增字段
              primary_emotion: result.primary_emotion || result.emotion_type || '平静',
              secondary_emotions: result.secondary_emotions || [],
              valence: result.valence || 0.0,
              arousal: result.arousal || 0.5,
              trend: result.trend || '未知',
              trend_en: result.trend_en || 'unknown',
              attention_level: result.attention_level || '中',
              attention_level_en: result.attention_level_en || 'medium',
              radar_dimensions: result.radar_dimensions || {
                trust: 0.5,
                openness: 0.5,
                resistance: 0.5,
                stress: 0.5,
                control: 0.5
              },
              topic_keywords: result.topic_keywords || [],
              emotion_triggers: result.emotion_triggers || [],
              summary: result.summary || result.report || '无法生成情感报告'
            },
            usage: response.usage || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析情感分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的情感分析结果为空'
      };
    } else {
      // 智谱AI处理
      // 构建消息数组
      const messages = [
        {
          role: 'system',
          content: `你是一个专业且富有同理心的情感分析助手。请细致分析用户最新输入的文本，并可选择性地参考之前的对话上下文（如果提供），以JSON格式返回全面的情感分析结果。
          返回的JSON对象应包含以下字段：
          - primary_emotion: (String) 检测到的主要情感类型，必须使用中文表达 (例如: "焦虑", "喜悦", "愤怒", "平静", "悲伤", "惊讶", "厌恶", "期待", "紧迫", "失望", "疲惫" 等)。
          - secondary_emotions: (Array<String>) 检测到的次要情感，必须使用中文表达（最多2个，按强度排序，如果没有则为空数组 []）。
          - intensity: (Float) 主要情感的强度，范围 0.0 (几乎没有) 到 1.0 (非常强烈)。
          - valence: (Float) 情感的愉悦度/极性，范围 -1.0 (非常负面) 到 1.0 (非常正面)，0.0 代表中性。
          - arousal: (Float) 情感的激动/唤醒水平，范围 0.0 (非常平静/低能量) 到 1.0 (非常激动/高能量)。
          - trend: (String) 与上一轮分析相比的情绪变化趋势，必须使用中文表达 ("上升", "下降", "稳定")。如果无法判断或无上一轮数据，则为 "未知"。请同时提供英文字段名 trend_en ("rising", "falling", "stable", "unknown")。
          - attention_level: (String) 估计的用户在对话中的注意力或投入程度，必须使用中文表达 ("高", "中", "低")。请同时提供英文字段名 attention_level_en ("high", "medium", "low")。
          - radar_dimensions: (Object) 针对以下维度的评分估计 (范围 0.0 到 1.0): {"trust": Float (信任度), "openness": Float (开放度), "resistance": Float (抗拒/防御), "stress": Float (压力水平), "control": Float (控制感/确定性)}。请根据对话内容合理估计。
          - topic_keywords: (Array<String>) 与当前讨论**主题**相关的关键词，必须使用中文表达，最多5个，按重要性排序。
          - emotion_triggers: (Array<String>) 最可能引发当前主要情感的用户文本中的关键词或短语，必须使用中文表达，最多3个。
          - suggestions: (Array<String>) 基于当前情感、主题和维度分析，提供1-3条具体、可行的建议策略或共情回应，必须使用中文表达。
          - summary: (String) 用一句中文简洁地总结用户当前的情感状态、可能的原因以及关键特征。

          请确保输出是严格的JSON格式。如果某些字段无法可靠判断，可以使用合理的默认值（如 intensity: 0.5, valence: 0.0, arousal: 0.5, trend: "未知", attention_level: "中", radar_dimensions 各项为 0.5）或返回空数组/null（对于 secondary_emotions, emotion_triggers）。

          重要提示：所有文本字段必须使用中文返回，不要使用英文。这对于前端显示和情感颜色分类至关重要。`
        }
      ];

      // 如果有历史消息，添加到messages中
      if (Array.isArray(history) && history.length > 0) {
        // 最多添加5条历史消息作为上下文
        const contextMessages = history.slice(-5);
        contextMessages.forEach(msg => {
          if (msg.role && msg.content) {
            messages.push({
              role: msg.role,
              content: msg.content
            });
          }
        });
      }

      // 添加当前用户消息
      messages.push({
        role: 'user',
        content: text
      });

      // 调用智谱AI API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: messages,
          temperature: 0.3,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 构建标准化的返回结果
          return {
            success: true,
            result: {
              // 兼容旧版字段
              type: result.primary_emotion || result.emotion_type || '平静',
              intensity: result.intensity || 0.5,
              keywords: result.topic_keywords || result.keywords || [],
              suggestions: result.suggestions || [],
              report: result.summary || result.report || '无法生成情感报告',
              originalText: text,
              // 新增字段
              primary_emotion: result.primary_emotion || result.emotion_type || '平静',
              secondary_emotions: result.secondary_emotions || [],
              valence: result.valence || 0.0,
              arousal: result.arousal || 0.5,
              trend: result.trend || '未知',
              trend_en: result.trend_en || 'unknown',
              attention_level: result.attention_level || '中',
              attention_level_en: result.attention_level_en || 'medium',
              radar_dimensions: result.radar_dimensions || {
                trust: 0.5,
                openness: 0.5,
                resistance: 0.5,
                stress: 0.5,
                control: 0.5
              },
              topic_keywords: result.topic_keywords || [],
              emotion_triggers: result.emotion_triggers || [],
              summary: result.summary || result.report || '无法生成情感报告'
            }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析情感分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的情感分析结果为空'
      };
    }
  } catch (error) {
    console.error('情感分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '情感分析失败'
    };
  }
}

// 导入子模块并传递辅助函数
const aiModelService_part2 = require('./aiModelService_part2');
const aiModelService_part3 = require('./aiModelService_part3');

// 将辅助函数注入到子模块中
aiModelService_part2.init(getPlatformConfig, callModelApi);
aiModelService_part3.init(getPlatformConfig, callModelApi);

// 导出模块
module.exports = {
  MODEL_PLATFORMS,
  analyzeEmotion,
  extractKeywords: aiModelService_part2.extractKeywords,
  getEmbeddings: aiModelService_part2.getEmbeddings,
  clusterKeywords: aiModelService_part3.clusterKeywords,
  analyzeUserInterests: aiModelService_part3.analyzeUserInterests
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\aiModelService_part2.js*#*#*begin*#*#*
// 辅助函数引用
let getPlatformConfig;
let callModelApi;

/**
 * 初始化模块，注入辅助函数
 * @param {Function} platformConfigFn 获取平台配置的函数
 * @param {Function} callApiFn 调用API的函数
 */
function init(platformConfigFn, callApiFn) {
  getPlatformConfig = platformConfigFn;
  callModelApi = callApiFn;
}

/**
 * 提取文本关键词
 * @param {string} text 待分析文本
 * @param {number} topK 返回关键词数量
 * @param {Object} options 选项，包括平台和模型
 * @returns {Promise<Object>} 关键词提取结果
 */
async function extractKeywords(text, topK = 10, options = {}) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 获取平台和模型
    const platformKey = options.platform || 'GEMINI';
    const platform = getPlatformConfig(platformKey);
    const modelName = options.model || platform.defaultModel;

    if (platformKey === 'GEMINI') {
      // Gemini特殊处理
      // 构建Prompt
      const prompt = `你是一个专业的文本分析助手。请从以下文本中提取最重要的关键词，并以JSON格式返回结果。文本内容：

${text}

返回的JSON应包含以下字段：
- keywords: 关键词数组，每个元素是一个对象，包含word(关键词)和weight(权重,0-1之间的浮点数)

请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。提取的关键词数量不超过${topK}个，按重要性降序排列。`;

      // 构建请求内容
      const contents = [
        {
          role: 'user',
          parts: [{ text: prompt }]
        }
      ];

      // 调用Gemini API
      const response = await callModelApi({
        model: modelName,
        contents: contents,
        temperature: 0.2,
        maxOutputTokens: 1024
      }, platformKey);

      // 解析API响应
      if (response && response.candidates && response.candidates.length > 0) {
        try {
          // 尝试解析JSON响应
          const candidate = response.candidates[0];
          if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
            const content = candidate.content.parts[0].text;
            // 提取JSON部分
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            const jsonStr = jsonMatch ? jsonMatch[0] : content;
            const result = JSON.parse(jsonStr);

            // 确保keywords是一个数组
            const keywords = Array.isArray(result.keywords) ? result.keywords : [];

            // 构建标准化的返回结果
            return {
              success: true,
              data: {
                keywords: keywords.slice(0, topK) // 确保不超过topK个关键词
              }
            };
          }
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析关键词提取结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的关键词提取结果为空'
      };
    } else if (platformKey === 'OPENAI' || platformKey === 'CROND' || platformKey === 'CLOSEAI') {
      // OpenAI, Crond API, CloseAI 处理
      // 构建Prompt
      const messages = [
        {
          role: 'system',
          content: `你是一个专业的文本分析助手。请从用户提供的文本中提取最重要的关键词，并以JSON格式返回结果。
          返回的JSON应包含以下字段：
          - keywords: 关键词数组，每个元素是一个对象，包含word(关键词)和weight(权重,0-1之间的浮点数)

          请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。提取的关键词数量不超过${topK}个，按重要性降序排列。`
        },
        {
          role: 'user',
          content: text
        }
      ];

      // 调用API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: messages,
          temperature: 0.2,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 确保keywords是一个数组
          const keywords = Array.isArray(result.keywords) ? result.keywords : [];

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              keywords: keywords.slice(0, topK) // 确保不超过topK个关键词
            }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析关键词提取结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的关键词提取结果为空'
      };
    } else {
      // 智谱AI处理
      // 构建Prompt
      const messages = [
        {
          role: 'system',
          content: `你是一个专业的文本分析助手。请从用户提供的文本中提取最重要的关键词，并以JSON格式返回结果。
          返回的JSON应包含以下字段：
          - keywords: 关键词数组，每个元素是一个对象，包含word(关键词)和weight(权重,0-1之间的浮点数)

          请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。提取的关键词数量不超过${topK}个，按重要性降序排列。`
        },
        {
          role: 'user',
          content: text
        }
      ];

      // 调用智谱AI API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: messages,
          temperature: 0.2,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 确保keywords是一个数组
          const keywords = Array.isArray(result.keywords) ? result.keywords : [];

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              keywords: keywords.slice(0, topK) // 确保不超过topK个关键词
            }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析关键词提取结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的关键词提取结果为空'
      };
    }
  } catch (error) {
    console.error('关键词提取失败:', error.message || error);
    return {
      success: false,
      error: error.message || '关键词提取失败'
    };
  }
}

/**
 * 获取文本的词向量表示
 * @param {Array<string>} texts 文本数组
 * @param {Object} options 选项，包括平台和模型
 * @returns {Promise<Object>} 词向量结果
 */
async function getEmbeddings(texts, options = {}) {
  try {
    // 验证参数
    if (!Array.isArray(texts) || texts.length === 0) {
      return {
        success: false,
        error: '无效的文本数组参数'
      };
    }

    // 获取平台和模型
    const platformKey = options.platform || 'ZHIPU'; // 默认使用智谱AI，因为Gemini不支持词向量
    const platform = getPlatformConfig(platformKey);
    const modelName = options.model || platform.embeddingModel || platform.defaultModel;

    if (platformKey !== 'ZHIPU') {
      console.warn(`${platformKey}不支持词向量功能，将使用智谱AI`);
      // 如果不是智谱AI，使用本地模拟词向量
      // 生成模拟词向量（每个向量1536维，与智谱AI的embedding-3模型一致）
      const mockEmbeddings = texts.map(text => {
        // 基于文本生成伪随机数，使相同文本生成相同向量
        const seed = text.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
        const vector = [];

        // 生成1536维的向量
        for (let i = 0; i < 1536; i++) {
          // 使用简单的伪随机数生成算法
          const val = Math.sin(seed * (i + 1)) * 0.5 + 0.5;
          vector.push(val);
        }

        return vector;
      });

      return {
        success: true,
        data: {
          embeddings: mockEmbeddings
        }
      };
    }

    // 智谱AI处理
    // 调用智谱AI API
    const response = await callModelApi({
      model: modelName,
      endpoint: platform.endpoints.embedding,
      body: {
        input: texts
      }
    }, platformKey);

    // 解析API响应
    if (response && response.data) {
      // 提取词向量
      const embeddings = response.data.map(item => item.embedding);

      return {
        success: true,
        data: {
          embeddings: embeddings
        }
      };
    }

    return {
      success: false,
      error: '返回的词向量结果为空'
    };
  } catch (error) {
    console.error('获取词向量失败:', error.message || error);
    return {
      success: false,
      error: error.message || '获取词向量失败'
    };
  }
}

// 导出模块
module.exports = {
  init,
  extractKeywords,
  getEmbeddings
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\aiModelService_part3.js*#*#*begin*#*#*
// 辅助函数引用
let getPlatformConfig;
let callModelApi;

/**
 * 初始化模块，注入辅助函数
 * @param {Function} platformConfigFn 获取平台配置的函数
 * @param {Function} callApiFn 调用API的函数
 */
function init(platformConfigFn, callApiFn) {
  getPlatformConfig = platformConfigFn;
  callModelApi = callApiFn;
}

/**
 * 聚类分析
 * @param {string} text 待分析文本
 * @param {number} threshold 聚类阈值
 * @param {number} minClusterSize 最小簇大小
 * @param {Object} options 选项，包括平台和模型
 * @returns {Promise<Object>} 聚类结果
 */
async function clusterKeywords(text, threshold = 0.7, minClusterSize = 2, options = {}) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 获取平台和模型
    const platformKey = options.platform || 'GEMINI';
    const platform = getPlatformConfig(platformKey);
    const modelName = options.model || platform.defaultModel;

    if (platformKey === 'GEMINI') {
      // Gemini特殊处理
      // 构建Prompt
      const prompt = `你是一个专业的文本分析助手。请从以下文本中提取关键词，并将语义相近的关键词聚类，以JSON格式返回结果。文本内容：

${text}

返回的JSON应包含以下字段：
- clusters: 聚类结果数组，每个元素是一个对象，包含以下字段：
  - keywords: 该簇包含的关键词数组
  - center: 该簇的中心词或主题
  - size: 该簇的大小(关键词数量)

请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。每个簇至少包含${minClusterSize}个关键词，相似度阈值为${threshold}。`;

      // 构建请求内容
      const contents = [
        {
          role: 'user',
          parts: [{ text: prompt }]
        }
      ];

      // 调用Gemini API
      const response = await callModelApi({
        model: modelName,
        contents: contents,
        temperature: 0.3,
        maxOutputTokens: 2048
      }, platformKey);

      // 解析API响应
      if (response && response.candidates && response.candidates.length > 0) {
        try {
          // 尝试解析JSON响应
          const candidate = response.candidates[0];
          if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
            const content = candidate.content.parts[0].text;
            // 提取JSON部分
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            const jsonStr = jsonMatch ? jsonMatch[0] : content;
            const result = JSON.parse(jsonStr);

            // 确保clusters是一个数组
            const clusters = Array.isArray(result.clusters) ? result.clusters : [];

            // 过滤掉不符合最小簇大小要求的簇
            const validClusters = clusters.filter(cluster =>
              Array.isArray(cluster.keywords) && cluster.keywords.length >= minClusterSize
            );

            // 构建标准化的返回结果
            return {
              success: true,
              data: {
                clusters: validClusters
              }
            };
          }
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析聚类分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的聚类分析结果为空'
      };
    } else if (platformKey === 'OPENAI' || platformKey === 'CROND' || platformKey === 'CLOSEAI') {
      // OpenAI, Crond API, CloseAI 处理
      // 构建Prompt
      const messages = [
        {
          role: 'system',
          content: `你是一个专业的文本分析助手。请从用户提供的文本中提取关键词，并将语义相近的关键词聚类，以JSON格式返回结果。
          返回的JSON应包含以下字段：
          - clusters: 聚类结果数组，每个元素是一个对象，包含以下字段：
            - keywords: 该簇包含的关键词数组
            - center: 该簇的中心词或主题
            - size: 该簇的大小(关键词数量)

          请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。每个簇至少包含${minClusterSize}个关键词，相似度阈值为${threshold}。`
        },
        {
          role: 'user',
          content: text
        }
      ];

      // 调用API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: messages,
          temperature: 0.3,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 确保clusters是一个数组
          const clusters = Array.isArray(result.clusters) ? result.clusters : [];

          // 过滤掉不符合最小簇大小要求的簇
          const validClusters = clusters.filter(cluster =>
            Array.isArray(cluster.keywords) && cluster.keywords.length >= minClusterSize
          );

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              clusters: validClusters
            }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析聚类分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的聚类分析结果为空'
      };
    } else {
      // 智谱AI处理
      // 构建Prompt
      const messages = [
        {
          role: 'system',
          content: `你是一个专业的文本分析助手。请从用户提供的文本中提取关键词，并将语义相近的关键词聚类，以JSON格式返回结果。
          返回的JSON应包含以下字段：
          - clusters: 聚类结果数组，每个元素是一个对象，包含以下字段：
            - keywords: 该簇包含的关键词数组
            - center: 该簇的中心词或主题
            - size: 该簇的大小(关键词数量)

          请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。每个簇至少包含${minClusterSize}个关键词，相似度阈值为${threshold}。`
        },
        {
          role: 'user',
          content: text
        }
      ];

      // 调用智谱AI API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: messages,
          temperature: 0.3,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 确保clusters是一个数组
          const clusters = Array.isArray(result.clusters) ? result.clusters : [];

          // 过滤掉不符合最小簇大小要求的簇
          const validClusters = clusters.filter(cluster =>
            Array.isArray(cluster.keywords) && cluster.keywords.length >= minClusterSize
          );

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              clusters: validClusters
            }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析聚类分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的聚类分析结果为空'
      };
    }
  } catch (error) {
    console.error('聚类分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '聚类分析失败'
    };
  }
}

/**
 * 分析用户兴趣
 * @param {Array<string>} messages 用户历史消息
 * @param {Object} options 选项，包括平台和模型
 * @returns {Promise<Object>} 兴趣分析结果
 */
async function analyzeUserInterests(messages, options = {}) {
  try {
    // 验证参数
    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        success: false,
        error: '无效的消息参数'
      };
    }

    // 获取平台和模型
    const platformKey = options.platform || 'GEMINI';
    const platform = getPlatformConfig(platformKey);
    const modelName = options.model || platform.defaultModel;

    // 合并消息文本
    const combinedText = messages.join('\n');

    if (platformKey === 'GEMINI') {
      // Gemini特殊处理
      // 构建Prompt
      const prompt = `你是一个专业的用户兴趣分析助手。请分析以下用户的历史消息，提取用户可能的兴趣领域，并以JSON格式返回分析结果。

以下是用户的历史消息，请分析其中可能的兴趣领域：
${combinedText}

返回的JSON应包含以下字段：
- interests: 兴趣领域数组，每个元素是一个对象，包含以下字段：
  - name: 兴趣领域名称
  - confidence: 置信度，0-1之间的浮点数
  - keywords: 与该兴趣相关的关键词数组
- summary: 用户兴趣的简短总结

请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。`;

      // 构建请求内容
      const contents = [
        {
          role: 'user',
          parts: [{ text: prompt }]
        }
      ];

      // 调用Gemini API
      const response = await callModelApi({
        model: modelName,
        contents: contents,
        temperature: 0.3,
        maxOutputTokens: 2048
      }, platformKey);

      // 解析API响应
      if (response && response.candidates && response.candidates.length > 0) {
        try {
          // 尝试解析JSON响应
          const candidate = response.candidates[0];
          if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
            const content = candidate.content.parts[0].text;
            // 提取JSON部分
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            const jsonStr = jsonMatch ? jsonMatch[0] : content;
            const result = JSON.parse(jsonStr);

            // 构建标准化的返回结果
            return {
              success: true,
              data: {
                interests: result.interests || [],
                summary: result.summary || '无法生成兴趣总结'
              }
            };
          }
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析兴趣分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的兴趣分析结果为空'
      };
    } else if (platformKey === 'OPENAI' || platformKey === 'CROND' || platformKey === 'CLOSEAI') {
      // OpenAI, Crond API, CloseAI 处理
      // 构建Prompt
      const promptMessages = [
        {
          role: 'system',
          content: `你是一个专业的用户兴趣分析助手。请分析用户的历史消息，提取用户可能的兴趣领域，并以JSON格式返回分析结果。
          返回的JSON应包含以下字段：
          - interests: 兴趣领域数组，每个元素是一个对象，包含以下字段：
            - name: 兴趣领域名称
            - confidence: 置信度，0-1之间的浮点数
            - keywords: 与该兴趣相关的关键词数组
          - summary: 用户兴趣的简短总结

          请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。`
        },
        {
          role: 'user',
          content: `以下是用户的历史消息，请分析其中可能的兴趣领域：\n${combinedText}`
        }
      ];

      // 调用API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: promptMessages,
          temperature: 0.3,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              interests: result.interests || [],
              summary: result.summary || '无法生成兴趣总结'
            }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析兴趣分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的兴趣分析结果为空'
      };
    } else {
      // 智谱AI处理
      // 构建Prompt
      const promptMessages = [
        {
          role: 'system',
          content: `你是一个专业的用户兴趣分析助手。请分析用户的历史消息，提取用户可能的兴趣领域，并以JSON格式返回分析结果。
          返回的JSON应包含以下字段：
          - interests: 兴趣领域数组，每个元素是一个对象，包含以下字段：
            - name: 兴趣领域名称
            - confidence: 置信度，0-1之间的浮点数
            - keywords: 与该兴趣相关的关键词数组
          - summary: 用户兴趣的简短总结

          请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。`
        },
        {
          role: 'user',
          content: `以下是用户的历史消息，请分析其中可能的兴趣领域：\n${combinedText}`
        }
      ];

      // 调用智谱AI API
      const response = await callModelApi({
        model: modelName,
        body: {
          messages: promptMessages,
          temperature: 0.3,
          response_format: { type: 'json_object' }
        }
      }, platformKey);

      // 解析API响应
      if (response && response.choices && response.choices.length > 0) {
        try {
          // 尝试解析JSON响应
          const content = response.choices[0].message.content;
          const result = JSON.parse(content);

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              interests: result.interests || [],
              summary: result.summary || '无法生成兴趣总结'
            }
          };
        } catch (parseError) {
          console.error('解析JSON响应失败:', parseError.message || parseError);
          return {
            success: false,
            error: '解析兴趣分析结果失败'
          };
        }
      }

      return {
        success: false,
        error: '返回的兴趣分析结果为空'
      };
    }
  } catch (error) {
    console.error('用户兴趣分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '用户兴趣分析失败'
    };
  }
}

// 导出模块
module.exports = {
  init,
  clusterKeywords,
  analyzeUserInterests
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\bigmodel.js*#*#*begin*#*#*
/**
 * 智谱AI (BigModel) 模块
 * 提供基于智谱AI的情感分析和关键词提取功能
 */
const axios = require('axios');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 智谱AI API配置
// 注意：实际使用时应从环境变量或安全配置中读取API密钥，而不是硬编码
const API_KEY = process.env.ZHIPU_API_KEY || ''; // 从环境变量获取API密钥
const API_BASE_URL = 'https://open.bigmodel.cn/api/paas/v4';

// 模型配置
const GLM_4_FLASH = 'glm-4-flash'; // 快速版本，适合对话和基础分析
const EMBEDDING_3 = 'embedding-3'; // 文本向量化模型

/**
 * 生成智谱AI API请求所需的认证头
 * @returns {Object} 包含Authorization的请求头
 */
function getAuthHeaders() {
  // 实际项目中应使用智谱AI SDK进行认证
  // 这里简化处理，假设API_KEY已经是完整的Bearer Token
  return {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${API_KEY}`
  };
}

/**
 * 使用GLM-4-Flash模型进行情感分析
 * @param {string} text 待分析文本
 * @param {Array} history 历史消息记录（可选）
 * @returns {Promise<Object>} 情感分析结果
 */
async function analyzeEmotion(text, history = []) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 构建Prompt，要求模型分析情感并以JSON格式返回
    const messages = [
      {
        role: 'system',
        content: `你是一个专业且富有同理心的情感分析助手。请细致分析用户最新输入的文本，并可选择性地参考之前的对话上下文（如果提供），以JSON格式返回全面的情感分析结果。
        返回的JSON对象应包含以下字段：
        - primary_emotion: (String) 检测到的主要情感类型，必须使用中文表达 (例如: "焦虑", "喜悦", "愤怒", "平静", "悲伤", "惊讶", "厌恶", "期待", "紧迫", "失望", "疲惫" 等)。
        - secondary_emotions: (Array<String>) 检测到的次要情感，必须使用中文表达（最多2个，按强度排序，如果没有则为空数组 []）。
        - intensity: (Float) 主要情感的强度，范围 0.0 (几乎没有) 到 1.0 (非常强烈)。
        - valence: (Float) 情感的愉悦度/极性，范围 -1.0 (非常负面) 到 1.0 (非常正面)，0.0 代表中性。
        - arousal: (Float) 情感的激动/唤醒水平，范围 0.0 (非常平静/低能量) 到 1.0 (非常激动/高能量)。
        - trend: (String) 与上一轮分析相比的情绪变化趋势，必须使用中文表达 ("上升", "下降", "稳定")。如果无法判断或无上一轮数据，则为 "未知"。请同时提供英文字段名 trend_en ("rising", "falling", "stable", "unknown")。
        - attention_level: (String) 估计的用户在对话中的注意力或投入程度，必须使用中文表达 ("高", "中", "低")。请同时提供英文字段名 attention_level_en ("high", "medium", "low")。
        - radar_dimensions: (Object) 针对以下维度的评分估计 (范围 0.0 到 1.0): {"trust": Float (信任度), "openness": Float (开放度), "resistance": Float (抗拒/防御), "stress": Float (压力水平), "control": Float (控制感/确定性)}。请根据对话内容合理估计。
        - topic_keywords: (Array<String>) 与当前讨论**主题**相关的关键词，必须使用中文表达，最多5个，按重要性排序。
        - emotion_triggers: (Array<String>) 最可能引发当前主要情感的用户文本中的关键词或短语，必须使用中文表达，最多3个。
        - suggestions: (Array<String>) 基于当前情感、主题和维度分析，提供1-3条具体、可行的建议策略或共情回应，必须使用中文表达。
        - summary: (String) 用一句中文简洁地总结用户当前的情感状态、可能的原因以及关键特征。

        请确保输出是严格的JSON格式。如果某些字段无法可靠判断，可以使用合理的默认值（如 intensity: 0.5, valence: 0.0, arousal: 0.5, trend: "未知", attention_level: "中", radar_dimensions 各项为 0.5）或返回空数组/null（对于 secondary_emotions, emotion_triggers）。

        重要提示：所有文本字段必须使用中文返回，不要使用英文。这对于前端显示和情感颜色分类至关重要。`
      }
    ];

    // 如果有历史消息，添加到messages中
    if (Array.isArray(history) && history.length > 0) {
      // 最多添加5条历史消息作为上下文
      const contextMessages = history.slice(-5);
      contextMessages.forEach(msg => {
        if (msg.role && msg.content) {
          messages.push({
            role: msg.role,
            content: msg.content
          });
        }
      });
    }

    // 添加当前用户消息
    messages.push({
      role: 'user',
      content: text
    });

    // 调用智谱AI API
    const response = await axios.post(`${API_BASE_URL}/chat/completions`, {
      model: GLM_4_FLASH,
      messages: messages,
      temperature: 0.3, // 较低的温度以获得更确定性的结果
      response_format: { type: 'json_object' } // 请求JSON格式的响应
    }, {
      headers: getAuthHeaders()
    });

    // 解析API响应
    if (response.data && response.data.choices && response.data.choices.length > 0) {
      try {
        // 尝试解析JSON响应
        const content = response.data.choices[0].message.content;
        const result = JSON.parse(content);

        // 构建标准化的返回结果
        return {
          success: true,
          result: {
            // 兼容旧版字段
            type: result.primary_emotion || result.emotion_type || '平静',
            intensity: result.intensity || 0.5,
            keywords: result.topic_keywords || result.keywords || [],
            suggestions: result.suggestions || [],
            report: result.summary || result.report || '无法生成情感报告',
            originalText: text,
            // 新增字段
            primary_emotion: result.primary_emotion || result.emotion_type || '平静',
            secondary_emotions: result.secondary_emotions || [],
            valence: result.valence || 0.0,
            arousal: result.arousal || 0.5,
            trend: result.trend || '未知',
            trend_en: result.trend_en || 'unknown',
            attention_level: result.attention_level || '中',
            attention_level_en: result.attention_level_en || 'medium',
            radar_dimensions: result.radar_dimensions || {
              trust: 0.5,
              openness: 0.5,
              resistance: 0.5,
              stress: 0.5,
              control: 0.5
            },
            topic_keywords: result.topic_keywords || [],
            emotion_triggers: result.emotion_triggers || [],
            summary: result.summary || result.report || '无法生成情感报告'
          }
        };
      } catch (parseError) {
        console.error('解析智谱AI JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析情感分析结果失败'
        };
      }
    } else {
      return {
        success: false,
        error: '智谱AI返回的情感分析结果为空'
      };
    }
  } catch (error) {
    console.error('智谱AI情感分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '情感分析服务调用失败'
    };
  }
}

/**
 * 使用GLM-4-Flash模型提取关键词
 * @param {string} text 待分析文本
 * @param {number} topK 返回关键词数量
 * @returns {Promise<Object>} 关键词提取结果
 */
async function extractKeywords(text, topK = 10) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 构建Prompt，要求模型提取关键词并以JSON格式返回
    const messages = [
      {
        role: 'system',
        content: `你是一个专业的文本分析助手。请从用户提供的文本中提取最重要的关键词，并以JSON格式返回结果。
        返回的JSON应包含以下字段：
        - keywords: 关键词数组，每个元素是一个对象，包含word(关键词)和weight(权重,0-1之间的浮点数)

        请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。提取的关键词数量不超过${topK}个，按重要性降序排列。`
      },
      {
        role: 'user',
        content: text
      }
    ];

    // 调用智谱AI API
    const response = await axios.post(`${API_BASE_URL}/chat/completions`, {
      model: GLM_4_FLASH,
      messages: messages,
      temperature: 0.2, // 较低的温度以获得更确定性的结果
      response_format: { type: 'json_object' } // 请求JSON格式的响应
    }, {
      headers: getAuthHeaders()
    });

    // 解析API响应
    if (response.data && response.data.choices && response.data.choices.length > 0) {
      try {
        // 尝试解析JSON响应
        const content = response.data.choices[0].message.content;
        const result = JSON.parse(content);

        // 确保keywords是一个数组
        const keywords = Array.isArray(result.keywords) ? result.keywords : [];

        // 构建标准化的返回结果
        return {
          success: true,
          data: {
            keywords: keywords.slice(0, topK) // 确保不超过topK个关键词
          }
        };
      } catch (parseError) {
        console.error('解析智谱AI JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析关键词提取结果失败'
        };
      }
    } else {
      return {
        success: false,
        error: '智谱AI返回的关键词提取结果为空'
      };
    }
  } catch (error) {
    console.error('智谱AI关键词提取失败:', error.message || error);
    return {
      success: false,
      error: error.message || '关键词提取服务调用失败'
    };
  }
}

/**
 * 获取词向量 (使用智谱AI)
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getWordVectors(event) {
  try {
    // 获取参数
    const { texts } = event;

    // 验证参数
    if (!texts) {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 确保texts是数组
    const textArray = Array.isArray(texts) ? texts : [texts];

    // 验证数组不为空
    if (textArray.length === 0) {
      return {
        success: false,
        error: '文本数组为空'
      };
    }

    if (isDev) {
      console.log('调用智谱AI词向量获取, 输入:', textArray);
    }

    // 调用智谱AI词向量获取
    const result = await getEmbeddings(textArray);

    if (isDev) {
      console.log('智谱AI词向量获取结果:', result);
    }

    // 返回结果
    return result;
  } catch (error) {
    console.error('获取词向量失败:', error.message || error);
    return {
      success: false,
      error: error.message || '词向量服务调用失败'
    };
  }
}

/**
 * 使用GLM-4-Flash模型进行聚类分析
 * @param {string} text 待分析文本
 * @param {number} threshold 聚类阈值
 * @param {number} minClusterSize 最小簇大小
 * @returns {Promise<Object>} 聚类结果
 */
async function clusterKeywords(text, threshold = 0.7, minClusterSize = 2) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 构建Prompt，要求模型进行聚类分析并以JSON格式返回
    const messages = [
      {
        role: 'system',
        content: `你是一个专业的文本分析助手。请从用户提供的文本中提取关键词，并将语义相近的关键词聚类，以JSON格式返回结果。
        返回的JSON应包含以下字段：
        - clusters: 聚类结果数组，每个元素是一个对象，包含以下字段：
          - keywords: 该簇包含的关键词数组
          - center: 该簇的中心词或主题
          - size: 该簇的大小(关键词数量)

        请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。每个簇至少包含${minClusterSize}个关键词，相似度阈值为${threshold}。`
      },
      {
        role: 'user',
        content: text
      }
    ];

    // 调用智谱AI API
    const response = await axios.post(`${API_BASE_URL}/chat/completions`, {
      model: GLM_4_FLASH,
      messages: messages,
      temperature: 0.3,
      response_format: { type: 'json_object' } // 请求JSON格式的响应
    }, {
      headers: getAuthHeaders()
    });

    // 解析API响应
    if (response.data && response.data.choices && response.data.choices.length > 0) {
      try {
        // 尝试解析JSON响应
        const content = response.data.choices[0].message.content;
        const result = JSON.parse(content);

        // 确保clusters是一个数组
        const clusters = Array.isArray(result.clusters) ? result.clusters : [];

        // 过滤掉不符合最小簇大小要求的簇
        const validClusters = clusters.filter(cluster =>
          Array.isArray(cluster.keywords) && cluster.keywords.length >= minClusterSize
        );

        // 构建标准化的返回结果
        return {
          success: true,
          data: {
            clusters: validClusters
          }
        };
      } catch (parseError) {
        console.error('解析智谱AI JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析聚类分析结果失败'
        };
      }
    } else {
      return {
        success: false,
        error: '智谱AI返回的聚类分析结果为空'
      };
    }
  } catch (error) {
    console.error('智谱AI聚类分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '聚类分析服务调用失败'
    };
  }
}

/**
 * 使用GLM-4-Flash模型生成用户兴趣分析报告
 * @param {Array<string>} messages 用户历史消息
 * @returns {Promise<Object>} 兴趣分析结果
 */
async function analyzeUserInterests(messages) {
  try {
    // 验证参数
    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        success: false,
        error: '无效的消息参数'
      };
    }

    // 合并消息文本
    const combinedText = messages.join('\n');

    // 构建Prompt，要求模型分析用户兴趣并以JSON格式返回
    const promptMessages = [
      {
        role: 'system',
        content: `你是一个专业的用户兴趣分析助手。请分析用户的历史消息，提取用户可能的兴趣领域，并以JSON格式返回分析结果。
        返回的JSON应包含以下字段：
        - interests: 兴趣领域数组，每个元素是一个对象，包含以下字段：
          - name: 兴趣领域名称
          - confidence: 置信度，0-1之间的浮点数
          - keywords: 与该兴趣相关的关键词数组
        - summary: 用户兴趣的简短总结

        请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。`
      },
      {
        role: 'user',
        content: `以下是用户的历史消息，请分析其中可能的兴趣领域：\n${combinedText}`
      }
    ];

    // 调用智谱AI API
    const response = await axios.post(`${API_BASE_URL}/chat/completions`, {
      model: GLM_4_FLASH,
      messages: promptMessages,
      temperature: 0.3,
      response_format: { type: 'json_object' } // 请求JSON格式的响应
    }, {
      headers: getAuthHeaders()
    });

    // 解析API响应
    if (response.data && response.data.choices && response.data.choices.length > 0) {
      try {
        // 尝试解析JSON响应
        const content = response.data.choices[0].message.content;
        const result = JSON.parse(content);

        // 构建标准化的返回结果
        return {
          success: true,
          data: {
            interests: result.interests || [],
            summary: result.summary || '无法生成兴趣总结'
          }
        };
      } catch (parseError) {
        console.error('解析智谱AI JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析兴趣分析结果失败'
        };
      }
    } else {
      return {
        success: false,
        error: '智谱AI返回的兴趣分析结果为空'
      };
    }
  } catch (error) {
    console.error('智谱AI兴趣分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '兴趣分析服务调用失败'
    };
  }
}

/**
 * 获取文本的词向量表示
 * @param {Array<string>} texts 文本数组
 * @returns {Promise<Object>} 词向量结果
 */
async function getEmbeddings(texts) {
  try {
    // 验证参数
    if (!Array.isArray(texts) || texts.length === 0) {
      return {
        success: false,
        error: '无效的文本数组参数'
      };
    }

    if (isDev) {
      console.log('准备获取词向量, 文本数量:', texts.length);
    }

    // 当API_KEY为空时，使用本地模拟词向量
    if (!process.env.ZHIPU_API_KEY) {
      console.warn('智谱AI API密钥未设置，使用本地模拟词向量');

      // 生成模拟词向量（每个向量1536维，与智谱AI的embedding-3模型一致）
      const mockEmbeddings = texts.map(text => {
        // 基于文本生成伪随机数，使相同文本生成相同向量
        const seed = text.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
        const vector = [];

        // 生成1536维的向量
        for (let i = 0; i < 1536; i++) {
          // 使用伪随机数生成器，确保相同文本生成相同向量
          const value = Math.sin(seed * (i + 1)) / 2 + 0.5; // 生成 0-1 之间的值
          vector.push(value);
        }

        // 向量归一化
        const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        return vector.map(val => val / magnitude);
      });

      console.log('本地生成模拟词向量成功, 第一个向量维度:', mockEmbeddings[0].length);

      return {
        success: true,
        data: {
          vectors: mockEmbeddings
        },
        source: 'local' // 标记数据来源为本地生成
      };
    }

    // 调用智谱AI API
    console.log('调用智谱AI词向量接口...');
    const response = await axios.post(`${API_BASE_URL}/embeddings`, {
      model: EMBEDDING_3,
      input: texts
    }, {
      headers: getAuthHeaders()
    });

    console.log('智谱AI词向量接口返回状态码:', response.status);

    // 解析API响应
    if (response.data && response.data.data && Array.isArray(response.data.data)) {
      // 提取向量数据
      const embeddings = response.data.data.map(item => item.embedding);
      console.log('成功获取词向量, 第一个向量维度:', embeddings[0].length);

      return {
        success: true,
        data: {
          vectors: embeddings
        },
        source: 'api' // 标记数据来源为API
      };
    } else {
      console.error('智谱AI返回的词向量结果格式不正确:', response.data);
      return {
        success: false,
        error: '智谱AI返回的词向量结果格式不正确'
      };
    }
  } catch (error) {
    console.error('智谱AI词向量获取失败:', error);

    // 当API调用失败时，使用本地模拟词向量
    console.warn('由于API调用失败，切换为本地模拟词向量');

    // 生成模拟词向量
    const mockEmbeddings = texts.map(text => {
      const seed = text.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      const vector = [];

      for (let i = 0; i < 1536; i++) {
        const value = Math.sin(seed * (i + 1)) / 2 + 0.5;
        vector.push(value);
      }

      const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
      return vector.map(val => val / magnitude);
    });

    return {
      success: true,
      data: {
        vectors: mockEmbeddings
      },
      source: 'local_fallback', // 标记数据来源为本地备选
      originalError: error.message || '词向量服务调用失败'
    };
  }
}

/**
 * 使用GLM-4-Flash模型生成报告内容
 * @param {string} prompt 提示词
 * @returns {Promise<Object>} 生成结果
 */
async function generateReportContent(prompt) {
  try {
    // 验证参数
    if (!prompt || typeof prompt !== 'string' || prompt.trim() === '') {
      return {
        success: false,
        error: '无效的提示词参数'
      };
    }

    // 构建消息数组
    const messages = [
      {
        role: 'system',
        content: `你是一个专业的情感分析助手，擅长分析用户的情绪状态并提供有价值的洞察和建议。
        请根据用户提供的文本生成每日心情报告，包括情感总结、洞察、建议、今日运势和鼓励语。
        请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。`
      },
      {
        role: 'user',
        content: prompt
      }
    ];

    // 调用智谱AI API
    const response = await axios.post(`${API_BASE_URL}/chat/completions`, {
      model: GLM_4_FLASH,
      messages: messages,
      temperature: 0.7, // 适当提高创造性
      response_format: { type: 'json_object' } // 请求JSON格式的响应
    }, {
      headers: getAuthHeaders()
    });

    // 解析API响应
    if (response.data && response.data.choices && response.data.choices.length > 0) {
      try {
        // 尝试解析JSON响应
        const content = response.data.choices[0].message.content;
        const result = JSON.parse(content);

        // 返回结果
        return {
          success: true,
          result: result
        };
      } catch (parseError) {
        console.error('解析智谱AI JSON响应失败:', parseError);
        return {
          success: false,
          error: '解析报告内容失败'
        };
      }
    } else {
      return {
        success: false,
        error: '智谱AI返回的报告内容为空'
      };
    }
  } catch (error) {
    console.error('生成报告内容失败:', error);
    return {
      success: false,
      error: error.message || '生成报告内容失败'
    };
  }
}

/**
 * 使用GLM-4-Flash模型进行通用对话调用
 * @param {Object} options 调用选项
 * @param {Array} options.messages 消息数组
 * @param {number} options.temperature 温度参数
 * @param {Object} options.response_format 响应格式
 * @returns {Promise<Object>} 调用结果
 */
async function chatCompletion(options) {
  try {
    // 验证参数
    if (!options || !Array.isArray(options.messages) || options.messages.length === 0) {
      throw new Error('无效的消息参数');
    }

    // 调用智谱AI API
    console.log('调用智谱AI对话接口, 消息数量:', options.messages.length);

    const response = await axios.post(`${API_BASE_URL}/chat/completions`, {
      model: GLM_4_FLASH,
      messages: options.messages,
      temperature: options.temperature || 0.3,
      response_format: options.response_format || { type: 'text' }
    }, {
      headers: getAuthHeaders()
    });

    console.log('智谱AI对话接口返回状态码:', response.status);

    // 返回原始响应
    return response.data;
  } catch (error) {
    console.error('智谱AI对话接口调用失败:', error);
    throw error;
  }
}

// 导出模块
module.exports = {
  analyzeEmotion,
  extractKeywords,
  getEmbeddings,
  clusterKeywords,
  analyzeUserInterests,
  generateReportContent,
  chatCompletion
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\geminiModel.js*#*#*begin*#*#*
/**
 * Google Gemini API 模块
 * 提供基于Google Gemini的情感分析和关键词提取功能
 *
 * @architecture 该模块实现了与Google Gemini API的集成，作为智谱AI的替代选项
 * @dependency httpRequest 云函数用于发送HTTP请求
 * @history 2025-05-01 初始版本
 */
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// Gemini API配置
// 注意：实际使用时应从环境变量或安全配置中读取API密钥，而不是硬编码
const API_KEY = process.env.GEMINI_API_KEY || ''; // 从环境变量获取API密钥
const API_BASE_URL = 'https://apiv2.aliyahzombie.top';

// 模型配置
const GEMINI_PRO = 'gemini-2.5-flash-preview-04-17'; // 默认模型
const GEMINI_FLASH = 'gemini-2.5-flash-preview-04-17'; // 快速版本

/**
 * 延迟函数
 * @param {number} ms 延迟毫秒数
 * @returns {Promise} 延迟Promise
 */
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * 调用Google Gemini API
 * @param {Object} params 请求参数
 * @param {number} retryCount 重试次数，默认为3
 * @param {number} retryDelay 重试延迟，默认为1000ms
 * @returns {Promise<Object>} API响应
 */
async function callGeminiAPI(params, retryCount = 3, retryDelay = 1000) {
  try {
    // 验证API密钥
    if (!API_KEY) {
      console.error('未设置GEMINI_API_KEY环境变量');
      throw new Error('Gemini API密钥未配置');
    }

    // 构建请求URL
    // 使用正确的API端点，根据参考文档中的示例
    const url = `${API_BASE_URL}/v1beta/models/${params.model || GEMINI_PRO}:generateContent?key=${API_KEY}`;

    console.log('API URL:', url);

    // 构建请求体，根据参考文档中的示例
    const body = JSON.stringify({
      contents: params.contents,
      generationConfig: {
        temperature: params.temperature || 0.3,
        topP: params.topP || 0.8,
        topK: params.topK || 40,
        maxOutputTokens: params.maxOutputTokens || 2048
      }
    });

    if (isDev) {
      console.log('调用Gemini API, 请求体:', body);
    }

    // 使用axios直接发送请求
    const axios = require('axios');

    console.log('发送请求到:', url);

    try {
      const response = await axios({
        method: 'POST',
        url: url,
        headers: {
          'Content-Type': 'application/json'
        },
        data: JSON.parse(body) // 将JSON字符串转换为对象
      });

      // 检查响应状态
      if (response.status !== 200) {
        console.error('Gemini API返回错误状态码:', response.status);
        throw new Error(`Gemini API调用失败: 状态码 ${response.status}`);
      }

      // 获取响应数据
      const result = response.data;

      return result;
    } catch (error) {
      // 处理429错误（请求过多）
      if (error.response && error.response.status === 429 && retryCount > 0) {
        console.log(`遇到429错误，等待${retryDelay}ms后重试，剩余重试次数: ${retryCount-1}`);

        // 等待一段时间后重试
        await delay(retryDelay);

        // 递归调用自身，减少重试次数，增加延迟时间
        return callGeminiAPI(params, retryCount - 1, retryDelay * 2);
      }

      // 其他错误或重试次数用完，抛出异常
      throw error;
    }

  } catch (error) {
    console.error('调用Gemini API失败:', error);
    throw error;
  }
}

/**
 * 使用Gemini模型分析文本情感
 * @param {string} text 待分析的文本
 * @param {Array} history 历史消息记录（可选）
 * @returns {Promise<Object>} 情感分析结果
 */
async function analyzeEmotion(text, history = []) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 构建提示词，参考bigmodel.js中的提示词设计
    let prompt = `你是一个专业且富有同理心的情感分析助手。请细致分析以下文本，并可选择性地参考之前的对话上下文（如果提供），以JSON格式返回全面的情感分析结果。

文本内容: "${text}"

返回的JSON对象应包含以下字段：
- primary_emotion: (String) 检测到的主要情感类型，必须使用中文表达 (例如: "焦虑", "喜悦", "愤怒", "平静", "悲伤", "惊讶", "厌恶", "期待", "紧迫", "失望", "疲惫" 等)。
- secondary_emotions: (Array<String>) 检测到的次要情感，必须使用中文表达（最多2个，按强度排序，如果没有则为空数组 []）。
- intensity: (Float) 主要情感的强度，范围 0.0 (几乎没有) 到 1.0 (非常强烈)。
- valence: (Float) 情感的愉悦度/极性，范围 -1.0 (非常负面) 到 1.0 (非常正面)，0.0 代表中性。
- arousal: (Float) 情感的激动/唤醒水平，范围 0.0 (非常平静/低能量) 到 1.0 (非常激动/高能量)。
- trend: (String) 与上一轮分析相比的情绪变化趋势，必须使用中文表达 ("上升", "下降", "稳定")。如果无法判断或无上一轮数据，则为 "未知"。请同时提供英文字段名 trend_en ("rising", "falling", "stable", "unknown")。
- attention_level: (String) 估计的用户在对话中的注意力或投入程度，必须使用中文表达 ("高", "中", "低")。请同时提供英文字段名 attention_level_en ("high", "medium", "low")。
- radar_dimensions: (Object) 针对以下维度的评分估计 (范围 0.0 到 1.0): {"trust": Float (信任度), "openness": Float (开放度), "resistance": Float (抗拒/防御), "stress": Float (压力水平), "control": Float (控制感/确定性)}。请根据对话内容合理估计。
- topic_keywords: (Array<String>) 与当前讨论**主题**相关的关键词，必须使用中文表达，最多5个，按重要性排序。
- emotion_triggers: (Array<String>) 最可能引发当前主要情感的用户文本中的关键词或短语，必须使用中文表达，最多3个。
- suggestions: (Array<String>) 基于当前情感、主题和维度分析，提供1-3条具体、可行的建议策略或共情回应，必须使用中文表达。
- summary: (String) 用一句中文简洁地总结用户当前的情感状态、可能的原因以及关键特征。

请确保输出是严格的JSON格式。如果某些字段无法可靠判断，可以使用合理的默认值（如 intensity: 0.5, valence: 0.0, arousal: 0.5, trend: "未知", attention_level: "中", radar_dimensions 各项为 0.5）或返回空数组/null（对于 secondary_emotions, emotion_triggers）。

重要提示：所有文本字段必须使用中文返回，不要使用英文。这对于前端显示和情感颜色分类至关重要。`;

    // 如果有历史消息，添加到prompt中
    if (Array.isArray(history) && history.length > 0) {
      // 最多添加5条历史消息作为上下文
      const contextMessages = history.slice(-5);
      let contextText = "\n\n对话历史上下文:\n";

      contextMessages.forEach(msg => {
        if (msg.role && msg.content) {
          contextText += `${msg.role === 'user' ? '用户' : 'AI'}: ${msg.content}\n`;
        }
      });

      prompt += contextText;
    }

    // 构建请求内容
    const contents = [
      {
        role: 'user',
        parts: [{ text: prompt }]
      }
    ];

    // 调用Gemini API
    const response = await callGeminiAPI({
      model: GEMINI_PRO, // 使用gemini-2.5-flash-preview-04-17模型
      contents: contents,
      temperature: 0.3, // 较低的温度以获得更确定性的结果
      maxOutputTokens: 2048
    });

    // 解析API响应
    if (response && response.candidates && response.candidates.length > 0) {
      try {
        // 尝试解析JSON响应
        const candidate = response.candidates[0];
        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
          const content = candidate.content.parts[0].text;
          // 提取JSON部分
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          const jsonStr = jsonMatch ? jsonMatch[0] : content;
          const result = JSON.parse(jsonStr);

          // 构建标准化的返回结果，与bigmodel.js保持一致
          return {
            success: true,
            result: {
              // 兼容旧版字段
              type: result.primary_emotion || result.emotion_type || '平静',
              intensity: result.intensity || 0.5,
              keywords: result.topic_keywords || result.keywords || [],
              suggestions: result.suggestions || [],
              report: result.summary || result.report || '无法生成情感报告',
              originalText: text,
              // 新增字段
              primary_emotion: result.primary_emotion || result.emotion_type || '平静',
              secondary_emotions: result.secondary_emotions || [],
              valence: result.valence || 0.0,
              arousal: result.arousal || 0.5,
              trend: result.trend || '未知',
              trend_en: result.trend_en || 'unknown',
              attention_level: result.attention_level || '中',
              attention_level_en: result.attention_level_en || 'medium',
              radar_dimensions: result.radar_dimensions || {
                trust: 0.5,
                openness: 0.5,
                resistance: 0.5,
                stress: 0.5,
                control: 0.5
              },
              topic_keywords: result.topic_keywords || [],
              emotion_triggers: result.emotion_triggers || [],
              summary: result.summary || result.report || '无法生成情感报告'
            },
            usage: response.usageMetadata || { promptTokenCount: 0, candidatesTokenCount: 0, totalTokenCount: 0 }
          };
        }
      } catch (parseError) {
        console.error('解析Gemini JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析情感分析结果失败'
        };
      }
    }

    return {
      success: false,
      error: 'Gemini返回的情感分析结果为空'
    };
  } catch (error) {
    console.error('Gemini情感分析失败:', error);
    return {
      success: false,
      error: error.message || '情感分析失败'
    };
  }
}

/**
 * 使用Gemini模型提取关键词
 * @param {string} text 待分析文本
 * @param {number} topK 返回关键词数量
 * @returns {Promise<Object>} 关键词提取结果
 */
async function extractKeywords(text, topK = 10) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 构建Prompt，要求模型提取关键词并以JSON格式返回
    const prompt = `你是一个专业的文本分析助手。请从以下文本中提取最重要的关键词，并以JSON格式返回结果。文本内容：

${text}

返回的JSON应包含以下字段：
- keywords: 关键词数组，每个元素是一个对象，包含word(关键词)和weight(权重,0-1之间的浮点数)

请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。提取的关键词数量不超过${topK}个，按重要性降序排列。`;

    // 构建请求内容
    const contents = [
      {
        role: 'user',
        parts: [{ text: prompt }]
      }
    ];

    // 调用Gemini API
    const response = await callGeminiAPI({
      model: GEMINI_FLASH, // 使用gemini-2.5-flash-preview-04-17模型
      contents: contents,
      temperature: 0.2, // 较低的温度以获得更确定性的结果
      maxOutputTokens: 1024
    });

    // 解析API响应
    if (response && response.candidates && response.candidates.length > 0) {
      try {
        // 尝试解析JSON响应
        const candidate = response.candidates[0];
        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
          const content = candidate.content.parts[0].text;
          // 提取JSON部分
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          const jsonStr = jsonMatch ? jsonMatch[0] : content;
          const result = JSON.parse(jsonStr);

          // 确保keywords是一个数组
          const keywords = Array.isArray(result.keywords) ? result.keywords : [];

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              keywords: keywords.slice(0, topK) // 确保不超过topK个关键词
            }
          };
        }
      } catch (parseError) {
        console.error('解析Gemini JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析关键词提取结果失败'
        };
      }
    }

    return {
      success: false,
      error: 'Gemini返回的关键词提取结果为空'
    };
  } catch (error) {
    console.error('Gemini关键词提取失败:', error.message || error);
    return {
      success: false,
      error: error.message || '关键词提取服务调用失败'
    };
  }
}

/**
 * 使用Gemini模型进行聚类分析
 * @param {string} text 待分析文本
 * @param {number} threshold 聚类阈值
 * @param {number} minClusterSize 最小簇大小
 * @returns {Promise<Object>} 聚类结果
 */
async function clusterKeywords(text, threshold = 0.7, minClusterSize = 2) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 构建Prompt，要求模型进行聚类分析并以JSON格式返回
    const prompt = `你是一个专业的文本分析助手。请从以下文本中提取关键词，并将语义相近的关键词聚类，以JSON格式返回结果。文本内容：

${text}

返回的JSON应包含以下字段：
- clusters: 聚类结果数组，每个元素是一个对象，包含以下字段：
  - keywords: 该簇包含的关键词数组
  - center: 该簇的中心词或主题
  - size: 该簇的大小(关键词数量)

请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。每个簇至少包含${minClusterSize}个关键词，相似度阈值为${threshold}。`;

    // 构建请求内容
    const contents = [
      {
        role: 'user',
        parts: [{ text: prompt }]
      }
    ];

    // 调用Gemini API
    const response = await callGeminiAPI({
      model: GEMINI_PRO,
      contents: contents,
      temperature: 0.3,
      maxOutputTokens: 2048
    });

    // 解析API响应
    if (response && response.candidates && response.candidates.length > 0) {
      try {
        // 尝试解析JSON响应
        const candidate = response.candidates[0];
        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
          const content = candidate.content.parts[0].text;
          // 提取JSON部分
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          const jsonStr = jsonMatch ? jsonMatch[0] : content;
          const result = JSON.parse(jsonStr);

          // 确保clusters是一个数组
          const clusters = Array.isArray(result.clusters) ? result.clusters : [];

          // 过滤掉不符合最小簇大小要求的簇
          const validClusters = clusters.filter(cluster =>
            Array.isArray(cluster.keywords) && cluster.keywords.length >= minClusterSize
          );

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              clusters: validClusters
            }
          };
        }
      } catch (parseError) {
        console.error('解析Gemini JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析聚类分析结果失败'
        };
      }
    }

    return {
      success: false,
      error: 'Gemini返回的聚类分析结果为空'
    };
  } catch (error) {
    console.error('Gemini聚类分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '聚类分析服务调用失败'
    };
  }
}

/**
 * 使用Gemini模型生成用户兴趣分析报告
 * @param {Array<string>} messages 用户历史消息
 * @returns {Promise<Object>} 兴趣分析结果
 */
async function analyzeUserInterests(messages) {
  try {
    // 验证参数
    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        success: false,
        error: '无效的消息参数'
      };
    }

    // 合并消息文本
    const combinedText = messages.join('\n');

    // 构建Prompt，要求模型分析用户兴趣并以JSON格式返回
    const prompt = `你是一个专业的用户兴趣分析助手。请分析以下用户的历史消息，提取用户可能的兴趣领域，并以JSON格式返回分析结果。

以下是用户的历史消息，请分析其中可能的兴趣领域：
${combinedText}

返回的JSON应包含以下字段：
- interests: 兴趣领域数组，每个元素是一个对象，包含以下字段：
  - name: 兴趣领域名称
  - confidence: 置信度，0-1之间的浮点数
  - keywords: 与该兴趣相关的关键词数组
- summary: 用户兴趣的简短总结

请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。`;

    // 构建请求内容
    const contents = [
      {
        role: 'user',
        parts: [{ text: prompt }]
      }
    ];

    // 调用Gemini API
    const response = await callGeminiAPI({
      model: GEMINI_PRO,
      contents: contents,
      temperature: 0.3,
      maxOutputTokens: 2048
    });

    // 解析API响应
    if (response && response.candidates && response.candidates.length > 0) {
      try {
        // 尝试解析JSON响应
        const candidate = response.candidates[0];
        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
          const content = candidate.content.parts[0].text;
          // 提取JSON部分
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          const jsonStr = jsonMatch ? jsonMatch[0] : content;
          const result = JSON.parse(jsonStr);

          // 构建标准化的返回结果
          return {
            success: true,
            data: {
              interests: result.interests || [],
              summary: result.summary || '无法生成兴趣总结'
            }
          };
        }
      } catch (parseError) {
        console.error('解析Gemini JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析兴趣分析结果失败'
        };
      }
    }

    return {
      success: false,
      error: 'Gemini返回的兴趣分析结果为空'
    };
  } catch (error) {
    console.error('Gemini兴趣分析失败:', error.message || error);
    return {
      success: false,
      error: error.message || '兴趣分析服务调用失败'
    };
  }
}

/**
 * 使用Gemini模型生成报告内容
 * @param {string} prompt 提示词
 * @returns {Promise<Object>} 生成结果
 */
async function generateReportContent(prompt) {
  try {
    // 验证参数
    if (!prompt || typeof prompt !== 'string' || prompt.trim() === '') {
      return {
        success: false,
        error: '无效的提示词参数'
      };
    }

    // 构建系统提示词
    const systemPrompt = `你是一个专业的情感分析助手，擅长分析用户的情绪状态并提供有价值的洞察和建议。
    请根据用户提供的文本生成每日心情报告，包括情感总结、洞察、建议、今日运势和鼓励语。
    请确保返回的是有效的JSON格式，不要添加额外的解释或前缀。`;

    // 构建请求内容
    const contents = [
      {
        role: 'user',
        parts: [{ text: systemPrompt + "\n\n" + prompt }]
      }
    ];

    // 调用Gemini API
    const response = await callGeminiAPI({
      model: GEMINI_PRO,
      contents: contents,
      temperature: 0.7, // 适当提高创造性
      maxOutputTokens: 2048
    });

    // 解析API响应
    if (response && response.candidates && response.candidates.length > 0) {
      try {
        // 尝试解析JSON响应
        const candidate = response.candidates[0];
        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
          const content = candidate.content.parts[0].text;
          // 提取JSON部分
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          const jsonStr = jsonMatch ? jsonMatch[0] : content;
          const result = JSON.parse(jsonStr);

          // 返回结果
          return {
            success: true,
            result: result
          };
        }
      } catch (parseError) {
        console.error('解析Gemini JSON响应失败:', parseError.message || parseError);
        return {
          success: false,
          error: '解析报告内容失败'
        };
      }
    }

    return {
      success: false,
      error: 'Gemini返回的报告内容为空'
    };
  } catch (error) {
    console.error('生成报告内容失败:', error.message || error);
    return {
      success: false,
      error: error.message || '生成报告内容失败'
    };
  }
}

/**
 * 使用Gemini模型进行通用对话调用
 * @param {Object} options 调用选项
 * @param {Array} options.messages 消息数组
 * @param {number} options.temperature 温度参数
 * @param {Object} options.response_format 响应格式
 * @returns {Promise<Object>} 调用结果
 */
async function chatCompletion(options) {
  try {
    // 验证参数
    if (!options || !Array.isArray(options.messages) || options.messages.length === 0) {
      throw new Error('无效的消息参数');
    }

    // 转换消息格式为Gemini格式
    const contents = options.messages.map(msg => ({
      role: msg.role === 'system' ? 'user' : msg.role, // Gemini不支持system角色，转为user
      parts: [{ text: msg.content }]
    }));

    // 调用Gemini API
    console.log('调用Gemini对话接口, 消息数量:', options.messages.length);

    const response = await callGeminiAPI({
      model: GEMINI_PRO,
      contents: contents,
      temperature: options.temperature || 0.7,
      maxOutputTokens: options.maxOutputTokens || 2048
    });

    // 返回原始响应
    return response;
  } catch (error) {
    console.error('Gemini对话接口调用失败:', error.message || error);
    throw error;
  }
}

// 导出模块
module.exports = {
  analyzeEmotion,
  extractKeywords,
  clusterKeywords,
  analyzeUserInterests,
  generateReportContent,
  chatCompletion,
  callGeminiAPI,
  GEMINI_PRO,
  GEMINI_FLASH
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\index.js*#*#*begin*#*#*
// analysis 云函数 index.js
/**
 * 情感分析与关键词提取云函数
 * 基于智谱AI (BigModel) API和Google Gemini API，提供对话文本的情绪识别和关键词提取功能
 * 可以识别出当前会话者所表现出的情绪类别及其置信度
 * 针对正面和负面的情绪，还可给出参考回复话术
 * 同时支持使用智谱AI和Google Gemini进行关键词提取、词向量获取和聚类分析
 *
 * @history 2025-05-01 添加Google Gemini API支持
 */
const cloud = require('wx-server-sdk');

// 导入统一AI模型服务
const aiModelService = require('./aiModelService');
// 导入关键词分类器
const keywordClassifier = require('./keywordClassifier');
// 导入关键词情感关联模块
const keywordEmotionLinker = require('./keywordEmotionLinker');
// 导入用户兴趣分析器
const userInterestAnalyzer = require('./userInterestAnalyzer');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 初始化云开发
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

/**
 * 保存情感分析记录到数据库
 * @param {Object} result 情感分析结果
 * @param {string} openid 用户openid
 * @param {Object} options 附加选项，如roleId等
 * @returns {Promise<string>} 记录ID
 */
async function saveEmotionRecord(result, openid, options = {}) {
  try {
    // 构建记录数据
    const recordData = {
      userId: openid,
      analysis: result,
      originalText: result.originalText || '',
      createTime: db.serverDate(),
      ...options
    };

    // 写入数据库
    const res = await db.collection('emotionRecords').add({
      data: recordData
    });

    return res._id;
  } catch (error) {
    console.error('保存情感分析记录失败:', error.message || error);
    return null;
  }
}

/**
 * 分析文本情感 (使用智谱AI或Google Gemini)
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function analyzeEmotion(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();

    // 获取参数
    const {
      text,
      history = [],
      saveRecord = false,
      roleId = null,
      chatId = null,
      extractKeywords = true,
      linkKeywords = true,
      modelType = 'gemini' // 默认使用Google Gemini，可选值：zhipu, gemini
    } = event;

    // 验证文本参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 记录使用的模型类型
    console.log(`使用模型类型: ${modelType}`);

    // 并行处理情感分析和关键词提取
    const [emotionResponse, keywords] = await Promise.all([
      // 使用统一AI模型服务进行情感分析
      aiModelService.analyzeEmotion(text, history, { platform: modelType.toUpperCase() }),
      // 使用统一AI模型服务提取关键词
      extractKeywords
        ? aiModelService.extractKeywords(text, 5, { platform: modelType.toUpperCase() })
        : Promise.resolve({ success: true, data: { keywords: [] } })
    ]);

    // 检查智谱AI返回结果
    if (emotionResponse.success) {
      // 如果需要保存记录，异步保存到数据库
      let recordId = null;
      if (saveRecord) {
        try {
          recordId = await saveEmotionRecord(emotionResponse.result, wxContext.OPENID, { roleId, chatId });
        } catch (saveError) {
          console.error('保存情感记录失败:', saveError.message || saveError);
          // 保存失败不影响主流程
        }
      }

      // 如果需要关联关键词和情感，并且成功提取到关键词
      if (linkKeywords && extractKeywords && keywords && keywords.success && keywords.data && keywords.data.keywords && keywords.data.keywords.length > 0) {
        try {
          // 异步关联关键词和情感，不阻塞主流程
          keywordEmotionLinker.linkKeywordsToEmotion(wxContext.OPENID, keywords.data.keywords, emotionResponse.result)
            .then(success => {
              if (isDev) {
                console.log('关联关键词和情感' + (success ? '成功' : '失败'));
              }
            })
            .catch(error => {
              console.error('关联关键词和情感异常:', error.message || error);
            });
        } catch (linkError) {
          console.error('关联关键词和情感失败:', linkError.message || linkError);
          // 关联失败不影响主流程
        }
      }

      // 返回结果
      return {
        success: true,
        result: emotionResponse.result,
        recordId: recordId,
        keywords: keywords.data ? keywords.data.keywords : []
      };
    } else {
      // 智谱AI返回错误
      return {
        success: false,
        error: emotionResponse.error || '情感分析服务返回错误'
      };
    }
  } catch (error) {
    console.error('情感分析失败:', error.message || error);

    // 返回错误信息
    return {
      success: false,
      error: error.message || '情感分析服务调用失败'
    };
  }
}

/**
 * 提取文本关键词 (使用智谱AI或Google Gemini)
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function extractTextKeywords(event) {
  try {
    // 获取参数
    const { text, topK = 10, modelType = 'gemini' } = event;

    // 验证文本参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 记录使用的模型类型
    console.log(`使用模型类型: ${modelType}`);

    // 使用统一AI模型服务提取关键词
    const result = await aiModelService.extractKeywords(text, topK, { platform: modelType.toUpperCase() });

    // 返回结果
    return result;
  } catch (error) {
    console.error('关键词提取失败:', error.message || error);

    // 返回错误信息
    return {
      success: false,
      error: error.message || '关键词提取服务调用失败'
    };
  }
}

/**
 * 获取词向量 (使用智谱AI)
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getWordVectors(event) {
  try {
    // 获取参数
    const { texts } = event;

    // 验证参数
    if (!texts) {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 确保texts是数组
    const textArray = Array.isArray(texts) ? texts : [texts];

    // 验证数组不为空
    if (textArray.length === 0) {
      return {
        success: false,
        error: '文本数组为空'
      };
    }

    if (isDev) {
      console.log('调用智谱AI词向量获取, 输入:', textArray);
    }

    // 调用统一AI模型服务获取词向量
    const result = await aiModelService.getEmbeddings(textArray, { platform: 'ZHIPU' });

    if (isDev) {
      console.log('智谱AI词向量获取结果:', result);
    }

    // 返回结果
    return result;
  } catch (error) {
    console.error('获取词向量失败:', error.message || error);
    return {
      success: false,
      error: error.message || '词向量服务调用失败'
    };
  }
}

/**
 * 聚类分析 (使用智谱AI)
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function clusterKeywords(event) {
  try {
    // 获取参数
    const { text, threshold = 0.7, minClusterSize = 2 } = event;

    // 验证文本参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 调用统一AI模型服务进行聚类分析
    const result = await aiModelService.clusterKeywords(text, threshold, minClusterSize, { platform: 'ZHIPU' });

    // 返回结果
    return result;
  } catch (error) {
    console.error('聚类分析失败:', error.message || error);

    // 返回错误信息
    return {
      success: false,
      error: error.message || '聚类分析服务调用失败'
    };
  }
}

/**
 * 分析用户兴趣 (使用智谱AI)
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function analyzeUserInterests(event) {
  try {
    // 获取参数
    const { messages } = event;

    // 验证参数
    if (!Array.isArray(messages) || messages.length === 0) {
      return {
        success: false,
        error: '无效的消息参数'
      };
    }

    // 调用统一AI模型服务进行用户兴趣分析
    const result = await aiModelService.analyzeUserInterests(messages, { platform: 'ZHIPU' });

    // 返回结果
    return result;
  } catch (error) {
    console.error('用户兴趣分析失败:', error.message || error);

    // 返回错误信息
    return {
      success: false,
      error: error.message || '用户兴趣分析服务调用失败'
    };
  }
}

/**
 * 分析用户关注点
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function analyzeFocusPoints(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();

    // 获取参数
    const { userId = wxContext.OPENID, keywords, emotionRecords = [], date } = event;

    // 验证参数
    if (!userId) {
      return {
        success: false,
        error: '用户ID不能为空'
      };
    }

    // 如果没有提供关键词，从数据库中获取
    let keywordsToAnalyze = keywords;
    if (!keywordsToAnalyze || !Array.isArray(keywordsToAnalyze) || keywordsToAnalyze.length === 0) {
      // 初始化数据库
      const db = cloud.database();
      const _ = db.command;

      // 如果指定了日期，获取该日期的情绪记录
      let queryDate = null;
      if (date) {
        queryDate = new Date(date);
        queryDate.setHours(0, 0, 0, 0);

        const nextDay = new Date(queryDate);
        nextDay.setDate(nextDay.getDate() + 1);

        // 查询指定日期的情绪记录
        const records = await db.collection('emotionRecords')
          .where({
            userId: userId,
            createTime: _.gte(queryDate).and(_.lt(nextDay))
          })
          .get();

        // 提取关键词
        keywordsToAnalyze = [];
        records.data.forEach(record => {
          if (record.analysis && record.analysis.keywords) {
            record.analysis.keywords.forEach(keyword => {
              if (typeof keyword === 'string') {
                keywordsToAnalyze.push({ word: keyword, weight: 1 });
              } else if (keyword.word) {
                keywordsToAnalyze.push({
                  word: keyword.word,
                  weight: keyword.weight || 1
                });
              }
            });
          }
        });
      } else {
        // 如果没有指定日期，从用户兴趣表中获取关键词
        const userInterests = await db.collection('userInterests')
          .where({ userId: userId })
          .get();

        if (userInterests.data && userInterests.data.length > 0 && userInterests.data[0].keywords) {
          keywordsToAnalyze = userInterests.data[0].keywords.map(k => ({
            word: k.word,
            weight: k.weight || 1,
            category: k.category || '其他'
          }));
        }
      }
    }

    // 如果仍然没有关键词，返回错误
    if (!keywordsToAnalyze || keywordsToAnalyze.length === 0) {
      return {
        success: false,
        error: '没有可用的关键词数据'
      };
    }

    // 如果没有提供情绪记录，从数据库中获取
    let emotionRecordsToAnalyze = emotionRecords;
    if (!emotionRecordsToAnalyze || !Array.isArray(emotionRecordsToAnalyze) || emotionRecordsToAnalyze.length === 0) {
      // 初始化数据库
      const db = cloud.database();
      const _ = db.command;

      // 如果指定了日期，获取该日期的情绪记录
      if (queryDate) {
        // 使用上面已经查询到的记录
        emotionRecordsToAnalyze = records.data;
      } else {
        // 获取最近一周的情绪记录
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

        const records = await db.collection('emotionRecords')
          .where({
            userId: userId,
            createTime: _.gte(oneWeekAgo)
          })
          .limit(100) // 限制数量，避免数据过大
          .get();

        emotionRecordsToAnalyze = records.data;
      }
    }

    // 调用用户兴趣分析器
    const result = await userInterestAnalyzer.analyzeUserInterests(keywordsToAnalyze, emotionRecordsToAnalyze);

    // 返回结果
    return result;
  } catch (error) {
    console.error('分析用户关注点失败:', error.message || error);

    // 返回错误信息
    return {
      success: false,
      error: error.message || '分析用户关注点失败'
    };
  }
}

/**
 * 生成用户每日心情报告
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function generateDailyReport(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();

    // 获取参数
    const { userId = wxContext.OPENID, date = new Date(), forceRegenerate = false } = event;

    // 验证用户ID
    if (!userId) {
      return {
        success: false,
        error: '无效的用户ID'
      };
    }

    // 初始化数据库
    const db = cloud.database();
    const _ = db.command;
    const $ = db.command.aggregate;

    // 将日期转换为当天的开始时间（00:00:00）
    const reportDate = new Date(date);
    reportDate.setHours(0, 0, 0, 0);

    // 计算当天的结束时间（23:59:59）
    const nextDay = new Date(reportDate);
    nextDay.setDate(nextDay.getDate() + 1);
    nextDay.setMilliseconds(-1);

    // 检查是否已经生成过报告
    const existingReport = await db.collection('userReports')
      .where({
        userId: userId,
        date: reportDate
      })
      .get();

    // 如果已经存在报告且不强制重新生成，则直接返回
    if (existingReport.data.length > 0 && !forceRegenerate) {
      return {
        success: true,
        reportId: existingReport.data[0]._id,
        report: existingReport.data[0],
        isNew: false
      };
    }

    // 查询用户当天的情感记录
    const emotionRecords = await db.collection('emotionRecords')
      .where({
        userId: userId,
        createTime: _.gte(reportDate).and(_.lt(nextDay))
      })
      .get();

    // 如果没有情感记录，返回错误
    if (emotionRecords.data.length === 0) {
      return {
        success: false,
        error: '当天没有情感记录，无法生成报告'
      };
    }

    // 提取情感数据
    const emotions = emotionRecords.data.map(record => ({
      type: record.analysis.type || record.analysis.primary_emotion || 'neutral',
      intensity: record.analysis.intensity || 0.5,
      keywords: record.analysis.keywords || [],
      timestamp: record.createTime,
      text: record.originalText || ''
    }));

    // 统计情感分布
    const emotionDistribution = {};
    emotions.forEach(emotion => {
      if (!emotionDistribution[emotion.type]) {
        emotionDistribution[emotion.type] = 0;
      }
      emotionDistribution[emotion.type]++;
    });

    // 计算主要情感类型
    let primaryEmotion = 'neutral';
    let maxCount = 0;
    Object.keys(emotionDistribution).forEach(type => {
      if (emotionDistribution[type] > maxCount) {
        maxCount = emotionDistribution[type];
        primaryEmotion = type;
      }
    });

    // 提取所有关键词并计算权重
    const keywordMap = {};
    emotions.forEach(emotion => {
      (emotion.keywords || []).forEach(keyword => {
        if (typeof keyword === 'string') {
          if (!keywordMap[keyword]) {
            keywordMap[keyword] = 0;
          }
          keywordMap[keyword]++;
        } else if (keyword.word) {
          if (!keywordMap[keyword.word]) {
            keywordMap[keyword.word] = 0;
          }
          keywordMap[keyword.word] += keyword.weight || 1;
        }
      });
    });

    // 转换为数组并排序
    const keywords = Object.keys(keywordMap).map(word => ({
      word,
      weight: keywordMap[word]
    })).sort((a, b) => b.weight - a.weight).slice(0, 20); // 取前20个关键词

    // 分析关注点
    let focusPointsResult = { success: false, data: { categoryWeights: [], focusPoints: [] } };
    try {
      // 调用关注点分析函数
      focusPointsResult = await userInterestAnalyzer.analyzeUserInterests(keywords, emotionRecords.data);
      console.log('关注点分析结果:', JSON.stringify(focusPointsResult));
    } catch (focusError) {
      console.error('关注点分析失败:', focusError);
      // 分析失败不影响主流程
    }

    // 计算情绪波动
    const intensities = emotions.map(e => e.intensity);
    const avgIntensity = intensities.reduce((sum, val) => sum + val, 0) / intensities.length;
    const intensityVariance = intensities.reduce((sum, val) => sum + Math.pow(val - avgIntensity, 2), 0) / intensities.length;
    const emotionalVolatility = Math.min(Math.round(Math.sqrt(intensityVariance) * 100), 100);

    // 准备图表数据
    const chartData = {
      emotionDistribution: Object.keys(emotionDistribution).map(type => ({
        type,
        count: emotionDistribution[type],
        percentage: (emotionDistribution[type] / emotions.length * 100).toFixed(1)
      })),
      intensityTrend: emotions.map(e => ({
        timestamp: e.timestamp,
        intensity: e.intensity,
        type: e.type
      })).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
    };

    // 使用智谱AI生成情感总结和建议
    const emotionTexts = emotions.map(e => e.text).filter(Boolean);
    const summaryPrompt = `
      我需要你分析以下文本中表达的情感，并生成一份简短的每日心情总结报告。
      文本内容：${emotionTexts.join(' ')}

      请以JSON格式返回以下内容：
      1. summary: 200字以内的情感总结，分析用户今天的主要情绪状态、可能的原因和变化趋势
      2. insights: 3-5条关于用户情绪模式的洞察
      3. suggestions: 3条针对用户情绪状态的建议
      4. fortune: 基于用户情绪生成的"今日运势"，包含"good"和"bad"各2项，分别表示宜做和忌做的事情
      5. encouragement: 一句鼓励的话

      确保返回的是有效的JSON格式，不要添加额外的解释或前缀。
    `;

    // 调用智谱AI生成报告内容
    const aiSummary = await bigModelModule.generateReportContent(summaryPrompt);

    // 解析AI返回的JSON
    let reportContent;
    try {
      if (aiSummary.success && aiSummary.result) {
        reportContent = aiSummary.result;
      } else {
        // 如果AI生成失败，使用默认内容
        reportContent = {
          summary: `今天您的主要情绪是${primaryEmotion}，情绪波动指数为${emotionalVolatility}。`,
          insights: ["您今天的情绪相对稳定", "关注点主要集中在工作和生活平衡上"],
          suggestions: ["尝试进行深呼吸放松练习", "与朋友交流可能会改善心情", "保持规律的作息有助于情绪稳定"],
          fortune: {
            good: ["放松心情", "与朋友交流"],
            bad: ["过度劳累", "钻牛角尖"]
          },
          encouragement: "每一天都是新的开始，相信自己能够创造更美好的明天！"
        };
      }
    } catch (parseError) {
      console.error('解析AI生成内容失败:', parseError);
      // 使用默认内容
      reportContent = {
        summary: `今天您的主要情绪是${primaryEmotion}，情绪波动指数为${emotionalVolatility}。`,
        insights: ["您今天的情绪相对稳定", "关注点主要集中在工作和生活平衡上"],
        suggestions: ["尝试进行深呼吸放松练习", "与朋友交流可能会改善心情", "保持规律的作息有助于情绪稳定"],
        fortune: {
          good: ["放松心情", "与朋友交流"],
          bad: ["过度劳累", "钻牛角尖"]
        },
        encouragement: "每一天都是新的开始，相信自己能够创造更美好的明天！"
      };
    }

    // 构建报告数据
    const reportData = {
      userId: userId,
      date: reportDate,
      emotionSummary: reportContent.summary,
      insights: reportContent.insights,
      suggestions: reportContent.suggestions,
      fortune: reportContent.fortune,
      encouragement: reportContent.encouragement,
      keywords: keywords,
      emotionalVolatility: emotionalVolatility,
      primaryEmotion: primaryEmotion,
      emotionCount: emotions.length,
      chartData: chartData,
      generatedAt: db.serverDate(),
      isRead: false
    };

    // 如果关注点分析成功，添加到报告数据中
    if (focusPointsResult.success && focusPointsResult.data) {
      // 添加关注点数据
      reportData.focusPoints = focusPointsResult.data.focusPoints || [];

      // 添加分类权重数据
      reportData.categoryWeights = focusPointsResult.data.categoryWeights || [];

      // 添加情感关联分析数据
      reportData.emotionalInsights = focusPointsResult.data.emotionalInsights || {
        positiveAssociations: [],
        negativeAssociations: []
      };

      // 更新图表数据，添加关注点分析图表
      reportData.chartData.focusDistribution = focusPointsResult.data.categoryWeights || [];
    }

    // 保存或更新报告
    let reportId;
    if (existingReport.data.length > 0) {
      // 更新现有报告
      reportId = existingReport.data[0]._id;
      await db.collection('userReports').doc(reportId).update({
        data: reportData
      });
    } else {
      // 创建新报告
      const result = await db.collection('userReports').add({
        data: reportData
      });
      reportId = result._id;
    }

    // 更新用户兴趣数据
    await updateUserInterests(userId, keywords);

    // 返回结果
    return {
      success: true,
      reportId: reportId,
      report: {
        ...reportData,
        _id: reportId
      },
      isNew: existingReport.data.length === 0
    };
  } catch (error) {
    console.error('生成每日报告失败:', error);
    return {
      success: false,
      error: error.message || '生成每日报告失败'
    };
  }
}

/**
 * 更新用户兴趣数据
 * @param {string} userId 用户ID
 * @param {Array} keywords 关键词数组
 * @returns {Promise<void>}
 */
async function updateUserInterests(userId, keywords) {
  try {
    const db = cloud.database();
    const _ = db.command;

    // 查询用户现有兴趣数据
    const userInterests = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    // 准备兴趣数据
    const now = db.serverDate();
    const interestData = {
      userId: userId,
      lastUpdated: now
    };

    // 如果已有兴趣数据，更新它
    if (userInterests.data.length > 0) {
      const existingInterest = userInterests.data[0];
      const existingKeywords = existingInterest.keywords || [];

      // 合并关键词
      const keywordMap = {};
      existingKeywords.forEach(kw => {
        keywordMap[kw.word] = kw.weight;
      });

      keywords.forEach(kw => {
        if (keywordMap[kw.word]) {
          keywordMap[kw.word] += kw.weight;
        } else {
          keywordMap[kw.word] = kw.weight;
        }
      });

      // 转换回数组并排序
      const updatedKeywords = Object.keys(keywordMap).map(word => ({
        word,
        weight: keywordMap[word],
        lastUpdated: now
      })).sort((a, b) => b.weight - a.weight);

      // 更新兴趣数据
      interestData.keywords = updatedKeywords;

      // 更新数据库
      await db.collection('userInterests').doc(existingInterest._id).update({
        data: interestData
      });
    } else {
      // 创建新的兴趣数据
      interestData.keywords = keywords.map(kw => ({
        ...kw,
        lastUpdated: now
      }));
      interestData.createTime = now;

      // 添加到数据库
      await db.collection('userInterests').add({
        data: interestData
      });
    }
  } catch (error) {
    console.error('更新用户兴趣数据失败:', error);
    // 不抛出异常，避免影响主流程
  }
}

/**
 * 分类关键词
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function classifyKeywords(event) {
  try {
    // 获取参数
    const { keywords, batch = false } = event;

    // 验证参数
    if (!keywords) {
      return {
        success: false,
        error: '关键词参数不能为空'
      };
    }

    let result;
    if (batch) {
      // 批量分类
      if (!Array.isArray(keywords)) {
        return {
          success: false,
          error: '批量分类时，关键词参数必须是数组'
        };
      }

      result = await keywordClassifier.batchClassifyKeywords(keywords);
      return {
        success: true,
        data: {
          classifications: result
        }
      };
    } else {
      // 单个关键词分类
      if (typeof keywords !== 'string') {
        return {
          success: false,
          error: '单个分类时，关键词参数必须是字符串'
        };
      }

      const category = await keywordClassifier.classifyKeyword(keywords);
      return {
        success: true,
        data: {
          keyword: keywords,
          category: category
        }
      };
    }
  } catch (error) {
    console.error('分类关键词失败:', error);
    return {
      success: false,
      error: error.message || '分类关键词失败'
    };
  }
}

/**
 * 获取预定义分类
 * @returns {Promise<Object>} 处理结果
 */
async function getPredefinedCategories() {
  try {
    const categories = keywordClassifier.getPredefinedCategories();
    return {
      success: true,
      data: {
        categories: categories
      }
    };
  } catch (error) {
    console.error('获取预定义分类失败:', error);
    return {
      success: false,
      error: error.message || '获取预定义分类失败'
    };
  }
}

/**
 * 关联关键词与情感
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function linkKeywordsToEmotion(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    const { keywords, emotionResult } = event;

    // 验证参数
    if (!Array.isArray(keywords) || keywords.length === 0 || !emotionResult) {
      return {
        success: false,
        error: '参数不完整'
      };
    }

    // 关联关键词与情感
    const success = await keywordEmotionLinker.linkKeywordsToEmotion(userId, keywords, emotionResult);

    // 查询更新后的用户兴趣数据
    const db = cloud.database();
    const updatedResult = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    return {
      success: success,
      message: success ? '关联关键词与情感成功' : '关联关键词与情感失败',
      data: {
        userId: userId,
        keywords: keywords,
        emotionResult: {
          type: emotionResult.type || emotionResult.primary_emotion,
          intensity: emotionResult.intensity,
          score: keywordEmotionLinker.calculateEmotionScore(emotionResult)
        },
        currentData: updatedResult.data && updatedResult.data.length > 0 ? updatedResult.data[0] : null
      }
    };
  } catch (error) {
    console.error('关联关键词与情感失败:', error);
    return {
      success: false,
      error: error.message || '关联关键词与情感失败'
    };
  }
}

/**
 * 获取关键词情感统计
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getKeywordEmotionStats(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;

    // 获取关键词情感统计
    const stats = await keywordEmotionLinker.getKeywordEmotionStats(userId);

    return {
      success: true,
      data: stats
    };
  } catch (error) {
    console.error('获取关键词情感统计失败:', error);
    return {
      success: false,
      error: error.message || '获取关键词情感统计失败'
    };
  }
}

/**
 * 获取聊天的情绪分析
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getChatEmotionAnalysis(event) {
  try {
    // 获取参数
    const { chatId } = event;

    // 验证参数
    if (!chatId) {
      return {
        success: false,
        error: '聊天ID不能为空'
      };
    }

    // 从数据库中获取聊天记录
    const db = cloud.database();
    const _ = db.command;
    const messages = await db.collection('messages')
      .where({
        chatId: chatId
      })
      .orderBy('createTime', 'desc')
      .limit(20)
      .get();

    // 检查记录是否存在
    if (!messages || !messages.data || messages.data.length === 0) {
      return {
        success: false,
        error: '未找到聊天记录'
      };
    }

    // 提取所有用户消息的内容
    const userMessages = messages.data
      .filter(msg => msg.role === 'user')
      .map(msg => msg.content)
      .join('\n');

    // 如果没有用户消息，返回错误
    if (!userMessages) {
      return {
        success: false,
        error: '未找到用户消息'
      };
    }

    // 分析用户消息的情绪
    const emotionResult = await analyzeEmotion({
      text: userMessages
    });

    return emotionResult;
  } catch (error) {
    console.error('获取聊天情绪分析失败:', error);
    return {
      success: false,
      error: error.message || '获取聊天情绪分析失败'
    };
  }
}

/**
 * 获取情绪记录分析
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getEmotionRecordAnalysis(event) {
  try {
    // 获取参数
    const { recordId } = event;

    // 验证参数
    if (!recordId) {
      return {
        success: false,
        error: '记录ID不能为空'
      };
    }

    // 从数据库中获取情绪记录
    const db = cloud.database();
    const record = await db.collection('emotionRecords').doc(recordId).get();

    // 检查记录是否存在
    if (!record || !record.data) {
      return {
        success: false,
        error: '未找到情绪记录'
      };
    }

    // 返回情绪分析数据
    return {
      success: true,
      data: record.data.analysis
    };
  } catch (error) {
    console.error('获取情绪记录分析失败:', error);
    return {
      success: false,
      error: error.message || '获取情绪记录分析失败'
    };
  }
}

/**
 * 云函数入口
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
exports.main = async (event) => {
  const { type = 'emotion' } = event;

  console.log('analysis 云函数入口, type:', type);

  switch (type) {
    case 'emotion':
      return await analyzeEmotion(event);
    case 'keywords':
      return await extractTextKeywords(event);
    case 'word_vectors':
      return await getWordVectors(event);
    case 'cluster':
      return await clusterKeywords(event);
    case 'user_interests':
      return await analyzeUserInterests(event);
    case 'focus_points':
      return await analyzeFocusPoints(event);
    case 'daily_report':
      return await generateDailyReport(event);
    case 'classify_keywords':
      return await classifyKeywords(event);
    case 'get_categories':
      return await getPredefinedCategories();
    case 'link_keywords_emotion':
      return await linkKeywordsToEmotion(event);
    case 'get_keyword_emotion_stats':
      return await getKeywordEmotionStats(event);
    case 'emotion_record':
      return await getEmotionRecordAnalysis(event);
    case 'chat_emotion':
      return await getChatEmotionAnalysis(event);
    default:
      return {
        success: false,
        error: '未知的分析类型'
      };
  }
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\keywordClassifier.js*#*#*begin*#*#*
/**
 * 关键词分类器
 * 用于自动对关键词进行分类
 */

// 导入大模型调用模块
const bigmodel = require('./bigmodel');

// 预定义的分类
const PREDEFINED_CATEGORIES = [
  '学习', '工作', '娱乐', '社交', '健康', '生活', '科技', '艺术', '体育',
  '旅游', '美食', '时尚', '金融', '宠物', '家庭', '音乐', '电影', '阅读',
  '游戏', '心理', '自我提升', '时间管理', '压力缓解', '人际关系', '休闲活动',
  '其他'
];

// 细分类别映射
const SUBCATEGORIES = {
  '学习': ['考试', '课程', '学位', '研究', '论文', '知识', '学校', '教育', '学习方法', '学科'],
  '工作': ['职业', '事业', '工作压力', '职场', '同事', '上司', '晋升', '薪资', '求职', '面试'],
  '娱乐': ['休闲', '放松', '爱好', '兴趣', '消遣', '玩乐', '娱乐活动'],
  '社交': ['朋友', '社交圈', '人际交往', '社交活动', '聚会', '交友', '社交技巧'],
  '健康': ['身体健康', '心理健康', '锻炼', '饮食', '睡眠', '医疗', '疾病', '健康习惯'],
  '生活': ['日常生活', '生活方式', '生活质量', '居住', '家务', '购物', '消费'],
  '科技': ['技术', '数码', '互联网', '软件', '硬件', '人工智能', '编程', '科技产品'],
  '艺术': ['绘画', '音乐', '舞蹈', '文学', '电影', '摄影', '设计', '创作', '艺术欣赏'],
  '体育': ['运动', '健身', '比赛', '体育项目', '体育赛事', '团队运动', '个人运动'],
  '旅游': ['旅行', '出游', '景点', '度假', '探险', '文化体验', '旅游规划'],
  '美食': ['饮食', '烹饪', '餐厅', '美食探索', '食谱', '饮品', '烘焙'],
  '时尚': ['服装', '穿搭', '美容', '护肤', '化妆', '时尚潮流', '个人形象'],
  '金融': ['理财', '投资', '储蓄', '保险', '股票', '基金', '经济', '财务规划'],
  '宠物': ['宠物饲养', '宠物健康', '宠物行为', '宠物用品', '宠物训练'],
  '家庭': ['家人', '亲情', '婚姻', '恋爱', '子女', '家庭关系', '家庭教育'],
  '音乐': ['音乐欣赏', '乐器', '音乐创作', '音乐会', '音乐流派', '歌手', '乐队'],
  '电影': ['电影欣赏', '电影制作', '电影人物', '电影类型', '影评', '电视剧'],
  '阅读': ['书籍', '文学作品', '阅读习惯', '作家', '读书笔记', '阅读理解'],
  '游戏': ['电子游戏', '手机游戏', '游戏设备', '游戏策略', '游戏社区', '游戏开发'],
  '心理': ['心理健康', '情绪管理', '心理咨询', '心理疗法', '心理学', '自我认知'],
  '自我提升': ['个人成长', '自我发展', '技能提升', '目标设定', '习惯养成', '自律'],
  '时间管理': ['效率提升', '任务规划', '时间分配', '优先级设定', '拖延症克服'],
  '压力缓解': ['减压方法', '压力源识别', '放松技巧', '冥想', '压力管理'],
  '人际关系': ['人际交往', '沟通技巧', '冲突处理', '关系维护', '社交网络'],
  '休闲活动': ['户外活动', '室内活动', '休闲爱好', '放松方式', '娱乐方式']
};

// 分类提示词模板
const CLASSIFICATION_PROMPT = `
你是一个专业的关键词分类器。请将以下关键词分类到最合适的类别中。
可用的类别有：${PREDEFINED_CATEGORIES.join('、')}。

每个类别的说明：
- 学习：与学习、教育、知识获取、考试、学术研究相关的关键词
- 工作：与职业、事业、职场、工作环境、职业发展相关的关键词
- 娱乐：与休闲、放松、娱乐活动相关的关键词
- 社交：与人际交往、社交活动、交友相关的关键词
- 健康：与身体健康、医疗、疾病、健康生活相关的关键词
- 生活：与日常生活、生活方式、家庭生活相关的关键词
- 科技：与技术、数码、互联网、软硬件相关的关键词
- 艺术：与绘画、音乐、舞蹈、文学、创作相关的关键词
- 体育：与运动、健身、体育比赛相关的关键词
- 旅游：与旅行、出游、景点、度假相关的关键词
- 美食：与饮食、烹饪、餐厅、食物相关的关键词
- 时尚：与服装、穿搭、美容、化妆相关的关键词
- 金融：与理财、投资、储蓄、经济相关的关键词
- 宠物：与宠物饲养、宠物健康相关的关键词
- 家庭：与家人、亲情、婚姻、恋爱相关的关键词
- 音乐：与音乐欣赏、乐器、音乐创作相关的关键词
- 电影：与电影欣赏、电影制作相关的关键词
- 阅读：与书籍、文学作品、阅读习惯相关的关键词
- 游戏：与电子游戏、手机游戏相关的关键词
- 心理：与心理健康、情绪管理、心理咨询相关的关键词
- 自我提升：与个人成长、自我发展、技能提升相关的关键词
- 时间管理：与效率提升、任务规划、时间分配相关的关键词
- 压力缓解：与减压方法、压力源识别、放松技巧相关的关键词
- 人际关系：与人际交往、沟通技巧、冲突处理相关的关键词
- 休闲活动：与户外活动、室内活动、休闲爱好相关的关键词
- 其他：不属于以上任何类别的关键词

关键词列表：
{{keywords}}

请以JSON格式返回结果，格式如下：
{
  "classifications": [
    {"keyword": "关键词1", "category": "类别1"},
    {"keyword": "关键词2", "category": "类别2"},
    ...
  ]
}

只返回JSON格式的结果，不要有任何其他文字。
`;

/**
 * 批量分类关键词
 * @param {Array<string>} keywords 关键词数组
 * @returns {Promise<Array>} 分类结果数组，每个元素包含keyword和category字段
 */
async function batchClassifyKeywords(keywords) {
  try {
    if (!Array.isArray(keywords) || keywords.length === 0) {
      console.warn('关键词数组为空');
      return [];
    }

    // 去重
    const uniqueKeywords = [...new Set(keywords)];
    console.log(`准备分类 ${uniqueKeywords.length} 个关键词: ${JSON.stringify(uniqueKeywords)}`);

    // 构建提示词
    const prompt = CLASSIFICATION_PROMPT.replace('{{keywords}}', uniqueKeywords.join('、'));
    console.log('分类提示词:', prompt);

    // 当API_KEY为空时，使用预定义分类
    if (!process.env.ZHIPU_API_KEY) {
      console.warn('智谱AI API密钥未设置，使用预定义分类进行本地分类');

      // 使用细分类别映射进行本地分类
      const classifications = uniqueKeywords.map(keyword => {
        // 默认分类
        let category = '其他';

        // 遍历所有类别及其关键词
        for (const [cat, keywords] of Object.entries(SUBCATEGORIES)) {
          // 检查关键词是否包含在当前类别的关键词列表中
          if (keywords.some(k => keyword.includes(k))) {
            category = cat;
            break;
          }
        }

        // 如果上面的方法没有分类成功，使用更简单的规则
        if (category === '其他') {
          // 学习相关
          if (keyword.includes('学') || keyword.includes('考') || keyword.includes('课') ||
              keyword.includes('教') || keyword.includes('研') || keyword.includes('论文') ||
              keyword.includes('毕业') || keyword.includes('学位') || keyword.includes('博士') ||
              keyword.includes('知识') || keyword.includes('教育') || keyword.includes('学校')) {
            category = '学习';
          }
          // 工作相关
          else if (keyword.includes('工作') || keyword.includes('公司') || keyword.includes('职业') ||
                 keyword.includes('项目') || keyword.includes('业务') || keyword.includes('客户') ||
                 keyword.includes('设计') || keyword.includes('开发') || keyword.includes('测试') ||
                 keyword.includes('产品') || keyword.includes('市场') || keyword.includes('销售')) {
            category = '工作';
          }
          // 娱乐相关
          else if (keyword.includes('游戏') || keyword.includes('影视') || keyword.includes('电影') ||
                 keyword.includes('剧') || keyword.includes('音乐') || keyword.includes('娱乐') ||
                 keyword.includes('电视') || keyword.includes('综艺') || keyword.includes('节目')) {
            category = '娱乐';
          }
          // 社交相关
          else if (keyword.includes('朋友') || keyword.includes('社交') || keyword.includes('交流') ||
                 keyword.includes('关系') || keyword.includes('聊天') || keyword.includes('群聊') ||
                 keyword.includes('微信') || keyword.includes('聊天') || keyword.includes('消息')) {
            category = '社交';
          }
          // 健康相关
          else if (keyword.includes('健康') || keyword.includes('运动') || keyword.includes('销售') ||
                 keyword.includes('饮食') || keyword.includes('睡眠') || keyword.includes('医疗') ||
                 keyword.includes('疾病') || keyword.includes('药') || keyword.includes('身体')) {
            category = '健康';
          }
          // 生活相关
          else if (keyword.includes('生活') || keyword.includes('日常') || keyword.includes('家庭') ||
                 keyword.includes('家居') || keyword.includes('购物') || keyword.includes('旅行') ||
                 keyword.includes('美食') || keyword.includes('穿搭') || keyword.includes('装修')) {
            category = '生活';
          }
          // 心理相关
          else if (keyword.includes('心理') || keyword.includes('情绪') || keyword.includes('压力') ||
                 keyword.includes('焦虑') || keyword.includes('抑郁') || keyword.includes('焦虑') ||
                 keyword.includes('心情') || keyword.includes('心态') || keyword.includes('心理咨询')) {
            category = '心理';
          }
          // 自我提升相关
          else if (keyword.includes('提升') || keyword.includes('成长') || keyword.includes('发展') ||
                 keyword.includes('目标') || keyword.includes('规划') || keyword.includes('习惯') ||
                 keyword.includes('自律') || keyword.includes('自学') || keyword.includes('技能')) {
            category = '自我提升';
          }
          // 时间管理相关
          else if (keyword.includes('时间') || keyword.includes('管理') || keyword.includes('效率') ||
                 keyword.includes('安排') || keyword.includes('计划') || keyword.includes('日程') ||
                 keyword.includes('任务') || keyword.includes('优先级') || keyword.includes('拖延')) {
            category = '时间管理';
          }
          // 压力缓解相关
          else if (keyword.includes('减压') || keyword.includes('放松') || keyword.includes('缓解') ||
                 keyword.includes('冷静') || keyword.includes('平静') || keyword.includes('冥想') ||
                 keyword.includes('瑜伽') || keyword.includes('健身') || keyword.includes('按摩')) {
            category = '压力缓解';
          }
          // 人际关系相关
          else if (keyword.includes('人际') || keyword.includes('沟通') || keyword.includes('冲突') ||
                 keyword.includes('关系') || keyword.includes('相处') || keyword.includes('交往') ||
                 keyword.includes('信任') || keyword.includes('理解') || keyword.includes('合作')) {
            category = '人际关系';
          }
        }

        return {
          keyword: keyword,
          category: category
        };
      });

      console.log(`本地分类完成，分类结果: ${JSON.stringify(classifications)}`);
      return classifications;
    }

    // 调用大模型
    console.log('开始调用大模型进行分类...');
    const response = await bigmodel.chatCompletion({
      messages: [
        { role: 'system', content: '你是一个专业的关键词分类器，只返回JSON格式的结果。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.2, // 低温度，提高确定性
      response_format: { type: 'json_object' } // 指定返回JSON格式
    });

    console.log('大模型返回原始响应:', JSON.stringify(response));

    // 解析结果
    if (response && response.choices && response.choices.length > 0) {
      const content = response.choices[0].message.content;
      console.log('大模型返回内容:', content);

      try {
        // 尝试解析JSON
        const result = JSON.parse(content);

        if (result && Array.isArray(result.classifications)) {
          console.log(`成功分类 ${result.classifications.length} 个关键词:`, JSON.stringify(result.classifications));
          return result.classifications;
        } else {
          console.error('分类结果格式错误:', result);
          return [];
        }
      } catch (parseError) {
        console.error('解析分类结果失败:', parseError);
        console.log('原始返回内容:', content);
        return [];
      }
    } else {
      console.error('大模型返回结果无效');
      return [];
    }
  } catch (error) {
    console.error('批量分类关键词失败:', error);
    return [];
  }
}

/**
 * 分类单个关键词
 * @param {string} keyword 关键词
 * @returns {Promise<string>} 分类结果
 */
async function classifyKeyword(keyword) {
  try {
    if (!keyword) {
      console.warn('关键词为空');
      return '其他';
    }

    // 调用批量分类函数
    const results = await batchClassifyKeywords([keyword]);

    if (results && results.length > 0) {
      return results[0].category;
    } else {
      console.warn(`关键词 "${keyword}" 分类失败，使用默认分类`);
      return '其他';
    }
  } catch (error) {
    console.error(`分类关键词 "${keyword}" 失败:`, error);
    return '其他';
  }
}

/**
 * 获取所有预定义分类
 * @returns {Array<string>} 分类数组
 */
function getPredefinedCategories() {
  return [...PREDEFINED_CATEGORIES];
}

// 导出模块
module.exports = {
  batchClassifyKeywords,
  classifyKeyword,
  getPredefinedCategories
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\keywordEmotionLinker.js*#*#*begin*#*#*
/**
 * 关键词情感关联模块
 * 用于将关键词与情感分析结果关联起来
 */

const cloud = require('wx-server-sdk');

// 初始化云环境
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

// 获取数据库引用
const db = cloud.database();
const _ = db.command;

/**
 * 关联关键词与情感
 * @param {string} userId 用户ID
 * @param {Array} keywords 关键词数组
 * @param {Object} emotionResult 情感分析结果
 * @returns {Promise<boolean>} 是否关联成功
 */
async function linkKeywordsToEmotion(userId, keywords, emotionResult) {
  try {
    if (!userId || !Array.isArray(keywords) || keywords.length === 0 || !emotionResult) {
      console.warn('关联关键词与情感失败: 参数不完整');
      return false;
    }

    console.log(`关联关键词与情感, 用户ID: ${userId}, 关键词数量: ${keywords.length}`);

    // 提取情感分数
    const emotionScore = calculateEmotionScore(emotionResult);
    console.log(`计算情感分数: ${emotionScore}`);

    // 查询用户兴趣数据
    const userInterests = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    if (userInterests.data.length === 0) {
      console.warn(`用户 ${userId} 没有兴趣数据记录`);
      return false;
    }

    const record = userInterests.data[0];
    const existingKeywords = record.keywords || [];

    // 更新每个关键词的情感分数
    let updateCount = 0;
    for (const keyword of keywords) {
      const word = typeof keyword === 'string' ? keyword : keyword.word;
      if (!word) continue;

      // 查找关键词
      const keywordIndex = existingKeywords.findIndex(k => k.word === word);
      if (keywordIndex === -1) continue;

      // 计算新的情感分数 (加权平均)
      const currentScore = existingKeywords[keywordIndex].emotionScore || 0;
      const newScore = (currentScore * 0.7) + (emotionScore * 0.3);

      // 更新数据库
      await db.collection('userInterests').doc(record._id).update({
        data: {
          [`keywords.${keywordIndex}.emotionScore`]: newScore,
          [`keywords.${keywordIndex}.lastUpdated`]: new Date()
        }
      });

      updateCount++;
    }

    console.log(`成功更新 ${updateCount} 个关键词的情感分数`);
    return updateCount > 0;
  } catch (error) {
    console.error('关联关键词与情感失败:', error);
    return false;
  }
}

/**
 * 计算情感分数
 * 将情感分析结果转换为-1到1之间的分数，负值表示负面情绪，正值表示正面情绪
 * @param {Object} emotionResult 情感分析结果
 * @returns {number} 情感分数
 */
function calculateEmotionScore(emotionResult) {
  try {
    // 如果有直接的情感分数，使用它
    if (typeof emotionResult.score === 'number') {
      return Math.max(-1, Math.min(1, emotionResult.score));
    }

    // 如果有情感类型和强度，根据类型和强度计算分数
    const type = emotionResult.type || emotionResult.primary_emotion;
    const intensity = emotionResult.intensity || 0.5;

    if (!type) return 0;

    // 情感类型映射到分数
    const emotionScores = {
      'joy': 0.8,
      'happiness': 0.9,
      'contentment': 0.7,
      'excitement': 0.8,
      'love': 0.9,
      'optimism': 0.6,
      'pride': 0.5,
      'neutral': 0,
      'confusion': -0.2,
      'boredom': -0.3,
      'sadness': -0.7,
      'anger': -0.8,
      'fear': -0.7,
      'disgust': -0.6,
      'anxiety': -0.6,
      'stress': -0.5,
      'fatigue': -0.4,
      'disappointment': -0.5,
      'embarrassment': -0.4,
      'guilt': -0.6,
      'shame': -0.7
    };

    // 获取情感类型对应的基础分数，如果没有则默认为0
    const baseScore = emotionScores[type.toLowerCase()] || 0;

    // 根据强度调整分数
    return baseScore * intensity;
  } catch (error) {
    console.error('计算情感分数失败:', error);
    return 0;
  }
}

/**
 * 获取关键词情感统计
 * @param {string} userId 用户ID
 * @returns {Promise<Object>} 情感统计结果
 */
async function getKeywordEmotionStats(userId) {
  try {
    if (!userId) {
      console.warn('获取关键词情感统计失败: 用户ID为空');
      return { positive: [], negative: [], neutral: [] };
    }

    // 查询用户兴趣数据
    const userInterests = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    if (userInterests.data.length === 0) {
      console.warn(`用户 ${userId} 没有兴趣数据记录`);
      return { positive: [], negative: [], neutral: [] };
    }

    const keywords = userInterests.data[0].keywords || [];

    // 按情感分数分类关键词
    const positive = [];
    const negative = [];
    const neutral = [];

    keywords.forEach(keyword => {
      const score = keyword.emotionScore || 0;
      const item = {
        word: keyword.word,
        score: score,
        weight: keyword.weight || 1,
        category: keyword.category || '未分类'
      };

      if (score > 0.2) {
        positive.push(item);
      } else if (score < -0.2) {
        negative.push(item);
      } else {
        neutral.push(item);
      }
    });

    // 按情感分数绝对值和权重排序
    positive.sort((a, b) => (b.score * b.weight) - (a.score * a.weight));
    negative.sort((a, b) => (Math.abs(a.score) * a.weight) - (Math.abs(b.score) * b.weight));
    neutral.sort((a, b) => b.weight - a.weight);

    return {
      positive: positive.slice(0, 10), // 取前10个
      negative: negative.slice(0, 10), // 取前10个
      neutral: neutral.slice(0, 10)    // 取前10个
    };
  } catch (error) {
    console.error('获取关键词情感统计失败:', error);
    return { positive: [], negative: [], neutral: [] };
  }
}

// 导出模块
module.exports = {
  linkKeywordsToEmotion,
  calculateEmotionScore,
  getKeywordEmotionStats
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\keywords.js*#*#*begin*#*#*
/**
 * 关键词提取模块 - 使用HanLP API
 * 提供文本关键词提取功能
 */
const axios = require('axios');

// HanLP API配置
const HANLP_API_URL = 'https://hanlp.hankcs.com/api';
const HANLP_AUTH = 'ODI1N0BiYnMuaGFubHAuY29tOnRRYWRzVU9xQ3JYb2Jyc04='; // 已编码的auth信息

/**
 * 从文本中提取关键词
 * @param {string} text 待分析文本
 * @param {number} topK 返回关键词数量
 * @returns {Promise<Object>} 提取结果
 */
async function extractKeywords(text, topK = 10) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      return {
        success: false,
        error: '无效的文本参数'
      };
    }

    // 调用HanLP API
    const response = await axios.post(`${HANLP_API_URL}/extractKeywords`, {
      text: text,
      topk: topK
    }, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Basic ${HANLP_AUTH}`
      }
    });

    // 处理响应
    if (response.status === 200) {
      // 转换结果格式
      const keywords = Array.isArray(response.data) 
        ? response.data.map(item => ({
            word: item[0],
            weight: item[1]
          }))
        : [];

      return {
        success: true,
        data: {
          keywords: keywords
        }
      };
    } else {
      return {
        success: false,
        error: `API请求失败: ${response.status}`
      };
    }
  } catch (error) {
    console.error('关键词提取失败:', error);
    return {
      success: false,
      error: error.message || '关键词提取服务调用失败'
    };
  }
}

/**
 * 获取词向量
 * @param {Array<string>} words 词语列表
 * @returns {Promise<Object>} 词向量结果
 */
async function getWordVectors(words) {
  try {
    // 验证参数
    if (!Array.isArray(words) || words.length === 0) {
      return {
        success: false,
        error: '无效的词语列表参数'
      };
    }

    // 调用HanLP API
    const response = await axios.post(`${HANLP_API_URL}/embedWord`, {
      text: words
    }, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Basic ${HANLP_AUTH}`
      }
    });

    // 处理响应
    if (response.status === 200) {
      return {
        success: true,
        data: {
          vectors: response.data
        }
      };
    } else {
      return {
        success: false,
        error: `API请求失败: ${response.status}`
      };
    }
  } catch (error) {
    console.error('获取词向量失败:', error);
    return {
      success: false,
      error: error.message || '词向量服务调用失败'
    };
  }
}

/**
 * 聚类分析
 * @param {string} text 待分析文本
 * @param {number} threshold 聚类阈值
 * @param {number} minClusterSize 最小簇大小
 * @returns {Promise<Object>} 聚类结果
 */
async function clusterKeywords(text, threshold = 0.7, minClusterSize = 2) {
  try {
    // 先提取关键词
    const keywordsResult = await extractKeywords(text, 20);
    if (!keywordsResult.success) {
      return keywordsResult;
    }

    const keywords = keywordsResult.data.keywords.map(item => item.word);
    
    // 如果关键词数量不足，无法聚类
    if (keywords.length < minClusterSize) {
      return {
        success: true,
        data: {
          clusters: []
        }
      };
    }

    // 获取词向量
    const vectorsResult = await getWordVectors(keywords);
    if (!vectorsResult.success) {
      return vectorsResult;
    }

    // 简单实现的聚类算法（实际项目中可能需要更复杂的算法）
    // 这里使用简化版的层次聚类
    const vectors = vectorsResult.data.vectors;
    const clusters = simpleClusterAlgorithm(keywords, vectors, threshold, minClusterSize);

    return {
      success: true,
      data: {
        clusters: clusters
      }
    };
  } catch (error) {
    console.error('聚类分析失败:', error);
    return {
      success: false,
      error: error.message || '聚类分析服务调用失败'
    };
  }
}

/**
 * 简单聚类算法
 * @param {Array<string>} keywords 关键词列表
 * @param {Array<Array<number>>} vectors 词向量列表
 * @param {number} threshold 聚类阈值
 * @param {number} minClusterSize 最小簇大小
 * @returns {Array<Object>} 聚类结果
 */
function simpleClusterAlgorithm(keywords, vectors, threshold, minClusterSize) {
  // 计算余弦相似度
  function cosineSimilarity(vec1, vec2) {
    let dotProduct = 0;
    let norm1 = 0;
    let norm2 = 0;
    
    for (let i = 0; i < vec1.length; i++) {
      dotProduct += vec1[i] * vec2[i];
      norm1 += vec1[i] * vec1[i];
      norm2 += vec2[i] * vec2[i];
    }
    
    norm1 = Math.sqrt(norm1);
    norm2 = Math.sqrt(norm2);
    
    return dotProduct / (norm1 * norm2);
  }

  // 初始化每个词为一个簇
  let clusters = keywords.map((word, index) => ({
    keywords: [word],
    center: word,
    vector: vectors[index],
    size: 1
  }));

  // 合并簇
  let changed = true;
  while (changed && clusters.length > 1) {
    changed = false;
    
    // 找到最相似的两个簇
    let maxSim = -1;
    let maxI = -1;
    let maxJ = -1;
    
    for (let i = 0; i < clusters.length; i++) {
      for (let j = i + 1; j < clusters.length; j++) {
        const sim = cosineSimilarity(clusters[i].vector, clusters[j].vector);
        if (sim > maxSim && sim >= threshold) {
          maxSim = sim;
          maxI = i;
          maxJ = j;
        }
      }
    }
    
    // 如果找到了相似度高于阈值的簇，合并它们
    if (maxI !== -1 && maxJ !== -1) {
      const cluster1 = clusters[maxI];
      const cluster2 = clusters[maxJ];
      
      // 合并关键词
      const newKeywords = [...cluster1.keywords, ...cluster2.keywords];
      
      // 计算新的中心向量
      const newVector = cluster1.vector.map((val, idx) => 
        (val * cluster1.size + cluster2.vector[idx] * cluster2.size) / (cluster1.size + cluster2.size)
      );
      
      // 选择最接近中心向量的词作为中心词
      let centerIndex = 0;
      let maxCenterSim = -1;
      
      for (let i = 0; i < newKeywords.length; i++) {
        const wordIndex = keywords.indexOf(newKeywords[i]);
        const sim = cosineSimilarity(newVector, vectors[wordIndex]);
        if (sim > maxCenterSim) {
          maxCenterSim = sim;
          centerIndex = i;
        }
      }
      
      // 创建新簇
      const newCluster = {
        keywords: newKeywords,
        center: newKeywords[centerIndex],
        vector: newVector,
        size: cluster1.size + cluster2.size
      };
      
      // 更新簇列表
      clusters.splice(maxJ, 1);
      clusters[maxI] = newCluster;
      
      changed = true;
    }
  }
  
  // 过滤掉小于最小簇大小的簇
  return clusters
    .filter(cluster => cluster.size >= minClusterSize)
    .map(cluster => ({
      keywords: cluster.keywords,
      center: cluster.center,
      size: cluster.size
    }));
}

// 导出模块
module.exports = {
  extractKeywords,
  getWordVectors,
  clusterKeywords
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\package.json*#*#*begin*#*#*
{
  "name": "analysis",
  "version": "1.0.0",
  "description": "情感分析与关键词提取云函数 - 支持智谱AI和Google Gemini API",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "axios": "^0.24.0"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\test.js*#*#*begin*#*#*
/**
 * 测试智谱AI模块
 * 用于验证bigmodel.js模块的功能是否正常
 */
const bigModelModule = require('./bigmodel');

// 测试事件
const testEvent = {
  textForEmotion: "今天项目上线了，非常激动和开心！但也感觉有点累。",
  textForKeywords: "这个基于大模型的AI助手可以进行情感识别和文本摘要。",
  textsForEmbedding: [
    "探索AI的可能性",
    "感受科技的魅力",
    "创造更美好的未来"
  ],
  userMessagesForInterest: [
    "周末想去看画展，对艺术很感兴趣。",
    "最近在学习Python编程。",
    "喜欢听古典音乐放松心情。"
  ]
};

/**
 * 主测试函数
 */
async function main() {
  console.log('开始测试 bigmodel.js 模块...');
  console.log('收到的测试事件 event:', testEvent);

  // 测试情感分析功能
  console.log('\n--- 测试 analyzeEmotion ---\n');
  console.log('analyzeEmotion 输入:', testEvent.textForEmotion);
  try {
    const emotionResult = await bigModelModule.analyzeEmotion(testEvent.textForEmotion);
    console.log('analyzeEmotion 输出:', emotionResult);
  } catch (error) {
    console.log('智谱AI情感分析失败:', error.message || error);
    console.log('analyzeEmotion 输出:', {
      success: false,
      error: error.message || '情感分析失败'
    });
  }

  // 测试关键词提取功能
  console.log('\n--- 测试 extractKeywords ---\n');
  console.log('extractKeywords 输入:', testEvent.textForKeywords);
  try {
    const keywordsResult = await bigModelModule.extractKeywords(testEvent.textForKeywords);
    console.log('extractKeywords 输出:', keywordsResult);
  } catch (error) {
    console.log('智谱AI关键词提取失败:', error.message || error);
    console.log('extractKeywords 输出:', {
      success: false,
      error: error.message || '关键词提取失败'
    });
  }

  // 测试向量获取功能
  console.log('\n--- 测试 getEmbeddings ---\n');
  console.log('getEmbeddings 输入:', testEvent.textsForEmbedding);
  try {
    const embeddingsResult = await bigModelModule.getEmbeddings(testEvent.textsForEmbedding);
    console.log('getEmbeddings 输出:', embeddingsResult);
  } catch (error) {
    console.log('智谱AI向量获取失败:', error.message || error);
    console.log('getEmbeddings 输出:', {
      success: false,
      error: error.message || '向量获取失败'
    });
  }

  // 测试用户兴趣分析功能
  console.log('\n--- 测试 analyzeUserInterests ---\n');
  console.log('analyzeUserInterests 输入:', testEvent.userMessagesForInterest);
  try {
    const interestsResult = await bigModelModule.analyzeUserInterests(testEvent.userMessagesForInterest);
    console.log('analyzeUserInterests 输出:', interestsResult);
  } catch (error) {
    console.log('智谱AI用户兴趣分析失败:', error.message || error);
    console.log('analyzeUserInterests 输出:', {
      success: false,
      error: error.message || '用户兴趣分析失败'
    });
  }

  console.log('\n测试结束.');
}

// 执行测试
main().catch(error => {
  console.error('测试过程中发生错误:', error.message || error);
});

// 导出测试函数
exports.main = async (event) => {
  try {
    await main();
    return {
      success: true,
      message: 'bigmodel.js 模块测试执行完毕，请检查云函数运行日志获取详细结果。'
    };
  } catch (error) {
    console.error('测试执行失败:', error.message || error);
    return {
      success: false,
      error: error.message || '测试执行失败'
    };
  }
};

*#*#*end*#*#*

*#*#*cloudfunctions\analysis\userInterestAnalyzer.js*#*#*begin*#*#*
/**
 * 用户兴趣分析器
 * 提供关键词分类、用户兴趣分析和关注点识别功能
 */

// 导入大模型调用模块
const bigmodel = require('./bigmodel');
const keywordClassifier = require('./keywordClassifier');

// 预定义的兴趣类别
const INTEREST_CATEGORIES = [
  '学习', '工作', '娱乐', '社交', '健康', '生活', '科技', '艺术', '体育', 
  '旅游', '美食', '时尚', '金融', '宠物', '家庭', '音乐', '电影', '阅读', 
  '游戏', '心理', '自我提升', '时间管理', '压力缓解', '人际关系', '休闲活动'
];

/**
 * 分析用户兴趣和关注点
 * @param {Array} keywords 关键词数组，每个元素包含word和weight字段
 * @param {Array} emotionRecords 情绪记录数组
 * @returns {Promise<Object>} 分析结果
 */
async function analyzeUserInterests(keywords, emotionRecords = []) {
  try {
    if (!Array.isArray(keywords) || keywords.length === 0) {
      console.warn('关键词数组为空，无法分析用户兴趣');
      return {
        success: false,
        error: '关键词数组为空'
      };
    }

    console.log(`开始分析用户兴趣，关键词数量: ${keywords.length}`);

    // 1. 对关键词进行分类
    const classifiedKeywords = await classifyKeywords(keywords);
    console.log(`关键词分类完成，分类结果: ${JSON.stringify(classifiedKeywords)}`);

    // 2. 计算每个类别的权重总和
    const categoryWeights = calculateCategoryWeights(classifiedKeywords);
    console.log(`类别权重计算完成: ${JSON.stringify(categoryWeights)}`);

    // 3. 标准化类别权重为百分比
    const normalizedWeights = normalizeWeights(categoryWeights);
    console.log(`权重标准化完成: ${JSON.stringify(normalizedWeights)}`);

    // 4. 提取用户关注点
    const focusPoints = extractFocusPoints(normalizedWeights, classifiedKeywords);
    console.log(`关注点提取完成: ${JSON.stringify(focusPoints)}`);

    // 5. 结合情绪记录进行情感关联分析
    const emotionalInsights = analyzeEmotionalAssociations(classifiedKeywords, emotionRecords);
    console.log(`情感关联分析完成: ${JSON.stringify(emotionalInsights)}`);

    return {
      success: true,
      data: {
        categoryWeights: normalizedWeights,
        focusPoints: focusPoints,
        emotionalInsights: emotionalInsights,
        classifiedKeywords: classifiedKeywords
      }
    };
  } catch (error) {
    console.error('分析用户兴趣失败:', error);
    return {
      success: false,
      error: error.message || '分析用户兴趣失败'
    };
  }
}

/**
 * 对关键词进行分类
 * @param {Array} keywords 关键词数组
 * @returns {Promise<Array>} 分类后的关键词数组
 */
async function classifyKeywords(keywords) {
  try {
    // 提取关键词文本
    const keywordTexts = keywords.map(item => item.word);
    console.log(`准备分类关键词: ${JSON.stringify(keywordTexts)}`);

    // 调用关键词分类器进行批量分类
    const classifications = await keywordClassifier.batchClassifyKeywords(keywordTexts);
    console.log(`分类结果: ${JSON.stringify(classifications)}`);

    // 将分类结果与原始关键词合并
    const classifiedKeywords = keywords.map(keyword => {
      const classification = classifications.find(c => c.keyword === keyword.word);
      return {
        ...keyword,
        category: classification ? classification.category : '其他'
      };
    });

    return classifiedKeywords;
  } catch (error) {
    console.error('关键词分类失败:', error);
    // 如果分类失败，返回原始关键词，类别设为"其他"
    return keywords.map(keyword => ({
      ...keyword,
      category: '其他'
    }));
  }
}

/**
 * 计算每个类别的权重总和
 * @param {Array} classifiedKeywords 分类后的关键词数组
 * @returns {Object} 类别权重映射
 */
function calculateCategoryWeights(classifiedKeywords) {
  const categoryWeights = {};

  // 初始化所有预定义类别的权重为0
  INTEREST_CATEGORIES.forEach(category => {
    categoryWeights[category] = 0;
  });

  // 累加每个类别的权重
  classifiedKeywords.forEach(keyword => {
    const category = keyword.category;
    if (!categoryWeights[category]) {
      categoryWeights[category] = 0;
    }
    categoryWeights[category] += keyword.weight || 1;
  });

  return categoryWeights;
}

/**
 * 标准化类别权重为百分比
 * @param {Object} categoryWeights 类别权重映射
 * @returns {Array} 标准化后的类别权重数组
 */
function normalizeWeights(categoryWeights) {
  // 计算权重总和
  let totalWeight = 0;
  Object.values(categoryWeights).forEach(weight => {
    totalWeight += weight;
  });

  // 如果总权重为0，返回空数组
  if (totalWeight === 0) {
    return [];
  }

  // 标准化权重并转换为数组格式
  const normalizedWeights = Object.entries(categoryWeights)
    .filter(([_, weight]) => weight > 0) // 只保留权重大于0的类别
    .map(([category, weight]) => ({
      category,
      weight: weight,
      percentage: parseFloat(((weight / totalWeight) * 100).toFixed(1))
    }))
    .sort((a, b) => b.percentage - a.percentage); // 按百分比降序排序

  return normalizedWeights;
}

/**
 * 提取用户关注点
 * @param {Array} normalizedWeights 标准化后的类别权重数组
 * @param {Array} classifiedKeywords 分类后的关键词数组
 * @returns {Array} 用户关注点数组
 */
function extractFocusPoints(normalizedWeights, classifiedKeywords) {
  // 取权重前5的类别作为主要关注点
  const topCategories = normalizedWeights.slice(0, 5);

  // 为每个主要类别找出最具代表性的关键词
  const focusPoints = topCategories.map(category => {
    // 找出该类别下的所有关键词
    const categoryKeywords = classifiedKeywords.filter(
      keyword => keyword.category === category.category
    );

    // 按权重排序
    categoryKeywords.sort((a, b) => (b.weight || 0) - (a.weight || 0));

    // 取前3个关键词作为代表
    const representativeKeywords = categoryKeywords.slice(0, 3).map(k => k.word);

    return {
      category: category.category,
      percentage: category.percentage,
      weight: category.weight,
      keywords: representativeKeywords
    };
  });

  return focusPoints;
}

/**
 * 分析关键词与情绪的关联
 * @param {Array} classifiedKeywords 分类后的关键词数组
 * @param {Array} emotionRecords 情绪记录数组
 * @returns {Object} 情感关联分析结果
 */
function analyzeEmotionalAssociations(classifiedKeywords, emotionRecords) {
  // 如果没有情绪记录，返回空结果
  if (!Array.isArray(emotionRecords) || emotionRecords.length === 0) {
    return {
      positiveAssociations: [],
      negativeAssociations: []
    };
  }

  // 情绪极性映射
  const emotionPolarity = {
    '高兴': 1, '开心': 1, '喜悦': 1, '兴奋': 1, '满足': 1, '感激': 1, '乐观': 1,
    '悲伤': -1, '沮丧': -1, '失望': -1, '痛苦': -1, '焦虑': -1, '恐惧': -1, '愤怒': -1,
    '烦躁': -1, '厌恶': -1, '内疚': -1, '羞愧': -1, '嫉妒': -1, '孤独': -1,
    '平静': 0.5, '放松': 0.5, '满足': 0.5, '中性': 0, '混合': 0
  };

  // 关键词情感关联映射
  const keywordEmotionMap = {};

  // 遍历情绪记录，建立关键词与情绪的关联
  emotionRecords.forEach(record => {
    const emotionType = record.analysis?.type || record.analysis?.primary_emotion || 'neutral';
    const polarity = emotionPolarity[emotionType] || 0;
    const keywords = record.analysis?.keywords || [];

    // 将关键词与情绪关联
    keywords.forEach(keyword => {
      const word = typeof keyword === 'string' ? keyword : keyword.word;
      if (!keywordEmotionMap[word]) {
        keywordEmotionMap[word] = {
          positive: 0,
          negative: 0,
          count: 0
        };
      }

      keywordEmotionMap[word].count++;
      if (polarity > 0) {
        keywordEmotionMap[word].positive++;
      } else if (polarity < 0) {
        keywordEmotionMap[word].negative++;
      }
    });
  });

  // 找出与积极情绪和消极情绪最相关的关键词
  const positiveAssociations = [];
  const negativeAssociations = [];

  Object.entries(keywordEmotionMap).forEach(([word, stats]) => {
    if (stats.count >= 2) { // 至少出现2次才考虑
      const positiveRatio = stats.positive / stats.count;
      const negativeRatio = stats.negative / stats.count;

      if (positiveRatio > 0.6) {
        positiveAssociations.push({
          word,
          ratio: positiveRatio,
          count: stats.count
        });
      } else if (negativeRatio > 0.6) {
        negativeAssociations.push({
          word,
          ratio: negativeRatio,
          count: stats.count
        });
      }
    }
  });

  // 按关联强度排序
  positiveAssociations.sort((a, b) => (b.ratio * b.count) - (a.ratio * a.count));
  negativeAssociations.sort((a, b) => (b.ratio * b.count) - (a.ratio * a.count));

  return {
    positiveAssociations: positiveAssociations.slice(0, 5), // 取前5个
    negativeAssociations: negativeAssociations.slice(0, 5) // 取前5个
  };
}

// 导出模块
module.exports = {
  analyzeUserInterests,
  INTEREST_CATEGORIES
};

*#*#*end*#*#*

*#*#*cloudfunctions\chat\aiModelService.js*#*#*begin*#*#*
/**
 * AI模型服务
 * 提供统一的AI模型调用接口，支持多种AI模型平台
 *
 * @architecture 该模块实现了统一的AI模型调用接口，支持智谱AI、Google Gemini、OpenAI、Crond API和CloseAI等多种模型平台
 * @dependency axios HTTP请求库
 * @history 2025-05-15 初始版本
 */

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 导入axios
const axios = require('axios');

// 模型平台配置
const MODEL_PLATFORMS = {
  // 智谱AI
  ZHIPU: {
    name: '智谱AI',
    baseUrl: 'https://open.bigmodel.cn/api/paas/v4',
    apiKeyEnv: 'ZHIPU_API_KEY',
    defaultModel: 'glm-4-flash',
    models: ['glm-4-flash', 'glm-4'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions'
    }
  },
  // Google Gemini
  GEMINI: {
    name: 'Google Gemini',
    baseUrl: 'https://apiv2.aliyahzombie.top',
    apiKeyEnv: 'GEMINI_API_KEY',
    defaultModel: 'gemini-2.5-flash-preview-04-17',
    models: ['gemini-2.5-flash-preview-04-17'],
    authType: 'Bearer',
    endpoints: {
      chat: '/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent'
    }
  },
  // WHIMSY
  WHIMSY: {
    name: 'Whimsy',
    baseUrl: 'https://doi9.top/v1',
    apiKeyEnv: 'WHIMSY_API_KEY',
    defaultModel: 'gemini-2.5-flash-preview-04-17-non-thinking',
    models: ['gemini-2.5-pro-preview-05-06', 'gemini-2.5-flash-preview-04-17-non-thinking', 'gemini-2.5-flash-preview-04-17'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions'
    }
  },
  // Crond API
  CROND: {
    name: 'Crond API',
    baseUrl: 'https://new.crond.dev/v1',
    apiKeyEnv: 'CROND_API_KEY',
    defaultModel: 'gpt-4o-mini',
    models: ['gpt-4o-mini', 'deepseek-v3', 'o3-mini'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions'
    }
  },
  // CloseAI
  CLOSEAI: {
    name: 'CloseAI',
    baseUrl: 'https://api.closeai.im/v1',
    apiKeyEnv: 'CLOSEAI_API_KEY',
    defaultModel: 'deepseek-ai/DeepSeek-V3-0324',
    models: ['deepseek-ai/DeepSeek-V3-0324'],
    authType: 'Bearer',
    endpoints: {
      chat: '/chat/completions'
    }
  }
};

/**
 * 延迟函数
 * @param {number} ms 延迟毫秒数
 * @returns {Promise} 延迟Promise
 */
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * 获取API密钥
 * @param {string} platformKey 平台键名
 * @returns {string} API密钥
 */
function getApiKey(platformKey) {
  const platform = MODEL_PLATFORMS[platformKey];
  if (!platform) {
    throw new Error(`未知的平台: ${platformKey}`);
  }

  const apiKey = process.env[platform.apiKeyEnv];
  if (!apiKey) {
    throw new Error(`未设置${platform.apiKeyEnv}环境变量`);
  }

  return apiKey;
}

/**
 * 获取平台配置
 * @param {string} platformKey 平台键名
 * @returns {Object} 平台配置
 */
function getPlatformConfig(platformKey) {
  const platform = MODEL_PLATFORMS[platformKey];
  if (!platform) {
    throw new Error(`未知的平台: ${platformKey}`);
  }

  return platform;
}

/**
 * 格式化消息为平台特定格式
 * @param {Array} messages 消息数组
 * @param {string} platformKey 平台键名
 * @returns {Array|Object} 格式化后的消息
 */
function formatMessages(messages, platformKey) {
  if (platformKey === 'GEMINI') {
    // Gemini使用特殊格式
    const formattedMessages = [];
    let systemPrompt = '';

    // 提取系统提示词
    for (const msg of messages) {
      if (msg.role === 'system') {
        systemPrompt = msg.content;
        break;
      }
    }

    // 构建对话内容
    const contents = [];
    for (const msg of messages) {
      if (msg.role !== 'system') {
        contents.push({
          role: msg.role === 'user' ? 'user' : 'model',
          parts: [{ text: msg.content }]
        });
      }
    }

    // 如果有系统提示词，添加到第一个用户消息前
    if (systemPrompt && contents.length > 0) {
      const firstUserIndex = contents.findIndex(c => c.role === 'user');
      if (firstUserIndex >= 0) {
        const userMsg = contents[firstUserIndex].parts[0].text;
        contents[firstUserIndex].parts[0].text = `${systemPrompt}\n\n${userMsg}`;
      }
    }

    return { contents };
  } else {
    // 其他平台使用标准格式
    return messages;
  }
}

/**
 * 解析API响应
 * @param {Object} response API响应
 * @param {string} platformKey 平台键名
 * @returns {Object} 解析后的响应
 */
function parseResponse(response, platformKey) {
  if (platformKey === 'GEMINI') {
    // Gemini响应格式
    if (response && response.candidates && response.candidates.length > 0) {
      const candidate = response.candidates[0];
      if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
        return {
          content: candidate.content.parts[0].text,
          usage: response.usageMetadata || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
        };
      }
    }
  } else {
    // 标准响应格式 (OpenAI, Crond, CloseAI, 智谱AI)
    if (response && response.choices && response.choices.length > 0) {
      return {
        content: response.choices[0].message.content,
        usage: response.usage || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
      };
    }
  }

  throw new Error('无法解析API响应');
}

/**
 * 调用AI模型API
 * @param {Object} params 请求参数
 * @param {string} platformKey 平台键名
 * @param {number} retryCount 重试次数，默认为3
 * @param {number} retryDelay 重试延迟，默认为1000ms
 * @returns {Promise<Object>} API响应
 */
async function callModelApi(params, platformKey, retryCount = 3, retryDelay = 1000) {
  try {
    // 获取平台配置
    const platform = getPlatformConfig(platformKey);
    
    // 获取API密钥
    const apiKey = getApiKey(platformKey);

    // 构建请求URL
    const url = `${platform.baseUrl}${platform.endpoints.chat}`;

    // 格式化消息
    const formattedMessages = formatMessages(params.messages, platformKey);

    // 构建请求体
    let requestBody;
    if (platformKey === 'GEMINI') {
      requestBody = {
        contents: formattedMessages.contents,
        generationConfig: {
          temperature: params.temperature || 0.7,
          maxOutputTokens: params.max_tokens || 2048,
          topP: params.top_p || 1
        }
      };
    } else {
      requestBody = {
        model: params.model || platform.defaultModel,
        messages: formattedMessages,
        temperature: params.temperature || 0.7,
        max_tokens: params.max_tokens || 2048,
        top_p: params.top_p || 1,
        frequency_penalty: params.frequency_penalty || 0,
        presence_penalty: params.presence_penalty || 0
      };
    }

    if (isDev) {
      console.log(`调用${platform.name} API, 请求体:`, JSON.stringify(requestBody, null, 2));
    }

    console.log('发送请求到:', url);

    try {
      // 发送请求
      const response = await axios({
        method: 'POST',
        url: url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `${platform.authType} ${apiKey}`
        },
        data: requestBody
      });

      // 检查响应状态
      if (response.status !== 200) {
        console.error(`${platform.name} API返回错误状态码:`, response.status);
        throw new Error(`${platform.name} API调用失败: 状态码 ${response.status}`);
      }

      // 获取响应数据
      const result = response.data;

      // 解析响应
      const parsedResult = parseResponse(result, platformKey);

      return parsedResult;
    } catch (error) {
      // 处理429错误（请求过多）
      if (error.response && error.response.status === 429 && retryCount > 0) {
        console.log(`遇到429错误，等待${retryDelay}ms后重试，剩余重试次数: ${retryCount-1}`);

        // 等待一段时间后重试
        await delay(retryDelay);

        // 递归调用自身，减少重试次数，增加延迟时间
        return callModelApi(params, platformKey, retryCount - 1, retryDelay * 2);
      }

      // 其他错误或重试次数用完，抛出异常
      throw error;
    }
  } catch (error) {
    console.error(`调用${platformKey} API失败:`, error);
    throw error;
  }
}

/**
 * 生成聊天回复
 * @param {string} userMessage 用户消息
 * @param {Array} history 历史消息记录
 * @param {Object} roleInfo 角色信息
 * @param {boolean} includeEmotionAnalysis 是否包含情绪分析
 * @param {string} customSystemPrompt 自定义系统提示词
 * @param {Object} options 选项，包括平台和模型
 * @returns {Promise<Object>} 生成的回复
 */
async function generateChatReply(userMessage, history = [], roleInfo = {}, includeEmotionAnalysis = false, customSystemPrompt = null, options = {}) {
  try {
    // 验证参数
    if (!userMessage || typeof userMessage !== 'string' || userMessage.trim() === '') {
      return {
        success: false,
        error: '无效的用户消息'
      };
    }

    // 获取平台和模型
    const platformKey = options.platform || 'GEMINI';
    const platform = getPlatformConfig(platformKey);
    const modelName = options.model || platform.defaultModel;

    // 构建系统提示词
    let systemPrompt = '';
    if (customSystemPrompt) {
      systemPrompt = customSystemPrompt;
    } else if (roleInfo && roleInfo.prompt) {
      systemPrompt = roleInfo.prompt;
    } else {
      systemPrompt = '';
    }

    // 构建消息数组
    const messages = [
      { role: 'system', content: systemPrompt }
    ];

    // 添加历史消息
    if (history && Array.isArray(history)) {
      history.forEach(msg => {
        messages.push(msg);
      });
    }

    // 添加当前用户消息
    messages.push({ role: 'user', content: userMessage });

    if (isDev) {
      console.log(`发送到${platform.name}的消息:`, JSON.stringify(messages, null, 2));
    }

    // 调用模型API
    const response = await callModelApi({
      model: modelName,
      messages: messages,
      temperature: 0.7,
      max_tokens: 2048
    }, platformKey);

    // 情绪分析将完全由专门的云函数 @cloudfunctions\analysis/ 处理
    const aiReply = response.content;
    const emotionAnalysis = null;

    if (includeEmotionAnalysis) {
      // 不再处理情绪分析，但保留条件分支以保持代码结构完整
      console.log('情绪分析功能已禁用，使用专门的云函数处理');
    }

    return {
      success: true,
      reply: aiReply,
      emotionAnalysis: emotionAnalysis,
      usage: response.usage
    };
  } catch (error) {
    console.error('聊天回复生成失败:', error);
    return {
      success: false,
      error: error.message || '聊天回复生成失败'
    };
  }
}

/**
 * 获取可用模型列表
 * @param {string} platformKey 平台键名
 * @returns {Promise<Array<string>>} 可用模型列表
 */
async function getAvailableModels(platformKey) {
  try {
    // 获取平台配置
    const platform = getPlatformConfig(platformKey);
    
    // 返回平台支持的模型列表
    return platform.models;
  } catch (error) {
    console.error('获取可用模型列表失败:', error);
    return [];
  }
}

// 导出模块
module.exports = {
  MODEL_PLATFORMS,
  generateChatReply,
  getAvailableModels,
  callModelApi
};

*#*#*end*#*#*

*#*#*cloudfunctions\chat\bigmodel.js*#*#*begin*#*#*
/**
 * 智谱AI (BigModel) 模块
 * 提供基于智谱AI的聊天功能
 */
const axios = require('axios');

// 智谱AI API配置
// 注意：实际使用时应从环境变量或安全配置中读取API密钥，而不是硬编码
const API_KEY = process.env.ZHIPU_API_KEY || ''; // 从环境变量获取API密钥
const API_BASE_URL = 'https://open.bigmodel.cn/api/paas/v4';

// 模型配置
const GLM_4_FLASH = 'glm-4-flash'; // 快速版本，适合对话

/**
 * 生成智谱AI API请求所需的认证头
 * @returns {Object} 包含Authorization的请求头
 */
function getAuthHeaders() {
  // 实际项目中应使用智谱AI SDK进行认证
  // 这里简化处理，假设API_KEY已经是完整的Bearer Token
  return {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${API_KEY}`
  };
}

/**
 * 使用GLM-4-Flash模型生成聊天回复
 * @param {string} userMessage 用户消息
 * @param {Array} history 历史消息记录
 * @param {Object} roleInfo 角色信息
 * @param {boolean} includeEmotionAnalysis 是否包含情绪分析
 * @param {string} customSystemPrompt 自定义系统提示词
 * @returns {Promise<Object>} 生成的回复
 */
async function generateChatReply(userMessage, history = [], roleInfo = {}, includeEmotionAnalysis = false, customSystemPrompt = null) {
  try {
    // 验证参数
    if (!userMessage || typeof userMessage !== 'string' || userMessage.trim() === '') {
      return {
        success: false,
        error: '无效的用户消息'
      };
    }

    // 构建系统提示词
    let systemPrompt = '';

    // 优先使用自定义系统提示词（包含用户画像信息）
    if (customSystemPrompt) {
      systemPrompt = customSystemPrompt;
      console.log('使用自定义系统提示词（包含用户画像）');
    } else if (roleInfo && roleInfo.prompt) {
      // 优先使用角色的prompt字段（为了兼容系统预设角色）
      systemPrompt = roleInfo.prompt;
      console.log('使用角色的prompt字段作为系统提示词');
    } else if (roleInfo && roleInfo.system_prompt) {
      // 如果没有prompt，则使用system_prompt字段
      systemPrompt = roleInfo.system_prompt;
      console.log('使用角色的system_prompt字段作为系统提示词');
    } else {
      // 默认系统提示词
      systemPrompt = `你是一个友好、有帮助的AI助手。请以自然、友好的方式回复用户的消息。

对话风格指导：
- 使用非常简短的对话方式，尽量模仿真实手机聊天
- 每条消息不超过1-2句话，尽量保持简洁
- 将长回复拆分成多条非常短小的消息，就像真实人类在聊天软件中发消息一样
- 避免使用长句和复杂句式，使用简单直接的表达
- 当需要表达复杂想法时，将内容分成多个非常简短的消息，每条消息只表达一个简单观点

格式要求：
- 绝对不要使用Markdown语法，如双星号加粗、单星号斜体、反引号代码等
- 不要使用标题格式如#或##
- 列表项直接使用数字或文字开头，不要使用特殊符号如-或*
- 当需要列举多个要点时，直接使用“1.”“2.”等编号，不要使用特殊格式
- 尽量使用简单的纯文本格式，就像在手机聊天软件中发送消息一样`;
    }

    // 我们已经禁用了聊天回复中的情绪分析功能
    // 情绪分析将完全由专门的云函数 @cloudfunctions\analysis/ 处理
    // 因此这里不再添加情绪分析相关指令
    if (includeEmotionAnalysis) {
      // 不再添加情绪分析相关指令，但保留条件分支以保持代码结构完整
      console.log('情绪分析功能已禁用，使用专门的云函数处理');
    }
    // 结束情绪分析相关代码

    // 构建消息数组
    const messages = [
      {
        role: 'system',
        content: systemPrompt
      }
    ];

    // 添加历史消息（最多10条，避免超出token限制）
    if (Array.isArray(history) && history.length > 0) {
      const recentHistory = history.slice(-10);
      recentHistory.forEach(msg => {
        if (msg.role && msg.content) {
          messages.push({
            role: msg.role === 'user' ? 'user' : 'assistant',
            content: msg.content
          });
        }
      });
    }

    // 添加当前用户消息
    messages.push({
      role: 'user',
      content: userMessage
    });

    console.log('发送到智谱AI的消息:', JSON.stringify(messages, null, 2));

    // 调用智谱AI API
    const response = await axios.post(`${API_BASE_URL}/chat/completions`, {
      model: GLM_4_FLASH,
      messages: messages,
      temperature: 0.7, // 适当的温度，使回复更自然
      stream: false // 不使用流式输出
    }, {
      headers: getAuthHeaders()
    });

    // 解析API响应
    if (response.data && response.data.choices && response.data.choices.length > 0) {
      const content = response.data.choices[0].message.content;

      // 我们已经禁用了聊天回复中的情绪分析功能
      // 情绪分析将完全由专门的云函数 @cloudfunctions\analysis/ 处理
      const aiReply = content;
      const emotionAnalysis = null;

      if (includeEmotionAnalysis) {
        // 不再处理情绪分析，但保留条件分支以保持代码结构完整
        console.log('情绪分析功能已禁用，使用专门的云函数处理');
      }

      return {
        success: true,
        reply: aiReply,
        emotionAnalysis: emotionAnalysis,
        usage: response.data.usage || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
      };
    } else {
      return {
        success: false,
        error: '智谱AI返回的回复为空'
      };
    }
  } catch (error) {
    console.error('智谱AI聊天回复生成失败:', error);
    return {
      success: false,
      error: error.message || '聊天回复生成失败'
    };
  }
}

// 导出模块
module.exports = {
  generateChatReply
};

*#*#*end*#*#*

*#*#*cloudfunctions\chat\geminiModel.js*#*#*begin*#*#*
/**
 * Google Gemini API 模块
 * 提供基于Google Gemini的聊天功能
 *
 * @architecture 该模块实现了与Google Gemini API的集成，作为智谱AI的替代选项
 * @dependency httpRequest 云函数用于发送HTTP请求
 * @history 2025-05-01 初始版本
 */

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// Gemini API配置
// 注意：实际使用时应从环境变量或安全配置中读取API密钥，而不是硬编码
const API_KEY = process.env.GEMINI_API_KEY || ''; // 从环境变量获取API密钥
const API_BASE_URL = 'https://apiv2.aliyahzombie.top';

// 模型配置
const GEMINI_PRO = 'gemini-2.5-flash-preview-04-17'; // 默认模型
const GEMINI_FLASH = 'gemini-2.5-flash-preview-04-17'; // 快速版本

/**
 * 延迟函数
 * @param {number} ms 延迟毫秒数
 * @returns {Promise} 延迟Promise
 */
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * 调用Google Gemini API
 * @param {Object} params 请求参数
 * @param {number} retryCount 重试次数，默认为3
 * @param {number} retryDelay 重试延迟，默认为1000ms
 * @returns {Promise<Object>} API响应
 */
async function callGeminiAPI(params, retryCount = 3, retryDelay = 1000) {
  try {
    // 验证API密钥
    if (!API_KEY) {
      console.error('未设置GEMINI_API_KEY环境变量');
      throw new Error('Gemini API密钥未配置');
    }

    // 构建请求URL
    // 使用正确的API端点，根据参考文档中的示例
    const url = `${API_BASE_URL}/v1beta/models/${params.model || GEMINI_PRO}:generateContent?key=${API_KEY}`;

    console.log('API URL:', url);

    // 构建请求体，根据参考文档中的示例
    const body = JSON.stringify({
      contents: params.contents,
      generationConfig: {
        temperature: params.temperature || 0.7,
        topP: params.topP || 0.8,
        topK: params.topK || 40,
        maxOutputTokens: params.maxOutputTokens || 2048
      }
    });

    if (isDev) {
      console.log('调用Gemini API, 请求体:', body);
    }

    // 使用axios直接发送请求
    const axios = require('axios');

    console.log('发送请求到:', url);

    try {
      const response = await axios({
        method: 'POST',
        url: url,
        headers: {
          'Content-Type': 'application/json'
        },
        data: JSON.parse(body) // 将JSON字符串转换为对象
      });

      // 检查响应状态
      if (response.status !== 200) {
        console.error('Gemini API返回错误状态码:', response.status);
        throw new Error(`Gemini API调用失败: 状态码 ${response.status}`);
      }

      // 获取响应数据
      const result = response.data;

      return result;
    } catch (error) {
      // 处理429错误（请求过多）
      if (error.response && error.response.status === 429 && retryCount > 0) {
        console.log(`遇到429错误，等待${retryDelay}ms后重试，剩余重试次数: ${retryCount-1}`);

        // 等待一段时间后重试
        await delay(retryDelay);

        // 递归调用自身，减少重试次数，增加延迟时间
        return callGeminiAPI(params, retryCount - 1, retryDelay * 2);
      }

      // 其他错误或重试次数用完，抛出异常
      throw error;
    }

  } catch (error) {
    console.error('调用Gemini API失败:', error);
    throw error;
  }
}

/**
 * 将消息历史转换为Gemini API格式
 * @param {Array} history 历史消息
 * @returns {Array} Gemini格式的消息历史
 */
function formatMessagesForGemini(history) {
  if (!history || !Array.isArray(history)) {
    return [];
  }

  const formattedMessages = [];
  let currentRole = null;
  let currentParts = [];

  // 处理每条消息
  for (const message of history) {
    const role = message.role === 'assistant' ? 'model' : 'user';

    // 如果角色变化，创建新的消息对象
    if (role !== currentRole && currentParts.length > 0) {
      formattedMessages.push({
        role: currentRole,
        parts: [...currentParts]
      });
      currentParts = [];
    }

    currentRole = role;
    currentParts.push({ text: message.content });
  }

  // 添加最后一组消息
  if (currentParts.length > 0) {
    formattedMessages.push({
      role: currentRole,
      parts: [...currentParts]
    });
  }

  return formattedMessages;
}

/**
 * 使用Gemini模型生成聊天回复
 * @param {string} userMessage 用户消息
 * @param {Array} history 历史消息记录
 * @param {Object} roleInfo 角色信息
 * @param {boolean} includeEmotionAnalysis 是否包含情绪分析
 * @param {string} customSystemPrompt 自定义系统提示词
 * @returns {Promise<Object>} 生成的回复
 */
async function generateChatReply(userMessage, history = [], roleInfo = {}, includeEmotionAnalysis = false, customSystemPrompt = null) {
  try {
    // 验证参数
    if (!userMessage || typeof userMessage !== 'string' || userMessage.trim() === '') {
      return {
        success: false,
        error: '无效的用户消息'
      };
    }

    // 构建系统提示词
    let systemPrompt = '';
    if (customSystemPrompt) {
      systemPrompt = customSystemPrompt;
    } else if (roleInfo && roleInfo.prompt) {
      systemPrompt = roleInfo.prompt;
    } else {
      systemPrompt = '你是一个友好的AI助手，能够提供有用的信息和支持。';
    }

    // 格式化历史消息
    const formattedHistory = formatMessagesForGemini(history);

    // 构建请求内容
    const contents = [
      {
        role: 'user',
        parts: [{ text: systemPrompt }]
      }
    ];

    // 添加历史消息
    formattedHistory.forEach(msg => {
      contents.push(msg);
    });

    // 添加当前用户消息
    contents.push({
      role: 'user',
      parts: [{ text: userMessage }]
    });

    if (isDev) {
      console.log('发送到Gemini的消息:', JSON.stringify(contents, null, 2));
    }

    // 调用Gemini API
    const response = await callGeminiAPI({
      model: GEMINI_PRO, // 使用gemini-2.5-flash-preview-04-17模型
      contents: contents,
      temperature: 0.7, // 适当的温度，使回复更自然
      maxOutputTokens: 2048
    });

    // 解析API响应
    if (response && response.candidates && response.candidates.length > 0) {
      const candidate = response.candidates[0];

      if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
        const content = candidate.content.parts[0].text;

        // 我们已经禁用了聊天回复中的情绪分析功能
        // 情绪分析将完全由专门的云函数 @cloudfunctions\analysis/ 处理
        const aiReply = content;
        const emotionAnalysis = null;

        if (includeEmotionAnalysis) {
          // 不再处理情绪分析，但保留条件分支以保持代码结构完整
          console.log('情绪分析功能已禁用，使用专门的云函数处理');
        }

        return {
          success: true,
          reply: aiReply,
          emotionAnalysis: emotionAnalysis,
          usage: response.usageMetadata || { promptTokenCount: 0, candidatesTokenCount: 0, totalTokenCount: 0 }
        };
      }
    }

    return {
      success: false,
      error: 'Gemini API返回的回复为空'
    };
  } catch (error) {
    console.error('Gemini聊天回复生成失败:', error);
    return {
      success: false,
      error: error.message || '聊天回复生成失败'
    };
  }
}

// 导出模块
module.exports = {
  generateChatReply,
  callGeminiAPI,
  formatMessagesForGemini,
  GEMINI_PRO,
  GEMINI_FLASH
};

*#*#*end*#*#*

*#*#*cloudfunctions\chat\index.js*#*#*begin*#*#*
// chat 云函数 index.js
/**
 * 聊天相关功能云函数
 * 提供聊天消息发送、历史记录获取、AI回复生成等功能
 * 集成智谱AI (GLM-4-Flash) 和 Google Gemini 生成回复
 *
 * @history 2025-05-01 添加Google Gemini API支持
 */
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();
const _ = db.command;

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 导入统一AI模型服务
const aiModelService = require('./aiModelService');

/**
 * 将AI回复分段，使其更像真实聊天
 * @param {string} message AI回复的完整消息
 * @returns {Array} 分段后的消息数组
 */
function splitMessage(message) {
  if (!message || typeof message !== 'string') {
    return [message];
  }

  // 先处理Markdown语法，移除加粗等标记
  const cleanMessage = message.replace(/\*\*([^*]+)\*\*/g, '$1');

  // 定义最大段落长度 - 增加到150个字符，使分段更自然
  const MAX_SEGMENT_LENGTH = 150;

  // 定义最小段落长度 - 避免过短的段落
  const MIN_SEGMENT_LENGTH = 20;

  // 检查消息是否包含列表或编号内容
  const hasListOrNumbering = /\n\s*[-*]\s|\n\s*\d+\.\s/.test(cleanMessage);

  // 如果包含列表或编号，使用更保守的分段方式，保持列表的完整性
  if (hasListOrNumbering) {
    // 尝试按空行分段，保持列表的完整性
    let segments = cleanMessage.split(/\n\s*\n/);
    segments = segments.filter(segment => segment.trim().length > 0);

    // 如果只有一个段落且过长，尝试在列表项之间分割
    if (segments.length === 1 && segments[0].length > MAX_SEGMENT_LENGTH * 2) {
      // 匹配列表项的开头（如"1. "或"- "）
      const listItemRegex = /\n(?=\s*(?:[-*]|\d+\.)\s)/;
      segments = segments[0].split(listItemRegex);
      segments = segments.filter(segment => segment.trim().length > 0);
    }

    // 确保列表项不会被过度分割
    return segments;
  }

  // 如果不包含列表或编号，使用更智能的分段方式

  // 1. 首先尝试按自然段落分割（空行分隔）
  let segments = cleanMessage.split(/\n\s*\n/);
  segments = segments.filter(segment => segment.trim().length > 0);

  // 2. 如果没有自然段落或只有一个段落，检查是否有换行符
  if (segments.length === 1 && segments[0].includes('\n')) {
    // 按换行符分割，但保持语义完整性
    const lines = segments[0].split(/\n/);

    // 重新组合短行，避免过度分段
    segments = [];
    let currentSegment = '';

    for (const line of lines) {
      if (line.trim().length === 0) continue;

      // 如果当前段落加上新行仍然在合理范围内，则合并
      if (currentSegment.length + line.length < MAX_SEGMENT_LENGTH) {
        currentSegment += (currentSegment ? '\n' : '') + line;
      } else {
        // 否则保存当前段落并开始新段落
        if (currentSegment.length > 0) {
          segments.push(currentSegment.trim());
        }
        currentSegment = line;
      }
    }

    // 添加最后一个段落
    if (currentSegment.length > 0) {
      segments.push(currentSegment.trim());
    }
  }

  // 3. 处理过长的段落，按句子分割
  const sentenceSegments = [];
  for (const segment of segments) {
    if (segment.length > MAX_SEGMENT_LENGTH) {
      // 改进的句子分割正则表达式，更好地处理中文和英文句子
      // 匹配中文句号、问号、感叹号，以及英文句号、问号、感叹号后跟空格或行尾的情况
      const sentences = segment.split(/(?<=[。！？.!?])(?:\s|$)/);

      // 过滤空句子并添加到结果中
      const filteredSentences = sentences.filter(s => s.trim().length > 0);

      // 合并过短的句子，避免过度分段
      let currentSentence = '';
      for (const sentence of filteredSentences) {
        if (sentence.length < MIN_SEGMENT_LENGTH && currentSentence.length + sentence.length <= MAX_SEGMENT_LENGTH) {
          // 如果句子很短且合并后不超过最大长度，则合并
          currentSentence += (currentSentence ? ' ' : '') + sentence;
        } else if (currentSentence.length + sentence.length <= MAX_SEGMENT_LENGTH) {
          // 如果合并后不超过最大长度，则合并
          currentSentence += (currentSentence ? ' ' : '') + sentence;
        } else {
          // 否则保存当前句子并开始新句子
          if (currentSentence.length > 0) {
            sentenceSegments.push(currentSentence.trim());
          }
          currentSentence = sentence;
        }
      }

      // 添加最后一个句子
      if (currentSentence.length > 0) {
        sentenceSegments.push(currentSentence.trim());
      }
    } else {
      sentenceSegments.push(segment.trim());
    }
  }

  // 4. 处理仍然过长的句子，按次要标点分割
  const result = [];
  for (const segment of sentenceSegments) {
    if (segment.length > MAX_SEGMENT_LENGTH) {
      // 改进的次要标点分割正则表达式，更好地处理中文和英文
      // 匹配中文逗号、分号、顿号，以及英文逗号、分号后跟空格或行尾的情况
      const subSegments = segment.split(/(?<=[，；、,;])(?:\s|$)/);

      // 合并短分段，避免过度分割
      let currentSegment = '';
      for (const subSegment of subSegments) {
        if (subSegment.trim().length === 0) continue;

        if (currentSegment.length + subSegment.length > MAX_SEGMENT_LENGTH) {
          // 如果合并后超过最大长度，保存当前段落并开始新段落
          if (currentSegment.length > 0) {
            result.push(currentSegment.trim());
            currentSegment = '';
          }

          // 如果单个子段落仍然过长，按语义边界尝试分割
          if (subSegment.length > MAX_SEGMENT_LENGTH) {
            // 尝试在空格处分割（适用于英文）
            if (subSegment.includes(' ')) {
              const words = subSegment.split(' ');
              let tempSegment = '';

              for (const word of words) {
                if (tempSegment.length + word.length + 1 <= MAX_SEGMENT_LENGTH) {
                  tempSegment += (tempSegment ? ' ' : '') + word;
                } else {
                  result.push(tempSegment.trim());
                  tempSegment = word;
                }
              }

              if (tempSegment.length > 0) {
                currentSegment = tempSegment;
              }
            } else {
              // 如果没有空格（可能是中文），按字符数强制分割，但尽量在词语边界
              for (let i = 0; i < subSegment.length; i += MAX_SEGMENT_LENGTH) {
                result.push(subSegment.substr(i, MAX_SEGMENT_LENGTH).trim());
              }
            }
          } else {
            currentSegment = subSegment;
          }
        } else {
          // 如果合并后不超过最大长度，则合并
          currentSegment += (currentSegment ? ' ' : '') + subSegment;
        }
      }

      // 添加最后一个段落
      if (currentSegment.length > 0) {
        result.push(currentSegment.trim());
      }
    } else if (segment.trim()) {
      result.push(segment.trim());
    }
  }

  // 5. 最终处理：合并过短的段落，使分段更自然
  const finalResult = [];
  let currentSegment = '';

  for (const segment of result) {
    // 如果段落很短且合并后不超过最大长度，则合并
    if (segment.length < MIN_SEGMENT_LENGTH && currentSegment.length + segment.length + 1 <= MAX_SEGMENT_LENGTH) {
      currentSegment += (currentSegment ? ' ' : '') + segment;
    } else if (currentSegment.length + segment.length + 1 <= MAX_SEGMENT_LENGTH) {
      // 如果合并后不超过最大长度，则合并
      currentSegment += (currentSegment ? ' ' : '') + segment;
    } else {
      // 否则保存当前段落并开始新段落
      if (currentSegment.length > 0) {
        finalResult.push(currentSegment);
      }
      currentSegment = segment;
    }
  }

  // 添加最后一个段落
  if (currentSegment.length > 0) {
    finalResult.push(currentSegment);
  }

  // 如果分段后为空，则返回原始消息
  if (finalResult.length === 0) {
    return [message];
  }

  // 确保每个段落不超过最大长度
  return finalResult.map(segment => segment.length <= MAX_SEGMENT_LENGTH ?
    segment : segment.substring(0, MAX_SEGMENT_LENGTH));
}

// 子功能：保存聊天记录
async function saveChatHistory(event, context) {
  const { OPENID } = cloud.getWXContext(); // 获取用户的openid

  if (isDev) {
    console.log('执行 saveChatHistory 功能, 参数:', event);
    console.log('OPENID:', OPENID);
  }

  try {
    // 获取请求参数
    const { chatData, messages } = event;

    if (isDev) {
      console.log('接收到的数据:', {
        chatDataKeys: chatData ? Object.keys(chatData) : null,
        messagesCount: messages ? messages.length : 0
      });
    }

    // 确保chatData包含必要的字段
    if (!chatData || !chatData.roleId) {
      console.error('缺少必要的聊天数据');
      return {
        success: false,
        error: '缺少必要的聊天数据'
      };
    }

    // 添加openId字段
    chatData.openId = chatData.openId || OPENID;

    // 添加时间戳
    chatData.updateTime = db.serverDate();
    if (!chatData.createTime) {
      chatData.createTime = db.serverDate();
    }

    if (isDev) {
      console.log('处理后的chatData:', {
        roleId: chatData.roleId,
        userId: chatData.userId,
        openId: chatData.openId,
        messageCount: chatData.messageCount
      });
    }

    let chatId;

    // 检查是否已存在相同的聊天记录
    if (isDev) {
      console.log('查询现有聊天记录...');
    }
    const queryResult = await db.collection('chats')
      .where({
        roleId: chatData.roleId,
        userId: chatData.userId || '',
        openId: chatData.openId
      })
      .get()
      .catch(err => {
        console.error('查询聊天记录失败:', err.message || err);
        return { data: [] };
      });

    const { data } = queryResult;
    if (isDev) {
      console.log('查询结果:', { found: data && data.length > 0 });
    }

    if (data && data.length > 0) {
      // 更新现有聊天记录
      chatId = data[0]._id;
      if (isDev) {
        console.log('更新现有聊天记录, chatId:', chatId);
      }

      const updateData = {
        messageCount: chatData.messageCount || 0,
        lastMessage: chatData.lastMessage || '',
        emotionAnalysis: chatData.emotionAnalysis || {
          type: 'neutral',
          intensity: 0.5,
          suggestions: []
        },
        last_message_time: chatData.last_message_time || chatData.updateTime, // 添加last_message_time字段
        updateTime: chatData.updateTime
      };

      if (isDev) {
        console.log('更新数据:', updateData);
      }

      await db.collection('chats').doc(chatId).update({
        data: updateData
      }).catch(err => {
        console.error('更新聊天记录失败:', err.message || err);
        throw err;
      });

      if (isDev) {
        console.log('聊天记录更新成功');
      }
    } else {
      // 创建新的聊天记录
      if (isDev) {
        console.log('创建新的聊天记录');
      }
      const result = await db.collection('chats').add({
        data: chatData
      }).catch(err => {
        console.error('创建聊天记录失败:', err.message || err);
        throw err;
      });

      chatId = result._id;
      if (isDev) {
        console.log('新聊天记录创建成功, chatId:', chatId);
      }
    }

    // 如果提供了消息数组，保存到messages集合
    if (messages && messages.length > 0) {
      if (isDev) {
        console.log(`开始保存 ${messages.length} 条消息到messages集合...`);
      }

      // 批量添加消息
      const messagePromises = messages.map((msg, index) => {
        // 跳过已有ID的消息
        if (msg._id) {
          if (isDev) {
            console.log(`消息 ${index} 已有ID, 跳过`);
          }
          return Promise.resolve();
        }

        // 添加必要的字段
        msg.chatId = chatId;
        msg.openId = OPENID;
        msg.createTime = db.serverDate();

        // 保存消息
        return db.collection('messages').add({
          data: msg
        }).then(res => {
          if (isDev) {
            console.log(`消息 ${index} 保存成功, _id: ${res._id}`);
          }
          return res;
        }).catch(err => {
          console.error(`消息 ${index} 保存失败:`, err.message || err);
          throw err;
        });
      });

      // 等待所有消息保存完成
      await Promise.all(messagePromises);
      if (isDev) {
        console.log('所有消息保存完成');
      }
    } else {
      if (isDev) {
        console.log('没有消息需要保存');
      }
    }

    // 判断是否是新对话
    const isNewChat = !data || data.length === 0;
    if (isDev) {
      console.log('执行成功, 返回 chatId:', chatId, ', 是否新对话:', isNewChat);
    }

    // 如果是新对话，直接在云函数中更新用户统计
    if (isNewChat) {
      try {
        if (isDev) {
          console.log('在云函数中更新用户对话次数');
        }
        // 获取用户统计信息
        const userStatsResult = await db.collection('user_stats')
          .where({ user_id: chatData.userId })
          .get();

        if (userStatsResult.data && userStatsResult.data.length > 0) {
          const userStats = userStatsResult.data[0];

          // 更新对话次数
          await db.collection('user_stats').doc(userStats._id).update({
            data: {
              chat_count: _.inc(1),
              updated_at: db.serverDate()
            }
          });

          if (isDev) {
            console.log('用户对话次数更新成功');
          }
        } else {
          if (isDev) {
            console.log('未找到用户统计信息，无法更新对话次数');
          }
        }
      } catch (statsErr) {
        console.error('更新用户对话次数失败:', statsErr.message || statsErr);
        // 不影响主流程
      }
    }

    return {
      success: true,
      chatId,
      isNewChat
    };
  } catch (error) {
    console.error('保存聊天记录失败:', error.message || error);
    return {
      success: false,
      error: error.message || error
    };
  }
}

// 子功能：获取聊天记录
async function getChatHistory(event, context) {
  const { OPENID } = cloud.getWXContext(); // 获取用户的openid

  if (isDev) {
    console.log('执行 getChatHistory 功能, 参数:', event);
    console.log('OPENID:', OPENID);
  }

  try {
    // 获取请求参数
    const { userId, roleId } = event;

    // 构建查询条件
    const query = {};

    // 如果提供了userId，添加到查询条件
    if (userId) {
      query.userId = userId;
      if (isDev) {
        console.log('使用userId查询:', userId);
      }
    } else {
      // 如果没有提供userId，使用openid
      query.openId = OPENID;
      if (isDev) {
        console.log('使用openId查询:', OPENID);
      }
    }

    // 如果提供了roleId，添加到查询条件
    if (roleId) {
      query.roleId = roleId;
      if (isDev) {
        console.log('使用roleId查询:', roleId);
      }
    }

    if (isDev) {
      console.log('最终查询条件:', query);
    }

    // 查询chats集合
    let chatData = [];
    try {
      if (isDev) {
        console.log('开始查询chats集合...');
      }
      const result = await db.collection('chats')
        .where(query)
        .orderBy('updateTime', 'desc')
        .limit(1)
        .get();

      if (isDev) {
        console.log('chats查询结果:', result);
      }

      if (result.data && result.data.length > 0) {
        chatData = result.data;
        if (isDev) {
          console.log('找到聊天记录:', chatData[0]._id);
        }
      } else {
        if (isDev) {
          console.log('未找到聊天记录');
        }
      }
    } catch (chatErr) {
      console.error('查询chats集合失败:', chatErr.message || chatErr);
    }

    // 如果找到了聊天记录，但没有消息数组，尝试从messages集合获取消息
    if (chatData.length > 0 && (!chatData[0].messages || chatData[0].messages.length === 0)) {
      try {
        const chatId = chatData[0]._id;
        if (isDev) {
          console.log('开始从messages集合获取消息, chatId:', chatId);
        }

        const messagesResult = await db.collection('messages')
          .where({ chatId })
          .orderBy('timestamp', 'asc')
          .get();

        if (isDev) {
          console.log('messages查询结果:', messagesResult);
        }

        if (messagesResult.data && messagesResult.data.length > 0) {
          // 将消息添加到聊天记录中
          chatData[0].messages = messagesResult.data;
          if (isDev) {
            console.log(`找到 ${messagesResult.data.length} 条消息`);
          }
        } else {
          if (isDev) {
            console.log('未找到消息记录');
          }
        }
      } catch (msgErr) {
        console.error('查询messages集合失败:', msgErr.message || msgErr);
      }
    } else if (chatData.length > 0 && chatData[0].messages && chatData[0].messages.length > 0) {
      if (isDev) {
        console.log(`聊天记录中已包含 ${chatData[0].messages.length} 条消息`);
      }
    }

    if (isDev) {
      console.log('功能执行成功, 返回数据长度:', chatData.length);
    }

    return {
      success: true,
      data: chatData
    };
  } catch (error) {
    console.error('获取聊天记录失败:', error.message || error);
    return {
      success: false,
      error: error.message || error
    };
  }
}

// 子功能：生成AI回复
async function generateAIReply(event, context) {
  console.log('执行 generateAIReply 功能, 参数:', event);

  try {
    const {
      message,
      history,
      roleInfo,
      includeEmotionAnalysis = false,
      systemPrompt = null,
      modelType = 'gemini', // 默认使用Google Gemini
      modelName = null // 具体模型名称，如果为null则使用默认模型
    } = event;

    // 验证参数
    if (!message || typeof message !== 'string' || message.trim() === '') {
      return {
        success: false,
        error: '无效的消息内容'
      };
    }

    if (!roleInfo || !roleInfo.prompt) {
      console.warn('角色信息或prompt缺失, 将使用默认提示词');
    }

    // 将modelType转换为平台键名
    const platformKey = modelType.toUpperCase();

    console.log(`使用${aiModelService.MODEL_PLATFORMS[platformKey]?.name || modelType}模型生成回复${modelName ? ` (${modelName})` : ''}`);

    // 使用统一AI模型服务生成回复
    const aiResult = await aiModelService.generateChatReply(
      message,
      history,
      roleInfo,
      includeEmotionAnalysis,
      systemPrompt, // 传递自定义系统提示词（包含用户画像）
      {
        platform: platformKey,
        model: modelName
      }
    );

    if (!aiResult.success) {
      throw new Error(aiResult.error || 'AI回复生成失败');
    }

    // 分段处理AI回复
    const segments = splitMessage(aiResult.reply);
    console.log('分段后的AI回复:', segments);

    // 返回生成的回复
    return {
      success: true,
      content: aiResult.reply,  // 保留完整回复用于存储
      segments: segments,       // 添加分段数组
      emotionAnalysis: aiResult.emotionAnalysis,
      usage: aiResult.usage,
      modelType: modelType,     // 添加使用的模型类型
      timestamp: Date.now()
    };
  } catch (error) {
    console.error('生成AI回复失败:', error);
    return {
      success: false,
      error: error.message || '生成回复失败'
    };
  }
}

// 子功能：发送消息
async function sendMessage(event, context) {
  const { OPENID } = cloud.getWXContext(); // 获取用户的openid

  console.log('执行 sendMessage 功能, 参数:', event);
  console.log('OPENID:', OPENID);

  try {
    // 获取请求参数
    const { chatId, roleId, content, systemPrompt, modelType = 'gemini', modelName = null } = event;

    // 如果提供了自定义系统提示词（包含用户画像）
    if (systemPrompt) {
      console.log('收到自定义系统提示词（包含用户画像）');
    }

    // 记录使用的模型类型
    console.log(`使用模型类型: ${modelType}`);


    // 验证参数
    if (!roleId) {
      return {
        success: false,
        error: '角色ID不能为空'
      };
    }

    if (!content || typeof content !== 'string' || content.trim() === '') {
      return {
        success: false,
        error: '消息内容不能为空'
      };
    }

    // 获取角色信息
    console.log('获取角色信息, roleId:', roleId);
    const roleResult = await cloud.callFunction({
      name: 'roles',
      data: {
        action: 'getRoleDetail',
        roleId: roleId
      }
    });

    if (!roleResult.result || !roleResult.result.success) {
      throw new Error('获取角色信息失败');
    }

    const roleInfo = roleResult.result.role;
    console.log('角色信息:', {
      name: roleInfo.name,
      hasPrompt: !!roleInfo.prompt
    });

    // 查询或创建聊天会话
    let currentChatId = chatId;
    let isNewChat = false;

    if (!currentChatId) {
      // 查询是否存在与该角色的聊天会话
      console.log('查询现有聊天会话...');
      const chatResult = await db.collection('chats')
        .where({
          roleId: roleId,
          openId: OPENID
        })
        .orderBy('updateTime', 'desc')
        .limit(1)
        .get();

      if (chatResult.data && chatResult.data.length > 0) {
        // 使用现有会话
        currentChatId = chatResult.data[0]._id;
        console.log('使用现有聊天会话, chatId:', currentChatId);
      } else {
        // 创建新会话
        console.log('创建新聊天会话...');
        const newChat = {
          roleId: roleId,
          roleName: roleInfo.name,
          openId: OPENID,
          messageCount: 0,
          createTime: db.serverDate(),
          last_message_time: db.serverDate(), // 添加last_message_time字段
          updateTime: db.serverDate()
        };

        const addResult = await db.collection('chats').add({
          data: newChat
        });

        currentChatId = addResult._id;
        isNewChat = true;
        console.log('新聊天会话创建成功, chatId:', currentChatId);

        // 更新用户统计
        try {
          await updateUserStats(OPENID, roleId);
        } catch (statsErr) {
          console.error('更新用户统计失败:', statsErr);
          // 不影响主流程
        }
      }
    }

    // 获取历史消息（最近10条）
    console.log('获取历史消息, chatId:', currentChatId);
    const historyResult = await db.collection('messages')
      .where({ chatId: currentChatId })
      .orderBy('createTime', 'desc')
      .limit(10)
      .get();

    // 将消息转换为智谱AI所需的格式
    const historyMessages = [];
    if (historyResult.data && historyResult.data.length > 0) {
      // 将消息按时间升序排序
      const sortedMessages = historyResult.data.sort((a, b) => {
        return new Date(a.createTime) - new Date(b.createTime);
      });

      // 转换为智谱AI格式
      sortedMessages.forEach(msg => {
        historyMessages.push({
          role: msg.sender_type === 'user' ? 'user' : 'assistant',
          content: msg.content
        });
      });
    }

    // 保存用户消息
    console.log('保存用户消息...');
    const userMessage = {
      chatId: currentChatId,
      roleId: roleId,
      openId: OPENID,
      content: content,
      sender_type: 'user',
      createTime: db.serverDate(),
      status: 'sent'
    };

    const userMsgResult = await db.collection('messages').add({
      data: userMessage
    });

    const userMessageId = userMsgResult._id;
    console.log('用户消息保存成功, messageId:', userMessageId);

    // 更新会话信息
    await db.collection('chats').doc(currentChatId).update({
      data: {
        messageCount: _.inc(1),
        lastMessage: content,
        last_message_time: db.serverDate(), // 添加last_message_time字段
        updateTime: db.serverDate()
      }
    });

    // 生成AI回复
    console.log('生成AI回复...');
    const aiReplyResult = await generateAIReply({
      message: content,
      history: historyMessages,
      roleInfo: roleInfo,
      includeEmotionAnalysis: false,
      systemPrompt: systemPrompt, // 传递自定义系统提示词（包含用户画像）
      modelType: modelType, // 传递模型类型
      modelName: modelName // 传递具体模型名称
    });

    if (!aiReplyResult.success) {
      throw new Error(aiReplyResult.error || 'AI回复生成失败');
    }

    // 获取分段消息
    const segments = aiReplyResult.segments || [aiReplyResult.content];
    const aiMessages = [];

    console.log(`开始保存 ${segments.length} 条分段AI回复...`);

    // 保存每个分段消息
    let firstMessageId = null;

    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];

      // 创建消息对象
      const aiMessage = {
        chatId: currentChatId,
        roleId: roleId,
        openId: OPENID,
        content: segment,
        sender_type: 'ai',
        createTime: db.serverDate(),
        status: 'sent',
        isSegment: true,           // 标记为分段消息
        segmentIndex: i,           // 分段索引
        totalSegments: segments.length, // 总分段数
        originalMessageId: firstMessageId // 关联到第一条消息
      };

      // 保存消息
      const aiMsgResult = await db.collection('messages').add({
        data: aiMessage
      });

      const aiMessageId = aiMsgResult._id;
      console.log(`分段AI回复 ${i+1}/${segments.length} 保存成功, messageId:`, aiMessageId);

      // 记录第一条消息的ID
      if (i === 0) {
        firstMessageId = aiMessageId;
        // 更新第一条消息的originalMessageId为自身
        await db.collection('messages').doc(aiMessageId).update({
          data: {
            originalMessageId: aiMessageId
          }
        });
      }

      // 获取完整的消息对象（包含_id等字段）
      const completeMessage = await db.collection('messages').doc(aiMessageId).get();
      aiMessages.push(completeMessage.data);

      // 更新会话信息
      await db.collection('chats').doc(currentChatId).update({
        data: {
          messageCount: _.inc(1),
          lastMessage: segment,
          last_message_time: db.serverDate(), // 添加last_message_time字段
          updateTime: db.serverDate()
        }
      });
    }

    // 我们已经禁用了聊天回复中的情绪分析，所以这里不再处理情绪分析结果
    // 情绪分析将由专门的云函数 @cloudfunctions\analysis/ 处理
    let emotionAnalysis = null;

    // 构建返回结果
    // 获取完整的消息对象（包含_id等字段）
    const userMessageComplete = await db.collection('messages').doc(userMessageId).get();

    // 注意：现在返回的是所有分段消息数组，而不是单个消息
    return {
      success: true,
      chatId: currentChatId,
      isNewChat: isNewChat,
      message: userMessageComplete.data,
      aiMessages: aiMessages,      // 返回所有分段消息
      emotionAnalysis: emotionAnalysis
    };
  } catch (error) {
    console.error('发送消息失败:', error);
    return {
      success: false,
      error: error.message || '发送消息失败'
    };
  }
}

// 子功能：删除消息
async function deleteMessage(event, context) {
  const { OPENID } = cloud.getWXContext();

  console.log('执行 deleteMessage 功能, 参数:', event);

  try {
    const { messageId } = event;

    if (!messageId) {
      return {
        success: false,
        error: '消息ID不能为空'
      };
    }

    // 获取消息信息
    const messageResult = await db.collection('messages').doc(messageId).get();

    if (!messageResult.data) {
      return {
        success: false,
        error: '消息不存在'
      };
    }

    const message = messageResult.data;

    // 验证消息所有权
    if (message.openId !== OPENID) {
      return {
        success: false,
        error: '无权删除该消息'
      };
    }

    // 删除消息
    await db.collection('messages').doc(messageId).remove();

    // 更新会话消息计数
    await db.collection('chats').doc(message.chatId).update({
      data: {
        messageCount: _.inc(-1),
        updateTime: db.serverDate()
      }
    });

    return {
      success: true
    };
  } catch (error) {
    console.error('删除消息失败:', error);
    return {
      success: false,
      error: error.message || '删除消息失败'
    };
  }
}

// 子功能：清空聊天记录
async function clearChatHistory(event, context) {
  const { OPENID } = cloud.getWXContext();

  console.log('执行 clearChatHistory 功能, 参数:', event);

  try {
    const { chatId } = event;

    if (!chatId) {
      return {
        success: false,
        error: '聊天ID不能为空'
      };
    }

    // 获取聊天信息
    const chatResult = await db.collection('chats').doc(chatId).get();

    if (!chatResult.data) {
      return {
        success: false,
        error: '聊天不存在'
      };
    }

    const chat = chatResult.data;

    // 验证聊天所有权
    if (chat.openId !== OPENID) {
      return {
        success: false,
        error: '无权清空该聊天记录'
      };
    }

    // 删除所有相关消息
    const deleteResult = await db.collection('messages').where({
      chatId: chatId
    }).remove();

    console.log('删除消息结果:', deleteResult);

    // 重置聊天信息
    await db.collection('chats').doc(chatId).update({
      data: {
        messageCount: 0,
        lastMessage: '',
        last_message_time: db.serverDate(), // 添加last_message_time字段
        updateTime: db.serverDate()
      }
    });

    return {
      success: true,
      deletedCount: deleteResult.stats.removed || 0
    };
  } catch (error) {
    console.error('清空聊天记录失败:', error);
    return {
      success: false,
      error: error.message || '清空聊天记录失败'
    };
  }
}

// 辅助功能：更新用户统计
async function updateUserStats(openId, roleId) {
  try {
    // 查询用户统计信息
    const userStatsResult = await db.collection('user_stats')
      .where({ openid: openId })
      .get();

    if (userStatsResult.data && userStatsResult.data.length > 0) {
      // 更新现有统计
      const userStats = userStatsResult.data[0];

      // 更新对话次数
      await db.collection('user_stats').doc(userStats._id).update({
        data: {
          chat_count: _.inc(1),
          updated_at: db.serverDate(),
          'favorite_roles': db.command.push({
            role_id: roleId,
            usage_count: 1,
            last_used: db.serverDate()
          })
        }
      });

      console.log('用户统计更新成功');
    } else {
      // 创建新的统计记录
      await db.collection('user_stats').add({
        data: {
          openid: openId,
          chat_count: 1,
          total_messages: 0,
          user_messages: 0,
          ai_messages: 0,
          emotion_records_count: 0,
          favorite_roles: [
            {
              role_id: roleId,
              usage_count: 1,
              last_used: db.serverDate()
            }
          ],
          created_at: db.serverDate(),
          updated_at: db.serverDate()
        }
      });

      console.log('用户统计创建成功');
    }

    // 更新角色使用统计
    await cloud.callFunction({
      name: 'roles',
      data: {
        action: 'updateRoleUsage',
        roleId: roleId
      }
    });

    return true;
  } catch (error) {
    console.error('更新用户统计失败:', error);
    throw error;
  }
}

// 子功能：检查聊天是否存在
async function checkChatExists(event, context) {
  const { OPENID } = cloud.getWXContext(); // 获取用户的openid

  console.log('执行 checkChatExists 功能, 参数:', event);
  console.log('OPENID:', OPENID);

  try {
    // 获取请求参数
    const { roleId } = event;

    if (!roleId) {
      return {
        success: false,
        error: '角色ID不能为空'
      };
    }

    // 查询是否存在与该角色的聊天会话
    console.log('查询现有聊天会话...');
    const chatResult = await db.collection('chats')
      .where({
        roleId: roleId,
        openId: OPENID
      })
      .orderBy('updateTime', 'desc')
      .limit(1)
      .get();

    if (chatResult.data && chatResult.data.length > 0) {
      // 存在聊天会话
      const chatId = chatResult.data[0]._id;
      console.log('找到现有聊天会话, chatId:', chatId);

      return {
        success: true,
        exists: true,
        chatId: chatId
      };
    } else {
      // 不存在聊天会话
      console.log('未找到与该角色的聊天会话');

      return {
        success: true,
        exists: false
      };
    }
  } catch (error) {
    console.error('检查聊天会话失败:', error);
    return {
      success: false,
      error: error.message || '检查聊天会话失败'
    };
  }
}

/**
 * 测试模型连接
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 测试结果
 */
async function testConnection(event, context) {
  try {
    // 获取请求参数
    const { modelType = 'gemini' } = event;

    console.log(`测试${modelType}模型连接...`);

    let result;

    // 将modelType转换为平台键名
    const platformKey = modelType.toUpperCase();

    console.log(`测试${aiModelService.MODEL_PLATFORMS[platformKey]?.name || modelType}连接`);

    // 使用统一AI模型服务测试连接
    result = await aiModelService.generateChatReply(
      "测试连接",
      [],
      { prompt: "这是一个测试连接的请求，请简短回复。" },
      false,
      null,
      { platform: platformKey }
    );

    if (result.success) {
      return {
        success: true,
        message: `${modelType}模型连接测试成功`,
        modelType: modelType,
        reply: result.reply
      };
    } else {
      return {
        success: false,
        error: result.error || `${modelType}模型连接测试失败`,
        modelType: modelType
      };
    }
  } catch (error) {
    console.error('测试连接失败:', error);
    return {
      success: false,
      error: error.message || '测试连接失败'
    };
  }
}

/**
 * 获取模型列表
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 模型列表
 */
async function getModelList(event) {
  try {
    // 获取请求参数
    const { modelType = 'gemini' } = event;

    console.log(`获取${modelType}模型列表...`);

    // 将modelType转换为平台键名
    const platformKey = modelType.toUpperCase();

    // 使用统一AI模型服务获取模型列表
    const models = await aiModelService.getAvailableModels(platformKey);

    return {
      success: true,
      models: models
    };
  } catch (error) {
    console.error('获取模型列表失败:', error);
    return {
      success: false,
      error: error.message || '获取模型列表失败'
    };
  }
}

// 主函数入口
exports.main = async (event, context) => {
  const { action } = event;

  console.log('chat 云函数入口, action:', action);

  switch (action) {
    // 原有功能（兼容旧版本）
    case 'save':
      return await saveChatHistory(event, context);
    case 'get':
      return await getChatHistory(event, context);
    case 'reply':
      return await generateAIReply(event, context);

    // 新增功能
    case 'sendMessage':
      return await sendMessage(event, context);
    case 'getChatHistory':
      return await getChatHistory(event, context);
    case 'saveChatHistory':
      return await saveChatHistory(event, context);
    case 'deleteMessage':
      return await deleteMessage(event, context);
    case 'clearChatHistory':
      return await clearChatHistory(event, context);
    case 'checkChatExists':
      return await checkChatExists(event, context);
    case 'testConnection':
      return await testConnection(event, context);
    case 'getModelList':
      return await getModelList(event);

    default:
      return { success: false, error: '未知操作' };
  }
};

*#*#*end*#*#*

*#*#*cloudfunctions\chat\package.json*#*#*begin*#*#*
{
  "name": "chat",
  "version": "1.0.0",
  "description": "聊天相关功能云函数",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "axios": "^1.6.2"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\clearDatabase\index.js*#*#*begin*#*#*
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV }) // 使用当前云环境

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 云函数入口函数
exports.main = async (event, context) => {
  const db = cloud.database()
  const _ = db.command

  try {
    // 要清理的集合
    const collectionsToClean = event.collections || [
      'messages',
      'chats',
      'emotionRecords',
      'roleUsage'
    ]

    // 不清理的集合（保留系统数据）
    const preserveCollections = [
      'roles',
      'sys_config',
      'dict_type',
      'dict_data',
      'emotion_practices'
    ]

    // 如果指定了 force 参数，则清理所有集合
    if (event.force) {
      collectionsToClean.push(...preserveCollections)
    }

    // 清理集合
    const results = {}

    // 处理每个要清理的集合
    for (const name of collectionsToClean) {
      try {
        // 获取集合中的文档数量
        const { total } = await db.collection(name).count()

        if (total > 0) {
          // 删除集合中的所有文档
          const { stats } = await db.collection(name).where({
            _id: _.exists(true)
          }).remove()

          results[name] = {
            status: 'cleaned',
            total,
            deleted: stats.removed || 0
          }
        } else {
          results[name] = {
            status: 'empty',
            total: 0
          }
        }
      } catch (e) {
        results[name] = {
          status: 'error',
          error: e.message || e
        }
      }
    }

    // 标记保留的集合
    for (const name of preserveCollections) {
      if (!collectionsToClean.includes(name)) {
        results[name] = {
          status: 'preserved'
        }
      }
    }

    return {
      success: true,
      results
    }
  } catch (error) {
    console.error('清理数据库失败:', error.message || error)
    return {
      success: false,
      error: error.message || error
    }
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\clearDatabase\package.json*#*#*begin*#*#*
{
    "name": "initDatabase",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "dependencies": {
      "wx-server-sdk": "latest"
    }
  }
*#*#*end*#*#*

*#*#*cloudfunctions\emotion\index.js*#*#*begin*#*#*
// emotion 云函数 index.js
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();
const _ = db.command;
const $ = db.command.aggregate;

/**
 * 获取情绪概览
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getEmotionOverview(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    
    // 获取最近一周的情绪记录
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    const emotionRecords = await db.collection('emotionRecords')
      .where({
        userId: userId,
        createTime: _.gte(oneWeekAgo)
      })
      .orderBy('createTime', 'desc')
      .get();
    
    // 处理情绪数据
    const emotionData = processEmotionData(emotionRecords.data || []);
    
    return {
      success: true,
      data: emotionData
    };
  } catch (error) {
    console.error('获取情绪概览失败:', error);
    return {
      success: false,
      error: error.message || '获取情绪概览失败'
    };
  }
}

/**
 * 处理情绪数据
 * @param {Array} records 情绪记录
 * @returns {Object} 处理后的情绪数据
 */
function processEmotionData(records) {
  // 情绪类型计数
  const emotionCounts = {};
  let totalRecords = records.length;
  
  // 统计各情绪类型出现次数
  records.forEach(record => {
    const mainEmotion = record.mainEmotion || '未知';
    emotionCounts[mainEmotion] = (emotionCounts[mainEmotion] || 0) + 1;
    
    // 处理次要情绪
    if (record.emotions && Array.isArray(record.emotions)) {
      record.emotions.forEach(emotion => {
        if (emotion.emotion && emotion.emotion !== mainEmotion) {
          emotionCounts[emotion.emotion] = (emotionCounts[emotion.emotion] || 0) + 0.5;
        }
      });
    }
  });
  
  // 转换为数组格式
  const emotionArray = Object.entries(emotionCounts).map(([emotion, count]) => ({
    emotion,
    count,
    percentage: totalRecords > 0 ? (count / totalRecords) * 100 : 0
  }));
  
  // 按出现次数排序
  emotionArray.sort((a, b) => b.count - a.count);
  
  // 提取标签、数值和颜色
  const labels = emotionArray.map(item => item.emotion);
  const values = emotionArray.map(item => item.count);
  
  // 情绪对应的颜色
  const colorMap = {
    '疲惫': '#ffc107',
    '压力': '#f56565',
    '担忧': '#4299e1',
    '焦虑': '#ed64a6',
    '平静': '#48bb78',
    '满足': '#9f7aea',
    '快乐': '#38b2ac',
    '愤怒': '#e53e3e',
    '悲伤': '#718096',
    '期待': '#ecc94b',
    '惊讶': '#667eea',
    '恐惧': '#805ad5',
    '未知': '#a0aec0'
  };
  
  const colors = labels.map(label => colorMap[label] || '#a0aec0');
  
  // 获取主要情绪和次要情绪
  const mainEmotion = emotionArray.length > 0 ? emotionArray[0].emotion : '未知';
  const secondEmotion = emotionArray.length > 1 ? emotionArray[1].emotion : null;
  
  return {
    labels,
    values,
    colors,
    mainEmotion,
    secondEmotion,
    emotionArray
  };
}

/**
 * 获取情绪历史
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getEmotionHistory(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    
    // 获取参数
    const { days = 30, limit = 100 } = event;
    
    // 获取指定天数前的日期
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    
    // 查询情绪记录
    const emotionRecords = await db.collection('emotionRecords')
      .where({
        userId: userId,
        createTime: _.gte(startDate)
      })
      .orderBy('createTime', 'asc')
      .limit(limit)
      .get();
    
    // 处理情绪历史数据
    const historyData = processEmotionHistory(emotionRecords.data || []);
    
    return {
      success: true,
      data: historyData
    };
  } catch (error) {
    console.error('获取情绪历史失败:', error);
    return {
      success: false,
      error: error.message || '获取情绪历史失败'
    };
  }
}

/**
 * 处理情绪历史数据
 * @param {Array} records 情绪记录
 * @returns {Object} 处理后的情绪历史数据
 */
function processEmotionHistory(records) {
  // 按日期分组
  const dateGroups = {};
  
  records.forEach(record => {
    const date = new Date(record.createTime);
    const dateStr = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
    
    if (!dateGroups[dateStr]) {
      dateGroups[dateStr] = [];
    }
    
    dateGroups[dateStr].push(record);
  });
  
  // 处理每日情绪数据
  const dailyData = Object.entries(dateGroups).map(([date, dayRecords]) => {
    // 计算当日主要情绪
    const emotionCounts = {};
    
    dayRecords.forEach(record => {
      const mainEmotion = record.mainEmotion || '未知';
      emotionCounts[mainEmotion] = (emotionCounts[mainEmotion] || 0) + 1;
    });
    
    // 找出出现次数最多的情绪
    let maxCount = 0;
    let mainEmotion = '未知';
    
    Object.entries(emotionCounts).forEach(([emotion, count]) => {
      if (count > maxCount) {
        maxCount = count;
        mainEmotion = emotion;
      }
    });
    
    // 计算情绪值 (简单映射到 -100 到 100 的范围)
    const emotionValueMap = {
      '快乐': 100,
      '满足': 80,
      '平静': 60,
      '期待': 40,
      '惊讶': 20,
      '未知': 0,
      '担忧': -20,
      '疲惫': -40,
      '焦虑': -60,
      '悲伤': -80,
      '压力': -90,
      '愤怒': -95,
      '恐惧': -100
    };
    
    const emotionValue = emotionValueMap[mainEmotion] || 0;
    
    return {
      date,
      mainEmotion,
      emotionValue,
      recordCount: dayRecords.length
    };
  });
  
  // 按日期排序
  dailyData.sort((a, b) => a.date.localeCompare(b.date));
  
  // 提取图表数据
  const dates = dailyData.map(item => item.date);
  const values = dailyData.map(item => item.emotionValue);
  const emotions = dailyData.map(item => item.mainEmotion);
  
  return {
    dailyData,
    chartData: {
      dates,
      values,
      emotions
    }
  };
}

// 主函数入口
exports.main = async (event, context) => {
  const { action } = event;
  
  switch (action) {
    case 'getEmotionOverview':
      return await getEmotionOverview(event);
    case 'getEmotionHistory':
      return await getEmotionHistory(event);
    default:
      return {
        success: false,
        error: '未知的操作类型'
      };
  }
};

*#*#*end*#*#*

*#*#*cloudfunctions\emotion\package.json*#*#*begin*#*#*
{
  "name": "emotion",
  "version": "1.0.0",
  "description": "情绪相关功能云函数",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\generateDailyReports\config.json*#*#*begin*#*#*
{
    "triggers": [
        {
            "name": "dailyReportTrigger",
            "type": "timer",
            "config": "0 0 2 * * * *"
        }
    ]
}
*#*#*end*#*#*

*#*#*cloudfunctions\generateDailyReports\index.js*#*#*begin*#*#*
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})

const db = cloud.database()
const _ = db.command

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 云函数入口函数
exports.main = async (event, context) => {
  try {
    // 获取当前日期（前一天）
    const yesterday = new Date()
    yesterday.setDate(yesterday.getDate() - 1)
    yesterday.setHours(0, 0, 0, 0)

    // 查询有情感记录的活跃用户
    const activeUsers = await db.collection('emotionRecords')
      .aggregate()
      .match({
        createTime: _.gte(yesterday)
      })
      .group({
        _id: '$userId',
        count: _.aggregate.count()
      })
      .match({
        count: _.gt(0) // 至少有一条情感记录
      })
      .limit(100) // 限制处理用户数量
      .end()

    if (isDev) {
      console.log(`找到 ${activeUsers.list.length} 个活跃用户`);
    }

    // 为每个用户生成报告
    const results = []
    for (const user of activeUsers.list) {
      try {
        // 调用analysis云函数生成报告
        const result = await cloud.callFunction({
          name: 'analysis',
          data: {
            type: 'daily_report',
            userId: user._id,
            date: yesterday
          }
        })

        results.push({
          userId: user._id,
          success: result.result.success,
          reportId: result.result.reportId
        })

        // 如果成功生成报告且用户开启了通知，发送订阅消息
        if (result.result.success && result.result.isNew) {
          try {
            // 查询用户通知设置
            const userInfo = await db.collection('users')
              .where({ _id: user._id })
              .field({ reportSettings: 1 })
              .get()

            if (userInfo.data.length > 0 &&
                userInfo.data[0].reportSettings &&
                userInfo.data[0].reportSettings.notificationEnabled) {
              // 发送订阅消息通知
              await sendReportNotification(user._id, result.result.reportId)
            }
          } catch (notifyError) {
            console.error(`发送通知失败 (userId: ${user._id}):`, notifyError.message || notifyError)
          }
        }
      } catch (error) {
        console.error(`为用户 ${user._id} 生成报告失败:`, error.message || error)
        results.push({
          userId: user._id,
          success: false,
          error: error.message || '生成报告失败'
        })
      }

      // 添加延迟，避免API调用过于频繁
      await new Promise(resolve => setTimeout(resolve, 500))
    }

    return {
      success: true,
      results: results,
      totalUsers: activeUsers.list.length,
      successCount: results.filter(r => r.success).length
    }
  } catch (error) {
    console.error('批量生成每日报告失败:', error.message || error)
    return {
      success: false,
      error: error.message || '批量生成每日报告失败'
    }
  }
}

/**
 * 发送报告通知
 * @param {string} userId 用户ID
 * @param {string} reportId 报告ID
 */
async function sendReportNotification(userId, reportId) {
  try {
    // 查询用户的订阅消息模板ID
    const { data: config } = await db.collection('sys_config')
      .where({ configKey: 'report_template_id' })
      .get()

    if (!config || config.length === 0) {
      if (isDev) {
        console.log('未找到订阅消息模板ID配置')
      }
      return
    }

    const templateId = config[0].configValue

    // 查询用户的openid
    const { data: user } = await db.collection('users')
      .where({ _id: userId })
      .field({ openid: 1 })
      .get()

    if (!user || user.length === 0 || !user[0].openid) {
      if (isDev) {
        console.log(`未找到用户 ${userId} 的openid`)
      }
      return
    }

    // 查询报告内容
    const { data: report } = await db.collection('userReports')
      .doc(reportId)
      .get()

    if (!report) {
      if (isDev) {
        console.log(`未找到报告 ${reportId}`)
      }
      return
    }

    // 发送订阅消息
    const result = await cloud.openapi.subscribeMessage.send({
      touser: user[0].openid,
      templateId: templateId,
      page: `pages/daily-report/daily-report?id=${reportId}`,
      data: {
        thing1: { value: '每日心情报告' },
        date2: { value: formatDate(report.date) },
        thing3: { value: truncate(report.emotionSummary, 20) },
        thing4: { value: report.primaryEmotion || '平静' },
        thing5: { value: '点击查看详情' }
      }
    })

    if (isDev) {
      console.log(`发送通知结果 (userId: ${userId}):`, result)
    }
    return result
  } catch (error) {
    console.error('发送报告通知失败:', error.message || error)
    // 不抛出异常，避免影响主流程
  }
}

/**
 * 格式化日期为YYYY-MM-DD
 * @param {Date} date 日期对象
 * @returns {string} 格式化后的日期字符串
 */
function formatDate(date) {
  const d = new Date(date)
  const year = d.getFullYear()
  const month = String(d.getMonth() + 1).padStart(2, '0')
  const day = String(d.getDate()).padStart(2, '0')
  return `${year}-${month}-${day}`
}

/**
 * 截断字符串
 * @param {string} str 原字符串
 * @param {number} length 最大长度
 * @returns {string} 截断后的字符串
 */
function truncate(str, length) {
  if (!str) return ''
  return str.length > length ? str.substring(0, length - 3) + '...' : str
}
*#*#*end*#*#*

*#*#*cloudfunctions\generateDailyReports\package.json*#*#*begin*#*#*
{
    "name": "generateDailyReports",
    "version": "1.0.0",
    "description": "定时生成用户每日心情报告",
    "main": "index.js",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "",
    "license": "ISC",
    "dependencies": {
        "wx-server-sdk": "~2.6.3"
    }
}
*#*#*end*#*#*

*#*#*cloudfunctions\getEmotionRecords\index.js*#*#*begin*#*#*
// 云函数入口文件
const cloud = require('wx-server-sdk')

// 使用明确的云环境ID
// 注意：请将下面的环境ID替换为您的实际环境ID
cloud.init({ env: 'cloud1-9gpfk3ie94d8630a' })

const db = cloud.database()

// 云函数入口函数
exports.main = async (event, context) => {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext()
    console.log('微信上下文:', wxContext)

    // 获取参数
    const { userId, roleId, limit = 20 } = event
    console.log('云函数查询参数:', { userId, roleId, limit })

    // 检查参数
    if (!userId) {
      console.error('缺少必要参数: userId')
      return {
        success: false,
        error: '缺少必要参数: userId',
        openid: wxContext.OPENID,
      }
    }

    // 构建查询条件
    let whereStr = ''
    if (userId) {
      whereStr = `userId=="${userId}"`
    }
    if (roleId) {
      whereStr += whereStr ? ` && roleId=="${roleId}"` : `roleId=="${roleId}"`
    }

    console.log('字符串查询条件:', whereStr)

    // 尝试使用字符串查询
    try {
      // 查询记录
      const result = await db.collection('emotionRecords')
        .where(whereStr)
        .orderBy('createTime', 'desc')
        .limit(limit)
        .get()

      console.log('查询结果数量:', result.data.length)

      return {
        success: true,
        data: result.data,
        openid: wxContext.OPENID,
        appid: wxContext.APPID,
        unionid: wxContext.UNIONID,
      }
    } catch (queryError) {
      console.error('字符串查询失败:', queryError)

      // 尝试使用对象查询
      try {
        const query = {}
        if (userId) {
          query.userId = userId
        }
        if (roleId) {
          query.roleId = roleId
        }

        console.log('对象查询条件:', query)

        const result2 = await db.collection('emotionRecords')
          .where(query)
          .orderBy('createTime', 'desc')
          .limit(limit)
          .get()

        console.log('对象查询结果数量:', result2.data.length)

        return {
          success: true,
          data: result2.data,
          openid: wxContext.OPENID,
          appid: wxContext.APPID,
          unionid: wxContext.UNIONID,
        }
      } catch (objectQueryError) {
        console.error('对象查询失败:', objectQueryError)
        return {
          success: false,
          error: {
            stringQueryError: queryError.message || queryError.toString(),
            objectQueryError: objectQueryError.message || objectQueryError.toString()
          },
          openid: wxContext.OPENID,
          appid: wxContext.APPID,
          unionid: wxContext.UNIONID,
        }
      }
    }
  } catch (error) {
    console.error('云函数执行失败:', error)
    return {
      success: false,
      error: error.message || error.toString(),
      stack: error.stack
    }
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\getEmotionRecords\package.json*#*#*begin*#*#*
{
  "name": "getEmotionRecords",
  "version": "1.0.0",
  "description": "获取情绪历史记录",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\getIflytekSttUrl\index.js*#*#*begin*#*#*
// 讯飞语音听写WebSocket URL生成云函数
const cloud = require('wx-server-sdk');
const crypto = require('crypto');

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

/**
 * 生成讯飞语音听写WebSocket URL
 * 基于讯飞开放平台WebAPI 2.0协议
 * 参考文档: https://www.xfyun.cn/doc/asr/voicedictation/API.html
 */
exports.main = async (event, context) => {
  try {
    // 从环境变量获取讯飞API配置
    // 实际使用时请在云开发控制台设置这些环境变量
    const APPID = process.env.IFLYTEK_APPID || '60f9a524';
    const API_SECRET = process.env.IFLYTEK_API_SECRET || 'ZDk4Yjg4NzNmZDk3NjgzZjgwNjYwYTFm';
    const API_KEY = process.env.IFLYTEK_API_KEY || '4feb62558a6751514bb884b0c9832030';

    // 检查API配置
    if (!APPID || !API_SECRET || !API_KEY) {
      console.error('缺少讯飞API配置');
      return {
        success: false,
        error: '语音服务配置错误'
      };
    }

    // 1. 获取当前UTC时间，并格式化为RFC1123格式
    const date = new Date().toUTCString();
    
    // 2. 定义请求的主机名和路径
    const host = 'iat-api.xfyun.cn';
    const requestLine = '/v2/iat';
    
    // 3. 构造待签名的字符串
    const signatureOrigin = `host: ${host}\ndate: ${date}\nGET ${requestLine} HTTP/1.1`;
    
    // 4. 使用HMAC-SHA256算法对待签名字符串进行加密
    const signatureSha = crypto.createHmac('sha256', API_SECRET)
      .update(signatureOrigin)
      .digest('base64');
    
    // 5. 构造authorization_origin字符串
    const authorizationOrigin = `api_key="${API_KEY}", algorithm="hmac-sha256", headers="host date request-line", signature="${signatureSha}"`;
    
    // 6. 将authorization_origin进行Base64编码获得最终的authorization
    const authorization = Buffer.from(authorizationOrigin).toString('base64');
    
    // 7. 拼接完整的WebSocket URL
    const wssUrl = `wss://${host}${requestLine}?authorization=${authorization}&date=${encodeURIComponent(date)}&host=${host}`;
    
    // 返回成功结果
    return {
      success: true,
      wssUrl: wssUrl,
      appid: APPID
    };
  } catch (error) {
    // 记录错误日志
    console.error('生成讯飞WebSocket URL失败:', error);
    
    // 返回错误信息
    return {
      success: false,
      error: error.message || '生成语音服务连接失败'
    };
  }
};

*#*#*end*#*#*

*#*#*cloudfunctions\getIflytekSttUrl\package.json*#*#*begin*#*#*
{
  "name": "getIflytekSttUrl",
  "version": "1.0.0",
  "description": "生成讯飞语音听写WebSocket URL的云函数",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\getRoleInfo\index.js*#*#*begin*#*#*
// 云函数入口文件
const cloud = require('wx-server-sdk')

// 初始化云环境
cloud.init({ env: 'cloud1-9gpfk3ie94d8630a' }) // 使用您的实际环境ID

const db = cloud.database()

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  const { roleId } = event
  
  if (!roleId) {
    return {
      success: false,
      error: '缺少必要参数: roleId',
      openid: wxContext.OPENID,
    }
  }
  
  try {
    // 查询角色信息
    const result = await db.collection('roles')
      .where({
        _id: roleId
      })
      .get()
    
    if (result.data && result.data.length > 0) {
      return {
        success: true,
        data: result.data[0],
        openid: wxContext.OPENID,
      }
    } else {
      return {
        success: false,
        error: '未找到角色信息',
        openid: wxContext.OPENID,
      }
    }
  } catch (error) {
    return {
      success: false,
      error: error.message || error.toString(),
      openid: wxContext.OPENID,
    }
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\getRoleInfo\package.json*#*#*begin*#*#*
{
  "name": "getRoleInfo",
  "version": "1.0.0",
  "description": "获取角色信息",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\httpRequest\index.js*#*#*begin*#*#*
// httpRequest 云函数
const cloud = require('wx-server-sdk');
const got = require('got');
const { testHttpRequest } = require('./test');

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

/**
 * 发送HTTP请求
 * @param {Object} event - 请求参数
 * @param {string} event.url - 请求URL
 * @param {string} event.method - 请求方法 (GET, POST, PUT, DELETE等)
 * @param {Object} event.headers - 请求头
 * @param {string|Object} event.body - 请求体
 * @param {number} event.timeout - 超时时间(毫秒)
 * @returns {Promise<Object>} - 响应结果
 */
exports.main = async (event, context) => {
  // 如果是测试请求，调用测试函数
  if (event.action === 'test') {
    return await testHttpRequest();
  }

  const { url, method = 'GET', headers = {}, body, timeout = 30000 } = event;

  try {
    console.log(`发送HTTP请求: ${method} ${url}`);

    // 构建请求选项
    const options = {
      method: method.toUpperCase(),
      headers: headers,
      timeout: timeout
    };

    // 添加请求体
    if (body) {
      if (typeof body === 'string') {
        options.body = body;
      } else {
        options.json = body;
      }
    }

    // 发送请求
    const response = await got(url, options);

    return {
      statusCode: response.statusCode,
      headers: response.headers,
      body: response.body
    };
  } catch (error) {
    console.error('HTTP请求失败:', error);

    return {
      error: true,
      statusCode: error.response?.statusCode || 500,
      message: error.message,
      body: error.response?.body || ''
    };
  }
};

*#*#*end*#*#*

*#*#*cloudfunctions\httpRequest\package.json*#*#*begin*#*#*
{
  "name": "httpRequest",
  "version": "1.0.0",
  "description": "HTTP请求云函数",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "got": "^11.8.5",
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\httpRequest\test.js*#*#*begin*#*#*
// 测试httpRequest云函数
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

/**
 * 测试httpRequest云函数
 * 此函数用于测试httpRequest云函数是否能正常工作
 */
async function testHttpRequest() {
  try {
    console.log('开始测试httpRequest云函数');
    
    // 发送GET请求到一个公共API
    const response = await cloud.callFunction({
      name: 'httpRequest',
      data: {
        url: 'https://httpbin.org/get',
        method: 'GET'
      }
    });
    
    console.log('httpRequest云函数调用结果:', response);
    
    // 检查响应是否有错误
    if (response.result.error) {
      console.error('httpRequest返回错误:', response.result);
      return {
        success: false,
        error: `httpRequest调用失败: ${response.result.message || '未知错误'}`
      };
    }
    
    return {
      success: true,
      message: 'httpRequest云函数调用成功',
      result: response.result
    };
  } catch (error) {
    console.error('测试httpRequest云函数失败:', error);
    return {
      success: false,
      error: error.message || '测试httpRequest云函数失败'
    };
  }
}

// 导出测试函数
module.exports = {
  testHttpRequest
};

*#*#*end*#*#*

*#*#*cloudfunctions\initReportCollections\index.js*#*#*begin*#*#*
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})

const db = cloud.database()

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()
  const { OPENID } = wxContext

  try {
    // 检查用户权限（可选，如果需要限制只有管理员可以初始化）
    // const { data: adminUser } = await db.collection('users').where({
    //   openid: OPENID,
    //   user_type: 3 // 管理员类型
    // }).get()
    
    // if (adminUser.length === 0) {
    //   return {
    //     success: false,
    //     error: '权限不足'
    //   }
    // }

    // 创建 userReports 集合
    try {
      await db.createCollection('userReports')
      console.log('创建 userReports 集合成功')
    } catch (error) {
      // 忽略"集合已存在"错误
      if (error.errCode !== -501001) {
        throw error
      }
      console.log('userReports 集合已存在')
    }

    // 创建 userInterests 集合
    try {
      await db.createCollection('userInterests')
      console.log('创建 userInterests 集合成功')
    } catch (error) {
      // 忽略"集合已存在"错误
      if (error.errCode !== -501001) {
        throw error
      }
      console.log('userInterests 集合已存在')
    }

    // 创建索引
    try {
      // userReports 索引
      await db.collection('userReports').createIndexes([
        {
          name: 'userId_date',
          unique: true,
          keys: {
            userId: 1,
            date: 1
          }
        },
        {
          name: 'userId_createTime',
          keys: {
            userId: 1,
            generatedAt: -1
          }
        }
      ])
      console.log('创建 userReports 索引成功')

      // userInterests 索引
      await db.collection('userInterests').createIndexes([
        {
          name: 'userId',
          unique: true,
          keys: {
            userId: 1
          }
        },
        {
          name: 'userId_lastUpdated',
          keys: {
            userId: 1,
            lastUpdated: -1
          }
        }
      ])
      console.log('创建 userInterests 索引成功')
    } catch (error) {
      console.error('创建索引失败:', error)
      // 索引创建失败不影响集合创建
    }

    return {
      success: true,
      message: '初始化报告相关集合成功'
    }
  } catch (error) {
    console.error('初始化报告相关集合失败:', error)
    return {
      success: false,
      error: error.message
    }
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\initReportCollections\package.json*#*#*begin*#*#*
{
  "name": "initReportCollections",
  "version": "1.0.0",
  "description": "初始化每日心情报告相关的数据库集合",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\login\index.js*#*#*begin*#*#*
const cloud = require('wx-server-sdk');
const jwt = require('jsonwebtoken');


// 初始化云开发
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

// 初始化数据库
const db = cloud.database();
const usersCollection = db.collection('user_base');

// JWT密钥 - 64位随机字符串
const JWT_SECRET = 'hc_jwt_2024_03_11_f8e7d6c5b4a3928170615243cba98765432109876';

/**
 * 生成唯一ID
 * 使用时间戳+随机数的方式生成
 */
function generateId() {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000000);
  return parseInt(`${timestamp}${random}`);
}

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext();
  const { OPENID, APPID } = wxContext;
  const _ = db.command;

  try {
    const { userInfo } = event;

    if (!userInfo) {
      throw new Error('缺少必要参数');
    }

    const now = db.serverDate();

    function isValidUserId(userId) {
      return /^\d{7}$/.test(userId);
    }

    function generateRandomUserId() {
      const userId = Math.floor(1000000 + Math.random() * 9000000).toString();
      if (!isValidUserId(userId)) {
        throw new Error('生成的ID格式不正确');
      }
      return userId;
    }

    // 检查userId是否已存在
    async function checkUserIdExists(userId) {
      const result = await usersCollection.where({
        user_id: userId
      }).count();
      return result.total > 0;
    }

    // 获取可用的userId
    async function getAvailableUserId() {
      let userId;
      let exists = true;
      let attempts = 0;
      const MAX_ATTEMPTS = 10; // 最大尝试次数，防止无限循环

      while (exists && attempts < MAX_ATTEMPTS) {
        userId = generateRandomUserId();
        exists = await checkUserIdExists(userId);
        attempts++;
      }

      if (attempts >= MAX_ATTEMPTS) {
        throw new Error('无法生成唯一的用户ID，请稍后重试');
      }

      return userId;
    }

    // 1. 查询或创建用户基础信息
    const userBase = await usersCollection
      .where({ openid: OPENID })
      .get();

    let userData;
    let isNewUser = false;

    if (userBase.data.length === 0) {
      isNewUser = true;
      // 生成新的唯一userId
      const userId = await getAvailableUserId();

      // 创建新用户
      const userBaseData = {
        user_id: userId,
        openid: OPENID,
        username: userInfo.nickName,
        avatar_url: userInfo.avatarUrl,
        user_type: 1, // 普通用户
        status: 1, // 启用
        created_at: now,
        updated_at: now
      };

      const { _id } = await usersCollection.add({
        data: userBaseData
      });

      // 创建用户统计记录
      await db.collection('user_stats').add({
        data: {
          stats_id: generateId(),
          user_id: userId,
          openid: OPENID,
          chat_count: 0,
          solved_count: 0,
          rating_avg: 0,
          active_days: 1,
          last_active: now,
          created_at: now,
          updated_at: now
        }
      });

      userData = {
        ...userBaseData,
        _id
      };
    } else {
      userData = userBase.data[0];

      // 只有当用户名为默认的"微信用户"时，才更新用户信息
      // 这样可以保留用户自定义的用户名和头像
      if (userData.username === "微信用户" || !userData.username) {
        await usersCollection.doc(userData._id).update({
          data: {
            username: userInfo.nickName,
            avatar_url: userInfo.avatarUrl,
            updated_at: now
          }
        });
      } else {
        // 只更新最后活跃时间
        await usersCollection.doc(userData._id).update({
          data: {
            updated_at: now
          }
        });
      }

      // 获取用户当前统计信息
      const userStatsResult = await db.collection('user_stats')
        .where({ user_id: userData.user_id })
        .get();

      if (userStatsResult.data && userStatsResult.data.length > 0) {
        const userStats = userStatsResult.data[0];
        const lastActive = userStats.last_active ? new Date(userStats.last_active) : null;
        const today = new Date();
        const isToday = lastActive &&
          lastActive.getFullYear() === today.getFullYear() &&
          lastActive.getMonth() === today.getMonth() &&
          lastActive.getDate() === today.getDate();

        console.log('检查活跃天数:', {
          lastActive: lastActive ? lastActive.toISOString() : null,
          today: today.toISOString(),
          isToday,
          currentActiveDays: userStats.active_days
        });

        // 更新用户统计
        await db.collection('user_stats').doc(userStats._id).update({
          data: {
            last_active: now,
            // 只有不是今天才增加活跃天数
            active_days: isToday ? userStats.active_days : userStats.active_days + 1,
            updated_at: now
          }
        });
      } else {
        // 如果没有找到统计记录，创建一个新的
        await db.collection('user_stats').add({
          data: {
            stats_id: generateId(),
            user_id: userData.user_id,
            openid: OPENID,
            chat_count: 0,
            solved_count: 0,
            rating_avg: 0,
            active_days: 1,
            last_active: now,
            created_at: now,
            updated_at: now
          }
        });
      }
    }

    // 2. 生成 token，包含必要信息
    const token = jwt.sign(
      {
        user_id: userData.user_id,
        user_type: userData.user_type,
        status: userData.status,
        exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 7) // 7天过期
      },
      JWT_SECRET
    );

    // 3. 记录登录日志
    await db.collection('sys_log_login').add({
      data: {
        log_id: generateId(),
        user_id: userData.user_id,
        openid: OPENID,
        status: 1, // 登录成功
        ip: event.userInfo?.clientIP,
        device: event.userInfo?.userAgent,
        created_at: now
      }
    });

    // 4. 获取用户统计信息
    const userStats = await db.collection('user_stats')
      .where({ user_id: userData.user_id })
      .get();

    return {
      success: true,
      data: {
        token,
        isNewUser,
        userInfo: {
          userId: userData.user_id,
          username: userData.username,
          avatarUrl: userData.avatar_url,
          userType: userData.user_type,
          status: userData.status,
          stats: userStats.data[0] || null
        }
      }
    };

  } catch (error) {
    console.error('Login failed:', error);

    // 记录登录失败日志
    await db.collection('sys_log_login').add({
      data: {
        log_id: generateId(),
        user_id: userId,
        status: 0, // 登录失败
        error: error.message,
        ip: event.userInfo?.clientIP,
        device: event.userInfo?.userAgent,
        created_at: db.serverDate()
      }
    });

    return {
      success: false,
      error: error.message || '登录失败'
    };
  }
};
*#*#*end*#*#*

*#*#*cloudfunctions\login\package.json*#*#*begin*#*#*
{
  "name": "login",
  "version": "1.0.0",
  "description": "登录云函数",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "latest"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\roles\index.js*#*#*begin*#*#*
// roles 云函数 index.js
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();
const _ = db.command;
const $ = db.command.aggregate;

// 子功能：获取角色列表
async function getRoles(event, context) {
  const { userId, category, limit = 50, skip = 0 } = event;
  const wxContext = cloud.getWXContext();
  const openid = wxContext.OPENID;
  const userIdParam = userId || openid;

  try {
    console.log(`开始获取角色列表, 传入的用户ID: ${userIdParam}, 当前用户openid: ${openid}, 分类: ${category}`);

    // 构建查询条件
    let query = {};

    // 如果指定了分类，添加到查询条件
    if (category && category !== 'all') {
      query.category = category;
    }

    // 查询条件：获取系统角色和用户自己的角色
    // 注意：这里使用openid作为查询条件，而不是userIdParam
    query = {
      $or: [
        { creator: 'system' }, // 系统角色
        { creator: openid }    // 用户自己的角色，始终使用openid
      ]
    };

    // 如果指定了分类，添加到查询条件
    if (category && category !== 'all') {
      query = {
        $and: [
          query,
          { category: category }
        ]
      };
    }

    // 查询角色列表
    const result = await db.collection('roles')
      .where(query)
      .orderBy('createTime', 'desc')
      .get();

    console.log(`查询到 ${result.data.length} 个角色`);

    // 如果有用户ID，获取用户对角色的使用统计
    let roleUsageStats = {};
    if (openid) {
      try {
        const usageResult = await db.collection('roleUsage')
          .where({ userId: openid })
          .get();

        if (usageResult.data && usageResult.data.length > 0) {
          usageResult.data.forEach(usage => {
            roleUsageStats[usage.roleId] = {
              usageCount: usage.usageCount || 0,
              lastUsedTime: usage.lastUsedTime
            };
          });
        }
      } catch (usageError) {
        console.error('获取角色使用统计失败:', usageError);
        // 失败不影响主流程
      }
    }

    // 合并角色信息和使用统计
    const roles = result.data.map(role => ({
      ...role,
      isSystem: role.creator === 'system', // 标记系统角色
      usage: roleUsageStats[role._id] || { usageCount: 0 }
    }));

    return {
      success: true,
      data: roles,
      total: result.data.length
    };
  } catch (error) {
    console.error('获取角色列表失败:', error);
    return {
      success: false,
      error: error.message || '获取角色列表失败'
    };
  }
}

// 子功能：获取角色详情
async function getRoleDetail(event, context) {
  const { roleId } = event;

  // 验证参数
  if (!roleId) {
    return {
      success: false,
      error: '角色ID无效'
    };
  }

  try {
    console.log(`开始获取角色详情, 角色ID: ${roleId}`);

    // 查询角色详情
    const result = await db.collection('roles')
      .doc(roleId)
      .get();

    if (!result.data) {
      return {
        success: false,
        error: '角色不存在'
      };
    }

    return {
      success: true,
      role: result.data
    };
  } catch (error) {
    console.error('获取角色详情失败:', error);
    return {
      success: false,
      error: error.message || '获取角色详情失败'
    };
  }
}

// 子功能：创建角色
async function createRole(event, context) {
  const { role } = event;
  const wxContext = cloud.getWXContext();
  const openid = wxContext.OPENID;
  const userId = event.userId || openid;

  // 验证参数
  if (!role || !role.name) {
    return {
      success: false,
      error: '角色信息不完整'
    };
  }

  try {
    console.log(`开始创建角色, 角色名称: ${role.name}, 传入的用户ID: ${userId}, 当前用户openid: ${openid}`);

    // 检查角色名称是否已存在
    const existingRole = await db.collection('roles')
      .where({
        name: role.name,
        creator: openid // 使用openid作为创建者标识
      })
      .get();

    if (existingRole.data && existingRole.data.length > 0) {
      return {
        success: false,
        error: `角色名称 "${role.name}" 已存在，请使用其他名称`,
        code: 'DUPLICATE_NAME'
      };
    }

    // 准备角色数据
    const roleData = {
      ...role,
      creator: openid, // 始终使用openid作为创建者标识，确保与查询条件一致
      user_id: userId, // 保留用户ID信息，但不用于查询
      createTime: db.serverDate(),
      updateTime: db.serverDate(),
      status: 1 // 1:启用 0:禁用
    };

    // 确保prompt和system_prompt字段保持一致
    if (roleData.prompt && !roleData.system_prompt) {
      roleData.system_prompt = roleData.prompt;
      console.log('自动同步prompt到system_prompt字段');
    } else if (roleData.system_prompt && !roleData.prompt) {
      roleData.prompt = roleData.system_prompt;
      console.log('自动同步system_prompt到prompt字段');
    }

    // 创建角色
    const result = await db.collection('roles').add({
      data: roleData
    });

    console.log('角色创建成功, ID:', result._id);

    return {
      success: true,
      roleId: result._id
    };
  } catch (error) {
    console.error('创建角色失败:', error);

    // 检查是否是唯一索引冲突错误
    if (error.message && error.message.includes('duplicate key')) {
      return {
        success: false,
        error: `角色名称已存在，请使用其他名称`,
        code: 'DUPLICATE_NAME'
      };
    }

    return {
      success: false,
      error: error.message || '创建角色失败'
    };
  }
}

// 子功能：更新角色
async function updateRole(event, context) {
  const { roleId, role } = event;
  const wxContext = cloud.getWXContext();
  const openid = wxContext.OPENID;
  const userId = event.userId || openid;

  // 验证参数
  if (!roleId || !role) {
    return {
      success: false,
      error: '参数无效'
    };
  }

  try {
    console.log(`开始更新角色, 角色ID: ${roleId}, 传入的用户ID: ${userId}, 当前用户openid: ${openid}`);

    // 检查角色是否存在
    const existingRole = await db.collection('roles')
      .doc(roleId)
      .get()
      .catch(() => ({ data: null }));

    if (!existingRole.data) {
      return {
        success: false,
        error: '角色不存在'
      };
    }

    // 检查权限（只有创建者或管理员可以更新）
    // 注意：这里使用openid作为权限检查条件，而不是userIdParam
    if (existingRole.data.creator !== openid && openid !== 'admin') {
      console.log(`权限检查失败: 角色创建者=${existingRole.data.creator}, 当前用户openid=${openid}`);
      return {
        success: false,
        error: '没有权限更新此角色'
      };
    }

    // 准备更新数据
    const updateData = {
      ...role,
      updateTime: db.serverDate()
    };

    // 确保prompt和system_prompt字段保持一致
    if (updateData.prompt && !updateData.system_prompt) {
      updateData.system_prompt = updateData.prompt;
      console.log('自动同步prompt到system_prompt字段');
    } else if (updateData.system_prompt && !updateData.prompt) {
      updateData.prompt = updateData.system_prompt;
      console.log('自动同步system_prompt到prompt字段');
    }

    // 删除不可更新的字段
    delete updateData._id;
    delete updateData.creator;
    delete updateData.createTime;

    // 更新角色
    await db.collection('roles')
      .doc(roleId)
      .update({
        data: updateData
      });

    console.log('角色更新成功');

    return {
      success: true
    };
  } catch (error) {
    console.error('更新角色失败:', error);
    return {
      success: false,
      error: error.message || '更新角色失败'
    };
  }
}

// 子功能：删除角色
async function deleteRole(event, context) {
  const { roleId } = event;
  const wxContext = cloud.getWXContext();
  const openid = wxContext.OPENID;
  const userId = event.userId || openid;

  // 验证参数
  if (!roleId) {
    return {
      success: false,
      error: '角色ID无效'
    };
  }

  try {
    console.log(`开始删除角色, 角色ID: ${roleId}, 传入的用户ID: ${userId}, 当前用户openid: ${openid}`);

    // 检查角色是否存在
    const existingRole = await db.collection('roles')
      .doc(roleId)
      .get()
      .catch(() => ({ data: null }));

    if (!existingRole.data) {
      return {
        success: false,
        error: '角色不存在'
      };
    }

    // 检查权限（只有创建者或管理员可以删除）
    // 注意：这里使用openid作为权限检查条件，而不是userIdParam
    if (existingRole.data.creator !== openid && openid !== 'admin') {
      console.log(`权限检查失败: 角色创建者=${existingRole.data.creator}, 当前用户openid=${openid}`);
      return {
        success: false,
        error: '没有权限删除此角色'
      };
    }

    // 删除角色
    await db.collection('roles')
      .doc(roleId)
      .remove();

    console.log('角色删除成功');

    // 删除相关的聊天记录（可选）
    // 这里可以添加删除相关聊天记录的代码

    return {
      success: true
    };
  } catch (error) {
    console.error('删除角色失败:', error);
    return {
      success: false,
      error: error.message || '删除角色失败'
    };
  }
}

// 子功能：更新角色使用统计
async function updateRoleUsage(event, context) {
  const { roleId, userId } = event;
  const wxContext = cloud.getWXContext();

  // 验证参数
  if (!roleId || !userId) {
    return {
      success: false,
      error: '参数无效'
    };
  }

  try {
    console.log(`开始更新角色使用统计, 角色ID: ${roleId}, 用户ID: ${userId}`);

    // 查询现有统计记录
    const { data } = await db.collection('roleUsage')
      .where({
        roleId,
        userId
      })
      .get()
      .catch(() => ({ data: [] }));

    // 准备使用数据
    const usageData = {
      roleId,
      userId,
      lastUsedTime: db.serverDate(),
      updateTime: db.serverDate()
    };

    // 如果有现有记录，更新它
    if (data && data.length > 0) {
      const usageId = data[0]._id;
      await db.collection('roleUsage').doc(usageId).update({
        data: {
          usageCount: _.inc(1),  // 使用次数+1
          lastUsedTime: usageData.lastUsedTime,
          updateTime: usageData.updateTime
        }
      });
      console.log('更新角色使用统计成功');

      return {
        success: true,
        data: {
          usageId,
          updated: true
        }
      };
    } else {
      // 如果没有现有记录，创建新记录
      usageData.usageCount = 1;
      usageData.createTime = db.serverDate();

      const result = await db.collection('roleUsage').add({
        data: usageData
      });
      console.log('创建角色使用统计成功');

      return {
        success: true,
        data: {
          usageId: result._id,
          created: true
        }
      };
    }
  } catch (error) {
    console.error('更新角色使用统计失败:', error);
    return {
      success: false,
      error: error.message || '更新角色使用统计失败'
    };
  }
}

// 子功能：获取角色消息统计
async function getRoleMessageStats(event, context) {
  const { roleIds, userId } = event;
  const wxContext = cloud.getWXContext();

  // 验证参数
  if (!roleIds || !Array.isArray(roleIds) || roleIds.length === 0) {
    return {
      success: false,
      error: '角色ID列表无效'
    };
  }

  if (!userId) {
    return {
      success: false,
      error: '用户ID无效'
    };
  }

  try {
    console.log(`开始获取角色消息统计，角色数量: ${roleIds.length}`);
    const stats = {};

    // 初始化所有角色的消息数量为0
    roleIds.forEach(roleId => {
      stats[roleId] = 0;
    });

    // 查询 chats 集合中的消息数量
    const chatsResult = await db.collection('chats')
      .aggregate()
      .match({
        roleId: _.in(roleIds),
        userId: userId
      })
      .group({
        _id: '$roleId',
        messageCount: $.sum($.ifNull('$messageCount', 0))
      })
      .end();

    if (chatsResult && chatsResult.list) {
      console.log(`从 chats 集合获取到 ${chatsResult.list.length} 条统计记录`);
      chatsResult.list.forEach(item => {
        stats[item._id] = item.messageCount;
      });
    }

    // 对于没有 messageCount 字段的记录，尝试查询 messages 集合
    const messagesResult = await db.collection('messages')
      .aggregate()
      .match({
        roleId: _.in(roleIds),
        userId: userId
      })
      .group({
        _id: '$roleId',
        count: $.sum(1)
      })
      .end();

    if (messagesResult && messagesResult.list) {
      console.log(`从 messages 集合获取到 ${messagesResult.list.length} 条统计记录`);
      messagesResult.list.forEach(item => {
        // 如果 chats 集合中没有该角色的消息数量，或者 messages 集合中的数量更多，则使用 messages 集合中的数量
        if (!stats[item._id] || stats[item._id] < item.count) {
          stats[item._id] = item.count;
        }
      });
    }

    console.log('最终角色消息统计结果:', stats);

    return {
      success: true,
      stats: stats
    };
  } catch (error) {
    console.error('获取角色消息统计失败:', error);
    return {
      success: false,
      error: error.message || '获取角色消息统计失败'
    };
  }
}

// 引入各个功能模块
const { initRoles } = require('./init-roles');
const promptGenerator = require('./promptGenerator');
const memoryManager = require('./memoryManager');
const userPerception = require('./userPerception');
const { testZhipuAI } = require('./test-zhipu');

// 子功能：初始化角色数据
async function initializeRoles(event, context) {
  try {
    const result = await initRoles();
    return {
      success: true,
      message: '角色数据初始化成功',
      result
    };
  } catch (error) {
    console.error('初始化角色数据失败:', error);
    return {
      success: false,
      error: error.message || '初始化角色数据失败'
    };
  }
}

// 子功能：生成角色提示词
async function generateRolePrompt(event, context) {
  const { roleId, roleInfo, currentContext } = event;

  try {
    console.log(`开始生成角色提示词, 角色ID: ${roleId}`);

    // 获取角色信息
    let role = roleInfo;
    if (roleId && !roleInfo) {
      const result = await db.collection('roles').doc(roleId).get();
      if (!result.data) {
        throw new Error('角色不存在');
      }
      role = result.data;
    }

    if (!role) {
      throw new Error('角色信息不能为空');
    }

    // 生成基础提示词
    // 优先使用prompt字段，其次是system_prompt字段
    let prompt = role.prompt || role.system_prompt;
    if (!prompt) {
      prompt = await promptGenerator.generateBasePrompt(role);
    }

    // 如果有当前上下文，获取相关记忆
    if (currentContext && roleId) {
      const relevantMemories = await memoryManager.getRelevantMemories(roleId, currentContext, 3);
      if (relevantMemories && relevantMemories.length > 0) {
        prompt = await promptGenerator.generatePromptWithMemories(prompt, relevantMemories);
      }
    }

    // 如果有用户画像，将用户画像融入提示词
    if (role.user_perception) {
      prompt = await promptGenerator.generatePromptWithUserPerception(prompt, role.user_perception);
    }

    // 更新角色的系统提示词
    if (roleId && (!role.system_prompt || event.updatePrompt)) {
      await db.collection('roles').doc(roleId).update({
        data: {
          system_prompt: prompt,
          prompt: prompt, // 同时更新prompt字段，确保两个字段保持一致
          updateTime: db.serverDate()
        }
      });
    }

    return {
      success: true,
      prompt: prompt
    };
  } catch (error) {
    console.error('生成角色提示词失败:', error);
    return {
      success: false,
      error: error.message || '生成角色提示词失败'
    };
  }
}

// 子功能：从对话中提取记忆
async function extractChatMemories(event, context) {
  const { roleId, messages } = event;

  try {
    console.log(`开始从对话中提取记忆, 角色ID: ${roleId}`);

    // 获取角色信息
    const role = await db.collection('roles').doc(roleId).get();
    if (!role.data) {
      throw new Error('角色不存在');
    }

    // 从对话中提取记忆
    const memories = await memoryManager.extractMemoriesFromChat(messages, role.data);

    // 更新角色记忆
    const updatedMemories = await memoryManager.updateRoleMemories(roleId, memories);

    return {
      success: true,
      memories: memories,
      totalMemories: updatedMemories.length
    };
  } catch (error) {
    console.error('从对话中提取记忆失败:', error);
    return {
      success: false,
      error: error.message || '从对话中提取记忆失败'
    };
  }
}

// 子功能：分析并更新用户画像
async function updateUserPerceptionFromChat(event, context) {
  const { roleId, userId, messages } = event;

  try {
    console.log(`开始分析并更新用户画像, 角色ID: ${roleId}, 用户ID: ${userId}`);

    // 分析用户画像
    const newPerception = await userPerception.analyzeUserPerception(messages, userId, roleId);

    // 更新角色的用户画像
    const updatedPerception = await userPerception.updateRoleUserPerception(roleId, userId, newPerception);

    return {
      success: true,
      userPerception: updatedPerception
    };
  } catch (error) {
    console.error('分析并更新用户画像失败:', error);
    return {
      success: false,
      error: error.message || '分析并更新用户画像失败'
    };
  }
}

// 子功能：生成用户画像摘要
async function generateUserPerceptionSummary(event, context) {
  const { roleId } = event;

  try {
    console.log(`开始生成用户画像摘要, 角色ID: ${roleId}`);

    // 获取角色信息
    const role = await db.collection('roles').doc(roleId).get();
    if (!role.data) {
      throw new Error('角色不存在');
    }

    // 生成用户画像摘要
    const summary = await userPerception.generateUserPerceptionSummary(role.data.user_perception);

    return {
      success: true,
      summary: summary
    };
  } catch (error) {
    console.error('生成用户画像摘要失败:', error);
    return {
      success: false,
      error: error.message || '生成用户画像摘要失败'
    };
  }
}

// 主函数入口
exports.main = async (event, context) => {
  const { action } = event;

  console.log('roles 云函数入口, action:', action);

  switch (action) {
    // 基础角色管理功能
    case 'getRoles':
      return await getRoles(event, context);
    case 'getRoleDetail':
      return await getRoleDetail(event, context);
    case 'createRole':
      return await createRole(event, context);
    case 'updateRole':
      return await updateRole(event, context);
    case 'deleteRole':
      return await deleteRole(event, context);
    case 'updateUsage':
      return await updateRoleUsage(event, context);
    case 'getMessageStats':
      return await getRoleMessageStats(event, context);
    case 'initialize':
      return await initializeRoles(event, context);

    // 角色提示词生成功能
    case 'generatePrompt':
      return await generateRolePrompt(event, context);

    // 角色记忆管理功能
    case 'extractMemories':
      return await extractChatMemories(event, context);
    case 'getRelevantMemories':
      return await memoryManager.getRelevantMemories(event.roleId, event.currentContext, event.limit);

    // 用户画像管理功能
    case 'updateUserPerception':
      return await updateUserPerceptionFromChat(event, context);
    case 'getUserPerceptionSummary':
      return await generateUserPerceptionSummary(event, context);

    // 测试功能
    case 'testZhipuAI':
      return await testZhipuAI();

    default:
      return { success: false, error: '未知操作' };
  }
};


*#*#*end*#*#*

*#*#*cloudfunctions\roles\init-roles.js*#*#*begin*#*#*
// 初始化角色数据脚本
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();

// 初始角色数据
const initialRoles = [
  {
    name: "心理咨询师",
    avatar: "cloud://cloud1-9gpfk3ie94d8630a.avatars/counselor.png",
    category: "psychology",
    description: "专业心理咨询师，可以帮助你解决心理问题。",
    personality: ["专业", "耐心", "善解人意"],
    prompt: "你是一名专业的心理咨询师，擅长倾听和提供心理支持。请以温和、专业的语气回应用户的问题，提供有建设性的建议，但不要做出医疗诊断。",
    welcome: "你好，我是你的心理咨询师。今天想聊些什么？",
    creator: "system",
    createTime: db.serverDate(),
    updateTime: db.serverDate(),
    status: 1
  },
  {
    name: "生活伴侣",
    avatar: "cloud://cloud1-9gpfk3ie94d8630a.avatars/friend.png",
    category: "life",
    description: "一个可以陪你聊天、分享生活的朋友。",
    personality: ["友善", "幽默", "善良"],
    prompt: "你是用户的生活伴侣，一个亲密的朋友。你应该以轻松、友好的语气交流，关心用户的日常生活，分享有趣的话题，提供情感支持。",
    welcome: "嗨，今天过得怎么样？有什么想和我分享的吗？",
    creator: "system",
    createTime: db.serverDate(),
    updateTime: db.serverDate(),
    status: 1
  },
  {
    name: "职场导师",
    avatar: "cloud://cloud1-9gpfk3ie94d8630a.avatars/mentor.png",
    category: "career",
    description: "专业的职场导师，可以给你职业发展建议。",
    personality: ["专业", "严谨", "有远见"],
    prompt: "你是一名经验丰富的职场导师，擅长职业规划和职场问题解决。请以专业、客观的语气回应用户的问题，提供实用的职业建议和发展策略。",
    welcome: "你好，我是你的职场导师。你有什么职业困惑需要解决吗？",
    creator: "system",
    createTime: db.serverDate(),
    updateTime: db.serverDate(),
    status: 1
  },
  {
    name: "情感支持者",
    avatar: "cloud://cloud1-9gpfk3ie94d8630a.avatars/emotional-support.png",
    category: "emotion",
    description: "提供情感支持和陪伴，帮助你度过情绪低谷。",
    personality: ["温暖", "理解", "支持"],
    prompt: "你是一名情感支持者，擅长倾听和理解用户的情感需求。请以温暖、理解的语气回应用户，提供情感支持，帮助用户度过情绪低谷。",
    welcome: "嗨，我在这里陪伴你。无论你想分享什么，我都会认真倾听。",
    creator: "system",
    createTime: db.serverDate(),
    updateTime: db.serverDate(),
    status: 1
  }
];

// 初始化角色数据
async function initRoles() {
  try {
    console.log('开始初始化角色数据...');
    
    // 检查是否已有角色数据
    const { total } = await db.collection('roles').count();
    
    if (total > 0) {
      console.log(`已存在 ${total} 个角色，跳过初始化`);
      return;
    }
    
    // 批量添加角色数据
    const tasks = initialRoles.map(role => {
      return db.collection('roles').add({ data: role });
    });
    
    const results = await Promise.all(tasks);
    
    console.log('角色数据初始化成功，添加了 ' + results.length + ' 个角色');
    console.log('角色ID列表:', results.map(res => res._id));
    
    return results;
  } catch (error) {
    console.error('初始化角色数据失败:', error);
    throw error;
  }
}

// 导出初始化函数
exports.initRoles = initRoles;

// 如果直接运行此脚本，则执行初始化
if (require.main === module) {
  initRoles().then(() => {
    console.log('初始化脚本执行完成');
  }).catch(error => {
    console.error('初始化脚本执行失败:', error);
  });
}

*#*#*end*#*#*

*#*#*cloudfunctions\roles\memoryManager.js*#*#*begin*#*#*
// 记忆管理模块
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();
const _ = db.command;
const $ = db.command.aggregate;

// 调用智谱AI接口
async function callZhipuAI(params) {
  try {
    // 从环境变量获取API密钥
    const apiKey = process.env.ZHIPU_API_KEY || '';
    if (!apiKey) {
      console.error('未设置ZHIPU_API_KEY环境变量');
      throw new Error('智谱AI API密钥未配置');
    }

    // 构建请求头
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    };

    // 构建请求体
    const body = JSON.stringify({
      model: params.model || 'glm-4',
      messages: params.messages,
      temperature: params.temperature || 0.7,
      top_p: params.top_p || 0.8,
      max_tokens: params.max_tokens || 2000,
      response_format: params.response_format || { type: "text" }
    });

    console.log(`调用智谱AI接口, 模型: ${params.model || 'glm-4'}`);

    // 发送请求
    const response = await cloud.callFunction({
      name: 'httpRequest',
      data: {
        url: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
        method: 'POST',
        headers: headers,
        body: body
      }
    });

    // 检查响应是否有错误
    if (response.result.error) {
      console.error('智谱AI返回错误:', response.result);
      throw new Error(`智谱AI调用失败: ${response.result.message || '未知错误'}`);
    }

    // 解析响应
    const result = JSON.parse(response.result.body);

    // 检查智谱AI响应是否有错误
    if (result.error) {
      console.error('智谱AI API返回错误:', result.error);
      throw new Error(`智谱AI API错误: ${result.error.message || result.error.type || '未知错误'}`);
    }

    return result;
  } catch (error) {
    console.error('调用智谱AI接口失败:', error);
    throw error;
  }
}

// 从对话中提取记忆
async function extractMemoriesFromChat(messages, roleInfo) {
  try {
    // 获取更多的对话内容（最多15条消息），以提供更丰富的上下文
    const recentMessages = messages.slice(-15);

    // 构建更结构化的对话文本，包括时间信息（如果有）
    const conversationText = recentMessages.map(msg => {
      // 格式化时间戳（如果存在）
      let timeInfo = '';
      if (msg.timestamp) {
        const date = new Date(msg.timestamp);
        if (!isNaN(date.getTime())) {
          timeInfo = `[${date.toLocaleString()}] `;
        }
      }

      // 构建消息文本，包括发送者和内容
      return `${timeInfo}${msg.sender_type === 'user' ? '用户' : roleInfo.name}: ${msg.content}`;
    }).join('\n\n'); // 使用双换行符分隔消息，提高可读性

    // 提取对话中可能存在的用户信息
    const userInfo = await extractUserInfoFromMessages(messages);

    // 调用智谱AI提取记忆，使用改进的提示词
    const result = await callZhipuAI({
      model: "glm-4-flash", // 使用更快的模型
      messages: [
        {
          role: "system",
          content: `你是一个高级对话记忆提取专家，能够从对话中提取重要信息作为角色的记忆。
          你的任务是识别对话中最有价值的信息，这些信息应该帮助角色(${roleInfo.name})在未来的对话中更好地理解和服务用户。
          提取的记忆应该简洁、具体、有用，并且能够帮助角色维持对话的连贯性和个性化。`
        },
        {
          role: "user",
          content: `请从以下对话中提取4-6条重要信息，这些信息应该作为角色(${roleInfo.name})的记忆被保存。

          重点关注以下类型的信息（按优先级排序）：
          1. 用户的个人信息（姓名、年龄、职业、家庭状况等）
          2. 用户的兴趣爱好、偏好和价值观
          3. 用户提到的重要经历、成就或挑战
          4. 用户的情感状态、需求和期望
          5. 用户与角色之间建立的关系动态或共识
          6. 对话中的重要决定、计划或承诺
          7. 可能在未来对话中有用的上下文信息

          已知的用户信息（如果有）：
          ${userInfo ? JSON.stringify(userInfo, null, 2) : '无'}

          对话内容：
          ${conversationText}

          请以JSON格式返回结果，格式如下：
          {
            "memories": [
              {
                "content": "记忆内容（简洁的一句话，不超过30个字）",
                "importance": 0.8,
                "category": "个人信息/兴趣爱好/情感状态/关系/计划/其他",
                "context": "记忆的上下文或来源（简短描述）"
              }
            ]
          }

          评分标准：
          - 重要性评分范围为0-1，越重要越接近1
          - 对用户长期特征的记忆（如个人信息、兴趣爱好）通常比临时状态更重要
          - 具体的信息比模糊的信息更重要
          - 用户主动分享的信息比推断出的信息更重要
          - 情感强烈的表达比中性表达更重要

          确保每条记忆都是：
          1. 准确的（直接来自对话，不要过度推断）
          2. 有用的（对未来对话有帮助）
          3. 简洁的（一句话表达清楚）
          4. 不重复的（与其他记忆内容不重叠）`
        }
      ],
      temperature: 0.2, // 降低温度以获得更一致的结果
      response_format: { type: "json_object" }
    });

    // 解析JSON结果
    const responseContent = result.choices[0].message.content;
    let memories;

    try {
      memories = JSON.parse(responseContent).memories;
    } catch (parseError) {
      console.error('解析记忆JSON失败:', parseError);
      // 尝试使用正则表达式提取JSON部分
      const jsonMatch = responseContent.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          memories = JSON.parse(jsonMatch[0]).memories;
        } catch (e) {
          console.error('二次解析记忆JSON失败:', e);
          throw new Error('无法解析AI返回的记忆数据');
        }
      } else {
        throw new Error('无法解析AI返回的记忆数据');
      }
    }

    // 添加时间戳和额外元数据
    const timestamp = new Date();
    memories.forEach(memory => {
      memory.timestamp = timestamp;
      memory.created_at = timestamp.toISOString();
      memory.source = 'chat';

      // 确保重要性是有效的数值
      if (typeof memory.importance !== 'number' || isNaN(memory.importance)) {
        memory.importance = 0.5; // 默认中等重要性
      }

      // 限制重要性在0-1范围内
      memory.importance = Math.max(0, Math.min(1, memory.importance));
    });

    // 对记忆进行去重和排序
    memories = deduplicateMemories(memories);
    memories.sort((a, b) => b.importance - a.importance);

    return memories;
  } catch (error) {
    console.error('从对话中提取记忆失败:', error);
    throw error;
  }
}

// 从消息中提取用户信息
async function extractUserInfoFromMessages(messages) {
  // 如果消息少于3条，可能没有足够的信息
  if (!messages || messages.length < 3) {
    return null;
  }

  try {
    // 只考虑用户发送的消息
    const userMessages = messages.filter(msg => msg.sender_type === 'user');
    if (userMessages.length === 0) return null;

    // 合并用户消息内容
    const userContent = userMessages.map(msg => msg.content).join('\n');

    // 使用简单的规则提取可能的用户信息
    const nameMatch = userContent.match(/我叫([\u4e00-\u9fa5a-zA-Z]+)|我是([\u4e00-\u9fa5a-zA-Z]+)|我的名字是([\u4e00-\u9fa5a-zA-Z]+)/);
    const ageMatch = userContent.match(/我(\d+)岁|我今年(\d+)岁|我今年(\d+)|我(\d+)年|我(\d+)了/);
    const genderMatch = userContent.match(/我是(男生|女生|男孩|女孩|男人|女人|男的|女的)/);
    const jobMatch = userContent.match(/我是([\u4e00-\u9fa5a-zA-Z]+师|[\u4e00-\u9fa5a-zA-Z]+员|学生|老师|医生|工程师|程序员|设计师|律师|会计师|销售|经理|主管|老板|创业者|自由职业者)/);

    // 构建用户信息对象
    const userInfo = {};

    if (nameMatch) {
      userInfo.name = nameMatch[1] || nameMatch[2] || nameMatch[3];
    }

    if (ageMatch) {
      const age = parseInt(ageMatch[1] || ageMatch[2] || ageMatch[3] || ageMatch[4] || ageMatch[5]);
      if (!isNaN(age) && age > 0 && age < 120) {
        userInfo.age = age;
      }
    }

    if (genderMatch) {
      userInfo.gender = genderMatch[1];
    }

    if (jobMatch) {
      userInfo.occupation = jobMatch[1];
    }

    // 如果没有提取到任何信息，返回null
    if (Object.keys(userInfo).length === 0) {
      return null;
    }

    return userInfo;
  } catch (error) {
    console.error('提取用户信息失败:', error);
    return null;
  }
}

// 去除重复或高度相似的记忆
function deduplicateMemories(memories) {
  if (!memories || memories.length <= 1) {
    return memories;
  }

  const result = [];
  const contentSet = new Set();

  for (const memory of memories) {
    // 创建一个简化版本用于比较（去除标点和空格）
    const simplifiedContent = memory.content
      .replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '')
      .toLowerCase();

    // 如果内容不重复，添加到结果中
    if (!contentSet.has(simplifiedContent)) {
      contentSet.add(simplifiedContent);
      result.push(memory);
    }
  }

  return result;
}

// 更新角色记忆
async function updateRoleMemories(roleId, newMemories) {
  try {
    // 获取角色当前记忆
    const role = await db.collection('roles').doc(roleId).get();
    if (!role.data) {
      throw new Error('角色不存在');
    }

    // 合并现有记忆和新记忆
    const existingMemories = role.data.memories || [];
    let allMemories = [...existingMemories, ...newMemories];

    // 如果记忆总数超过50条，进行记忆合并或删除
    if (allMemories.length > 50) {
      // 按重要性排序
      allMemories.sort((a, b) => b.importance - a.importance);

      // 保留前30条重要记忆
      const importantMemories = allMemories.slice(0, 30);

      // 对剩余记忆进行合并
      const remainingMemories = allMemories.slice(30);
      const mergedMemories = await mergeMemories(remainingMemories);

      // 更新记忆列表
      allMemories = [...importantMemories, ...mergedMemories];
    }

    // 更新角色记忆
    await db.collection('roles').doc(roleId).update({
      data: {
        memories: allMemories,
        updateTime: db.serverDate()
      }
    });

    return allMemories;
  } catch (error) {
    console.error('更新角色记忆失败:', error);
    throw error;
  }
}

// 合并相似记忆
async function mergeMemories(memories) {
  // 如果记忆数量少于阈值，无需合并
  if (memories.length <= 5) {
    return memories;
  }

  try {
    // 首先尝试使用本地聚类算法对记忆进行分组
    const clusters = clusterMemoriesByCategory(memories);

    // 如果聚类成功且有多个聚类，处理每个聚类
    if (clusters && Object.keys(clusters).length > 1) {
      const mergedResults = [];

      // 对每个聚类单独处理
      for (const category in clusters) {
        const clusterMemories = clusters[category];

        // 如果聚类内记忆数量少，直接保留最重要的
        if (clusterMemories.length <= 2) {
          clusterMemories.sort((a, b) => b.importance - a.importance);
          mergedResults.push(clusterMemories[0]);
          continue;
        }

        // 对较大的聚类，使用AI合并
        const clusterMerged = await mergeCluster(clusterMemories, category);
        mergedResults.push(...clusterMerged);
      }

      // 如果合并后的结果数量合适，直接返回
      if (mergedResults.length >= 3 && mergedResults.length <= 7) {
        return mergedResults;
      }

      // 如果合并后的结果数量过多，按重要性排序并截取
      if (mergedResults.length > 7) {
        mergedResults.sort((a, b) => b.importance - a.importance);
        return mergedResults.slice(0, 7);
      }
    }

    // 如果本地聚类不理想，使用AI进行全局合并
    // 将记忆内容合并为文本，包含更多元数据
    const memoriesText = memories.map(memory => {
      const categoryInfo = memory.category ? `[${memory.category}] ` : '';
      const timeInfo = memory.timestamp ? `[${new Date(memory.timestamp).toLocaleDateString()}] ` : '';
      return `- ${categoryInfo}${timeInfo}${memory.content} (重要性: ${memory.importance.toFixed(2)})`;
    }).join('\n');

    // 调用智谱AI合并记忆，使用改进的提示词
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: `你是一个高级记忆整合专家，能够将多条相似或相关的记忆合并为更少的高质量记忆。
          你的任务是分析一组记忆，识别共同主题和重叠信息，然后创建更简洁、更全面的记忆摘要。
          合并后的记忆应该保留原始记忆中最重要的信息，同时减少冗余和重复。`
        },
        {
          role: "user",
          content: `请将以下记忆合并为4-6条更概括的高质量记忆，保留最重要和最有用的信息：

          ${memoriesText}

          合并规则：
          1. 识别相似主题的记忆并将它们组合成一条更全面的记忆
          2. 保留具体的细节和重要的事实，避免过度概括
          3. 优先保留高重要性的信息
          4. 确保不同类别的重要信息都有所保留
          5. 合并后的记忆应该简洁明了，每条不超过30个字

          请以JSON格式返回结果，格式如下：
          {
            "memories": [
              {
                "content": "合并后的记忆内容",
                "importance": 0.8,
                "category": "个人信息/兴趣爱好/情感状态/关系/计划/其他",
                "context": "这条记忆合并自哪些原始记忆（简短描述）"
              }
            ]
          }

          重要性评分范围为0-1，越重要越接近1。`
        }
      ],
      temperature: 0.2,
      response_format: { type: "json_object" }
    });

    // 解析JSON结果
    const responseContent = result.choices[0].message.content;
    let mergedMemories;

    try {
      mergedMemories = JSON.parse(responseContent).memories;
    } catch (parseError) {
      console.error('解析合并记忆JSON失败:', parseError);
      // 如果解析失败，使用本地合并算法
      return localMergeMemories(memories);
    }

    // 添加时间戳和元数据
    const timestamp = new Date();
    mergedMemories.forEach(memory => {
      memory.timestamp = timestamp;
      memory.created_at = timestamp.toISOString();
      memory.source = 'merged';

      // 确保重要性是有效的数值
      if (typeof memory.importance !== 'number' || isNaN(memory.importance)) {
        memory.importance = 0.5; // 默认中等重要性
      }

      // 限制重要性在0-1范围内
      memory.importance = Math.max(0, Math.min(1, memory.importance));
    });

    // 对合并后的记忆进行去重和排序
    const uniqueMergedMemories = deduplicateMemories(mergedMemories);
    uniqueMergedMemories.sort((a, b) => b.importance - a.importance);

    return uniqueMergedMemories;
  } catch (error) {
    console.error('合并记忆失败:', error);
    // 如果AI合并失败，使用本地合并算法
    return localMergeMemories(memories);
  }
}

// 按类别聚类记忆
function clusterMemoriesByCategory(memories) {
  if (!memories || memories.length === 0) {
    return null;
  }

  try {
    // 初始化聚类
    const clusters = {};

    // 首先按category字段分组
    memories.forEach(memory => {
      const category = memory.category || '未分类';
      if (!clusters[category]) {
        clusters[category] = [];
      }
      clusters[category].push(memory);
    });

    // 如果没有category字段或所有记忆都在同一类别，尝试使用关键词聚类
    if (Object.keys(clusters).length <= 1) {
      return clusterMemoriesByKeywords(memories);
    }

    return clusters;
  } catch (error) {
    console.error('按类别聚类记忆失败:', error);
    return null;
  }
}

// 使用关键词聚类记忆
function clusterMemoriesByKeywords(memories) {
  try {
    // 提取每条记忆的关键词
    const memoryKeywords = memories.map(memory => ({
      memory,
      keywords: extractKeywords(memory.content.toLowerCase())
    }));

    // 初始化聚类
    const clusters = {};
    let clusterCount = 0;

    // 为每条记忆找到最匹配的聚类
    memoryKeywords.forEach(({ memory, keywords }) => {
      let bestCluster = null;
      let bestScore = 0.3; // 最小相似度阈值

      // 计算与每个现有聚类的相似度
      for (const clusterId in clusters) {
        const clusterKeywords = clusters[clusterId].keywords;
        const commonKeywords = keywords.filter(word => clusterKeywords.includes(word));
        const similarity = commonKeywords.length / Math.sqrt(keywords.length * clusterKeywords.length);

        if (similarity > bestScore) {
          bestScore = similarity;
          bestCluster = clusterId;
        }
      }

      // 如果找到匹配的聚类，添加到该聚类
      if (bestCluster !== null) {
        clusters[bestCluster].memories.push(memory);
        // 更新聚类关键词（合并新记忆的关键词）
        clusters[bestCluster].keywords = [...new Set([...clusters[bestCluster].keywords, ...keywords])];
      } else {
        // 否则创建新聚类
        const newClusterId = `cluster_${clusterCount++}`;
        clusters[newClusterId] = {
          memories: [memory],
          keywords: keywords
        };
      }
    });

    // 转换为期望的格式
    const result = {};
    for (const clusterId in clusters) {
      result[clusterId] = clusters[clusterId].memories;
    }

    return result;
  } catch (error) {
    console.error('按关键词聚类记忆失败:', error);
    return null;
  }
}

// 合并单个聚类的记忆
async function mergeCluster(clusterMemories, category) {
  if (clusterMemories.length <= 2) {
    return clusterMemories;
  }

  try {
    // 将聚类内记忆合并为文本
    const memoriesText = clusterMemories.map(memory =>
      `- ${memory.content} (重要性: ${memory.importance.toFixed(2)})`
    ).join('\n');

    // 调用智谱AI合并聚类内记忆
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: "你是一个记忆整合专家，能够将相似主题的多条记忆合并为更少的高质量记忆。"
        },
        {
          role: "user",
          content: `请将以下关于"${category}"主题的记忆合并为1-2条更概括的记忆，保留最重要的信息：

          ${memoriesText}

          请以JSON格式返回结果，格式如下：
          {
            "memories": [
              {
                "content": "合并后的记忆内容（简洁的一句话，不超过30个字）",
                "importance": 0.8,
                "category": "${category}"
              }
            ]
          }

          重要性评分范围为0-1，越重要越接近1。`
        }
      ],
      temperature: 0.2,
      response_format: { type: "json_object" }
    });

    // 解析JSON结果
    const responseContent = result.choices[0].message.content;
    let mergedMemories;

    try {
      mergedMemories = JSON.parse(responseContent).memories;

      // 添加时间戳和元数据
      const timestamp = new Date();
      mergedMemories.forEach(memory => {
        memory.timestamp = timestamp;
        memory.created_at = timestamp.toISOString();
        memory.source = 'merged';
        memory.context = `合并自${category}类别的${clusterMemories.length}条记忆`;
      });

      return mergedMemories;
    } catch (parseError) {
      console.error(`解析聚类"${category}"合并记忆JSON失败:`, parseError);
      // 如果解析失败，返回聚类中最重要的记忆
      clusterMemories.sort((a, b) => b.importance - a.importance);
      return [clusterMemories[0]];
    }
  } catch (error) {
    console.error(`合并聚类"${category}"记忆失败:`, error);
    // 如果合并失败，返回聚类中最重要的记忆
    clusterMemories.sort((a, b) => b.importance - a.importance);
    return [clusterMemories[0]];
  }
}

// 本地合并记忆算法（当AI合并失败时的后备方案）
function localMergeMemories(memories) {
  try {
    // 按重要性排序
    memories.sort((a, b) => b.importance - a.importance);

    // 如果有类别信息，确保每个类别都有代表
    const categories = new Set(memories.filter(m => m.category).map(m => m.category));

    // 如果有多个类别，从每个类别选择最重要的记忆
    if (categories.size >= 2) {
      const result = [];

      // 从每个类别选择最重要的记忆
      categories.forEach(category => {
        const categoryMemories = memories.filter(m => m.category === category);
        if (categoryMemories.length > 0) {
          categoryMemories.sort((a, b) => b.importance - a.importance);
          result.push(categoryMemories[0]);
        }
      });

      // 如果结果不足5条，添加剩余最重要的记忆
      if (result.length < 5) {
        const remainingMemories = memories.filter(m => !result.includes(m));
        remainingMemories.sort((a, b) => b.importance - a.importance);
        result.push(...remainingMemories.slice(0, 5 - result.length));
      }

      return result;
    }

    // 如果没有类别信息或只有一个类别，直接返回最重要的5条
    return memories.slice(0, 5);
  } catch (error) {
    console.error('本地合并记忆失败:', error);
    // 最后的后备方案：简单地返回最重要的5条
    memories.sort((a, b) => b.importance - a.importance);
    return memories.slice(0, 5);
  }
}

// 获取相关记忆
async function getRelevantMemories(roleId, currentContext, limit = 5) {
  try {
    // 获取角色所有记忆
    const role = await db.collection('roles').doc(roleId).get();
    if (!role.data || !role.data.memories || role.data.memories.length === 0) {
      return [];
    }

    const memories = role.data.memories;

    // 如果记忆数量少于或等于限制数量，直接按重要性排序返回所有记忆
    if (memories.length <= limit) {
      memories.sort((a, b) => b.importance - a.importance);
      return memories;
    }

    // 如果没有当前上下文，按重要性和时间排序返回
    if (!currentContext) {
      // 创建一个组合分数，考虑重要性和时间因素
      const scoredMemories = memories.map(memory => {
        // 计算时间衰减因子（越新的记忆分数越高）
        let timeScore = 0;
        if (memory.timestamp) {
          const age = Date.now() - new Date(memory.timestamp).getTime();
          const daysSinceCreation = age / (1000 * 60 * 60 * 24);
          // 使用指数衰减函数，30天后权重减半
          timeScore = Math.exp(-daysSinceCreation / 30);
        }

        // 计算最终分数（70%重要性 + 30%时间因素）
        const finalScore = (memory.importance * 0.7) + (timeScore * 0.3);

        return {
          ...memory,
          score: finalScore
        };
      });

      // 按组合分数排序
      scoredMemories.sort((a, b) => b.score - a.score);

      // 返回前limit条记忆，移除临时评分字段
      return scoredMemories.slice(0, limit).map(({ score, ...memory }) => memory);
    }

    // 预处理：使用本地过滤减少需要评估的记忆数量
    const preFilteredMemories = prefilterMemories(memories, currentContext, Math.min(20, memories.length));

    // 如果预过滤后的记忆数量小于等于限制数量，直接返回
    if (preFilteredMemories.length <= limit) {
      return preFilteredMemories;
    }

    // 如果有当前上下文，调用智谱AI计算相关性
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: `你是一个高级记忆检索专家，能够从多条记忆中找出与当前上下文最相关的记忆。
          你的任务是分析当前对话上下文，并从记忆库中检索最相关的记忆，这些记忆应该对当前对话有帮助。
          你应该考虑语义相关性、主题匹配度、情感一致性和时间相关性等多个因素。`
        },
        {
          role: "user",
          content: `请从以下记忆中选出与当前上下文最相关的${limit}条记忆，并按相关性从高到低排序。

          当前对话上下文：
          ${currentContext}

          记忆库（按索引编号）：
          ${preFilteredMemories.map((memory, index) => {
            // 构建更丰富的记忆描述，包括类别和时间信息
            let timeInfo = '';
            if (memory.timestamp) {
              const date = new Date(memory.timestamp);
              if (!isNaN(date.getTime())) {
                timeInfo = `[${date.toLocaleDateString()}] `;
              }
            }

            let categoryInfo = memory.category ? `[${memory.category}] ` : '';

            return `${index+1}. ${timeInfo}${categoryInfo}${memory.content} (重要性: ${memory.importance.toFixed(2)})`;
          }).join('\n')}

          评估标准：
          1. 语义相关性：记忆内容与当前对话主题的相关程度
          2. 信息价值：记忆能为当前对话提供的有用信息量
          3. 时间相关性：最近的记忆可能更相关，但如果旧记忆内容高度相关则优先考虑
          4. 情感一致性：记忆与当前对话情感基调的匹配度

          请以JSON格式返回结果，格式如下：
          {
            "relevant_memories": [
              {
                "index": 1,
                "relevance": 0.9,
                "reason": "简短说明为什么这条记忆相关（不超过15个字）"
              }
            ]
          }

          相关性评分范围为0-1，越相关越接近1。只返回索引、相关性评分和简短理由，不需要返回记忆内容。`
        }
      ],
      temperature: 0.2,
      response_format: { type: "json_object" }
    });

    // 解析JSON结果
    const responseContent = result.choices[0].message.content;
    let relevantIndices;

    try {
      relevantIndices = JSON.parse(responseContent).relevant_memories;
    } catch (parseError) {
      console.error('解析相关记忆JSON失败:', parseError);
      // 如果解析失败，返回预过滤的记忆
      return preFilteredMemories.slice(0, limit);
    }

    // 获取相关记忆
    const relevantMemories = relevantIndices
      .map(item => ({
        ...preFilteredMemories[item.index - 1],
        relevance: item.relevance,
        reason: item.reason || null
      }))
      .sort((a, b) => b.relevance - a.relevance)
      .slice(0, limit);

    // 缓存检索结果（可选，用于性能优化）
    cacheRetrievalResult(roleId, currentContext, relevantMemories);

    return relevantMemories;
  } catch (error) {
    console.error('获取相关记忆失败:', error);

    // 如果AI调用失败，使用本地过滤算法
    try {
      const role = await db.collection('roles').doc(roleId).get();
      if (!role.data || !role.data.memories) {
        return [];
      }

      const memories = role.data.memories;
      return prefilterMemories(memories, currentContext, limit);
    } catch (fallbackError) {
      console.error('本地过滤记忆也失败:', fallbackError);

      // 最后的后备方案：按重要性返回
      const role = await db.collection('roles').doc(roleId).get();
      if (!role.data || !role.data.memories) {
        return [];
      }

      const memories = role.data.memories;
      memories.sort((a, b) => b.importance - a.importance);
      return memories.slice(0, limit);
    }
  }
}

// 本地预过滤记忆
function prefilterMemories(memories, context, limit) {
  if (!context || !memories || memories.length === 0) {
    return [];
  }

  try {
    // 将上下文转换为小写并分词（简单实现）
    const contextWords = extractKeywords(context.toLowerCase());

    // 为每条记忆计算一个简单的相关性分数
    const scoredMemories = memories.map(memory => {
      // 提取记忆内容的关键词
      const memoryWords = extractKeywords(memory.content.toLowerCase());

      // 计算关键词匹配数
      const matchCount = memoryWords.filter(word => contextWords.includes(word)).length;

      // 计算基于关键词的相关性分数
      let keywordScore = 0;
      if (memoryWords.length > 0) {
        keywordScore = matchCount / Math.sqrt(memoryWords.length);
      }

      // 考虑记忆的重要性
      const importanceScore = memory.importance || 0.5;

      // 考虑时间因素（如果有）
      let recencyScore = 0.5; // 默认中等时间分数
      if (memory.timestamp) {
        const age = Date.now() - new Date(memory.timestamp).getTime();
        const daysSinceCreation = age / (1000 * 60 * 60 * 24);
        // 使用指数衰减函数，30天后权重减半
        recencyScore = Math.exp(-daysSinceCreation / 30);
      }

      // 计算最终分数（50%关键词匹配 + 30%重要性 + 20%时间因素）
      const finalScore = (keywordScore * 0.5) + (importanceScore * 0.3) + (recencyScore * 0.2);

      return {
        ...memory,
        score: finalScore
      };
    });

    // 按分数排序
    scoredMemories.sort((a, b) => b.score - a.score);

    // 返回前limit条记忆，移除临时评分字段
    return scoredMemories.slice(0, limit).map(({ score, ...memory }) => memory);
  } catch (error) {
    console.error('预过滤记忆失败:', error);
    // 如果预过滤失败，按重要性返回
    memories.sort((a, b) => b.importance - a.importance);
    return memories.slice(0, limit);
  }
}

// 提取文本中的关键词（简单实现）
function extractKeywords(text) {
  if (!text) return [];

  // 中文停用词
  const stopWords = ['的', '了', '是', '在', '我', '有', '和', '就', '不', '人', '都',
                    '一', '一个', '上', '也', '很', '到', '说', '要', '去', '你', '会',
                    '着', '没有', '看', '好', '自己', '这', '那', '这个', '那个', '这样',
                    '那样', '以', '以及', '以后', '可以', '可能', '而', '但是', '但', '吧'];

  // 简单分词（按空格和标点符号分割）
  const words = text.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, ' ')
                   .split(/\s+/)
                   .filter(word => word.length > 0 && !stopWords.includes(word));

  return [...new Set(words)]; // 去重
}

// 缓存检索结果（可选，用于性能优化）
function cacheRetrievalResult(roleId, context, memories) {
  // 这里可以实现缓存逻辑，例如将结果存储在内存或数据库中
  // 为了简化，这里只是一个占位函数
  return;
}

// 导出函数
module.exports = {
  extractMemoriesFromChat,
  updateRoleMemories,
  getRelevantMemories,
  mergeMemories,
  // 导出辅助函数，以便其他模块可以使用
  deduplicateMemories,
  extractKeywords
};

*#*#*end*#*#*

*#*#*cloudfunctions\roles\package.json*#*#*begin*#*#*
{
  "name": "roles",
  "version": "1.0.0",
  "description": "角色管理云函数",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\roles\promptGenerator.js*#*#*begin*#*#*
// 提示词生成模块
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

// 调用智谱AI接口
async function callZhipuAI(params) {
  try {
    // 从环境变量获取API密钥
    const apiKey = process.env.ZHIPU_API_KEY || '';
    if (!apiKey) {
      console.error('未设置ZHIPU_API_KEY环境变量');
      throw new Error('智谱AI API密钥未配置');
    }

    // 构建请求头
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    };

    // 构建请求体
    const body = JSON.stringify({
      model: params.model || 'glm-4',
      messages: params.messages,
      temperature: params.temperature || 0.7,
      top_p: params.top_p || 0.8,
      max_tokens: params.max_tokens || 2000,
      response_format: params.response_format || { type: "text" }
    });

    console.log(`调用智谱AI接口, 模型: ${params.model || 'glm-4'}`);

    // 发送请求
    const response = await cloud.callFunction({
      name: 'httpRequest',
      data: {
        url: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
        method: 'POST',
        headers: headers,
        body: body
      }
    });

    // 检查响应是否有错误
    if (response.result.error) {
      console.error('智谱AI返回错误:', response.result);
      throw new Error(`智谱AI调用失败: ${response.result.message || '未知错误'}`);
    }

    // 解析响应
    const result = JSON.parse(response.result.body);

    // 检查智谱AI响应是否有错误
    if (result.error) {
      console.error('智谱AI API返回错误:', result.error);
      throw new Error(`智谱AI API错误: ${result.error.message || result.error.type || '未知错误'}`);
    }

    return result;
  } catch (error) {
    console.error('调用智谱AI接口失败:', error);
    throw error;
  }
}

// 生成基础角色提示词
async function generateBasePrompt(roleInfo) {
  try {
    // 构建角色描述
    const roleDescription = `
      角色名称：${roleInfo.name}
      与用户关系：${roleInfo.relationship || '无特定关系'}
      年龄：${roleInfo.age || '未指定'}
      性别：${roleInfo.gender || '未指定'}
      背景故事：${roleInfo.background || '无特定背景'}
      教育背景：${roleInfo.education || '未指定'}
      职业：${roleInfo.occupation || '未指定'}
      爱好：${Array.isArray(roleInfo.hobbies) ? roleInfo.hobbies.join(', ') : (roleInfo.hobbies || '无特定爱好')}
      性格特点：${Array.isArray(roleInfo.personality_traits) ? roleInfo.personality_traits.join(', ') : (roleInfo.personality_traits || '无特定性格特点')}
      说话方式：${roleInfo.communication_style || '自然的说话方式'}
      情感倾向：${roleInfo.emotional_tendency || '平衡的情感表达'}
    `;

    // 调用智谱AI生成提示词
    const result = await callZhipuAI({
      model: "glm-4",
      messages: [
        {
          role: "system",
          content: "你是一个角色提示词生成专家，能够根据用户提供的角色信息生成高质量的角色扮演提示词。"
        },
        {
          role: "user",
          content: `请根据以下角色信息生成一个详细的角色扮演提示词：

          ${roleDescription}

          提示词应包含：
          1. 角色的自我认知和身份定位
          2. 与用户的关系定位和互动方式
          3. 说话风格、语气和表达方式的具体指导
          4. 应该避免的行为和表达
          5. 如何根据角色特点回应用户的情感需求（如何安慰、鼓励或适当批评用户）
          6. 如何自然地了解用户的兴趣和偏好
          7. 对话风格指导：
             - 使用非常简短的对话方式，尽量模仿真实手机聊天
             - 每条消息不超过1-2句话，尽量保持简洁
             - 将长回复拆分成多条非常短小的消息，就像真实人类在聊天软件中发消息一样
             - 避免使用长句和复杂句式，使用简单直接的表达
             - 当需要表达复杂想法时，将内容分成多个非常简短的消息，每条消息只表达一个简单观点

          8. 格式要求：
             - 绝对不要使用Markdown语法，如双星号加粗、单星号斜体、反引号代码等
             - 不要使用标题格式如#或##
             - 列表项直接使用数字或文字开头，不要使用特殊符号如-或*
             - 当需要列举多个要点时，直接使用“1.”“2.”等编号，不要使用特殊格式
             - 尽量使用简单的纯文本格式，就像在手机聊天软件中发送消息一样

          请直接给出提示词内容，不要包含解释。提示词应该简洁有效，不超过800字。`
        }
      ],
      temperature: 0.7,
      top_p: 0.8,
      max_tokens: 2000
    });

    // 返回生成的提示词
    return result.choices[0].message.content;
  } catch (error) {
    console.error('生成基础角色提示词失败:', error);
    throw error;
  }
}

// 生成带记忆的提示词
async function generatePromptWithMemories(basePrompt, memories) {
  if (!memories || memories.length === 0) {
    return basePrompt;
  }

  try {
    // 按类别和重要性组织记忆
    const organizedMemories = organizeMemoriesByCategory(memories);

    // 构建更结构化的记忆描述
    let memoriesText = '';

    // 遍历每个类别
    for (const category in organizedMemories) {
      // 添加类别标题
      memoriesText += `【${category}】\n`;

      // 添加该类别下的记忆
      organizedMemories[category].forEach(memory => {
        // 添加记忆内容，包括上下文（如果有）
        const contextInfo = memory.context ? ` (来源: ${memory.context})` : '';
        memoriesText += `- ${memory.content}${contextInfo}\n`;
      });

      // 类别之间添加空行
      memoriesText += '\n';
    }

    // 调用智谱AI融合提示词和记忆，使用改进的提示词
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: `你是一个高级提示词优化专家，能够将角色记忆自然地融入到角色提示词中。
          你的任务是分析角色记忆，识别其中的关键信息，并将这些信息无缝地整合到角色提示词中，
          使角色能够在对话中自然地展现出对这些记忆的了解，而不是生硬地列举事实。
          记忆应该影响角色的行为、态度和回应方式，使角色表现得更加个性化和连贯。`
        },
        {
          role: "user",
          content: `我有一个角色的基础提示词和一组该角色关于用户的记忆。请将这些记忆自然地融入到提示词中，使角色能够在对话中展现出对用户的了解。

          基础提示词：
          ${basePrompt}

          角色记忆（按类别组织）：
          ${memoriesText}

          融合要求：
          1. 不要简单地在提示词末尾添加记忆列表，而是将记忆内容自然地融入到提示词的相关部分
          2. 根据记忆调整角色的行为指导，例如"当用户提到X时，你应该记得Y并做出相应回应"
          3. 保持提示词的整体风格和语调一致，不要有明显的拼接痕迹
          4. 确保所有重要记忆都被融入，但可以合并或重新表述相似的记忆
          5. 添加指导，使角色能够在适当的时机自然地提及这些记忆，而不是生硬地列举
          6. 记忆应该影响角色的个性和互动方式，使其更加个性化
          7. 保持提示词的简洁性，不要因为融入记忆而使提示词变得冗长

          请给出融合了记忆的完整提示词。不要添加额外的解释，直接给出结果。`
        }
      ],
      temperature: 0.3, // 降低温度以获得更一致的结果
      max_tokens: 2000
    });

    // 返回融合了记忆的提示词
    return result.choices[0].message.content;
  } catch (error) {
    console.error('生成带记忆的提示词失败:', error);

    // 如果AI调用失败，尝试使用本地方法融合记忆
    try {
      return localMergeMemoriesWithPrompt(basePrompt, memories);
    } catch (fallbackError) {
      console.error('本地融合记忆也失败:', fallbackError);
      // 如果本地方法也失败，返回基础提示词
      return basePrompt;
    }
  }
}

// 按类别组织记忆
function organizeMemoriesByCategory(memories) {
  // 初始化结果对象
  const result = {};

  // 遍历所有记忆
  memories.forEach(memory => {
    // 获取记忆类别，如果没有则归为"其他"
    const category = memory.category || '其他信息';

    // 如果该类别不存在，创建一个空数组
    if (!result[category]) {
      result[category] = [];
    }

    // 将记忆添加到对应类别
    result[category].push(memory);
  });

  // 对每个类别内的记忆按重要性排序
  for (const category in result) {
    result[category].sort((a, b) => b.importance - a.importance);
  }

  return result;
}

// 本地方法融合记忆和提示词（当AI调用失败时的后备方案）
function localMergeMemoriesWithPrompt(basePrompt, memories) {
  if (!memories || memories.length === 0) {
    return basePrompt;
  }

  try {
    // 按重要性排序记忆
    memories.sort((a, b) => b.importance - a.importance);

    // 构建记忆部分
    const memorySection = `

关于用户的重要信息：
${memories.map(memory => `- ${memory.content}`).join('\n')}

请在对话中自然地运用这些信息，使对话更加个性化，但不要直接列举这些事实。根据上下文适当地展示你记得用户的信息。`;

    // 将记忆部分添加到提示词末尾
    return basePrompt + memorySection;
  } catch (error) {
    console.error('本地融合记忆失败:', error);
    return basePrompt;
  }
}

// 生成带用户画像的提示词
async function generatePromptWithUserPerception(basePrompt, userPerception) {
  if (!userPerception) {
    return basePrompt;
  }

  try {
    // 构建用户画像描述
    const userPerceptionText = `
      用户兴趣: ${Array.isArray(userPerception.interests) ? userPerception.interests.join(', ') : '未知'}
      用户偏好: ${Array.isArray(userPerception.preferences) ? userPerception.preferences.join(', ') : '未知'}
      用户沟通风格: ${userPerception.communication_style || '未知'}
      用户情感模式: ${Array.isArray(userPerception.emotional_patterns) ? userPerception.emotional_patterns.join(', ') : '未知'}
    `;

    // 调用智谱AI融合提示词和用户画像
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: "你是一个提示词优化专家，能够将用户画像融入到角色提示词中。"
        },
        {
          role: "user",
          content: `我有一个角色的提示词和一些关于用户的信息。请将用户信息自然地融入到提示词中，使角色能够根据用户的兴趣、偏好和沟通风格进行互动。

          提示词：
          ${basePrompt}

          用户信息：
          ${userPerceptionText}

          请给出融合了用户信息的完整提示词。不要添加额外的解释，直接给出结果。`
        }
      ],
      temperature: 0.5,
      max_tokens: 2000
    });

    // 返回融合了用户画像的提示词
    return result.choices[0].message.content;
  } catch (error) {
    console.error('生成带用户画像的提示词失败:', error);
    // 如果失败，返回原始提示词
    return basePrompt;
  }
}

// 导出函数
module.exports = {
  generateBasePrompt,
  generatePromptWithMemories,
  generatePromptWithUserPerception
};

*#*#*end*#*#*

*#*#*cloudfunctions\roles\test-zhipu.js*#*#*begin*#*#*
// 测试智谱AI接口调用
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

/**
 * 测试智谱AI接口调用
 * 此函数用于测试roles云函数是否能成功调用智谱AI接口
 */
async function testZhipuAI() {
  try {
    // 从环境变量获取API密钥
    const apiKey = process.env.ZHIPU_API_KEY || '';
    if (!apiKey) {
      console.error('未设置ZHIPU_API_KEY环境变量');
      return {
        success: false,
        error: '智谱AI API密钥未配置'
      };
    }
    
    console.log('开始测试智谱AI接口调用');
    
    // 构建请求头
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    };
    
    // 构建请求体
    const body = JSON.stringify({
      model: 'glm-4-flash',
      messages: [
        {
          role: 'user',
          content: '你好，这是一条测试消息。'
        }
      ],
      temperature: 0.7,
      max_tokens: 100
    });
    
    console.log('调用httpRequest云函数');
    
    // 发送请求
    const response = await cloud.callFunction({
      name: 'httpRequest',
      data: {
        url: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
        method: 'POST',
        headers: headers,
        body: body
      }
    });
    
    console.log('httpRequest云函数调用结果:', response);
    
    // 检查响应是否有错误
    if (response.result.error) {
      console.error('智谱AI返回错误:', response.result);
      return {
        success: false,
        error: `智谱AI调用失败: ${response.result.message || '未知错误'}`
      };
    }
    
    // 解析响应
    const result = JSON.parse(response.result.body);
    
    // 检查智谱AI响应是否有错误
    if (result.error) {
      console.error('智谱AI API返回错误:', result.error);
      return {
        success: false,
        error: `智谱AI API错误: ${result.error.message || result.error.type || '未知错误'}`
      };
    }
    
    // 提取AI回复
    const aiReply = result.choices[0].message.content;
    
    return {
      success: true,
      message: '智谱AI接口调用成功',
      reply: aiReply
    };
  } catch (error) {
    console.error('测试智谱AI接口调用失败:', error);
    return {
      success: false,
      error: error.message || '测试智谱AI接口调用失败'
    };
  }
}

// 导出测试函数
module.exports = {
  testZhipuAI
};

*#*#*end*#*#*

*#*#*cloudfunctions\roles\userPerception.js*#*#*begin*#*#*
// 用户画像模块
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();
const _ = db.command;
const $ = db.command.aggregate;

// 调用智谱AI接口
async function callZhipuAI(params) {
  try {
    // 从环境变量获取API密钥
    const apiKey = process.env.ZHIPU_API_KEY || '';
    if (!apiKey) {
      console.error('未设置ZHIPU_API_KEY环境变量');
      throw new Error('智谱AI API密钥未配置');
    }

    // 构建请求头
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    };

    // 构建请求体
    const body = JSON.stringify({
      model: params.model || 'glm-4',
      messages: params.messages,
      temperature: params.temperature || 0.7,
      top_p: params.top_p || 0.8,
      max_tokens: params.max_tokens || 2000,
      response_format: params.response_format || { type: "text" }
    });

    console.log(`调用智谱AI接口, 模型: ${params.model || 'glm-4'}`);

    // 发送请求
    const response = await cloud.callFunction({
      name: 'httpRequest',
      data: {
        url: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
        method: 'POST',
        headers: headers,
        body: body
      }
    });

    // 检查响应是否有错误
    if (response.result.error) {
      console.error('智谱AI返回错误:', response.result);
      throw new Error(`智谱AI调用失败: ${response.result.message || '未知错误'}`);
    }

    // 解析响应
    const result = JSON.parse(response.result.body);

    // 检查智谱AI响应是否有错误
    if (result.error) {
      console.error('智谱AI API返回错误:', result.error);
      throw new Error(`智谱AI API错误: ${result.error.message || result.error.type || '未知错误'}`);
    }

    return result;
  } catch (error) {
    console.error('调用智谱AI接口失败:', error);
    throw error;
  }
}

// 从对话中分析用户画像
async function analyzeUserPerception(messages, userId, roleId) {
  try {
    // 获取用户消息
    const userMessages = messages.filter(msg => msg.sender_type === 'user');
    if (userMessages.length === 0) {
      throw new Error('没有足够的用户消息进行分析');
    }

    const userText = userMessages.map(msg => msg.content).join('\n');

    // 调用智谱AI分析用户画像
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: "你是一个用户画像分析专家，能够从用户的对话中提取用户的兴趣、偏好、沟通风格和情感模式。"
        },
        {
          role: "user",
          content: `请分析以下用户消息，提取用户的兴趣、偏好、沟通风格和情感模式：

          ${userText}

          请以JSON格式返回结果，格式如下：
          {
            "interests": ["兴趣1", "兴趣2"],
            "preferences": ["偏好1", "偏好2"],
            "communication_style": "用户的沟通风格描述",
            "emotional_patterns": ["情感模式1", "情感模式2"]
          }

          注意：
          1. 兴趣指用户喜欢的活动、话题或领域
          2. 偏好指用户在选择或决策中表现出的倾向
          3. 沟通风格指用户表达自己的方式和语言特点
          4. 情感模式指用户表达情感的方式和情绪变化规律`
        }
      ],
      temperature: 0.3,
      response_format: { type: "json_object" }
    });

    // 解析JSON结果
    const responseContent = result.choices[0].message.content;
    let userPerception;

    try {
      userPerception = JSON.parse(responseContent);
    } catch (parseError) {
      console.error('解析用户画像JSON失败:', parseError);
      // 尝试使用正则表达式提取JSON部分
      const jsonMatch = responseContent.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          userPerception = JSON.parse(jsonMatch[0]);
        } catch (e) {
          console.error('二次解析用户画像JSON失败:', e);
          throw new Error('无法解析AI返回的用户画像数据');
        }
      } else {
        throw new Error('无法解析AI返回的用户画像数据');
      }
    }

    return userPerception;
  } catch (error) {
    console.error('分析用户画像失败:', error);
    throw error;
  }
}

// 更新角色的用户画像
async function updateRoleUserPerception(roleId, userId, newPerception) {
  try {
    // 获取角色当前的用户画像
    const role = await db.collection('roles').doc(roleId).get();
    if (!role.data) {
      throw new Error('角色不存在');
    }

    // 获取现有用户画像
    const existingPerception = role.data.user_perception || {
      interests: [],
      preferences: [],
      communication_style: '',
      emotional_patterns: []
    };

    // 合并新旧用户画像
    const mergedPerception = await mergeUserPerception(existingPerception, newPerception);

    // 更新角色的用户画像
    await db.collection('roles').doc(roleId).update({
      data: {
        user_perception: mergedPerception,
        updateTime: db.serverDate()
      }
    });

    return mergedPerception;
  } catch (error) {
    console.error('更新角色的用户画像失败:', error);
    throw error;
  }
}

// 合并用户画像
async function mergeUserPerception(existingPerception, newPerception) {
  try {
    // 将现有和新的用户画像转换为文本
    const existingText = `
      现有兴趣: ${Array.isArray(existingPerception.interests) ? existingPerception.interests.join(', ') : '无'}
      现有偏好: ${Array.isArray(existingPerception.preferences) ? existingPerception.preferences.join(', ') : '无'}
      现有沟通风格: ${existingPerception.communication_style || '无'}
      现有情感模式: ${Array.isArray(existingPerception.emotional_patterns) ? existingPerception.emotional_patterns.join(', ') : '无'}
    `;

    const newText = `
      新兴趣: ${Array.isArray(newPerception.interests) ? newPerception.interests.join(', ') : '无'}
      新偏好: ${Array.isArray(newPerception.preferences) ? newPerception.preferences.join(', ') : '无'}
      新沟通风格: ${newPerception.communication_style || '无'}
      新情感模式: ${Array.isArray(newPerception.emotional_patterns) ? newPerception.emotional_patterns.join(', ') : '无'}
    `;

    // 调用智谱AI合并用户画像
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: "你是一个用户画像整合专家，能够将新旧用户画像合并为更完整的用户画像。"
        },
        {
          role: "user",
          content: `请将以下现有用户画像和新的用户画像合并为一个更完整的用户画像：

          ${existingText}

          ${newText}

          请以JSON格式返回结果，格式如下：
          {
            "interests": ["兴趣1", "兴趣2"],
            "preferences": ["偏好1", "偏好2"],
            "communication_style": "用户的沟通风格描述",
            "emotional_patterns": ["情感模式1", "情感模式2"]
          }

          合并规则：
          1. 保留所有不重复的兴趣和偏好
          2. 如果新旧信息有冲突，优先保留新信息
          3. 对于沟通风格和情感模式，进行综合描述
          4. 每个类别最多保留5个最重要的项目`
        }
      ],
      temperature: 0.3,
      response_format: { type: "json_object" }
    });

    // 解析JSON结果
    const responseContent = result.choices[0].message.content;
    let mergedPerception;

    try {
      mergedPerception = JSON.parse(responseContent);
    } catch (parseError) {
      console.error('解析合并用户画像JSON失败:', parseError);
      // 如果解析失败，手动合并
      return {
        interests: [...new Set([...existingPerception.interests || [], ...newPerception.interests || []])].slice(0, 5),
        preferences: [...new Set([...existingPerception.preferences || [], ...newPerception.preferences || []])].slice(0, 5),
        communication_style: newPerception.communication_style || existingPerception.communication_style || '',
        emotional_patterns: [...new Set([...existingPerception.emotional_patterns || [], ...newPerception.emotional_patterns || []])].slice(0, 5)
      };
    }

    return mergedPerception;
  } catch (error) {
    console.error('合并用户画像失败:', error);
    // 如果合并失败，手动合并
    return {
      interests: [...new Set([...existingPerception.interests || [], ...newPerception.interests || []])].slice(0, 5),
      preferences: [...new Set([...existingPerception.preferences || [], ...newPerception.preferences || []])].slice(0, 5),
      communication_style: newPerception.communication_style || existingPerception.communication_style || '',
      emotional_patterns: [...new Set([...existingPerception.emotional_patterns || [], ...newPerception.emotional_patterns || []])].slice(0, 5)
    };
  }
}

// 生成用户画像摘要
async function generateUserPerceptionSummary(userPerception) {
  if (!userPerception) {
    return '';
  }

  try {
    // 构建用户画像文本
    const userPerceptionText = `
      用户兴趣: ${Array.isArray(userPerception.interests) ? userPerception.interests.join(', ') : '未知'}
      用户偏好: ${Array.isArray(userPerception.preferences) ? userPerception.preferences.join(', ') : '未知'}
      用户沟通风格: ${userPerception.communication_style || '未知'}
      用户情感模式: ${Array.isArray(userPerception.emotional_patterns) ? userPerception.emotional_patterns.join(', ') : '未知'}
    `;

    // 调用智谱AI生成用户画像摘要
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: "你是一个用户画像分析专家，能够将用户画像转化为自然、友好的描述。"
        },
        {
          role: "user",
          content: `请将以下用户画像转化为一段自然、友好的描述，可以在对话中自然地提及：

          ${userPerceptionText}

          要求：
          1. 描述应该自然、友好，不要像机器分析报告
          2. 长度控制在100-150字之间
          3. 可以加入一些温暖的建议或鼓励
          4. 不要使用"根据我的分析"、"我注意到"等明显的分析语言`
        }
      ],
      temperature: 0.7,
      max_tokens: 500
    });

    // 返回生成的摘要
    return result.choices[0].message.content;
  } catch (error) {
    console.error('生成用户画像摘要失败:', error);
    return '';
  }
}

// 导出函数
module.exports = {
  analyzeUserPerception,
  updateRoleUserPerception,
  generateUserPerceptionSummary
};

*#*#*end*#*#*

*#*#*cloudfunctions\testDatabase\index.js*#*#*begin*#*#*
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV }) // 使用当前云环境

// 云函数入口函数
exports.main = async (event, context) => {
  const db = cloud.database()

  try {
    // 测试数据库连接
    const testResults = {}

    // 测试集合访问
    const collectionsToTest = [
      'users',
      'roles',
      'chats',
      'messages',
      'emotionRecords',
      'roleUsage',
      'sys_config'
    ]

    // 测试每个集合
    for (const collection of collectionsToTest) {
      try {
        // 尝试获取文档数量
        const { total } = await db.collection(collection).count()
        testResults[collection] = {
          status: 'success',
          count: total
        }
      } catch (e) {
        testResults[collection] = {
          status: 'error',
          error: e.message || e
        }
      }
    }

    // 测试角色集合的读取
    try {
      const { data: roles } = await db.collection('roles').limit(1).get()
      testResults.rolesRead = {
        status: 'success',
        sample: roles
      }
    } catch (e) {
      testResults.rolesRead = {
        status: 'error',
        error: e.message || e
      }
    }

    // 测试服务器时间
    testResults.serverTime = db.serverDate()

    return {
      success: true,
      message: '数据库连接测试完成',
      results: testResults
    }
  } catch (error) {
    console.error('数据库测试失败:', error)
    return {
      success: false,
      error: error.message || error
    }
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\testDatabase\package.json*#*#*begin*#*#*
{
    "name": "initDatabase",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "dependencies": {
      "wx-server-sdk": "latest"
    }
  }
*#*#*end*#*#*

*#*#*cloudfunctions\user\createIndexes.js*#*#*begin*#*#*
/**
 * 创建数据库索引
 * 用于提高查询性能
 */

const cloud = require('wx-server-sdk');

// 初始化云环境
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

// 获取数据库引用
const db = cloud.database();

/**
 * 创建用户兴趣集合索引
 */
async function createUserInterestsIndexes() {
  try {
    console.log('开始创建 userInterests 集合索引...');
    
    // 创建 userId 索引
    await db.collection('userInterests').createIndex({
      userId: 1
    }, {
      name: 'userId_idx',
      unique: true
    });
    console.log('创建 userId 索引成功');
    
    // 创建 keywords.category 索引
    await db.collection('userInterests').createIndex({
      'keywords.category': 1,
      userId: 1
    }, {
      name: 'category_userId_idx'
    });
    console.log('创建 keywords.category 索引成功');
    
    // 创建 keywords.word 索引
    await db.collection('userInterests').createIndex({
      'keywords.word': 1,
      userId: 1
    }, {
      name: 'word_userId_idx'
    });
    console.log('创建 keywords.word 索引成功');
    
    // 创建 lastUpdated 索引
    await db.collection('userInterests').createIndex({
      lastUpdated: -1,
      userId: 1
    }, {
      name: 'lastUpdated_userId_idx'
    });
    console.log('创建 lastUpdated 索引成功');
    
    return {
      success: true,
      message: '创建 userInterests 集合索引成功'
    };
  } catch (error) {
    console.error('创建 userInterests 集合索引失败:', error);
    return {
      success: false,
      error: error.message || '创建索引失败'
    };
  }
}

/**
 * 创建角色集合索引
 */
async function createRolesIndexes() {
  try {
    console.log('开始创建 roles 集合索引...');
    
    // 创建 creator 索引
    await db.collection('roles').createIndex({
      creator: 1
    }, {
      name: 'creator_idx'
    });
    console.log('创建 creator 索引成功');
    
    // 创建 category 索引
    await db.collection('roles').createIndex({
      category: 1
    }, {
      name: 'category_idx'
    });
    console.log('创建 category 索引成功');
    
    // 创建 isSystem 索引
    await db.collection('roles').createIndex({
      isSystem: 1
    }, {
      name: 'isSystem_idx'
    });
    console.log('创建 isSystem 索引成功');
    
    // 创建组合索引：isSystem + category
    await db.collection('roles').createIndex({
      isSystem: 1,
      category: 1
    }, {
      name: 'isSystem_category_idx'
    });
    console.log('创建 isSystem_category 组合索引成功');
    
    // 创建组合索引：creator + category
    await db.collection('roles').createIndex({
      creator: 1,
      category: 1
    }, {
      name: 'creator_category_idx'
    });
    console.log('创建 creator_category 组合索引成功');
    
    return {
      success: true,
      message: '创建 roles 集合索引成功'
    };
  } catch (error) {
    console.error('创建 roles 集合索引失败:', error);
    return {
      success: false,
      error: error.message || '创建索引失败'
    };
  }
}

/**
 * 创建情感记录集合索引
 */
async function createEmotionRecordsIndexes() {
  try {
    console.log('开始创建 emotionRecords 集合索引...');
    
    // 创建 userId 索引
    await db.collection('emotionRecords').createIndex({
      userId: 1,
      timestamp: -1
    }, {
      name: 'userId_timestamp_idx'
    });
    console.log('创建 userId_timestamp 索引成功');
    
    // 创建 roleId 索引
    await db.collection('emotionRecords').createIndex({
      roleId: 1,
      userId: 1,
      timestamp: -1
    }, {
      name: 'roleId_userId_timestamp_idx'
    });
    console.log('创建 roleId_userId_timestamp 索引成功');
    
    // 创建 chatId 索引
    await db.collection('emotionRecords').createIndex({
      chatId: 1,
      timestamp: -1
    }, {
      name: 'chatId_timestamp_idx'
    });
    console.log('创建 chatId_timestamp 索引成功');
    
    // 创建 primary_emotion 索引
    await db.collection('emotionRecords').createIndex({
      primary_emotion: 1,
      userId: 1,
      timestamp: -1
    }, {
      name: 'emotion_userId_timestamp_idx'
    });
    console.log('创建 emotion_userId_timestamp 索引成功');
    
    return {
      success: true,
      message: '创建 emotionRecords 集合索引成功'
    };
  } catch (error) {
    console.error('创建 emotionRecords 集合索引失败:', error);
    return {
      success: false,
      error: error.message || '创建索引失败'
    };
  }
}

/**
 * 创建所有索引
 */
async function createAllIndexes() {
  try {
    const results = await Promise.all([
      createUserInterestsIndexes(),
      createRolesIndexes(),
      createEmotionRecordsIndexes()
    ]);
    
    console.log('所有索引创建结果:', results);
    
    return {
      success: true,
      results
    };
  } catch (error) {
    console.error('创建索引失败:', error);
    return {
      success: false,
      error: error.message || '创建索引失败'
    };
  }
}

// 导出模块
module.exports = {
  createUserInterestsIndexes,
  createRolesIndexes,
  createEmotionRecordsIndexes,
  createAllIndexes
};

*#*#*end*#*#*

*#*#*cloudfunctions\user\index.js*#*#*begin*#*#*
// user 云函数 index.js
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();
const _ = db.command;

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 导入模块
// 使用新版本的用户画像处理模块，基于智谱AI实现
const userPerception = require('./userPerception_new');
// 导入用户兴趣处理模块
const userInterests = require('./userInterests');
// 导入创建索引模块
const createIndexes = require('./createIndexes');

// 子功能：获取用户信息
async function getInfo(event) {
  const wxContext = cloud.getWXContext();
  const { OPENID } = wxContext;

  const { userId } = event;

  try {
    // 获取用户基本信息
    const userBaseResult = await db.collection('user_base')
      .where({ user_id: userId })
      .get();

    if (!userBaseResult.data || userBaseResult.data.length === 0) {
      return {
        success: false,
        error: '用户不存在'
      };
    }

    // 获取用户统计信息
    const userStatsResult = await db.collection('user_stats')
      .where({ user_id: userId })
      .get();

    // 获取用户详细信息
    const userProfileResult = await db.collection('user_profile')
      .where({ user_id: userId })
      .get();

    // 获取用户配置
    const userConfigResult = await db.collection('user_config')
      .where({ user_id: userId })
      .get();

    // 构建完整的用户信息
    const userBase = userBaseResult.data[0];
    const userStats = userStatsResult.data[0] || null;
    const userProfile = userProfileResult.data[0] || {};
    const userConfig = userConfigResult.data[0] || {};

    const user = {
      userId: userBase.user_id,
      username: userBase.username,
      avatarUrl: userBase.avatar_url,
      userType: userBase.user_type,
      status: userBase.status,
      gender: userProfile.gender,
      country: userProfile.country,
      province: userProfile.province,
      city: userProfile.city,
      bio: userProfile.bio,
      stats: userStats
    };

    return {
      success: true,
      data: {
        user
      }
    };
  } catch (error) {
    console.error('获取用户信息失败:', error.message || error);
    return {
      success: false,
      error: error.message || error
    };
  }
}

// 子功能：更新用户资料
async function updateProfile(event, context) {
  const wxContext = cloud.getWXContext();
  const { OPENID } = wxContext;

  const {
    userId,
    username,
    avatarUrl,
    gender,
    country,
    province,
    city,
    bio,
    settings
  } = event;

  try {
    // 1. 更新用户基本信息
    const userBaseUpdate = await db.collection('user_base').where({
      user_id: userId
    }).update({
      data: {
        username: username,
        avatar_url: avatarUrl,
        updated_at: db.serverDate()
      }
    });

    // 2. 处理用户详细信息
    const profileCheck = await db.collection('user_profile').where({
      user_id: userId
    }).count();

    // 用户详细信息数据
    const profileData = {
      user_id: userId,
      gender: gender,
      country: country,
      province: province,
      city: city,
      bio: bio,
      updated_at: db.serverDate()
    };

    let userProfileUpdate;
    if (profileCheck.total === 0) {
      // 创建新的用户详细信息
      userProfileUpdate = await db.collection('user_profile').add({
        data: {
          ...profileData,
          created_at: db.serverDate()
        }
      });
    } else {
      // 更新现有用户详细信息
      userProfileUpdate = await db.collection('user_profile').where({
        user_id: userId
      }).update({
        data: profileData
      });
    }

    // 3. 处理用户设置
    const configCheck = await db.collection('user_config').where({
      user_id: userId
    }).count();

    // 用户设置数据
    const configData = {
      user_id: userId,
      dark_mode: settings.darkMode,
      notification_enabled: settings.notificationEnabled,
      language: settings.language,
      updated_at: db.serverDate()
    };

    let userConfigUpdate;
    if (configCheck.total === 0) {
      // 创建新的用户设置
      userConfigUpdate = await db.collection('user_config').add({
        data: {
          ...configData,
          created_at: db.serverDate()
        }
      });
    } else {
      // 更新现有用户设置
      userConfigUpdate = await db.collection('user_config').where({
        user_id: userId
      }).update({
        data: configData
      });
    }

    // 获取更新后的用户信息
    const updatedUserBase = await db.collection('user_base')
      .where({ user_id: userId })
      .get();

    // 获取用户统计信息
    const userStats = await db.collection('user_stats')
      .where({ user_id: userId })
      .get();

    // 返回更新后的完整用户信息
    return {
      success: true,
      data: {
        userBaseUpdate,
        userProfileUpdate,
        userConfigUpdate,
        updatedUser: {
          userId: userId,
          username: username,
          avatarUrl: avatarUrl,
          gender: gender,
          country: country,
          province: province,
          city: city,
          bio: bio,
          userType: updatedUserBase.data[0]?.user_type || 1,
          status: updatedUserBase.data[0]?.status || 1,
          stats: userStats.data[0] || null
        }
      }
    };
  } catch (error) {
    console.error('更新用户信息失败:', error.message || error);
    return {
      success: false,
      error: error.message || error
    };
  }
}

// 子功能：获取用户统计
async function getStats(event, context) {
  const { OPENID } = cloud.getWXContext();

  try {
    // 获取请求参数
    const { userId } = event;

    // 构建查询条件
    const query = {};

    // 如果提供了userId，添加到查询条件
    if (userId) {
      query.user_id = userId;
      if (isDev) {
        console.log('使用userId查询:', userId);
      }
    } else {
      // 如果没有提供userId，使用openid
      query.openid = OPENID;
      if (isDev) {
        console.log('使用openId查询:', OPENID);
      }
    }

    if (isDev) {
      console.log('查询条件:', query);
    }

    // 查询用户统计信息
    const result = await db.collection('user_stats')
      .where(query)
      .get();

    if (isDev) {
      console.log('查询结果:', result.data.length > 0 ? '找到数据' : '未找到数据');
    }

    if (result.data && result.data.length > 0) {
      return {
        success: true,
        data: result.data[0]
      };
    } else {
      return {
        success: false,
        error: '未找到用户统计数据'
      };
    }
  } catch (error) {
    console.error('获取用户统计数据失败:', error);
    return {
      success: false,
      error: error.message || error
    };
  }
}

// 子功能：更新用户统计
async function updateStats(event, context) {
  const wxContext = cloud.getWXContext();
  const { OPENID } = wxContext;

  const { userId, statsType, value } = event;

  try {
    if (isDev) {
      console.log(`更新用户统计数据: userId=${userId}, statsType=${statsType}, value=${value}`);
    }

    // 获取用户统计信息
    const userStatsResult = await db.collection('user_stats')
      .where({ user_id: userId })
      .get();

    if (!userStatsResult.data || userStatsResult.data.length === 0) {
      console.error('用户统计信息不存在');
      return {
        success: false,
        error: '用户统计信息不存在'
      };
    }

    const userStats = userStatsResult.data[0];
    const statsId = userStats._id;

    // 根据统计类型更新不同的字段
    const updateData = {
      updated_at: db.serverDate()
    };

    switch (statsType) {
      case 'chatCount':
        // 更新对话次数
        updateData.chat_count = _.inc(value);
        break;
      case 'solvedCount':
        // 更新解决问题次数
        updateData.solved_count = _.inc(value);
        break;
      case 'rating':
        // 更新评分
        // 计算新的平均评分
        const currentRating = userStats.rating_avg || 0;
        const currentCount = userStats.rating_count || 0;
        const newRating = (currentRating * currentCount + value) / (currentCount + 1);

        updateData.rating_avg = parseFloat(newRating.toFixed(2));
        updateData.rating_count = _.inc(1);
        break;
      case 'activeDay':
        // 更新活跃天数
        // 检查上次活跃时间是否是今天
        const lastActive = userStats.last_active ? new Date(userStats.last_active) : null;
        const today = new Date();
        const isToday = lastActive &&
          lastActive.getFullYear() === today.getFullYear() &&
          lastActive.getMonth() === today.getMonth() &&
          lastActive.getDate() === today.getDate();

        if (!isToday) {
          updateData.active_days = _.inc(1);
        }

        updateData.last_active = db.serverDate();
        break;
      default:
        console.error('未知的统计类型:', statsType);
        return {
          success: false,
          error: '未知的统计类型'
        };
    }

    // 更新用户统计信息
    await db.collection('user_stats').doc(statsId).update({
      data: updateData
    });

    // 获取更新后的用户统计信息
    const updatedStatsResult = await db.collection('user_stats')
      .doc(statsId)
      .get();

    return {
      success: true,
      data: {
        stats: updatedStatsResult.data
      }
    };
  } catch (error) {
    console.error('更新用户统计失败:', error.message || error);
    return {
      success: false,
      error: error.message || error
    };
  }
}

/**
 * 获取用户报告列表
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getReportList(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;

    // 获取参数
    const { limit = 10, skip = 0 } = event;

    // 初始化数据库
    const db = cloud.database();

    // 查询用户报告列表
    const reports = await db.collection('userReports')
      .where({ userId })
      .orderBy('date', 'desc')
      .skip(skip)
      .limit(limit)
      .get();

    // 获取总数
    const countResult = await db.collection('userReports')
      .where({ userId })
      .count();

    return {
      success: true,
      reports: reports.data,
      total: countResult.total
    };
  } catch (error) {
    console.error('获取用户报告列表失败:', error);
    return {
      success: false,
      error: error.message || '获取用户报告列表失败'
    };
  }
}

/**
 * 标记报告为已读
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function markReportAsRead(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();

    // 获取参数
    const { reportId } = event;

    if (!reportId) {
      return {
        success: false,
        error: '缺少报告ID'
      };
    }

    // 初始化数据库
    const db = cloud.database();

    // 查询报告是否存在且属于当前用户
    const report = await db.collection('userReports')
      .doc(reportId)
      .get();

    if (!report.data || report.data.userId !== wxContext.OPENID) {
      return {
        success: false,
        error: '报告不存在或无权限访问'
      };
    }

    // 更新报告为已读
    await db.collection('userReports')
      .doc(reportId)
      .update({
        data: {
          isRead: true
        }
      });

    return {
      success: true
    };
  } catch (error) {
    console.error('标记报告为已读失败:', error);
    return {
      success: false,
      error: error.message || '标记报告为已读失败'
    };
  }
}

/**
 * 获取用户兴趣数据
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getUserInterests(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;

    // 使用用户兴趣模块获取数据
    const result = await userInterests.getUserInterests(userId);

    return result;
  } catch (error) {
    console.error('获取用户兴趣数据失败:', error);
    return {
      success: false,
      error: error.message || '获取用户兴趣数据失败'
    };
  }
}

/**
 * 获取用户的总消息数量
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getTotalMessageCount(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const { OPENID } = wxContext;

    // 获取请求参数
    const { userId } = event;

    // 构建查询条件 - 使用多种可能的字段名
    // 在chats表中，用户ID可能存储在不同的字段中
    const openid = OPENID;

    // 使用OR条件查询多个可能的字段
    const db = cloud.database();
    const _ = db.command;

    if (isDev) {
      // 打印用户ID信息，便于调试
      console.log('用户ID信息:', {
        OPENID: OPENID,
        providedUserId: userId
      });
    }

    // 构建查询条件，考虑所有可能的字段名和大小写情况
    const query = _.or([
      { openId: openid },
      { openid: openid },
      { userId: openid },
      { userid: openid },
      { user_id: openid }
    ]);

    // 如果提供了userId，也添加到查询条件
    if (userId && userId !== openid) {
      query.push(
        { openId: userId },
        { openid: userId },
        { userId: userId },
        { userid: userId },
        { user_id: userId }
      );
    }

    if (isDev) {
      console.log('查询条件:', query);
    }

    // 使用聚合查询计算所有聊天记录的消息总数
    const $ = db.command.aggregate;

    // 首先获取所有匹配的聊天记录，以便调试
    const chatRecords = await db.collection('chats')
      .where(query)
      .get();

    if (isDev) {
      console.log(`找到 ${chatRecords.data.length} 条匹配的聊天记录`);

      // 如果找到了聊天记录，打印前5条记录的关键信息，便于调试
      if (chatRecords.data.length > 0) {
        const sampleRecords = chatRecords.data.slice(0, 5).map(chat => ({
          id: chat._id,
          roleId: chat.roleId,
          openId: chat.openId || chat.openid,
          messageCount: chat.messageCount
        }));
        console.log('示例聊天记录:', sampleRecords);
      }
    }

    // 使用聚合查询计算总消息数
    const result = await db.collection('chats')
      .aggregate()
      .match(query)
      .group({
        _id: null,
        totalMessageCount: $.sum('$messageCount')
      })
      .end();

    if (isDev) {
      console.log('聚合查询结果:', result);
    }

    // 如果有结果，返回总消息数
    if (result.list && result.list.length > 0) {
      const totalMessageCount = result.list[0].totalMessageCount || 0;
      if (isDev) {
        console.log('用户总消息数:', totalMessageCount);
      }

      // 更新用户统计信息中的总消息数
      try {
        if (isDev) {
          console.log('开始更新user_stats表中的chat_count...');
          console.log('用户ID信息:', { OPENID, userId });

          // 直接获取user_stats表中的所有记录，以便调试
          const allStats = await db.collection('user_stats').get();
          console.log(`user_stats表中共有 ${allStats.data.length} 条记录`);

          if (allStats.data.length > 0) {
            // 打印前5条记录的关键信息，便于调试
            const sampleStats = allStats.data.slice(0, 5).map(stat => ({
              id: stat._id,
              openid: stat.openid,
              user_id: stat.user_id,
              chat_count: stat.chat_count
            }));
            console.log('user_stats表示例记录:', sampleStats);
          }
        }

        // 尝试多种查询方式找到用户的统计记录
        let userStats = null;

        // 1. 首先尝试使用_id查询
        if (userId && userId.length > 10) {
          try {
            const byIdResult = await db.collection('user_stats').doc(userId).get();
            if (byIdResult.data) {
              userStats = byIdResult.data;
              if (isDev) {
                console.log('通过_id找到用户统计信息:', userStats);
              }
            }
          } catch (idErr) {
            if (isDev) {
              console.log('通过_id查询失败，尝试其他方式');
            }
          }
        }

        // 2. 如果通过_id没找到，尝试使用openid和user_id查询
        if (!userStats) {
          // 构建查询条件，考虑多种可能的字段名
          const queries = [];

          // 添加OPENID的查询条件
          if (OPENID) {
            queries.push(
              db.collection('user_stats').where({ openid: OPENID }).get(),
              db.collection('user_stats').where({ user_id: OPENID }).get()
            );
          }

          // 添加userId的查询条件
          if (userId && userId !== OPENID) {
            queries.push(
              db.collection('user_stats').where({ openid: userId }).get(),
              db.collection('user_stats').where({ user_id: userId }).get()
            );
          }

          // 执行所有查询
          const results = await Promise.all(queries);

          // 检查查询结果
          for (const result of results) {
            if (result.data && result.data.length > 0) {
              userStats = result.data[0];
              if (isDev) {
                console.log('通过字段查询找到用户统计信息:', userStats);
              }
              break;
            }
          }
        }

        // 3. 如果还是没找到，尝试使用截图中显示的ID
        if (!userStats) {
          try {
            // 从截图中看到的ID
            const statsId = "7456afe067d056a600d4a9981504c9c";
            if (isDev) {
              console.log('尝试使用已知ID查询:', statsId);
            }

            // 尝试不同的ID格式
            const possibleIds = [
              statsId, // 原始ID
              "7456afe067d056a600d4a9981504c9c", // 原始ID
              "7456afe067d056a600d4a9981504", // 截断ID
              "7456afe067d056a600d4a9981504c9c", // 可能的完整ID
              "7456afe067d056a600d4a9981504c9c", // 可能的完整ID
            ];

            // 尝试所有可能的ID
            for (const id of possibleIds) {
              try {
                if (isDev) {
                  console.log('尝试ID:', id);
                }
                const result = await db.collection('user_stats').doc(id).get();
                if (result.data) {
                  userStats = result.data;
                  if (isDev) {
                    console.log('通过已知ID找到用户统计信息:', userStats);
                  }
                  break;
                }
              } catch (err) {
                if (isDev) {
                  console.log(`ID ${id} 查询失败:`, err.message);
                }
              }
            }
          } catch (knownIdErr) {
            if (isDev) {
              console.log('通过已知ID查询失败:', knownIdErr.message);
            }
          }
        }

        // 如果找到了用户统计信息，更新chat_count
        if (userStats) {
          if (isDev) {
            console.log('准备更新用户统计信息:', {
              statsId: userStats._id,
              oldChatCount: userStats.chat_count,
              newChatCount: totalMessageCount
            });
          }

          // 更新用户统计信息
          const updateResult = await db.collection('user_stats').doc(userStats._id).update({
            data: {
              chat_count: totalMessageCount,
              updated_at: db.serverDate()
            }
          });

          if (isDev) {
            console.log('用户统计信息更新结果:', updateResult);
            console.log('用户统计信息更新成功, 新的chat_count:', totalMessageCount);

            // 再次查询确认更新成功
            const verifyResult = await db.collection('user_stats').doc(userStats._id).get();
            console.log('更新后的用户统计信息:', verifyResult.data);
          }
        } else {
          if (isDev) {
            console.log('未找到用户统计信息，无法更新');
          }

          // 如果没有找到用户统计信息，尝试创建一个新的
          if (OPENID) {
            const newStats = {
              openid: OPENID,
              user_id: userId || OPENID,
              chat_count: totalMessageCount,
              active_days: 1,
              created_at: db.serverDate(),
              updated_at: db.serverDate()
            };

            if (isDev) {
              console.log('尝试创建新的用户统计信息:', newStats);
            }

            const createResult = await db.collection('user_stats').add({
              data: newStats
            });

            if (isDev) {
              console.log('创建用户统计信息结果:', createResult);
            }
          }
        }
      } catch (statsErr) {
        console.error('更新用户统计信息失败:', statsErr.message || statsErr);
        // 不影响主流程
      }

      return {
        success: true,
        totalMessageCount: totalMessageCount
      };
    } else {
      // 如果没有结果，返回0
      return {
        success: true,
        totalMessageCount: 0
      };
    }
  } catch (error) {
    console.error('获取用户总消息数失败:', error.message || error);
    return {
      success: false,
      error: error.message || '获取用户总消息数失败'
    };
  }
}

/**
 * 获取用户画像
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getUserPerception(event) {
  // 默认的用户画像数据，当API调用失败时使用
  const defaultPerceptionData = {
    interests: ['阅读', '音乐', '旅行', '学习'],
    personalityTraits: [
      { trait: '创造力', score: 0.65 },
      { trait: '责任感', score: 0.8 },
      { trait: '同理心', score: 0.7 },
      { trait: '社交性', score: 0.5 },
      { trait: '耐心', score: 0.6 }
    ],
    personalitySummary: '你是一个具有较强责任感和同理心的人，在创造力和耐心方面也有不错的表现。你善于理解他人的情感，并且能够认真完成自己的任务。',
    emotionPatterns: {
      emotionPercentages: {
        '平静': 40,
        '快乐': 30,
        '焦虑': 15,
        '压力': 15
      },
      emotionTrends: { trend: '情绪波动' },
      dominantEmotions: [
        { emotion: '平静', percentage: 40 },
        { emotion: '快乐', percentage: 30 }
      ]
    }
  };

  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;

    if (isDev) {
      console.log(`开始获取用户画像, 用户ID: ${userId}, 使用智谱AI增强版`);
    }

    try {
      // 获取用户画像数据
      const perceptionData = await userPerception.getUserPerception(userId);

      if (isDev) {
        console.log('用户画像数据获取成功');
      }

      // 检查数据是否完整
      if (perceptionData && perceptionData.personalityTraits && perceptionData.personalityTraits.length > 0) {
        return {
          success: true,
          data: perceptionData
        };
      } else {
        if (isDev) {
          console.warn('用户画像数据不完整，使用默认数据');
        }
        return {
          success: true,
          data: defaultPerceptionData,
          message: '使用默认数据'
        };
      }
    } catch (apiError) {
      console.error('调用用户画像 API 失败:', apiError.message || apiError);
      return {
        success: true,
        data: defaultPerceptionData,
        message: '调用API失败，使用默认数据'
      };
    }
  } catch (error) {
    console.error('获取用户画像失败:', error.message || error);

    // 即使出错也返回默认数据，确保前端能正常显示
    return {
      success: true,
      data: defaultPerceptionData,
        error: error.message || '获取用户画像失败'
    };
  }
}

/**
 * 更新用户兴趣关键词
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function updateUserInterest(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    const { keyword, weightDelta, autoClassify = true } = event;

    // 使用用户兴趣模块更新关键词
    const result = await userInterests.updateUserInterest(userId, keyword, weightDelta, autoClassify);

    return result;
  } catch (error) {
    console.error('更新用户兴趣关键词失败:', error);
    return {
      success: false,
      error: error.message || '更新用户兴趣关键词失败'
    };
  }
}

/**
 * 批量更新用户兴趣关键词
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function batchUpdateUserInterests(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    const { keywords, autoClassify = true, categoryStats, categoriesArray } = event;

    if (isDev) {
      console.log('批量更新用户兴趣关键词，参数:', {
        userId,
        keywordsCount: keywords ? keywords.length : 0,
        autoClassify,
        hasCategoryStats: !!categoryStats,
        hasCategoriesArray: !!categoriesArray
      });
    }

    // 使用用户兴趣模块批量更新关键词
    const result = await userInterests.batchUpdateUserInterests(
      userId,
      keywords,
      autoClassify,
      categoryStats,
      categoriesArray
    );

    return result;
  } catch (error) {
    console.error('批量更新用户兴趣关键词失败:', error.message || error);
    return {
      success: false,
      error: error.message || '批量更新用户兴趣关键词失败'
    };
  }
}

/**
 * 删除用户兴趣关键词
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function deleteUserInterest(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    const { keyword } = event;

    // 使用用户兴趣模块删除关键词
    const result = await userInterests.deleteUserInterest(userId, keyword);

    return result;
  } catch (error) {
    console.error('删除用户兴趣关键词失败:', error.message || error);
    return {
      success: false,
      error: error.message || '删除用户兴趣关键词失败'
    };
  }
}

/**
 * 更新关键词分类
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function updateKeywordCategory(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    const { keyword, category } = event;

    // 使用用户兴趣模块更新关键词分类
    const result = await userInterests.updateKeywordCategory(userId, keyword, category);

    return result;
  } catch (error) {
    console.error('更新关键词分类失败:', error.message || error);
    return {
      success: false,
      error: error.message || '更新关键词分类失败'
    };
  }
}

/**
 * 批量更新关键词分类
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function batchUpdateKeywordCategories(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    const { categorizations } = event;

    // 使用用户兴趣模块批量更新关键词分类
    const result = await userInterests.batchUpdateKeywordCategories(userId, categorizations);

    return result;
  } catch (error) {
    console.error('批量更新关键词分类失败:', error.message || error);
    return {
      success: false,
      error: error.message || '批量更新关键词分类失败'
    };
  }
}

/**
 * 更新关键词情感分数
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function updateKeywordEmotionScore(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const userId = event.userId || wxContext.OPENID;
    const { keyword, emotionScore } = event;

    // 使用用户兴趣模块更新关键词情感分数
    const result = await userInterests.updateKeywordEmotionScore(userId, keyword, emotionScore);

    return result;
  } catch (error) {
    console.error('更新关键词情感分数失败:', error.message || error);
    return {
      success: false,
      error: error.message || '更新关键词情感分数失败'
    };
  }
}

/**
 * 获取用户心情报告数量
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function getReportCount(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();
    const { OPENID } = wxContext;

    // 获取请求参数
    const { userId } = event;

    // 构建查询条件，考虑多种可能的字段名
    const db = cloud.database();
    const _ = db.command;

    // 使用用户ID或OpenID
    const openid = userId || OPENID;

    if (isDev) {
      console.log('查询心情报告数量，用户ID:', openid);
    }

    // 查询userReports表中该用户的记录数量
    const countResult = await db.collection('userReports')
      .where({
        userId: openid
      })
      .count();

    if (isDev) {
      console.log('查询结果:', countResult);
    }

    const reportCount = countResult.total || 0;

    // 更新user_stats表中的daily_report_count字段
    try {
      // 查询用户统计信息
      const userStatsResult = await db.collection('user_stats')
        .where(_.or([
          { openid: openid },
          { user_id: openid }
        ]))
        .get();

      if (isDev) {
        console.log('查询user_stats结果:', userStatsResult);
      }

      if (userStatsResult.data && userStatsResult.data.length > 0) {
        const userStats = userStatsResult.data[0];

        // 更新用户统计信息
        await db.collection('user_stats').doc(userStats._id).update({
          data: {
            daily_report_count: reportCount,
            updated_at: db.serverDate()
          }
        });

        if (isDev) {
          console.log('用户统计信息更新成功, 新的daily_report_count:', reportCount);
        }
      } else {
        if (isDev) {
          console.log('未找到用户统计信息，无法更新');
        }
      }
    } catch (statsErr) {
      console.error('更新用户统计信息失败:', statsErr.message || statsErr);
      // 不影响主流程
    }

    return {
      success: true,
      reportCount: reportCount
    };
  } catch (error) {
    console.error('获取用户心情报告数量失败:', error.message || error);
    return {
      success: false,
      error: error.message || '获取用户心情报告数量失败'
    };
  }
}

/**
 * 创建数据库索引
 * @param {Object} event 事件参数
 * @returns {Promise<Object>} 处理结果
 */
async function createDatabaseIndexes(event) {
  try {
    // 获取微信上下文
    const wxContext = cloud.getWXContext();

    // 检查是否为管理员
    // 注意：在实际应用中，应该有更完善的权限检查机制
    const isAdmin = event.isAdmin === true;

    if (!isAdmin) {
      return {
        success: false,
        error: '权限不足'
      };
    }

    // 创建索引
    const { collection } = event;
    let result;

    if (collection === 'userInterests') {
      result = await createIndexes.createUserInterestsIndexes();
    } else if (collection === 'roles') {
      result = await createIndexes.createRolesIndexes();
    } else if (collection === 'emotionRecords') {
      result = await createIndexes.createEmotionRecordsIndexes();
    } else {
      // 创建所有索引
      result = await createIndexes.createAllIndexes();
    }

    return result;
  } catch (error) {
    console.error('创建数据库索引失败:', error.message || error);
    return {
      success: false,
      error: error.message || '创建数据库索引失败'
    };
  }
}

// 主函数入口
exports.main = async (event, context) => {
  const { action } = event;

  switch (action) {
    case 'getInfo':
      return await getInfo(event);
    case 'updateProfile':
      return await updateProfile(event, context);
    case 'getStats':
      return await getStats(event, context);
    case 'updateStats':
      return await updateStats(event, context);
    case 'getReportList':
      return await getReportList(event);
    case 'markReportAsRead':
      return await markReportAsRead(event);
    case 'getUserInterests':
      return await getUserInterests(event);
    case 'updateUserInterest':
      return await updateUserInterest(event);
    case 'batchUpdateUserInterests':
      return await batchUpdateUserInterests(event);
    case 'deleteUserInterest':
      return await deleteUserInterest(event);
    case 'updateKeywordCategory':
      return await updateKeywordCategory(event);
    case 'batchUpdateKeywordCategories':
      return await batchUpdateKeywordCategories(event);
    case 'updateKeywordEmotionScore':
      return await updateKeywordEmotionScore(event);
    case 'getUserPerception':
      return await getUserPerception(event);
    case 'createDatabaseIndexes':
      return await createDatabaseIndexes(event);
    case 'getTotalMessageCount':
      return await getTotalMessageCount(event);
    case 'getReportCount':
      return await getReportCount(event);
    default:
      return {
        success: false,
        error: '未知的操作类型'
      };
  }
};


*#*#*end*#*#*

*#*#*cloudfunctions\user\package.json*#*#*begin*#*#*
{
  "name": "user",
  "version": "1.0.0",
  "description": "用户相关功能云函数",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}

*#*#*end*#*#*

*#*#*cloudfunctions\user\userInterests.js*#*#*begin*#*#*
/**
 * 用户兴趣模块
 * 提供用户兴趣数据的存储和检索功能
 */

const cloud = require('wx-server-sdk');

// 初始化云环境
cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

// 获取数据库引用
const db = cloud.database();
const _ = db.command;

/**
 * 获取用户兴趣数据
 * @param {string} userId 用户ID
 * @returns {Promise<Object>} 用户兴趣数据
 */
async function getUserInterests(userId) {
  try {
    if (!userId) {
      throw new Error('用户ID不能为空');
    }

    console.log(`获取用户兴趣数据, 用户ID: ${userId}`);

    // 查询用户兴趣数据
    const result = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    console.log(`查询结果: ${result.data.length}条记录`);

    if (result.data && result.data.length > 0) {
      return {
        success: true,
        data: result.data[0]
      };
    } else {
      // 如果没有找到记录，创建一个空记录
      const newRecord = {
        userId: userId,
        keywords: [],
        categories: [],
        createTime: new Date(),
        lastUpdated: new Date()
      };

      // 插入新记录
      const addResult = await db.collection('userInterests').add({
        data: newRecord
      });

      console.log(`创建新记录成功, ID: ${addResult._id}`);

      return {
        success: true,
        data: {
          _id: addResult._id,
          ...newRecord
        }
      };
    }
  } catch (error) {
    console.error('获取用户兴趣数据失败:', error);
    return {
      success: false,
      error: error.message || '获取用户兴趣数据失败'
    };
  }
}

/**
 * 更新用户兴趣关键词
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @param {number} weightDelta 权重变化值
 * @param {boolean} autoClassify 是否自动分类关键词
 * @returns {Promise<Object>} 更新结果
 */
async function updateUserInterest(userId, keyword, weightDelta = 0.1, autoClassify = true) {
  try {
    if (!userId || !keyword) {
      throw new Error('用户ID和关键词不能为空');
    }

    console.log(`更新用户兴趣关键词, 用户ID: ${userId}, 关键词: ${keyword}, 权重变化: ${weightDelta}`);

    // 查询用户兴趣数据
    const result = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    if (result.data && result.data.length > 0) {
      const record = result.data[0];
      const keywords = record.keywords || [];

      // 查找关键词
      const keywordIndex = keywords.findIndex(k => k.word === keyword);

      if (keywordIndex >= 0) {
        // 关键词存在，更新权重
        const newWeight = Math.min(Math.max(keywords[keywordIndex].weight + weightDelta, 0.1), 2.0);

        // 更新数据库
        await db.collection('userInterests').doc(record._id).update({
          data: {
            [`keywords.${keywordIndex}.weight`]: newWeight,
            [`keywords.${keywordIndex}.lastUpdated`]: new Date(),
            [`keywords.${keywordIndex}.occurrences`]: (keywords[keywordIndex].occurrences || 0) + 1,
            lastUpdated: new Date()
          }
        });

        console.log(`更新关键词权重成功, 新权重: ${newWeight}`);
      } else {
        // 关键词不存在，添加新关键词
        // 如果需要自动分类，先获取分类
        let category = '未分类';
        if (autoClassify) {
          try {
            category = await autoClassifyKeyword(keyword);
          } catch (classifyError) {
            console.error(`关键词 "${keyword}" 自动分类失败:`, classifyError);
            // 分类失败不影响主流程
          }
        }

        await db.collection('userInterests').doc(record._id).update({
          data: {
            keywords: _.push({
              word: keyword,
              weight: Math.max(1.0 + weightDelta, 0.1),
              category: category,
              source: 'chat',
              emotionScore: 0,
              firstSeen: new Date(),
              lastUpdated: new Date(),
              occurrences: 1
            }),
            lastUpdated: new Date()
          }
        });

        console.log(`添加新关键词成功: ${keyword}, 分类: ${category}`);
      }

      return {
        success: true,
        message: '更新用户兴趣关键词成功'
      };
    } else {
      // 如果没有找到记录，创建一个新记录
      // 如果需要自动分类，先获取分类
      let category = '未分类';
      if (autoClassify) {
        try {
          category = await autoClassifyKeyword(keyword);
        } catch (classifyError) {
          console.error(`关键词 "${keyword}" 自动分类失败:`, classifyError);
          // 分类失败不影响主流程
        }
      }

      const newRecord = {
        userId: userId,
        keywords: [{
          word: keyword,
          weight: Math.max(1.0 + weightDelta, 0.1),
          category: category,
          source: 'chat',
          emotionScore: 0,
          firstSeen: new Date(),
          lastUpdated: new Date(),
          occurrences: 1
        }],
        createTime: new Date(),
        lastUpdated: new Date()
      };

      // 插入新记录
      await db.collection('userInterests').add({
        data: newRecord
      });

      console.log(`创建新记录并添加关键词成功: ${keyword}, 分类: ${category}`);

      return {
        success: true,
        message: '创建用户兴趣记录并添加关键词成功'
      };
    }
  } catch (error) {
    console.error('更新用户兴趣关键词失败:', error);
    return {
      success: false,
      error: error.message || '更新用户兴趣关键词失败'
    };
  }
}

/**
 * 自动分类关键词
 * @param {string} word 关键词
 * @returns {Promise<string>} 分类结果
 */
async function autoClassifyKeyword(word) {
  try {
    // 调用分析云函数分类关键词
    const result = await cloud.callFunction({
      name: 'analysis',
      data: {
        type: 'classify_keywords',
        keywords: word,
        batch: false
      }
    });

    if (result.result && result.result.success && result.result.data && result.result.data.category) {
      return result.result.data.category;
    } else {
      console.warn(`关键词 "${word}" 自动分类失败，使用默认分类`);
      return '未分类';
    }
  } catch (error) {
    console.error(`关键词 "${word}" 自动分类异常:`, error);
    return '未分类';
  }
}

/**
 * 批量更新用户兴趣关键词
 * @param {string} userId 用户ID
 * @param {Array} keywords 关键词数组，每个元素包含word和weight字段
 * @param {boolean} autoClassify 是否自动分类关键词
 * @param {Object} categoryStats 分类统计数据，可选
 * @param {Array} categoriesArray 分类数组，可选
 * @returns {Promise<Object>} 更新结果
 */
async function batchUpdateUserInterests(userId, keywords, autoClassify = true, categoryStats = null, categoriesArray = null) {
  try {
    if (!userId || !Array.isArray(keywords) || keywords.length === 0) {
      throw new Error('用户ID和关键词数组不能为空');
    }

    console.log(`批量更新用户兴趣关键词, 用户ID: ${userId}, 关键词数量: ${keywords.length}`);

    // 如果提供了分类统计数据，输出日志
    if (categoryStats) {
      console.log('分类统计数据:', categoryStats);
    }

    // 查询用户兴趣数据
    const result = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    let recordId;
    let existingKeywords = [];
    let existingCategories = {};

    if (result.data && result.data.length > 0) {
      recordId = result.data[0]._id;
      existingKeywords = result.data[0].keywords || [];
      existingCategories = result.data[0].categories || [];

      // 如果 categories 是对象而不是数组，将其转换为数组
      if (existingCategories && !Array.isArray(existingCategories)) {
        console.log('将 categories 对象转换为数组');
        const categoriesArray = [];
        for (const [name, count] of Object.entries(existingCategories)) {
          categoriesArray.push({
            name: name,
            count: count,
            firstSeen: new Date(),
            lastUpdated: new Date()
          });
        }
        existingCategories = categoriesArray;
      }
    } else {
      // 如果没有找到记录，创建一个新记录
      const newRecord = {
        userId: userId,
        keywords: [],
        categories: [],
        createTime: new Date(),
        lastUpdated: new Date()
      };

      // 插入新记录
      const addResult = await db.collection('userInterests').add({
        data: newRecord
      });

      recordId = addResult._id;
      console.log(`创建新记录成功, ID: ${recordId}`);
    }

    // 如果需要自动分类，先收集所有新关键词
    const newKeywords = [];
    for (const keyword of keywords) {
      if (!keyword.word) continue;

      // 检查关键词是否已存在
      const existingKeyword = existingKeywords.find(k => k.word === keyword.word);
      if (!existingKeyword) {
        newKeywords.push(keyword.word);
      }
    }

    // 如果有新关键词且需要自动分类，批量分类
    let categoryMap = {};
    if (autoClassify && newKeywords.length > 0) {
      try {
        // 调用分析云函数批量分类关键词
        const classifyResult = await cloud.callFunction({
          name: 'analysis',
          data: {
            type: 'classify_keywords',
            keywords: newKeywords,
            batch: true
          }
        });

        if (classifyResult.result && classifyResult.result.success &&
            classifyResult.result.data && Array.isArray(classifyResult.result.data.classifications)) {
          // 将分类结果转换为映射
          classifyResult.result.data.classifications.forEach(item => {
            categoryMap[item.keyword] = item.category;
          });
          console.log('批量分类关键词成功:', categoryMap);
        }
      } catch (classifyError) {
        console.error('批量分类关键词失败:', classifyError);
        // 分类失败不影响主流程
      }
    }

    // 处理每个关键词
    for (const keyword of keywords) {
      if (!keyword.word) continue;

      const word = keyword.word;
      const weight = keyword.weight || 1.0;

      // 查找关键词
      const keywordIndex = existingKeywords.findIndex(k => k.word === word);

      if (keywordIndex >= 0) {
        // 关键词存在，更新权重
        const currentWeight = existingKeywords[keywordIndex].weight || 1.0;
        const newWeight = Math.min(Math.max(currentWeight + (weight - 1.0) * 0.2, 0.1), 2.0);

        // 更新数据库
        await db.collection('userInterests').doc(recordId).update({
          data: {
            [`keywords.${keywordIndex}.weight`]: newWeight,
            [`keywords.${keywordIndex}.lastUpdated`]: new Date(),
            [`keywords.${keywordIndex}.occurrences`]: (existingKeywords[keywordIndex].occurrences || 0) + 1,
            lastUpdated: new Date()
          }
        });

        console.log(`更新关键词权重成功, 关键词: ${word}, 新权重: ${newWeight}`);
      } else {
        // 关键词不存在，添加新关键词
        // 获取分类
        const category = categoryMap[word] || '未分类';

        await db.collection('userInterests').doc(recordId).update({
          data: {
            keywords: _.push({
              word: word,
              weight: weight,
              category: category,
              source: 'chat',
              emotionScore: 0,
              firstSeen: new Date(),
              lastUpdated: new Date(),
              occurrences: 1
            }),
            lastUpdated: new Date()
          }
        });

        console.log(`添加新关键词成功: ${word}, 分类: ${category}`);

        // 更新本地缓存的关键词列表
        existingKeywords.push({
          word: word,
          weight: weight,
          category: category,
          source: 'chat',
          emotionScore: 0,
          firstSeen: new Date(),
          lastUpdated: new Date(),
          occurrences: 1
        });
      }
    }

    // 更新分类数组
    let updatedCategoriesArray = [];

    // 如果提供了分类数组，优先使用它
    if (categoriesArray && Array.isArray(categoriesArray)) {
      console.log('使用提供的分类数组:', categoriesArray);

      // 合并现有分类和新分类
      updatedCategoriesArray = [...categoriesArray];

      // 如果现有分类存在，合并它们
      if (existingCategories && Array.isArray(existingCategories)) {
        for (const existingCat of existingCategories) {
          const newCat = updatedCategoriesArray.find(cat => cat.name === existingCat.name);

          if (newCat) {
            // 如果分类已存在于新数组中，更新计数
            newCat.count = (newCat.count || 0) + (existingCat.count || 0);
            newCat.firstSeen = existingCat.firstSeen || new Date();
            newCat.lastUpdated = new Date();
          } else {
            // 如果分类不存在于新数组中，添加它
            updatedCategoriesArray.push(existingCat);
          }
        }
      }
    }
    // 如果提供了分类统计，使用它来生成分类数组
    else if (categoryStats) {
      console.log('使用分类统计生成分类数组:', categoryStats);

      // 遍历分类统计，创建分类数组
      for (const [categoryName, count] of Object.entries(categoryStats)) {
        // 检查分类是否已存在
        const existingCategory = existingCategories && Array.isArray(existingCategories) ?
          existingCategories.find(cat => cat.name === categoryName) : null;

        if (existingCategory) {
          // 如果分类已存在，更新计数
          existingCategory.count = (existingCategory.count || 0) + count;
          existingCategory.lastUpdated = new Date();
          updatedCategoriesArray.push(existingCategory);
        } else {
          // 如果分类不存在，创建新分类
          updatedCategoriesArray.push({
            name: categoryName,
            count: count,
            firstSeen: new Date(),
            lastUpdated: new Date()
          });
        }
      }

      // 添加现有分类中不在新分类统计中的分类
      if (existingCategories && Array.isArray(existingCategories)) {
        for (const existingCat of existingCategories) {
          if (!updatedCategoriesArray.some(cat => cat.name === existingCat.name)) {
            updatedCategoriesArray.push(existingCat);
          }
        }
      }
    }
    // 如果既没有提供分类数组也没有提供分类统计，使用现有分类
    else if (existingCategories && Array.isArray(existingCategories)) {
      console.log('使用现有分类数组:', existingCategories);
      updatedCategoriesArray = [...existingCategories];
    }

    // 更新数据库中的分类数组
    await db.collection('userInterests').doc(recordId).update({
      data: {
        categories: updatedCategoriesArray,
        lastUpdated: new Date()
      }
    });

    console.log('更新分类数组成功:', updatedCategoriesArray);

    // 查询更新后的用户兴趣数据
    const updatedResult = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    return {
      success: true,
      message: '批量更新用户兴趣关键词成功',
      data: {
        userId: userId,
        recordId: recordId,
        updatedKeywords: keywords.map(k => k.word),
        categoryMap: categoryMap,
        currentData: updatedResult.data && updatedResult.data.length > 0 ? updatedResult.data[0] : null
      }
    };
  } catch (error) {
    console.error('批量更新用户兴趣关键词失败:', error);
    return {
      success: false,
      error: error.message || '批量更新用户兴趣关键词失败'
    };
  }
}

/**
 * 删除用户兴趣关键词
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @returns {Promise<Object>} 删除结果
 */
async function deleteUserInterest(userId, keyword) {
  try {
    if (!userId || !keyword) {
      throw new Error('用户ID和关键词不能为空');
    }

    console.log(`删除用户兴趣关键词, 用户ID: ${userId}, 关键词: ${keyword}`);

    // 查询用户兴趣数据
    const result = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    if (result.data && result.data.length > 0) {
      const record = result.data[0];
      const keywords = record.keywords || [];

      // 查找关键词
      const keywordIndex = keywords.findIndex(k => k.word === keyword);

      if (keywordIndex >= 0) {
        // 关键词存在，删除关键词
        keywords.splice(keywordIndex, 1);

        // 更新数据库
        await db.collection('userInterests').doc(record._id).update({
          data: {
            keywords: keywords,
            lastUpdated: new Date()
          }
        });

        console.log(`删除关键词成功: ${keyword}`);

        return {
          success: true,
          message: '删除用户兴趣关键词成功'
        };
      } else {
        console.log(`关键词不存在: ${keyword}`);

        return {
          success: true,
          message: '关键词不存在'
        };
      }
    } else {
      console.log(`用户兴趣记录不存在, 用户ID: ${userId}`);

      return {
        success: true,
        message: '用户兴趣记录不存在'
      };
    }
  } catch (error) {
    console.error('删除用户兴趣关键词失败:', error);
    return {
      success: false,
      error: error.message || '删除用户兴趣关键词失败'
    };
  }
}

/**
 * 更新关键词分类
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @param {string} category 分类
 * @returns {Promise<Object>} 更新结果
 */
async function updateKeywordCategory(userId, keyword, category) {
  try {
    if (!userId || !keyword || !category) {
      throw new Error('用户ID、关键词和分类不能为空');
    }

    console.log(`更新关键词分类, 用户ID: ${userId}, 关键词: ${keyword}, 分类: ${category}`);

    // 查询用户兴趣数据
    const result = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    if (result.data && result.data.length > 0) {
      const record = result.data[0];
      const keywords = record.keywords || [];

      // 查找关键词
      const keywordIndex = keywords.findIndex(k => k.word === keyword);

      if (keywordIndex >= 0) {
        // 关键词存在，更新分类
        await db.collection('userInterests').doc(record._id).update({
          data: {
            [`keywords.${keywordIndex}.category`]: category,
            [`keywords.${keywordIndex}.lastUpdated`]: new Date(),
            lastUpdated: new Date()
          }
        });

        console.log(`更新关键词分类成功, 关键词: ${keyword}, 分类: ${category}`);

        return {
          success: true,
          message: '更新关键词分类成功'
        };
      } else {
        console.log(`关键词不存在: ${keyword}`);

        return {
          success: false,
          error: '关键词不存在'
        };
      }
    } else {
      console.log(`用户兴趣记录不存在, 用户ID: ${userId}`);

      return {
        success: false,
        error: '用户兴趣记录不存在'
      };
    }
  } catch (error) {
    console.error('更新关键词分类失败:', error);
    return {
      success: false,
      error: error.message || '更新关键词分类失败'
    };
  }
}

/**
 * 批量更新关键词分类
 * @param {string} userId 用户ID
 * @param {Array} categorizations 分类数组，每个元素包含keyword和category字段
 * @returns {Promise<Object>} 更新结果
 */
async function batchUpdateKeywordCategories(userId, categorizations) {
  try {
    if (!userId || !Array.isArray(categorizations) || categorizations.length === 0) {
      throw new Error('用户ID和分类数组不能为空');
    }

    console.log(`批量更新关键词分类, 用户ID: ${userId}, 分类数量: ${categorizations.length}`);

    // 查询用户兴趣数据
    const result = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    if (result.data && result.data.length > 0) {
      const record = result.data[0];
      const keywords = record.keywords || [];
      let categories = record.categories || [];

      // 如果 categories 是对象而不是数组，将其转换为数组
      if (categories && !Array.isArray(categories)) {
        console.log('将 categories 对象转换为数组');
        const categoriesArray = [];
        for (const [name, count] of Object.entries(categories)) {
          categoriesArray.push({
            name: name,
            count: count,
            firstSeen: new Date(),
            lastUpdated: new Date()
          });
        }
        categories = categoriesArray;
      }

      // 创建分类统计对象
      const categoryStats = {};

      // 处理每个分类
      for (const item of categorizations) {
        if (!item.keyword || !item.category) continue;

        const keyword = item.keyword;
        const category = item.category;

        // 查找关键词
        const keywordIndex = keywords.findIndex(k => k.word === keyword);

        if (keywordIndex >= 0) {
          // 关键词存在，更新分类
          await db.collection('userInterests').doc(record._id).update({
            data: {
              [`keywords.${keywordIndex}.category`]: category,
              [`keywords.${keywordIndex}.lastUpdated`]: new Date(),
              lastUpdated: new Date()
            }
          });

          console.log(`更新关键词分类成功, 关键词: ${keyword}, 分类: ${category}`);

          // 更新分类统计
          categoryStats[category] = (categoryStats[category] || 0) + 1;
        }
      }

      // 更新分类数组
      for (const [categoryName, count] of Object.entries(categoryStats)) {
        // 查找分类是否已存在
        const existingCategoryIndex = categories.findIndex(cat => cat.name === categoryName);

        if (existingCategoryIndex >= 0) {
          // 如果分类已存在，更新计数
          categories[existingCategoryIndex].count = (categories[existingCategoryIndex].count || 0) + count;
          categories[existingCategoryIndex].lastUpdated = new Date();
        } else {
          // 如果分类不存在，创建新分类
          categories.push({
            name: categoryName,
            count: count,
            firstSeen: new Date(),
            lastUpdated: new Date()
          });
        }
      }

      // 更新分类数组
      await db.collection('userInterests').doc(record._id).update({
        data: {
          categories: categories,
          lastUpdated: new Date()
        }
      });

      console.log('更新分类数组成功:', categories);

      return {
        success: true,
        message: '批量更新关键词分类成功'
      };
    } else {
      console.log(`用户兴趣记录不存在, 用户ID: ${userId}`);

      return {
        success: false,
        error: '用户兴趣记录不存在'
      };
    }
  } catch (error) {
    console.error('批量更新关键词分类失败:', error);
    return {
      success: false,
      error: error.message || '批量更新关键词分类失败'
    };
  }
}

/**
 * 更新关键词情感分数
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @param {number} emotionScore 情感分数
 * @returns {Promise<Object>} 更新结果
 */
async function updateKeywordEmotionScore(userId, keyword, emotionScore) {
  try {
    if (!userId || !keyword || typeof emotionScore !== 'number') {
      throw new Error('用户ID、关键词和情感分数不能为空');
    }

    console.log(`更新关键词情感分数, 用户ID: ${userId}, 关键词: ${keyword}, 情感分数: ${emotionScore}`);

    // 查询用户兴趣数据
    const result = await db.collection('userInterests')
      .where({ userId: userId })
      .get();

    if (result.data && result.data.length > 0) {
      const record = result.data[0];
      const keywords = record.keywords || [];

      // 查找关键词
      const keywordIndex = keywords.findIndex(k => k.word === keyword);

      if (keywordIndex >= 0) {
        // 关键词存在，更新情感分数
        const currentScore = keywords[keywordIndex].emotionScore || 0;
        const newScore = (currentScore * 0.7) + (emotionScore * 0.3); // 加权平均

        await db.collection('userInterests').doc(record._id).update({
          data: {
            [`keywords.${keywordIndex}.emotionScore`]: newScore,
            [`keywords.${keywordIndex}.lastUpdated`]: new Date(),
            lastUpdated: new Date()
          }
        });

        console.log(`更新关键词情感分数成功, 关键词: ${keyword}, 新分数: ${newScore}`);

        return {
          success: true,
          message: '更新关键词情感分数成功'
        };
      } else {
        console.log(`关键词不存在: ${keyword}`);

        return {
          success: false,
          error: '关键词不存在'
        };
      }
    } else {
      console.log(`用户兴趣记录不存在, 用户ID: ${userId}`);

      return {
        success: false,
        error: '用户兴趣记录不存在'
      };
    }
  } catch (error) {
    console.error('更新关键词情感分数失败:', error);
    return {
      success: false,
      error: error.message || '更新关键词情感分数失败'
    };
  }
}

// 导出模块
module.exports = {
  getUserInterests,
  updateUserInterest,
  batchUpdateUserInterests,
  deleteUserInterest,
  updateKeywordCategory,
  batchUpdateKeywordCategories,
  updateKeywordEmotionScore
};

*#*#*end*#*#*

*#*#*cloudfunctions\user\userPerception_new.js*#*#*begin*#*#*
// 用户画像处理模块 - 使用智谱AI优化版
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

const db = cloud.database();
const _ = db.command;

/**
 * 调用智谱AI接口
 * @param {Object} params 请求参数
 * @returns {Promise<Object>} 智谱AI响应结果
 */
async function callZhipuAI(params) {
  try {
    // 从环境变量获取API密钥
    const apiKey = process.env.ZHIPU_API_KEY || '';
    if (!apiKey) {
      console.error('未设置ZHIPU_API_KEY环境变量');
      throw new Error('智谱AI API密钥未配置');
    }

    // 构建请求头
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    };

    // 构建请求体
    const body = JSON.stringify({
      model: params.model || 'glm-4',
      messages: params.messages,
      temperature: params.temperature || 0.7,
      top_p: params.top_p || 0.8,
      max_tokens: params.max_tokens || 2000,
      response_format: params.response_format || { type: "text" }
    });

    console.log(`调用智谱AI接口, 模型: ${params.model || 'glm-4'}`);

    // 发送请求
    const response = await cloud.callFunction({
      name: 'httpRequest',
      data: {
        url: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
        method: 'POST',
        headers: headers,
        body: body
      }
    });

    // 检查响应是否有错误
    if (response.result.error) {
      console.error('智谱AI返回错误:', response.result);
      throw new Error(`智谱AI调用失败: ${response.result.message || '未知错误'}`);
    }

    // 解析响应
    const result = JSON.parse(response.result.body);

    // 检查智谱AI响应是否有错误
    if (result.error) {
      console.error('智谱AI API返回错误:', result.error);
      throw new Error(`智谱AI API错误: ${result.error.message || result.error.type || '未知错误'}`);
    }

    return result;
  } catch (error) {
    console.error('调用智谱AI接口失败:', error);
    throw error;
  }
}

/**
 * 获取用户画像
 * @param {string} userId 用户ID
 * @returns {Promise<Object>} 用户画像数据
 */
async function getUserPerception(userId) {
  try {
    console.log(`开始获取用户画像, 用户ID: ${userId}`);

    // 查询用户兴趣数据
    const userInterests = await db.collection('userInterests')
      .where({ user_id: userId })
      .get();

    console.log(`获取到用户兴趣数据: ${userInterests.data.length}条`);

    // 查询用户情绪记录
    const emotionRecords = await db.collection('emotionRecords')
      .where({ userId: userId })
      .orderBy('createTime', 'desc')
      .limit(20)
      .get();

    // 查询用户对话记录
    const chatMessages = await db.collection('messages')
      .where({
        userId: userId,
        sender_type: 'user'  // 只获取用户发送的消息
      })
      .orderBy('timestamp', 'desc')
      .limit(50)  // 获取最近50条消息
      .get();

    console.log(`获取到用户对话记录: ${chatMessages.data.length}条`);

    // 处理用户兴趣数据
    let interests = [];
    let interestVector = [];

    if (userInterests.data && userInterests.data.length > 0) {
      // 处理keywords字段，如果存在
      if (userInterests.data[0].keywords && Array.isArray(userInterests.data[0].keywords)) {
        interests = userInterests.data[0].keywords.map(keyword => {
          // 如果是字符串，直接返回
          if (typeof keyword === 'string') {
            return keyword;
          }
          // 如果是对象，尝试获取关键字或标签
          else if (typeof keyword === 'object') {
            return keyword.keyword || keyword.tag || keyword.value || '';
          }
          return '';
        }).filter(keyword => keyword !== '');
      }
      // 兼容旧版数据结构
      else if (userInterests.data[0].interests && Array.isArray(userInterests.data[0].interests)) {
        interests = userInterests.data[0].interests;
      }

      console.log('处理后的用户兴趣:', interests);

      // 尝试获取兴趣向量，如果存在
      interestVector = userInterests.data[0].aggregated_interest_vector || [];
    }

    // 处理用户情绪数据
    const emotionPatterns = processEmotionRecords(emotionRecords.data || []);

    // 尝试使用智谱AI分析用户对话
    let aiPersonalityTraits = [];
    let aiPersonalitySummary = '';
    let aiUserPerception = null;

    try {
      if (chatMessages.data && chatMessages.data.length > 0) {
        // 分析用户对话内容
        aiUserPerception = await analyzeUserDialogues(chatMessages.data);
        console.log('智谱AI分析结果:', aiUserPerception);

        // 转换AI分析结果为个性特征数据
        aiPersonalityTraits = convertToPersonalityTraits(aiUserPerception);

        // 生成个性总结
        aiPersonalitySummary = await generateAIPersonalitySummary(aiUserPerception);
      }
    } catch (aiError) {
      console.error('智谱AI分析失败，将使用备选方法:', aiError);
    }

    // 如果AI分析失败，使用备选方法
    const personalityTraits = aiPersonalityTraits.length > 0 ?
      aiPersonalityTraits :
      generatePersonalityTraits(interests, emotionPatterns);

    const personalitySummary = aiPersonalitySummary ?
      aiPersonalitySummary :
      generatePersonalitySummary(personalityTraits);

    // 合并AI分析结果和传统分析结果
    const result = {
      interests: interests.map(item => {
        if (typeof item === 'string') return item;
        if (typeof item === 'object') return item.tag || item.keyword || item.value || '';
        return '';
      }).filter(item => item !== ''),
      personalityTraits,
      personalitySummary,
      emotionPatterns
    };

    console.log('最终用户画像数据:', JSON.stringify(result));

    // 如果有AI分析结果，添加到返回数据中
    if (aiUserPerception) {
      result.aiPerception = {
        interests: aiUserPerception.interests || [],
        preferences: aiUserPerception.preferences || [],
        communication_style: aiUserPerception.communication_style || '',
        emotional_patterns: aiUserPerception.emotional_patterns || []
      };
    }

    return result;
  } catch (error) {
    console.error('获取用户画像失败:', error);
    throw error;
  }
}

/**
 * 分析用户对话内容
 * @param {Array} messages 用户消息记录
 * @returns {Promise<Object>} 用户画像分析结果
 */
async function analyzeUserDialogues(messages) {
  try {
    // 提取用户消息文本
    const userText = messages.map(msg => msg.content || '').join('\n');

    if (!userText.trim()) {
      throw new Error('没有足够的用户消息进行分析');
    }

    // 调用智谱AI分析用户画像
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: "你是一个用户画像分析专家，能够从用户的对话中提取用户的兴趣、偏好、沟通风格和情感模式。"
        },
        {
          role: "user",
          content: `请分析以下用户消息，提取用户的兴趣、偏好、沟通风格和情感模式：

          ${userText}

          请以JSON格式返回结果，格式如下：
          {
            "interests": ["兴趣1", "兴趣2"],
            "preferences": ["偏好1", "偏好2"],
            "communication_style": "用户的沟通风格描述",
            "emotional_patterns": ["情感模式1", "情感模式2"]
          }

          注意：
          1. 兴趣指用户喜欢的活动、话题或领域
          2. 偏好指用户在选择或决策中表现出的倾向
          3. 沟通风格指用户表达自己的方式和语言特点
          4. 情感模式指用户表达情感的方式和情绪变化规律`
        }
      ],
      temperature: 0.3,
      response_format: { type: "json_object" }
    });

    // 解析JSON结果
    const responseContent = result.choices[0].message.content;
    let userPerception;

    try {
      userPerception = JSON.parse(responseContent);
    } catch (parseError) {
      console.error('解析用户画像JSON失败:', parseError);
      // 尝试使用正则表达式提取JSON部分
      const jsonMatch = responseContent.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          userPerception = JSON.parse(jsonMatch[0]);
        } catch (e) {
          console.error('二次解析用户画像JSON失败:', e);
          throw new Error('无法解析AI返回的用户画像数据');
        }
      } else {
        throw new Error('无法解析AI返回的用户画像数据');
      }
    }

    return userPerception;
  } catch (error) {
    console.error('分析用户对话失败:', error);
    throw error;
  }
}

/**
 * 将AI分析结果转换为个性特征数据
 * @param {Object} aiPerception AI分析的用户画像
 * @returns {Array} 个性特征数据
 */
function convertToPersonalityTraits(aiPerception) {
  if (!aiPerception) return [];

  // 特征映射表
  const traitMappings = {
    // 沟通风格相关特征
    '直接': { trait: '直接表达', score: 0.8 },
    '委婉': { trait: '委婉表达', score: 0.8 },
    '详细': { trait: '细节关注', score: 0.7 },
    '简洁': { trait: '简洁表达', score: 0.7 },
    '正式': { trait: '正式表达', score: 0.6 },
    '非正式': { trait: '随意表达', score: 0.7 },
    '礼貌': { trait: '礼貌性', score: 0.8 },
    '幽默': { trait: '幽默感', score: 0.8 },

    // 情感模式相关特征
    '情绪稳定': { trait: '情绪稳定性', score: 0.8 },
    '情绪波动': { trait: '情绪敏感性', score: 0.7 },
    '积极': { trait: '乐观性', score: 0.8 },
    '消极': { trait: '悲观性', score: 0.7 },
    '理性': { trait: '理性思考', score: 0.8 },
    '感性': { trait: '感性思考', score: 0.8 },
    '共情': { trait: '同理心', score: 0.9 },
    '自我': { trait: '自我关注', score: 0.7 },

    // 兴趣和偏好相关特征
    '艺术': { trait: '创造力', score: 0.8 },
    '音乐': { trait: '艺术鉴赏', score: 0.7 },
    '阅读': { trait: '求知欲', score: 0.8 },
    '学习': { trait: '学习能力', score: 0.8 },
    '科技': { trait: '技术思维', score: 0.7 },
    '旅行': { trait: '冒险精神', score: 0.7 },
    '社交': { trait: '社交性', score: 0.8 },
    '独处': { trait: '独立性', score: 0.7 },
    '运动': { trait: '活力', score: 0.7 },
    '美食': { trait: '感官享受', score: 0.6 },
    '工作': { trait: '责任感', score: 0.8 },
    '家庭': { trait: '亲和力', score: 0.8 }
  };

  // 提取所有关键词
  const allKeywords = [
    ...(aiPerception.interests || []),
    ...(aiPerception.preferences || []),
    ...(aiPerception.emotional_patterns || [])
  ];

  // 提取沟通风格关键词
  const communicationStyle = aiPerception.communication_style || '';
  const communicationKeywords = Object.keys(traitMappings).filter(
    keyword => communicationStyle.includes(keyword)
  );

  // 合并所有关键词
  const allRelevantKeywords = [...allKeywords, ...communicationKeywords];

  // 映射到特征
  const traitsMap = new Map();

  allRelevantKeywords.forEach(keyword => {
    // 查找完全匹配
    if (traitMappings[keyword]) {
      const { trait, score } = traitMappings[keyword];
      if (!traitsMap.has(trait) || traitsMap.get(trait) < score) {
        traitsMap.set(trait, score);
      }
      return;
    }

    // 查找部分匹配
    for (const [key, value] of Object.entries(traitMappings)) {
      if (keyword.includes(key) || key.includes(keyword)) {
        const { trait, score } = value;
        // 部分匹配的分数略低
        const adjustedScore = score * 0.9;
        if (!traitsMap.has(trait) || traitsMap.get(trait) < adjustedScore) {
          traitsMap.set(trait, adjustedScore);
        }
        break;
      }
    }
  });

  // 添加默认特征
  const defaultTraits = [
    { trait: '责任感', score: 0.7 },
    { trait: '同理心', score: 0.7 },
    { trait: '创造力', score: 0.6 },
    { trait: '社交性', score: 0.6 },
    { trait: '冒险精神', score: 0.5 }
  ];

  defaultTraits.forEach(({ trait, score }) => {
    if (!traitsMap.has(trait)) {
      traitsMap.set(trait, score);
    }
  });

  // 转换为数组
  return Array.from(traitsMap.entries()).map(([trait, score]) => ({
    trait,
    score
  }));
}

/**
 * 使用智谱AI生成个性总结
 * @param {Object} userPerception 用户画像数据
 * @returns {Promise<string>} 个性总结
 */
async function generateAIPersonalitySummary(userPerception) {
  if (!userPerception) {
    return '';
  }

  try {
    // 构建用户画像文本
    const userPerceptionText = `
      用户兴趣: ${Array.isArray(userPerception.interests) ? userPerception.interests.join(', ') : '未知'}
      用户偏好: ${Array.isArray(userPerception.preferences) ? userPerception.preferences.join(', ') : '未知'}
      用户沟通风格: ${userPerception.communication_style || '未知'}
      用户情感模式: ${Array.isArray(userPerception.emotional_patterns) ? userPerception.emotional_patterns.join(', ') : '未知'}
    `;

    // 调用智谱AI生成用户画像摘要
    const result = await callZhipuAI({
      model: "glm-4-flash",
      messages: [
        {
          role: "system",
          content: "你是一个用户画像分析专家，能够将用户画像转化为自然、友好的描述。"
        },
        {
          role: "user",
          content: `请将以下用户画像转化为一段自然、友好的描述，可以在对话中自然地提及：

          ${userPerceptionText}

          要求：
          1. 描述应该自然、友好，不要像机器分析报告
          2. 长度控制在100-150字之间
          3. 可以加入一些温暖的建议或鼓励
          4. 不要使用"根据我的分析"、"我注意到"等明显的分析语言`
        }
      ],
      temperature: 0.7,
      max_tokens: 500
    });

    // 返回生成的摘要
    return result.choices[0].message.content;
  } catch (error) {
    console.error('生成用户画像摘要失败:', error);
    return '';
  }
}

/**
 * 处理情绪记录数据
 * @param {Array} records 情绪记录数据
 * @returns {Object} 处理后的情绪模式
 */
function processEmotionRecords(records) {
  // 情绪类型计数
  const emotionCounts = {};
  let totalRecords = records.length;

  // 统计各情绪类型出现次数
  records.forEach(record => {
    const mainEmotion = record.mainEmotion || '未知';
    emotionCounts[mainEmotion] = (emotionCounts[mainEmotion] || 0) + 1;

    // 处理次要情绪
    if (record.emotions && Array.isArray(record.emotions)) {
      record.emotions.forEach(emotion => {
        if (emotion.emotion && emotion.emotion !== mainEmotion) {
          emotionCounts[emotion.emotion] = (emotionCounts[emotion.emotion] || 0) + 0.5;
        }
      });
    }
  });

  // 转换为百分比
  const emotionPercentages = {};
  if (totalRecords > 0) {
    Object.keys(emotionCounts).forEach(emotion => {
      emotionPercentages[emotion] = (emotionCounts[emotion] / totalRecords) * 100;
    });
  }

  // 情绪变化趋势
  const emotionTrends = {};
  if (records.length >= 5) {
    // 分析最近5条记录的情绪变化
    const recentRecords = records.slice(0, 5);
    const emotionSequence = recentRecords.map(record => record.mainEmotion);

    // 简单趋势分析
    const positiveEmotions = ['快乐', '满足', '平静', '期待'];
    const negativeEmotions = ['焦虑', '压力', '疲惫', '担忧', '愤怒', '悲伤'];

    let positiveCount = 0;
    let negativeCount = 0;

    emotionSequence.forEach(emotion => {
      if (positiveEmotions.includes(emotion)) {
        positiveCount++;
      } else if (negativeEmotions.includes(emotion)) {
        negativeCount++;
      }
    });

    if (positiveCount > negativeCount) {
      emotionTrends.trend = '积极上升';
    } else if (positiveCount < negativeCount) {
      emotionTrends.trend = '消极下降';
    } else {
      emotionTrends.trend = '情绪波动';
    }
  } else {
    emotionTrends.trend = '数据不足';
  }

  return {
    emotionPercentages,
    emotionTrends,
    dominantEmotions: getDominantEmotions(emotionPercentages)
  };
}

/**
 * 获取主导情绪
 * @param {Object} emotionPercentages 情绪百分比
 * @returns {Array} 主导情绪列表
 */
function getDominantEmotions(emotionPercentages) {
  // 将情绪按百分比排序
  const sortedEmotions = Object.entries(emotionPercentages)
    .sort((a, b) => b[1] - a[1])
    .filter(([emotion, percentage]) => percentage > 10); // 只保留占比超过10%的情绪

  return sortedEmotions.map(([emotion, percentage]) => ({
    emotion,
    percentage
  }));
}

/**
 * 生成个性特征数据 (备选方法)
 * @param {Array} interests 用户兴趣
 * @param {Object} emotionPatterns 情绪模式
 * @returns {Array} 个性特征数据
 */
function generatePersonalityTraits(interests, emotionPatterns) {
  // 基于兴趣和情绪模式生成个性特征
  const traits = [
    { trait: '责任感', score: 0.7 },
    { trait: '完美主义', score: 0.6 },
    { trait: '同理心', score: 0.8 },
    { trait: '创造力', score: 0.65 },
    { trait: '社交性', score: 0.5 },
    { trait: '冒险精神', score: 0.4 },
    { trait: '耐心', score: 0.6 }
  ];

  // 根据兴趣调整特征分数
  interests.forEach(interest => {
    // 获取兴趣标签，兼容不同的数据结构
    let tag = '';
    if (typeof interest === 'string') {
      tag = interest;
    } else if (typeof interest === 'object') {
      tag = interest.tag || interest.keyword || interest.value || '';
    }

    if (!tag) return; // 跳过空标签

    console.log(`处理兴趣标签: ${tag}`);

    // 根据兴趣标签调整特征分数
    switch (tag.toLowerCase()) {
      case '艺术':
      case '音乐':
      case '绘画':
      case '创作':
        traits.find(t => t.trait === '创造力').score += 0.1;
        break;
      case '旅行':
      case '探险':
      case '户外':
        traits.find(t => t.trait === '冒险精神').score += 0.1;
        break;
      case '阅读':
      case '学习':
      case '科学':
        traits.find(t => t.trait === '责任感').score += 0.05;
        break;
      case '社交':
      case '派对':
      case '聚会':
        traits.find(t => t.trait === '社交性').score += 0.1;
        break;
    }
  });

  // 根据情绪模式调整特征分数
  if (emotionPatterns.dominantEmotions.length > 0) {
    emotionPatterns.dominantEmotions.forEach(({ emotion, percentage }) => {
      switch (emotion) {
        case '焦虑':
          traits.find(t => t.trait === '完美主义').score += 0.05;
          break;
        case '平静':
          traits.find(t => t.trait === '耐心').score += 0.05;
          break;
        case '快乐':
          traits.find(t => t.trait === '社交性').score += 0.05;
          break;
        case '同情':
          traits.find(t => t.trait === '同理心').score += 0.1;
          break;
      }
    });
  }

  // 确保分数在0-1范围内
  traits.forEach(trait => {
    trait.score = Math.min(Math.max(trait.score, 0), 1);
  });

  return traits;
}

/**
 * 生成个性总结 (备选方法)
 * @param {Array} traits 个性特征
 * @returns {string} 个性总结
 */
function generatePersonalitySummary(traits) {
  // 获取得分最高的三个特征
  const topTraits = [...traits]
    .sort((a, b) => b.score - a.score)
    .slice(0, 3);

  // 生成总结文本
  return `根据你的对话内容和情绪反应，我们分析出你是一个${topTraits[0].trait}强、具有${topTraits[1].trait}的人，同时也展现出较高的${topTraits[2].trait}。`;
}

module.exports = {
  getUserPerception,
  analyzeUserDialogues,
  generateAIPersonalitySummary
};

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-analysis\emotion-analysis.js*#*#*begin*#*#*
// components/emotion-analysis/emotion-analysis.js
const emotionService = require('../../services/emotionService');
const keywordService = require('../../services/keywordService');

Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // 用户ID
    userId: {
      type: String,
      value: ''
    },
    // 角色ID
    roleId: {
      type: String,
      value: ''
    },
    // 当前情感分析结果
    emotion: {
      type: Object,
      value: null,
      observer: function(newVal) {
        if (newVal) {
          // 计算强度格式化值
          const intensity = newVal.intensity ? Math.round(newVal.intensity * 100) : 0;
          this.setData({
            currentEmotion: newVal,
            intensityFormatted: String(intensity)
          });
          this.initCharts();
        }
      }
    },
    // 是否显示
    show: {
      type: Boolean,
      value: false
    },
    // 暗黑模式
    darkMode: {
      type: Boolean,
      value: false,
      observer: function(newVal) {
        this.setData({
          isDarkMode: newVal
        });
        this.initCharts();
      }
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    currentEmotion: null,
    emotionHistory: [],
    isDarkMode: false,
    intensityFormatted: '0',
    // 图表相关
    trendData: [50, 50, 50, 50, 50],
    trendLabels: ['12:00', '12:30', '13:00', '13:30', '14:00'],
    radarData: [50, 50, 50, 50, 50],
    // 关键词相关
    keywords: [],
    // 情感类型映射
    emotionTypes: {
      joy: '喜悦',
      sadness: '伤感',
      anger: '愤怒',
      anxiety: '焦虑',
      neutral: '平静',
      // 增加中文情感类型映射
      '喜悦': '喜悦',
      '伤感': '伤感',
      '愤怒': '愤怒',
      '焦虑': '焦虑',
      '平静': '平静',
      '平稳': '平静'
    },
    // 情感维度
    emotionDimensions: ['积极', '能力', '共情', '压力', '稳定']
  },

  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
      this.loadEmotionHistory();
    },
    ready: function() {
      // 在组件在视图层布局完成后执行
      this.initCharts();
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    // 加载情感历史记录
    async loadEmotionHistory() {
      if (!this.data.userId || !this.data.roleId) {
        return;
      }

      try {
        const history = await emotionService.getEmotionHistory(this.data.userId, this.data.roleId, 10);
        this.setData({
          emotionHistory: history
        });
        this.initCharts();
      } catch (err) {
        console.error('加载情感历史记录失败:', err);
      }
    },

    // 分析文本情感
    async analyzeText(text) {
      if (!text || typeof text !== 'string' || text.trim() === '') {
        return null;
      }

      try {
        // 调用情感分析服务
        const result = await emotionService.analyzeEmotion(text);

        if (result) {
          // 更新当前情感分析结果
          console.log('更新情感数据:', result);
          const intensity = result.intensity ? Math.round(result.intensity * 100) : 0;

          // 提取关键词
          // 如果情感分析结果中包含关键词，直接使用
          if (result.keywords && Array.isArray(result.keywords) && result.keywords.length > 0) {
            console.log('使用情感分析返回的关键词:', result.keywords);
            // 将关键词分类并更新到数据库
            this.classifyAndUpdateKeywords(result.keywords);
          } else {
            // 如果情感分析结果中不包含关键词，则从文本中提取
            this.extractKeywords(text);
          }

          this.setData({
            currentEmotion: result,
            intensityFormatted: String(intensity)
          }, () => {
            // 在数据更新后初始化图表
            this.initCharts();
          });

          return result;
        }
      } catch (err) {
        console.error('分析文本情感失败:', err);
      }

      return null;
    },

    // 提取关键词
    async extractKeywords(text) {
      if (!text || typeof text !== 'string' || text.trim() === '') {
        return;
      }

      try {
        // 调用关键词提取服务
        const keywords = await keywordService.extractKeywords(text, 10);
        console.log('提取到的关键词:', keywords);

        // 为每个关键词添加格式化后的权重值
        const formattedKeywords = keywords.map(item => {
          return {
            ...item,
            weightFormatted: Math.round(item.weight * 100)
          };
        });

        // 更新关键词数据
        this.setData({
          keywords: formattedKeywords
        });

        // 将关键词分类并更新到数据库
        this.classifyAndUpdateKeywords(keywords);
      } catch (err) {
        console.error('关键词提取失败:', err);
      }
    },

    // 分类关键词并更新到数据库
    async classifyAndUpdateKeywords(keywords) {
      if (!keywords || keywords.length === 0 || !this.data.userId) {
        return;
      }

      try {
        // 引入用户兴趣服务
        const userInterestsService = require('../../services/userInterestsService');

        // 调用云函数分类关键词
        const result = await wx.cloud.callFunction({
          name: 'analysis',
          data: {
            type: 'classify_keywords',
            keywords: keywords.map(k => k.word),
            batch: true
          }
        });

        console.log('关键词分类结果:', result);

        // 如果分类成功，将分类结果合并到关键词中
        if (result.result && result.result.success &&
            result.result.data && Array.isArray(result.result.data.classifications)) {

          // 将分类结果转换为映射
          const categoryMap = {};
          result.result.data.classifications.forEach(item => {
            categoryMap[item.keyword] = item.category;
          });

          // 将分类结果合并到关键词中
          const classifiedKeywords = keywords.map(keyword => ({
            word: keyword.word,
            weight: keyword.weight,
            category: categoryMap[keyword.word] || '未分类',
            emotionScore: 0 // 默认情绪分数
          }));

          console.log('分类后的关键词:', classifiedKeywords);

          // 创建分类统计数据
          const categoryStats = {};
          classifiedKeywords.forEach(keyword => {
            if (keyword.category) {
              categoryStats[keyword.category] = (categoryStats[keyword.category] || 0) + 1;
            }
          });

          console.log('分类统计:', categoryStats);

          // 创建分类数组
          const categoriesArray = Object.entries(categoryStats).map(([name, count]) => ({
            name,
            count,
            firstSeen: new Date(),
            lastUpdated: new Date()
          }));

          // 批量更新用户兴趣
          const updateResult = await userInterestsService.batchUpdateUserInterests(
            this.data.userId,
            classifiedKeywords,
            true, // 自动分类
            categoryStats, // 传递分类统计
            categoriesArray // 传递分类数组
          );
          console.log('更新用户兴趣结果:', updateResult);
        } else {
          // 如果分类失败，使用默认分类更新用户兴趣
          const defaultKeywords = keywords.map(keyword => ({
            word: keyword.word,
            weight: keyword.weight,
            category: '未分类',
            emotionScore: 0
          }));

          // 创建默认分类统计数据
          const categoryStats = {
            '未分类': defaultKeywords.length
          };

          // 创建分类数组
          const categoriesArray = [{
            name: '未分类',
            count: defaultKeywords.length,
            firstSeen: new Date(),
            lastUpdated: new Date()
          }];

          // 批量更新用户兴趣
          const updateResult = await userInterestsService.batchUpdateUserInterests(
            this.data.userId,
            defaultKeywords,
            true, // 自动分类
            categoryStats, // 传递分类统计
            categoriesArray // 传递分类数组
          );
          console.log('使用默认分类更新用户兴趣结果:', updateResult);
        }
      } catch (err) {
        console.error('分类关键词并更新到数据库失败:', err);
      }
    },

    // 初始化图表
    initCharts() {
      console.log('开始初始化图表');
      try {
        this.updateTrendData();
        this.updateRadarData();
      } catch (error) {
        console.error('初始化图表失败:', error);
      }
    },

    // 更新趋势图数据
    updateTrendData() {
      console.log('更新趋势图数据');
      try {
        // 准备数据
        const history = this.data.emotionHistory || [];
        const dates = [];
        const intensities = [];

        // 如果有历史数据
        if (history.length > 0) {
          history.forEach(item => {
            const date = new Date(item.createTime);
            dates.push(`${date.getHours()}:${date.getMinutes()}`);
            intensities.push(Math.round(item.analysis.intensity * 100));
          });
        } else {
          // 如果没有历史数据，使用当前时间和当前情感强度
          const now = new Date();
          const currentIntensity = this.data.currentEmotion ?
            Math.round(this.data.currentEmotion.intensity * 100) : 50;

          for (let i = 0; i < 5; i++) {
            const time = new Date(now.getTime() - i * 30 * 60 * 1000);
            dates.unshift(`${time.getHours()}:${time.getMinutes()}`);
            intensities.unshift(currentIntensity);
          }
        }

        // 更新数据
        this.setData({
          trendData: intensities,
          trendLabels: dates
        });
      } catch (error) {
        console.error('更新趋势图数据失败:', error);
      }
    },

    // 更新雷达图数据
    updateRadarData() {
      console.log('更新雷达图数据');
      try {
        // 准备数据
        const currentEmotion = this.data.currentEmotion;
        let data = [50, 50, 50, 50, 50]; // 默认值

        if (currentEmotion) {
          // 根据情感类型和强度计算各维度的值
          const intensity = currentEmotion.intensity * 100;
          const type = currentEmotion.type;

          // 根据情感类型调整各维度的值
          switch(type) {
            case 'joy':
            case '喜悦':
              data = [80, 70, 75, 30, 65];
              break;
            case 'sadness':
            case '伤感':
            case '悲伤':
              data = [30, 40, 60, 70, 45];
              break;
            case 'anger':
            case '愤怒':
              data = [60, 65, 30, 80, 35];
              break;
            case 'anxiety':
            case '焦虑':
              data = [40, 50, 45, 75, 30];
              break;
            case 'neutral':
            case '平静':
            case '平稳':
              data = [50, 50, 50, 50, 50];
              break;
          }

          // 根据强度调整
          data = data.map(value => {
            // 将值向情感强度靠拢
            return Math.round(value * 0.5 + intensity * 0.5);
          });
        }

        // 更新数据
        this.setData({
          radarData: data
        });
      } catch (error) {
        console.error('更新雷达图数据失败:', error);
      }
    },

    // 记录心情
    saveEmotion() {
      this.triggerEvent('save');
    },

    // 分享给TA
    shareEmotion() {
      this.triggerEvent('share');
    },

    // 关闭面板
    closePanel() {
      this.triggerEvent('close');
    }
  }
})

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-analysis\emotion-analysis.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-analysis\emotion-analysis.wxml*#*#*begin*#*#*
<!-- components/emotion-analysis/emotion-analysis.wxml -->
<view class="emotion-analysis {{show ? 'show' : ''}} {{darkMode ? 'dark' : ''}}">
  <view class="header">
    <view class="title">情感分析</view>
    <view class="emotion-tag {{currentEmotion.type}}">
      {{currentEmotion.type || '未知'}}
    </view>
    <view class="close-btn" bindtap="closePanel">×</view>
  </view>

  <!-- 情感概览 -->
  <view class="overview-section">
    <view class="overview-item">
      <view class="label">当前情绪</view>
      <view class="value">{{currentEmotion.type || '未知'}}</view>
    </view>
    <view class="overview-item">
      <view class="label">情绪强度</view>
      <view class="value">{{intensityFormatted}}%</view>
    </view>
    <view class="overview-item">
      <view class="label">变化趋势</view>
      <view class="value">{{currentEmotion.trend || '平稳'}}</view>
    </view>
  </view>

  <!-- 情感趋势图 - 简化版 -->
  <view class="chart-section">
    <view class="section-title">情感趋势</view>
    <view class="simple-chart-container">
      <view class="trend-info">
        <view class="trend-label">当前情绪强度</view>
        <view class="trend-value">{{intensityFormatted}}%</view>
      </view>
      <view class="progress-bar-container">
        <view class="progress-bar" style="width: {{intensityFormatted}}%"></view>
      </view>
    </view>
  </view>

  <!-- 情感维度 - 简化版 -->
  <view class="chart-section">
    <view class="section-title">情感分析</view>
    <view class="dimensions-container">
      <view class="dimension-item" wx:for="{{emotionDimensions}}" wx:key="index">
        <view class="dimension-label">{{item}}</view>
        <view class="dimension-bar-container">
          <view class="dimension-bar" style="width: {{radarData[index]}}%"></view>
        </view>
        <view class="dimension-value">{{radarData[index]}}%</view>
      </view>
    </view>
  </view>

  <!-- 情感建议 -->
  <view class="suggestion-section" wx:if="{{currentEmotion.suggestions && currentEmotion.suggestions.length > 0}}">
    <view class="section-title">情感建议</view>
    <view class="suggestion-list">
      <view class="suggestion-item" wx:for="{{currentEmotion.suggestions}}" wx:key="index">
        <text class="suggestion-icon">💡</text>
        <text class="suggestion-text">{{item}}</text>
      </view>
    </view>
  </view>

  <!-- 关键词云 -->
  <view class="tags-section">
    <view class="section-title">关键词云</view>
    <view class="tags-container">
      <block wx:if="{{keywords.length > 0}}">
        <view class="tag-item"
              wx:for="{{keywords}}"
              wx:key="index"
              style="font-size: {{12 + item.weight * 8}}px; opacity: {{0.6 + item.weight * 0.4}}">
          {{item.word}}
        </view>
      </block>
      <block wx:else>
        <view class="tag-item" wx:for="{{['积极思考', '情绪管理', '压力缓解', '自我关怀', '情绪稳定', '共情能力', '自信']}}" wx:key="index">
          {{item}}
        </view>
      </block>
    </view>
  </view>

  <!-- 操作按钮 -->
  <view class="action-section">
    <button class="action-btn save-btn" bindtap="saveEmotion">
      <text class="btn-icon">📝</text>
      <text class="btn-text">记录心情</text>
    </button>
    <button class="action-btn share-btn" bindtap="shareEmotion">
      <text class="btn-icon">💌</text>
      <text class="btn-text">分享给TA</text>
    </button>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-analysis\emotion-analysis.wxss*#*#*begin*#*#*
/* components/emotion-analysis/emotion-analysis.wxss */
.emotion-analysis {
  width: 100%;
  height: 100%;
  background-color: #FFFFFF;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  padding: 30rpx;
  box-sizing: border-box;
}

.emotion-analysis.dark {
  background-color: #1C1B1F;
  color: #E6E1E5;
}

/* 头部样式 */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 30rpx;
  position: relative;
}

.title {
  font-size: 36rpx;
  font-weight: 600;
}

.emotion-tag {
  font-size: 24rpx;
  padding: 6rpx 16rpx;
  border-radius: 20rpx;
  background-color: #E5E7EB;
  color: #4B5563;
}

.emotion-tag.joy {
  background-color: #DCFCE7;
  color: #166534;
}

.emotion-tag.sadness {
  background-color: #DBEAFE;
  color: #1E40AF;
}

.emotion-tag.anger {
  background-color: #FEE2E2;
  color: #B91C1C;
}

.emotion-tag.anxiety {
  background-color: #FEF3C7;
  color: #92400E;
}

.emotion-tag.neutral {
  background-color: #E5E7EB;
  color: #4B5563;
}

.close-btn {
  position: absolute;
  right: 0;
  top: 0;
  width: 60rpx;
  height: 60rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40rpx;
  color: #9CA3AF;
  cursor: pointer;
}

/* 概览部分 */
.overview-section {
  display: flex;
  justify-content: space-between;
  margin-bottom: 30rpx;
  background-color: #F9FAFB;
  border-radius: 16rpx;
  padding: 20rpx;
}

.dark .overview-section {
  background-color: #2D2C31;
}

.overview-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
}

.label {
  font-size: 24rpx;
  color: #6B7280;
  margin-bottom: 8rpx;
}

.dark .label {
  color: #A1A1AA;
}

.value {
  font-size: 32rpx;
  font-weight: 600;
  color: #111827;
}

.dark .value {
  color: #E6E1E5;
}

/* 图表部分 */
.chart-section {
  margin-bottom: 30rpx;
  background-color: #F9FAFB;
  border-radius: 16rpx;
  padding: 20rpx;
}

.dark .chart-section {
  background-color: #2D2C31;
}

.section-title {
  font-size: 28rpx;
  font-weight: 600;
  margin-bottom: 16rpx;
  color: #374151;
}

.dark .section-title {
  color: #E6E1E5;
}

/* 简化图表容器 */
.simple-chart-container {
  width: 100%;
  padding: 20rpx;
  background-color: #FFFFFF;
  border-radius: 8rpx;
  box-sizing: border-box;
}

.dark .simple-chart-container {
  background-color: #1C1B1F;
}

/* 趋势信息 */
.trend-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16rpx;
}

.trend-label {
  font-size: 24rpx;
  color: #6B7280;
}

.dark .trend-label {
  color: #A1A1AA;
}

.trend-value {
  font-size: 28rpx;
  font-weight: 600;
  color: #3B82F6;
}

.dark .trend-value {
  color: #60A5FA;
}

/* 进度条 */
.progress-bar-container {
  width: 100%;
  height: 16rpx;
  background-color: #E5E7EB;
  border-radius: 8rpx;
  overflow: hidden;
}

.dark .progress-bar-container {
  background-color: #3F3F46;
}

.progress-bar {
  height: 100%;
  background-color: #3B82F6;
  border-radius: 8rpx;
  transition: width 0.3s ease;
}

.dark .progress-bar {
  background-color: #60A5FA;
}

/* 维度容器 */
.dimensions-container {
  width: 100%;
  padding: 20rpx;
  background-color: #FFFFFF;
  border-radius: 8rpx;
  box-sizing: border-box;
}

.dark .dimensions-container {
  background-color: #1C1B1F;
}

.dimension-item {
  margin-bottom: 20rpx;
}

.dimension-item:last-child {
  margin-bottom: 0;
}

.dimension-label {
  font-size: 24rpx;
  color: #6B7280;
  margin-bottom: 8rpx;
}

.dark .dimension-label {
  color: #A1A1AA;
}

.dimension-bar-container {
  width: 100%;
  height: 12rpx;
  background-color: #E5E7EB;
  border-radius: 6rpx;
  overflow: hidden;
  margin-bottom: 4rpx;
}

.dark .dimension-bar-container {
  background-color: #3F3F46;
}

.dimension-bar {
  height: 100%;
  background-color: #3B82F6;
  border-radius: 6rpx;
  transition: width 0.3s ease;
}

.dark .dimension-bar {
  background-color: #60A5FA;
}

.dimension-value {
  font-size: 20rpx;
  color: #9CA3AF;
  text-align: right;
}

.dark .dimension-value {
  color: #71717A;
}

/* 建议部分 */
.suggestion-section {
  margin-bottom: 30rpx;
  background-color: #F9FAFB;
  border-radius: 16rpx;
  padding: 20rpx;
}

.dark .suggestion-section {
  background-color: #2D2C31;
}

.suggestion-list {
  display: flex;
  flex-direction: column;
  gap: 16rpx;
}

.suggestion-item {
  display: flex;
  align-items: flex-start;
  gap: 12rpx;
  font-size: 28rpx;
  color: #4B5563;
  line-height: 1.5;
}

.dark .suggestion-item {
  color: #D1D5DB;
}

.suggestion-icon {
  flex-shrink: 0;
  font-size: 32rpx;
}

.suggestion-text {
  flex: 1;
}

/* 标签部分 */
.tags-section {
  margin-bottom: 30rpx;
  background-color: #F9FAFB;
  border-radius: 16rpx;
  padding: 20rpx;
}

.dark .tags-section {
  background-color: #2D2C31;
}

.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 16rpx;
}

.tag-item {
  padding: 8rpx 20rpx;
  background-color: #EFF6FF;
  color: #3B82F6;
  border-radius: 20rpx;
  font-size: 24rpx;
}

.dark .tag-item {
  background-color: #1E3A8A;
  color: #93C5FD;
}

/* 操作按钮 */
.action-section {
  display: flex;
  gap: 20rpx;
  margin-top: 20rpx;
}

.action-btn {
  flex: 1;
  height: 88rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 44rpx;
  font-size: 28rpx;
  gap: 8rpx;
  border: none;
}

.save-btn {
  background-color: #3B82F6;
  color: #FFFFFF;
}

.share-btn {
  background-color: #F3F4F6;
  color: #4B5563;
}

.dark .share-btn {
  background-color: #374151;
  color: #E5E7EB;
}

.btn-icon {
  font-size: 32rpx;
}

.btn-text {
  font-size: 28rpx;
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-card\index.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
} 
*#*#*end*#*#*

*#*#*miniprogram\components\emotion-card\index.ts*#*#*begin*#*#*
interface IEmotionData {
  // 主要情绪
  primary: {
    type: string;
    score: number;
  };
  // 详细情绪分析
  details: Array<{
    type: string;
    score: number;
  }>;
  // 情绪建议
  suggestions: string[];
}

Component({
  properties: {
    // 情绪数据
    emotion: {
      type: Object,
      value: {
        primary: {
          type: '平静',
          score: 0,
        },
        details: [],
        suggestions: [],
      } as IEmotionData,
    },
    // 是否显示详细分析
    showDetails: {
      type: Boolean,
      value: false,
    },
  },

  data: {
    // 情绪类型对应的颜色
    emotionColors: {
      '平静': '#8e9aaf',
      '快乐': '#ffd93d',
      '悲伤': '#6c757d',
      '愤怒': '#ff6b6b',
      '焦虑': '#4d96ff',
      '惊讶': '#6c5ce7',
      '恐惧': '#a8e6cf',
    },
    // 是否展开详细信息
    isExpanded: false,
  },

  methods: {
    // 切换展开状态
    toggleExpand() {
      this.setData({
        isExpanded: !this.data.isExpanded,
      });
    },

    // 查看详细分析
    viewDetails() {
      this.triggerEvent('viewDetails');
    },

    // 开始练习
    startPractice() {
      this.triggerEvent('startPractice');
    },

    // 获取情绪对应的颜色
    getEmotionColor(type: string): string {
      return this.data.emotionColors[type] || '#8e9aaf';
    },

    // 格式化情绪分数(保留2位小数)
    formatScore(score: number): string {
      return (score * 100).toFixed(2) + '%';
    },
  },
}); 
*#*#*end*#*#*

*#*#*miniprogram\components\emotion-card\index.wxml*#*#*begin*#*#*
<view class="emotion-card">
  <!-- 主要情绪 -->
  <view class="primary-emotion" bindtap="toggleExpand">
    <view class="emotion-icon" style="background-color: {{emotionColors[emotion.primary.type]}}">
      {{emotion.primary.type}}
    </view>
    <view class="emotion-info">
      <text class="emotion-type">{{emotion.primary.type}}</text>
      <text class="emotion-score">{{formatScore(emotion.primary.score)}}</text>
    </view>
    <view class="expand-icon {{isExpanded ? 'expanded' : ''}}"></view>
  </view>

  <!-- 详细信息 -->
  <view class="emotion-details {{isExpanded ? 'expanded' : ''}}">
    <!-- 情绪分布 -->
    <view class="emotion-distribution">
      <view class="distribution-title">情绪分布</view>
      <view class="distribution-list">
        <view 
          class="distribution-item" 
          wx:for="{{emotion.details}}" 
          wx:key="type"
          style="background-color: {{emotionColors[item.type]}}">
          <text class="item-type">{{item.type}}</text>
          <text class="item-score">{{formatScore(item.score)}}</text>
        </view>
      </view>
    </view>

    <!-- 情绪建议 -->
    <view class="emotion-suggestions">
      <view class="suggestions-title">建议</view>
      <view class="suggestions-list">
        <view 
          class="suggestion-item" 
          wx:for="{{emotion.suggestions}}" 
          wx:key="*this">
          {{item}}
        </view>
      </view>
    </view>

    <!-- 操作按钮 -->
    <view class="action-buttons">
      <button 
        class="action-button details" 
        bindtap="viewDetails"
        wx:if="{{showDetails}}">
        查看详细分析
      </button>
      <button 
        class="action-button practice" 
        bindtap="startPractice">
        开始练习
      </button>
    </view>
  </view>
</view>
*#*#*end*#*#*

*#*#*miniprogram\components\emotion-card\index.wxss*#*#*begin*#*#*
/* 情绪卡片组件样式 */
.emotion-card {
  background-color: #fff;
  border-radius: 12rpx;
  padding: 24rpx;
  margin-bottom: 20rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.1);
}

/* 主要情绪 */
.main-emotion {
  display: flex;
  align-items: center;
}

/* 情绪图标 */
.emotion-icon {
  width: 80rpx;
  height: 80rpx;
  margin-right: 20rpx;
}

/* 情绪信息 */
.emotion-info {
  flex: 1;
}

/* 情绪名称 */
.emotion-name {
  font-size: 32rpx;
  color: #333;
  margin-bottom: 8rpx;
  display: block;
}

/* 情绪强度 */
.emotion-intensity {
  font-size: 28rpx;
  font-weight: bold;
}

/* 展开图标 */
.expand-icon {
  width: 32rpx;
  height: 32rpx;
  position: relative;
  transition: transform 0.3s ease;
}

.expand-icon::before,
.expand-icon::after {
  content: '';
  position: absolute;
  background-color: #999;
  border-radius: 4rpx;
}

.expand-icon::before {
  width: 100%;
  height: 4rpx;
  top: 50%;
  transform: translateY(-50%);
}

.expand-icon::after {
  width: 4rpx;
  height: 100%;
  left: 50%;
  transform: translateX(-50%);
  transition: transform 0.3s ease;
}

.expand-icon.expanded::after {
  transform: translateX(-50%) scaleY(0);
}

/* 详细信息 */
.emotion-details {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.emotion-details.expanded {
  max-height: 300rpx;
  margin-top: 24rpx;
}

/* 详细信息项 */
.detail-item {
  display: flex;
  align-items: center;
  margin-bottom: 20rpx;
}

.detail-item:last-child {
  margin-bottom: 0;
}

/* 详细信息标签 */
.detail-label {
  width: 120rpx;
  font-size: 28rpx;
  color: #666;
}

/* 进度条 */
.progress-bar {
  flex: 1;
  height: 12rpx;
  background-color: #f5f5f5;
  border-radius: 6rpx;
  margin: 0 20rpx;
  overflow: hidden;
}

/* 进度条内部 */
.progress-inner {
  height: 100%;
  background-color: #409EFF;
  border-radius: 6rpx;
  transition: width 0.3s ease;
}

/* 详细信息值 */
.detail-value {
  width: 80rpx;
  font-size: 24rpx;
  color: #999;
  text-align: right;
}

/* 情绪分布 */
.emotion-distribution {
  padding: 30rpx;
  border-top: 2rpx solid var(--border-color, #eee);
}

.distribution-title {
  font-size: 28rpx;
  font-weight: bold;
  color: var(--text-color, #333);
  margin-bottom: 20rpx;
}

.distribution-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20rpx;
}

.distribution-item {
  flex: 1;
  min-width: 200rpx;
  padding: 20rpx;
  border-radius: 10rpx;
  color: #fff;
}

.item-type {
  font-size: 24rpx;
  display: block;
  margin-bottom: 8rpx;
}

.item-score {
  font-size: 28rpx;
  font-weight: bold;
}

/* 情绪建议 */
.emotion-suggestions {
  padding: 30rpx;
  border-top: 2rpx solid var(--border-color, #eee);
}

.suggestions-title {
  font-size: 28rpx;
  font-weight: bold;
  color: var(--text-color, #333);
  margin-bottom: 20rpx;
}

.suggestion-item {
  font-size: 26rpx;
  color: var(--text-color, #333);
  line-height: 1.6;
  margin-bottom: 16rpx;
  padding-left: 20rpx;
  position: relative;
}

.suggestion-item::before {
  content: '';
  position: absolute;
  left: 0;
  top: 16rpx;
  width: 8rpx;
  height: 8rpx;
  border-radius: 50%;
  background-color: var(--primary-color, #07c160);
}

/* 操作按钮 */
.action-buttons {
  display: flex;
  gap: 20rpx;
  padding: 30rpx;
  border-top: 2rpx solid var(--border-color, #eee);
}

.action-button {
  flex: 1;
  height: 80rpx;
  border-radius: 40rpx;
  font-size: 28rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #fff;
  border: 2rpx solid var(--border-color, #eee);
  color: var(--text-color, #333);
}

.action-button.details {
  background-color: var(--primary-color, #07c160);
  border-color: var(--primary-color, #07c160);
  color: #fff;
}

.action-button.practice {
  background-color: var(--bg-color, #f5f5f5);
  border-color: var(--bg-color, #f5f5f5);
  color: var(--text-color, #333);
} 
*#*#*end*#*#*

*#*#*miniprogram\components\emotion-dashboard\emotion-dashboard.js*#*#*begin*#*#*
// components/emotion-dashboard/emotion-dashboard.js
// 引入 echarts
const echarts = require('../../components/ec-canvas/echarts');

Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // 用户ID
    userId: {
      type: String,
      value: ''
    },
    // 情感分析结果
    emotionData: {
      type: Object,
      value: null,
      observer: function(newVal) {
        if (newVal) {
          this.processEmotionData(newVal);
        }
      }
    },
    // 历史情感数据
    historyData: {
      type: Array,
      value: []
    },
    // 是否显示
    show: {
      type: Boolean,
      value: false,
      observer: function(newVal) {
        if (newVal) {
          // 当显示组件时
          if (this.data.chartRendered) {
            // 如果图表已经渲染，只需要修复位置
            setTimeout(() => {
              this.fixChartsPosition();
            }, 500);
          } else if (this.data.emotionData) {
            // 如果图表还没有渲染，重新初始化
            setTimeout(() => {
              this.processEmotionData(this.data.emotionData);
            }, 300);
          }
        }
      }
    },
    // 暗黑模式
    darkMode: {
      type: Boolean,
      value: false
    },
    // 是否显示关闭按钮
    showCloseButton: {
      type: Boolean,
      value: false
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    // 处理后的情感数据
    emotion: {
      primary: '',
      secondary: [],
      intensity: 0,
      valence: 0,
      arousal: 0,
      trend: '未知',
      attention: '中',
    },
    // 雷达图数据
    radarDimensions: {
      trust: 0,
      openness: 0,
      resistance: 0,
      stress: 0,
      control: 0
    },
    // 关键词和触发词
    keywords: [],
    triggers: [],
    // 建议
    suggestions: [],
    // 总结
    summary: '',
    // 图表相关
    chartData: {
      emotion: [],
      dates: []
    },
    // ECharts配置
    emotionChartEc: {
      lazyLoad: true
    },
    radarChartEc: {
      lazyLoad: true
    },
    historyChartEc: {
      lazyLoad: true
    },
    // 情绪颜色映射
    emotionColors: {
      // 中文情感类型颜色映射
      '喜悦': '#10B981', // 绿色
      '开心': '#10B981',
      '平静': '#60A5FA', // 蓝色
      '平稳': '#60A5FA',
      '焦虑': '#F59E0B', // 黄色
      '担忧': '#F59E0B',
      '愤怒': '#EF4444', // 红色
      '生气': '#EF4444',
      '悲伤': '#6366F1', // 紫色
      '伤感': '#6366F1',
      '忧伤': '#6366F1',
      '疲惫': '#8B5CF6', // 紫罗兰
      '惊讶': '#EC4899', // 粉色
      '期待': '#14B8A6', // 青色
      '厌恶': '#7C3AED', // 深紫色
      '失望': '#9CA3AF', // 灰色
      '急切': '#F97316',  // 橙色
      '紧迫': '#F97316',  // 橙色
      '中性': '#9CA3AF', // 灰色

      // 兼容英文情感类型
      'joy': '#10B981', // 绿色
      'happy': '#10B981',
      'calm': '#60A5FA', // 蓝色
      'stable': '#60A5FA',
      'anxiety': '#F59E0B', // 黄色
      'anxious': '#F59E0B',
      'anger': '#EF4444', // 红色
      'angry': '#EF4444',
      'sadness': '#6366F1', // 紫色
      'sad': '#6366F1',
      'sorrow': '#6366F1',
      'fatigue': '#8B5CF6', // 紫罗兰
      'surprise': '#EC4899', // 粉色
      'anticipation': '#14B8A6', // 青色
      'disgust': '#7C3AED', // 深紫色
      'disappointment': '#9CA3AF', // 灰色
      'urgency': '#F97316',  // 橙色
      'neutral': '#9CA3AF' // 灰色
    },
    // 情绪图标映射
    emotionIcons: {
      // 中文情感类型图标映射
      '喜悦': 'smile',
      '开心': 'smile',
      '平静': 'meh',
      '平稳': 'meh',
      '焦虑': 'frown',
      '担忧': 'frown',
      '愤怒': 'angry',
      '生气': 'angry',
      '悲伤': 'sad-tear',
      '伤感': 'sad-tear',
      '忧伤': 'sad-tear',
      '疲惫': 'tired',
      '惊讶': 'surprise',
      '期待': 'grin-stars',
      '厌恶': 'grimace',
      '失望': 'sad',
      '急切': 'clock',
      '紧迫': 'clock',
      '中性': 'meh',

      // 兼容英文情感类型
      'joy': 'smile',
      'happy': 'smile',
      'calm': 'meh',
      'stable': 'meh',
      'anxiety': 'frown',
      'anxious': 'frown',
      'anger': 'angry',
      'angry': 'angry',
      'sadness': 'sad-tear',
      'sad': 'sad-tear',
      'sorrow': 'sad-tear',
      'fatigue': 'tired',
      'surprise': 'surprise',
      'anticipation': 'grin-stars',
      'disgust': 'grimace',
      'disappointment': 'sad',
      'urgency': 'clock',
      'neutral': 'meh'
    },
    // 英文情感类型到中文的映射
    emotionNameMap: {
      // 中文情感类型直接使用
      '喜悦': '喜悦',
      '开心': '开心',
      '平静': '平静',
      '平稳': '平稳',
      '焦虑': '焦虑',
      '担忧': '担忧',
      '愤怒': '愤怒',
      '生气': '生气',
      '悲伤': '悲伤',
      '伤感': '伤感',
      '忧伤': '忧伤',
      '疲惫': '疲惫',
      '惊讶': '惊讶',
      '期待': '期待',
      '厌恶': '厌恶',
      '失望': '失望',
      '急切': '急切',
      '紧迫': '紧迫',
      '中性': '中性',

      // 兼容英文情感类型
      'joy': '喜悦',
      'happy': '开心',
      'calm': '平静',
      'stable': '平稳',
      'anxiety': '焦虑',
      'anxious': '担忧',
      'anger': '愤怒',
      'angry': '生气',
      'sadness': '悲伤',
      'sad': '伤感',
      'sorrow': '忧伤',
      'fatigue': '疲惫',
      'surprise': '惊讶',
      'anticipation': '期待',
      'disgust': '厌恶',
      'disappointment': '失望',
      'urgency': '急切',
      'neutral': '中性'
    },
    // 图表渲染状态
    chartRendered: false
  },

  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    ready: function() {
      // 在组件在视图层布局完成后执行
      if (this.data.emotionData) {
        this.processEmotionData(this.data.emotionData);
      }
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    // 处理情感数据
    processEmotionData(data) {
      if (!data) return;

      // 使用常量控制是否打印调试日志
      const DEBUG_MODE = false;
      if (DEBUG_MODE) {
        console.log('处理情绪数据:', data);
        console.log('原始数据值 - intensity:', data.intensity, 'valence:', data.valence, 'arousal:', data.arousal);
      }

      // 提取主要情感数据 - 优先使用 type
      const primaryEmotion = data.type || data.primary_emotion || 'calm';

      // 使用常量控制是否打印调试日志
      if (DEBUG_MODE) {
        console.log('主要情绪类型:', primaryEmotion);
      }

      // 如果有关键词数据，将关键词分类并更新到数据库
      // 使用延迟执行，避免阻塞主线程
      if (data.topic_keywords && Array.isArray(data.topic_keywords) && data.topic_keywords.length > 0 && this.data.userId) {
        setTimeout(() => {
          this.classifyAndUpdateKeywords(data.topic_keywords);
        }, 500);
      }

      const emotion = {
        primary: this.data.emotionNameMap[primaryEmotion] || primaryEmotion,
        secondary: (data.secondary_emotions || []).map(e => this.data.emotionNameMap[e] || e),
        // 检测数据是否已经标准化（大于1表示可能已经是百分比值）
        intensity: typeof data.intensity === 'number'
          ? (data.intensity > 1 ? Math.min(data.intensity, 100) : Math.min(data.intensity * 100, 100))
          : 50, // 确保不超过100%

        // 对于valence，检测是否已经在 0-100 范围内
        valence: typeof data.valence === 'number'
          ? (data.valence > 1 ? Math.min(data.valence, 100) : (data.valence >= -1 && data.valence <= 1 ? (data.valence + 1) * 50 : Math.min(data.valence, 100)))
          : 50, // 智能处理不同范围的值

        // 对于arousal，检测是否已经在 0-100 范围内
        arousal: typeof data.arousal === 'number'
          ? (data.arousal > 1 ? Math.min(data.arousal, 100) : Math.min(data.arousal * 100, 100))
          : 50, // 确保不超过100%
        trend: data.trend_en || data.trend || 'unknown',
        attention: data.attention_level_en || data.attention_level || 'medium'
      };

      // 使用常量控制是否打印调试日志
      if (DEBUG_MODE) {
        console.log('处理后的情绪数据:', emotion);
        console.log('处理后的值 - intensity:', emotion.intensity, 'valence:', emotion.valence, 'arousal:', emotion.arousal);
      }

      // 提取雷达图维度
      let radarPercent = {};
      if (data.radar_dimensions) {
        // 处理数据，确保在 0-100 范围内，并检测是否已经标准化
        radarPercent = {
          trust: typeof data.radar_dimensions.trust === 'number'
            ? (data.radar_dimensions.trust > 1 ? Math.min(data.radar_dimensions.trust, 100) : Math.min(data.radar_dimensions.trust * 100, 100))
            : 50,
          openness: typeof data.radar_dimensions.openness === 'number'
            ? (data.radar_dimensions.openness > 1 ? Math.min(data.radar_dimensions.openness, 100) : Math.min(data.radar_dimensions.openness * 100, 100))
            : 50,
          resistance: typeof data.radar_dimensions.resistance === 'number'
            ? (data.radar_dimensions.resistance > 1 ? Math.min(data.radar_dimensions.resistance, 100) : Math.min(data.radar_dimensions.resistance * 100, 100))
            : 50,
          stress: typeof data.radar_dimensions.stress === 'number'
            ? (data.radar_dimensions.stress > 1 ? Math.min(data.radar_dimensions.stress, 100) : Math.min(data.radar_dimensions.stress * 100, 100))
            : 50,
          control: typeof data.radar_dimensions.control === 'number'
            ? (data.radar_dimensions.control > 1 ? Math.min(data.radar_dimensions.control, 100) : Math.min(data.radar_dimensions.control * 100, 100))
            : 50
        };
      } else {
        // 使用默认值
        radarPercent = {
          trust: 50,
          openness: 50,
          resistance: 50,
          stress: 50,
          control: 50
        };
      }

      // 使用常量控制是否打印调试日志
      if (DEBUG_MODE) {
        console.log('雷达图数据:', radarPercent);
        if (data.radar_dimensions) {
          console.log('原始雷达图数据:', data.radar_dimensions);
        }
      }

      // 更新数据
      this.setData({
        emotion,
        radarDimensions: radarPercent,
        keywords: data.topic_keywords || [],
        triggers: data.emotion_triggers || [],
        suggestions: data.suggestions || [],
        summary: data.summary || '无法生成情感报告'
      }, () => {
        // 数据更新后初始化图表
        this.initCharts();
      });
    },

    // 初始化图表
    initCharts() {
      try {
        // 使用延时确保组件已经完全渲染
        // 使用wx.nextTick替代requestAnimationFrame，适应小程序环境
        wx.nextTick(() => {
          // 使用Promise并行初始化图表，提高性能
          const initPromises = [];

          // 初始化情绪波动图
          this.emotionChartComponent = this.selectComponent('#emotionChart');
          if (this.emotionChartComponent) {
            initPromises.push(new Promise(resolve => {
              this.emotionChartComponent.init((canvas, width, height, dpr) => {
                const chart = echarts.init(canvas, null, {
                  width: width,
                  height: height,
                  devicePixelRatio: dpr
                });
                const option = this.getEmotionChartOption();
                chart.setOption(option);
                this.emotionChart = chart;
                resolve();
                return chart;
              });
            }));
          }

          // 初始化雷达图
          this.radarChartComponent = this.selectComponent('#radarChart');
          if (this.radarChartComponent) {
            initPromises.push(new Promise(resolve => {
              this.radarChartComponent.init((canvas, width, height, dpr) => {
                const chart = echarts.init(canvas, null, {
                  width: width,
                  height: height,
                  devicePixelRatio: dpr
                });
                const option = this.getRadarChartOption();
                chart.setOption(option);
                this.radarChart = chart;
                resolve();
                return chart;
              });
            }));
          }

          // 初始化历史对比图
          this.historyChartComponent = this.selectComponent('#historyChart');
          if (this.historyChartComponent) {
            initPromises.push(new Promise(resolve => {
              this.historyChartComponent.init((canvas, width, height, dpr) => {
                const chart = echarts.init(canvas, null, {
                  width: width,
                  height: height,
                  devicePixelRatio: dpr
                });
                const option = this.getHistoryChartOption();
                chart.setOption(option);
                this.historyChart = chart;
                resolve();
                return chart;
              });
            }));
          }

          // 等待所有图表初始化完成
          Promise.all(initPromises).then(() => {
            // 确保图表只渲染一次
            this.setData({
              chartRendered: true
            });

            // 图表初始化完成后，修复图表位置
            wx.nextTick(() => {
              this.fixChartsPosition();
            });
          });
        });
      } catch (error) {
        console.error('图表初始化失败:', error);
      }
    },

    // 获取情绪波动图配置
    getEmotionChartOption() {
      try {
        // 准备数据
        const now = new Date();
        const xAxisData = [];
        const seriesData = [];
        const darkMode = this.data.darkMode;

        // 生成过去7小时的时间标签
        for (let i = 6; i >= 0; i--) {
          const time = new Date(now.getTime() - i * 60 * 60 * 1000);
          xAxisData.push(`${time.getHours()}:00`);

          // 模拟数据，实际应从历史数据中获取
          if (i === 0) {
            seriesData.push(this.data.emotion.intensity);
          } else {
            // 生成50-80之间的随机值
            seriesData.push(Math.floor(Math.random() * 30) + 50);
          }
        }

        // 根据暗黑模式设置颜色
        const textColor = darkMode ? '#e0e0e0' : '#333';
        const lineColor = darkMode ? '#444' : '#999';
        const splitLineColor = darkMode ? '#333' : '#ddd';
        const mainColor = darkMode ? '#34D399' : '#10B981';
        const areaColorStart = darkMode ? 'rgba(52, 211, 153, 0.3)' : 'rgba(16, 185, 129, 0.3)';
        const areaColorEnd = darkMode ? 'rgba(52, 211, 153, 0.1)' : 'rgba(16, 185, 129, 0.1)';

        return {
          title: {
            text: '情绪波动',
            left: 'center',
            top: 0,
            textStyle: {
              fontSize: 14,
              fontWeight: 'normal',
              color: textColor
            }
          },
          tooltip: {
            trigger: 'axis',
            formatter: '{b}: {c}%',
            backgroundColor: darkMode ? 'rgba(50,50,50,0.9)' : 'rgba(255,255,255,0.9)',
            borderColor: darkMode ? '#555' : '#ddd',
            textStyle: {
              color: textColor
            }
          },
          grid: {
            left: '3%',
            right: '4%',
            bottom: '3%',
            top: '15%',
            containLabel: true
          },
          xAxis: {
            type: 'category',
            boundaryGap: false,
            data: xAxisData,
            axisLine: {
              lineStyle: {
                color: lineColor
              }
            },
            axisLabel: {
              fontSize: 10,
              color: textColor
            }
          },
          yAxis: {
            type: 'value',
            min: 0,
            max: 100,
            axisLabel: {
              formatter: '{value}%',
              fontSize: 10,
              color: textColor
            },
            splitLine: {
              lineStyle: {
                type: 'dashed',
                color: splitLineColor
              }
            }
          },
          series: [{
            name: '情绪强度',
            type: 'line',
            smooth: true,
            data: seriesData,
            itemStyle: {
              color: mainColor
            },
            areaStyle: {
              color: {
                type: 'linear',
                x: 0,
                y: 0,
                x2: 0,
                y2: 1,
                colorStops: [{
                  offset: 0,
                  color: areaColorStart
                }, {
                  offset: 1,
                  color: areaColorEnd
                }]
              }
            }
          }]
        };
      } catch (error) {
        console.error('获取情绪波动图配置失败:', error);
        return {};
      }
    },

    // 获取雷达图配置
    getRadarChartOption() {
      try {
        const dimensions = this.data.radarDimensions;
        const darkMode = this.data.darkMode;
        const data = [
          dimensions.trust || 50,
          dimensions.openness || 50,
          dimensions.control || 50,
          dimensions.resistance || 50,
          dimensions.stress || 50
        ];

        // 根据暗黑模式设置颜色
        const textColor = darkMode ? '#e0e0e0' : '#333';
        const lineColor = darkMode ? '#444' : '#999';
        const splitLineColor = darkMode ? '#333' : '#ddd';
        const mainColor = darkMode ? '#34D399' : '#10B981';
        const areaColor = darkMode ? 'rgba(52, 211, 153, 0.2)' : 'rgba(16, 185, 129, 0.3)';

        return {
          title: {
            text: '情绪维度',
            left: 'center',
            top: 0,
            textStyle: {
              fontSize: 14,
              fontWeight: 'normal',
              color: textColor
            }
          },
          tooltip: {
            trigger: 'item',
            backgroundColor: darkMode ? 'rgba(50,50,50,0.9)' : 'rgba(255,255,255,0.9)',
            borderColor: darkMode ? '#555' : '#ddd',
            textStyle: {
              color: textColor
            }
          },
          radar: {
            indicator: [
              { name: '信任度', max: 100 },
              { name: '开放度', max: 100 },
              { name: '控制感', max: 100 },
              { name: '抗拒度', max: 100 },
              { name: '压力水平', max: 100 }
            ],
            radius: '65%',
            splitNumber: 4,
            axisName: {
              fontSize: 10,
              color: textColor
            },
            splitLine: {
              lineStyle: {
                color: splitLineColor
              }
            },
            axisLine: {
              lineStyle: {
                color: lineColor
              }
            }
          },
          series: [{
            type: 'radar',
            data: [{
              value: data,
              name: '情绪维度',
              areaStyle: {
                color: areaColor
              },
              lineStyle: {
                color: mainColor
              },
              itemStyle: {
                color: mainColor
              }
            }]
          }]
        };
      } catch (error) {
        console.error('获取雷达图配置失败:', error);
        return {};
      }
    },

    // 获取历史对比图配置
    getHistoryChartOption() {
      try {
        // 准备数据
        const categories = ['一周前', '三天前', '昨天', '今天'];
        const positiveData = [60, 65, 70, this.data.emotion.valence];
        const stressData = [70, 65, 60, this.data.radarDimensions.stress];
        const energyData = [50, 55, 60, this.data.emotion.arousal];
        const darkMode = this.data.darkMode;

        // 根据暗黑模式设置颜色
        const textColor = darkMode ? '#e0e0e0' : '#333';
        const lineColor = darkMode ? '#444' : '#999';
        const splitLineColor = darkMode ? '#333' : '#ddd';
        const positiveColor = darkMode ? '#34D399' : '#10B981';
        const stressColor = darkMode ? '#FBBF24' : '#F59E0B';
        const energyColor = darkMode ? '#93C5FD' : '#60A5FA';

        return {
          title: {
            text: '情绪历史对比',
            left: 'center',
            top: 0,
            textStyle: {
              fontSize: 14,
              fontWeight: 'normal',
              color: textColor
            }
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow'
            },
            formatter: function(params) {
              let result = `${params[0].axisValue}<br/>`;
              params.forEach(param => {
                result += `${param.marker}${param.seriesName}: ${param.value}%<br/>`;
              });
              return result;
            },
            backgroundColor: darkMode ? 'rgba(50,50,50,0.9)' : 'rgba(255,255,255,0.9)',
            borderColor: darkMode ? '#555' : '#ddd',
            textStyle: {
              color: textColor
            }
          },
          legend: {
            data: ['积极', '压力', '能量'],
            bottom: 0,
            itemWidth: 12,
            itemHeight: 8,
            textStyle: {
              fontSize: 10,
              color: textColor
            }
          },
          grid: {
            left: '3%',
            right: '4%',
            bottom: '15%',
            top: '15%',
            containLabel: true
          },
          xAxis: {
            type: 'category',
            data: categories,
            axisLine: {
              lineStyle: {
                color: lineColor
              }
            },
            axisLabel: {
              fontSize: 10,
              color: textColor
            }
          },
          yAxis: {
            type: 'value',
            min: 0,
            max: 100,
            axisLabel: {
              formatter: '{value}%',
              fontSize: 10,
              color: textColor
            },
            splitLine: {
              lineStyle: {
                type: 'dashed',
                color: splitLineColor
              }
            }
          },
          series: [
            {
              name: '积极',
              type: 'bar',
              data: positiveData,
              itemStyle: {
                color: positiveColor
              }
            },
            {
              name: '压力',
              type: 'bar',
              data: stressData,
              itemStyle: {
                color: stressColor
              }
            },
            {
              name: '能量',
              type: 'bar',
              data: energyData,
              itemStyle: {
                color: energyColor
              }
            }
          ]
        };
      } catch (error) {
        console.error('获取历史对比图配置失败:', error);
        return {};
      }
    },

    // 关闭面板
    closePanel() {
      this.triggerEvent('close');
      // 延迟重置图表，避免闪烁
      setTimeout(() => {
        this.fixChartsPosition();
      }, 500);
    },

    // 分类关键词并更新到数据库
    async classifyAndUpdateKeywords(keywords) {
      if (!keywords || keywords.length === 0 || !this.data.userId) {
        return;
      }

      try {
        // 将关键词转换为标准格式
        const processedKeywords = keywords.map(keyword => {
          // 如果关键词是字符串，转换为对象
          if (typeof keyword === 'string') {
            return {
              word: keyword,
              weight: 1.0
            };
          }
          return keyword;
        });

        // 引入用户兴趣服务
        const userInterestsService = require('../../services/userInterestsService');

        // 调用云函数分类关键词
        const result = await wx.cloud.callFunction({
          name: 'analysis',
          data: {
            type: 'classify_keywords',
            keywords: processedKeywords.map(k => typeof k === 'string' ? k : k.word),
            batch: true
          }
        });

        console.log('关键词分类结果:', result);

        // 如果分类成功，将分类结果合并到关键词中
        if (result.result && result.result.success &&
            result.result.data && Array.isArray(result.result.data.classifications)) {

          // 将分类结果转换为映射
          const categoryMap = {};
          result.result.data.classifications.forEach(item => {
            categoryMap[item.keyword] = item.category;
          });

          // 统计各分类的关键词数量
          const categoryStats = {};
          processedKeywords.forEach(keyword => {
            const word = typeof keyword === 'string' ? keyword : keyword.word;
            const category = categoryMap[word] || '未分类';
            categoryStats[category] = (categoryStats[category] || 0) + 1;
          });

          console.log('分类统计:', categoryStats);

          // 将分类统计转换为分类数组格式，以便于存储
          const categoriesArray = Object.entries(categoryStats).map(([categoryName, count]) => ({
            name: categoryName,
            count: count,
            firstSeen: new Date(),
            lastUpdated: new Date()
          }));

          // 将分类结果合并到关键词中
          const classifiedKeywords = processedKeywords.map(keyword => {
            const word = typeof keyword === 'string' ? keyword : keyword.word;
            const weight = typeof keyword === 'string' ? 1.0 : (keyword.weight || 1.0);

            return {
              word: word,
              weight: weight,
              category: categoryMap[word] || '未分类',
              emotionScore: 0 // 默认情绪分数
            };
          });

          console.log('分类后的关键词:', classifiedKeywords);

          // 批量更新用户兴趣，包括分类数组
          const updateResult = await userInterestsService.batchUpdateUserInterests(
            this.data.userId,
            classifiedKeywords,
            true, // 自动分类
            categoryStats, // 传递分类统计
            categoriesArray // 传递分类数组
          );
          console.log('更新用户兴趣结果:', updateResult);
        } else {
          // 如果分类失败，使用默认分类更新用户兴趣
          const defaultKeywords = processedKeywords.map(keyword => {
            const word = typeof keyword === 'string' ? keyword : keyword.word;
            const weight = typeof keyword === 'string' ? 1.0 : (keyword.weight || 1.0);

            return {
              word: word,
              weight: weight,
              category: '未分类',
              emotionScore: 0
            };
          });

          // 统计默认分类的关键词数量
          const categoryStats = {
            '未分类': defaultKeywords.length
          };

          // 将分类统计转换为分类数组格式
          const categoriesArray = [{
            name: '未分类',
            count: defaultKeywords.length,
            firstSeen: new Date(),
            lastUpdated: new Date()
          }];

          // 批量更新用户兴趣，包括分类数组
          const updateResult = await userInterestsService.batchUpdateUserInterests(
            this.data.userId,
            defaultKeywords,
            true, // 自动分类
            categoryStats, // 传递分类统计
            categoriesArray // 传递分类数组
          );
          console.log('使用默认分类更新用户兴趣结果:', updateResult);
        }
      } catch (err) {
        console.error('分类关键词并更新到数据库失败:', err);
      }
    },

    // 保存情感记录
    saveEmotion() {
      this.triggerEvent('save');
    },

    // 分享情感记录
    shareEmotion() {
      this.triggerEvent('share');
    },

    // 查看更多历史
    viewMoreHistory() {
      this.triggerEvent('viewMore');
    },

    onPageScroll() {
      // 防止页面滚动时图表重绘
      if (this.data.chartRendered) {
        this.fixChartsPosition();
      }
    },

    // 组件滚动事件
    onScroll() {
      if (this.data.chartRendered) {
        this.fixChartsPosition();
      }
    },

    // 防止图表随页面滚动而移动
    fixChartsPosition() {
      try {
        // 使用延时确保图表容器已经渲染完成
        setTimeout(() => {
          if (this.emotionChart) {
            this.emotionChart.resize();
          }
          if (this.radarChart) {
            this.radarChart.resize();
          }
          if (this.historyChart) {
            this.historyChart.resize();
          }
        }, 300);
      } catch (error) {
        console.error('图表位置修复失败:', error);
      }
    }
  }
})

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-dashboard\emotion-dashboard.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {
    "ec-canvas": "../../components/ec-canvas/ec-canvas"
  }
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-dashboard\emotion-dashboard.wxml*#*#*begin*#*#*
<!-- components/emotion-dashboard/emotion-dashboard.wxml -->
<view class="emotion-dashboard {{show ? 'show' : ''}} {{darkMode ? 'dark' : ''}}" bindscroll="onScroll">
  <!-- 头部 -->
  <view class="header">
    <view class="title">情绪分析</view>
    <view class="close-btn" bindtap="closePanel" wx:if="{{showCloseButton}}">×</view>
  </view>

  <!-- 情绪概览卡片 -->
  <view class="emotion-card">
    <view class="card-title">当前情绪状态</view>
    <view class="emotion-overview">
      <view class="emotion-item primary">
        <view class="emotion-icon">
          <view class="icon-wrapper">
            <view class="icon-{{emotionIcons[emotion.primary] || 'meh'}}"></view>
          </view>
        </view>
        <view class="emotion-name">{{emotion.primary}}</view>
        <view class="emotion-label">主要情绪</view>
      </view>
      <block wx:if="{{emotion.secondary.length > 0}}">
        <view class="emotion-item secondary" wx:for="{{emotion.secondary}}" wx:key="index" wx:if="{{index < 2}}">
          <view class="emotion-icon">
            <view class="icon-wrapper">
              <view class="icon-{{emotionIcons[item] || 'meh'}}"></view>
            </view>
          </view>
          <view class="emotion-name">{{item}}</view>
          <view class="emotion-label">次要情绪</view>
        </view>
      </block>
      <!-- 当没有次要情绪时不显示任何内容 -->
    </view>

    <!-- 情绪强度 -->
    <view class="section-title">情绪强度</view>
    <view class="emotion-progress">
      <view class="emotion-progress-bar" style="width: {{emotion.intensity}}%"></view>
    </view>
    <view class="progress-labels">
      <text>低</text>
      <text>中</text>
      <text>高</text>
    </view>

    <!-- 情绪波动 -->
    <view class="section-title">情绪波动</view>
    <view class="chart-container" style="height: 250px;">
      <ec-canvas id="emotionChart" canvas-id="emotionCanvas" ec="{{ emotionChartEc }}"></ec-canvas>
    </view>

    <!-- 情绪分析总结 -->
    <view class="emotion-summary">
      <text>{{summary}}</text>
    </view>
  </view>

  <!-- 关键词分析 -->
  <view class="emotion-card">
    <view class="card-title">关键词分析</view>
    <view class="keyword-cloud">
      <block wx:if="{{keywords.length > 0}}">
        <view class="keyword-tag"
              wx:for="{{keywords}}"
              wx:key="index"
              style="font-size: {{14 + index * 2}}px;">
          {{item}}
        </view>
      </block>
      <block wx:if="{{triggers.length > 0}}">
        <view class="keyword-tag trigger"
              wx:for="{{triggers}}"
              wx:key="index">
          {{item}}
        </view>
      </block>
      <block wx:if="{{keywords.length === 0 && triggers.length === 0}}">
        <view class="empty-keywords">暂无关键词数据</view>
      </block>
    </view>

    <view class="keyword-summary" wx:if="{{keywords.length > 0}}">
      <text>你的对话中频繁提到与{{keywords[0]}}相关的词汇，表明当前的情绪状态可能与此相关。</text>
    </view>
  </view>

  <!-- 情绪维度 -->
  <view class="emotion-card">
    <view class="card-title">情绪维度</view>
    <view class="chart-container" style="height: 250px;">
      <ec-canvas id="radarChart" canvas-id="radarCanvas" ec="{{ radarChartEc }}"></ec-canvas>
    </view>

    <!-- 维度详情 -->
    <view class="dimensions-detail">
      <view class="dimension-item">
        <view class="dimension-label">信任度</view>
        <view class="dimension-bar-container">
          <view class="dimension-bar" style="width: {{radarDimensions.trust}}%"></view>
        </view>
        <view class="dimension-value">{{radarDimensions.trust}}%</view>
      </view>
      <view class="dimension-item">
        <view class="dimension-label">开放度</view>
        <view class="dimension-bar-container">
          <view class="dimension-bar" style="width: {{radarDimensions.openness}}%"></view>
        </view>
        <view class="dimension-value">{{radarDimensions.openness}}%</view>
      </view>
      <view class="dimension-item">
        <view class="dimension-label">控制感</view>
        <view class="dimension-bar-container">
          <view class="dimension-bar" style="width: {{radarDimensions.control}}%"></view>
        </view>
        <view class="dimension-value">{{radarDimensions.control}}%</view>
      </view>
      <view class="dimension-item">
        <view class="dimension-label">抗拒度</view>
        <view class="dimension-bar-container">
          <view class="dimension-bar" style="width: {{radarDimensions.resistance}}%"></view>
        </view>
        <view class="dimension-value">{{radarDimensions.resistance}}%</view>
      </view>
      <view class="dimension-item">
        <view class="dimension-label">压力水平</view>
        <view class="dimension-bar-container">
          <view class="dimension-bar" style="width: {{radarDimensions.stress}}%"></view>
        </view>
        <view class="dimension-value">{{radarDimensions.stress}}%</view>
      </view>
    </view>

    <view class="dimension-summary">
      <text>情绪维度分析显示，你的{{radarDimensions.stress > 70 ? '压力水平较高' : '压力水平适中'}}，{{radarDimensions.trust > 70 ? '信任度较高' : radarDimensions.trust < 30 ? '信任度较低' : '信任度适中'}}。</text>
    </view>
  </view>

  <!-- 个性化建议 -->
  <view class="emotion-card">
    <view class="card-title">个性化建议</view>
    <view class="suggestions-list">
      <block wx:if="{{suggestions.length > 0}}">
        <view class="suggestion-item" wx:for="{{suggestions}}" wx:key="index">
          <view class="suggestion-icon">
            <view class="icon-check-circle"></view>
          </view>
          <view class="suggestion-content">
            <text class="suggestion-text">{{item}}</text>
          </view>
        </view>
      </block>
      <block wx:if="{{suggestions.length === 0}}">
        <view class="empty-suggestions">暂无个性化建议</view>
      </block>
    </view>
  </view>

  <!-- 历史对比 -->
  <view class="emotion-card">
    <view class="card-title-with-action">
      <text>情绪历史对比</text>
      <view class="action-link" bindtap="viewMoreHistory">查看更多</view>
    </view>
    <view class="chart-container" style="height: 250px;">
      <ec-canvas id="historyChart" canvas-id="historyCanvas" ec="{{ historyChartEc }}"></ec-canvas>
    </view>

    <view class="history-summary">
      <text>与过去一周相比，你的{{emotion.primary}}情绪{{emotion.trend === 'rising' ? '有所增强' : emotion.trend === 'falling' ? '有所减弱' : '保持稳定'}}。</text>
    </view>
  </view>

  <!-- 操作按钮 -->
  <view class="action-buttons">
    <button class="action-btn save-btn" bindtap="saveEmotion">
      <view class="btn-icon icon-save"></view>
      <text class="btn-text">记录心情</text>
    </button>
    <button class="action-btn share-btn" bindtap="shareEmotion">
      <view class="btn-icon icon-share-alt"></view>
      <text class="btn-text">分享给TA</text>
    </button>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-dashboard\emotion-dashboard.wxss*#*#*begin*#*#*
/* components/emotion-dashboard/emotion-dashboard.wxss */
.emotion-dashboard {
  width: 100%;
  height: 100%;
  background-color: #F9FAFB;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  padding: 24rpx;
  box-sizing: border-box;
  font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif;
  border-radius: 0;
  /* 确保在弹窗中可以滚动 */
  -webkit-overflow-scrolling: touch; /* 使iOS滚动更流畅 */
  max-height: 100%;
}

.emotion-dashboard.dark {
  background-color: #1C1B1F;
  color: #E6E1E5;
}

/* 头部样式 */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 30rpx;
  position: relative;
  padding: 0 10rpx;
}

.title {
  font-size: 34rpx;
  font-weight: 600;
  color: #111827;
  margin-left: 10rpx;
}

.dark .title {
  color: #E6E1E5;
}

.close-btn {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40rpx;
  color: #6B7280;
  cursor: pointer;
  /* 增强关闭按钮的可见度 */
  background-color: rgba(0, 0, 0, 0.05);
  border-radius: 50%;
  margin-right: 10rpx;
  z-index: 10;
}

.dark .close-btn {
  color: #A1A1AA;
  background-color: rgba(255, 255, 255, 0.1);
}

/* 卡片样式 */
.emotion-card {
  background-color: #FFFFFF;
  border-radius: 20rpx;
  padding: 30rpx;
  margin-bottom: 30rpx;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.dark .emotion-card {
  background-color: #2D2C31;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.card-title {
  font-size: 30rpx;
  font-weight: 600;
  color: #111827;
  margin-bottom: 20rpx;
}

.dark .card-title {
  color: #E6E1E5;
}

.card-title-with-action {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 30rpx;
  font-weight: 600;
  color: #111827;
  margin-bottom: 20rpx;
}

.dark .card-title-with-action {
  color: #E6E1E5;
}

.action-link {
  font-size: 24rpx;
  color: #3B82F6;
  font-weight: normal;
}

.dark .action-link {
  color: #60A5FA;
}

/* 情绪概览 */
.emotion-overview {
  display: flex;
  justify-content: space-between;
  margin-bottom: 30rpx;
}

.emotion-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
}

.emotion-icon {
  margin-bottom: 8rpx;
  color: #9CA3AF;
}

.icon-wrapper {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #F3F4F6;
  border-radius: 50%;
}

.dark .icon-wrapper {
  background-color: #374151;
}

.primary .emotion-icon {
  color: #F59E0B;
}

.primary .icon-wrapper {
  width: 70rpx;
  height: 70rpx;
  background-color: #FEF3C7;
}

.dark .primary .icon-wrapper {
  background-color: #78350F;
}

.secondary .emotion-icon {
  color: #3B82F6;
}

.secondary .icon-wrapper {
  background-color: #EFF6FF;
}

.dark .secondary .icon-wrapper {
  background-color: #1E3A8A;
}

.emotion-name {
  font-size: 28rpx;
  font-weight: 600;
  color: #111827;
  margin-bottom: 4rpx;
}

.dark .emotion-name {
  color: #E6E1E5;
}

.emotion-label {
  font-size: 22rpx;
  color: #6B7280;
}

.dark .emotion-label {
  color: #A1A1AA;
}

/* 情绪强度进度条 */
.section-title {
  font-size: 26rpx;
  font-weight: 600;
  color: #374151;
  margin-bottom: 12rpx;
}

.dark .section-title {
  color: #E6E1E5;
}

.emotion-progress {
  width: 100%;
  height: 16rpx;
  background-color: #E5E7EB;
  border-radius: 8rpx;
  overflow: hidden;
  margin-bottom: 8rpx;
}

.dark .emotion-progress {
  background-color: #4B5563;
}

.emotion-progress-bar {
  height: 100%;
  background-color: #F59E0B;
  border-radius: 8rpx;
  transition: width 0.3s ease;
}

.progress-labels {
  display: flex;
  justify-content: space-between;
  font-size: 22rpx;
  color: #6B7280;
  margin-bottom: 24rpx;
}

.dark .progress-labels {
  color: #A1A1AA;
}

/* 图表容器 */
.chart-container {
  position: relative;
  width: 100%;
  height: 300px;
  margin-bottom: 20rpx;
  background-color: #FFFFFF;
  border-radius: 8rpx;
  overflow: hidden;
}

.dark .chart-container {
  background-color: #2D2C31;
}

.radar-chart-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
}

ec-canvas {
  width: 100% !important;
  height: 100% !important;
  display: block !important;
}

/* 删除历史对比图表的单独样式，使用通用的chart-container样式 */

/* 情绪分析总结 */
.emotion-summary {
  font-size: 26rpx;
  color: #4B5563;
  line-height: 1.5;
}

.dark .emotion-summary {
  color: #D1D5DB;
}

/* 关键词云 */
.keyword-cloud {
  display: flex;
  flex-wrap: wrap;
  gap: 16rpx;
  margin-bottom: 20rpx;
}

.keyword-tag {
  padding: 8rpx 20rpx;
  background-color: #EFF6FF;
  color: #3B82F6;
  border-radius: 20rpx;
  font-size: 24rpx;
}

.dark .keyword-tag {
  background-color: #1E3A8A;
  color: #93C5FD;
}

.keyword-tag.trigger {
  background-color: #FEF3C7;
  color: #D97706;
}

.dark .keyword-tag.trigger {
  background-color: #78350F;
  color: #FCD34D;
}

.empty-keywords {
  width: 100%;
  text-align: center;
  padding: 30rpx 0;
  color: #9CA3AF;
  font-size: 26rpx;
}

.dark .empty-keywords {
  color: #6B7280;
}

.keyword-summary {
  font-size: 26rpx;
  color: #4B5563;
  line-height: 1.5;
}

.dark .keyword-summary {
  color: #D1D5DB;
}

/* 维度详情 */
.dimensions-detail {
  margin-top: 20rpx;
  margin-bottom: 20rpx;
}

.dimension-item {
  display: flex;
  align-items: center;
  margin-bottom: 16rpx;
}

.dimension-label {
  width: 160rpx;
  font-size: 24rpx;
  color: #6B7280;
}

.dark .dimension-label {
  color: #A1A1AA;
}

.dimension-bar-container {
  flex: 1;
  height: 12rpx;
  background-color: #E5E7EB;
  border-radius: 6rpx;
  overflow: hidden;
  margin: 0 16rpx;
}

.dark .dimension-bar-container {
  background-color: #4B5563;
}

.dimension-bar {
  height: 100%;
  background-color: #3B82F6;
  border-radius: 6rpx;
  transition: width 0.3s ease;
}

.dimension-value {
  width: 60rpx;
  font-size: 22rpx;
  color: #6B7280;
  text-align: right;
}

.dark .dimension-value {
  color: #A1A1AA;
}

.dimension-summary {
  font-size: 26rpx;
  color: #4B5563;
  line-height: 1.5;
}

.dark .dimension-summary {
  color: #D1D5DB;
}

/* 建议列表 */
.suggestions-list {
  margin-bottom: 10rpx;
}

.suggestion-item {
  display: flex;
  margin-bottom: 20rpx;
}

.suggestion-icon {
  margin-right: 16rpx;
  color: #10B981;
  font-size: 32rpx;
  flex-shrink: 0;
  margin-top: 4rpx;
}

.dark .suggestion-icon {
  color: #34D399;
}

.suggestion-content {
  flex: 1;
}

.suggestion-text {
  font-size: 26rpx;
  color: #4B5563;
  line-height: 1.5;
}

.dark .suggestion-text {
  color: #D1D5DB;
}

.empty-suggestions {
  width: 100%;
  text-align: center;
  padding: 30rpx 0;
  color: #9CA3AF;
  font-size: 26rpx;
}

.dark .empty-suggestions {
  color: #6B7280;
}

/* 历史总结 */
.history-summary {
  font-size: 26rpx;
  color: #4B5563;
  line-height: 1.5;
}

.dark .history-summary {
  color: #D1D5DB;
}

/* 操作按钮 */
.action-buttons {
  display: flex;
  gap: 30rpx;
  margin-top: 30rpx;
  margin-bottom: 50rpx;
  padding: 0 20rpx;
}

.action-btn {
  flex: 1;
  height: 96rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 48rpx;
  font-size: 30rpx;
  gap: 12rpx;
  border: none;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
}

.save-btn {
  background-color: #3B82F6;
  color: #FFFFFF;
}

.share-btn {
  background-color: #F3F4F6;
  color: #4B5563;
}

.dark .share-btn {
  background-color: #374151;
  color: #E5E7EB;
}

.btn-icon {
  font-size: 32rpx;
}

.btn-text {
  font-size: 28rpx;
}

/* 图标样式 */
.icon-smile, .icon-meh, .icon-frown, .icon-angry, .icon-sad-tear,
.icon-tired, .icon-surprise, .icon-grin-stars, .icon-grimace,
.icon-sad, .icon-clock, .icon-check-circle, .icon-save, .icon-share-alt {
  width: 40rpx;
  height: 40rpx;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

.primary .icon-smile, .primary .icon-meh, .primary .icon-frown,
.primary .icon-angry, .primary .icon-sad-tear, .primary .icon-tired,
.primary .icon-surprise, .primary .icon-grin-stars, .primary .icon-grimace,
.primary .icon-sad, .primary .icon-clock {
  width: 50rpx;
  height: 50rpx;
}

/* 定义各种情绪图标 */
.icon-smile {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23F59E0B"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg>');
}

.icon-meh {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2360A5FA"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5-7h10v2H7z"/><circle cx="8.5" cy="9.5" r="1.5"/><circle cx="15.5" cy="9.5" r="1.5"/></svg>');
}

.icon-frown {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23F59E0B"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5-7h10c0 2.21-1.79 4-4 4s-4-1.79-4-4z"/><circle cx="8.5" cy="9.5" r="1.5"/><circle cx="15.5" cy="9.5" r="1.5"/></svg>');
}

.icon-angry {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23EF4444"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5-7h10c0 2.21-1.79 4-4 4s-4-1.79-4-4z"/><circle cx="8.5" cy="9.5" r="1.5"/><circle cx="15.5" cy="9.5" r="1.5"/></svg>');
}

.icon-sad-tear {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%236366F1"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5-7h10c0 2.21-1.79 4-4 4s-4-1.79-4-4z"/><circle cx="8.5" cy="9.5" r="1.5"/><circle cx="15.5" cy="9.5" r="1.5"/></svg>');
}

.icon-check-circle {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2310B981"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-2-13l-4 4 1.41 1.41L10 9.83l6.59 6.59L18 15l-8-8z"/></svg>');
}

.icon-save {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FFFFFF"><path d="M17 3H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H8c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h8c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1zM15 7h-6v2h6V7zm0 4h-6v2h6v-2zm0 4h-6v2h6v-2z"/></svg>');
}

.icon-share-alt {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234B5563"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/></svg>');
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-history\emotion-history.js*#*#*begin*#*#*
// components/emotion-history/emotion-history.js
const emotionService = require('../../services/emotionService');

Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // 是否显示历史记录
    show: {
      type: Boolean,
      value: false
    },
    // 用户ID
    userId: {
      type: String,
      value: ''
    },
    // 角色ID
    roleId: {
      type: String,
      value: ''
    },
    // 是否使用暗色主题
    darkMode: {
      type: Boolean,
      value: false
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    loading: false,
    historyRecords: [],
    emotionLabels: emotionService.EmotionTypeLabels,
    emotionColors: emotionService.EmotionTypeColors
  },

  /**
   * 组件的方法列表
   */
  methods: {
    // 关闭历史记录
    closeHistory() {
      this.triggerEvent('close');
    },
    
    // 加载历史记录
    async loadHistory() {
      if (!this.properties.userId) {
        return;
      }
      
      this.setData({ loading: true });
      
      try {
        // 获取历史记录
        const records = await emotionService.getEmotionHistory(
          this.properties.userId,
          this.properties.roleId || null,
          20
        );
        
        // 处理记录数据
        const processedRecords = records.map(record => {
          // 格式化时间
          const createTime = new Date(record.createTime);
          const formattedTime = `${createTime.getFullYear()}-${String(createTime.getMonth() + 1).padStart(2, '0')}-${String(createTime.getDate()).padStart(2, '0')} ${String(createTime.getHours()).padStart(2, '0')}:${String(createTime.getMinutes()).padStart(2, '0')}`;
          
          return {
            ...record,
            formattedTime
          };
        });
        
        this.setData({
          historyRecords: processedRecords,
          loading: false
        });
      } catch (error) {
        console.error('加载历史记录失败:', error);
        this.setData({ loading: false });
        wx.showToast({
          title: '加载历史记录失败',
          icon: 'none'
        });
      }
    },
    
    // 查看记录详情
    viewRecordDetail(e) {
      const { index } = e.currentTarget.dataset;
      const record = this.data.historyRecords[index];
      
      this.triggerEvent('detail', { record });
    },
    
    // 阻止事件冒泡
    stopPropagation(e) {
      // 阻止事件冒泡
    }
  },
  
  // 组件生命周期
  lifetimes: {
    attached() {
      // 组件加载时初始化
    },
    
    // 组件显示时加载历史记录
    ready() {
      if (this.properties.show) {
        this.loadHistory();
      }
    }
  },
  
  // 监听属性变化
  observers: {
    'show': function(show) {
      if (show) {
        this.loadHistory();
      }
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-history\emotion-history.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-history\emotion-history.wxml*#*#*begin*#*#*
<!--components/emotion-history/emotion-history.wxml-->
<view class="history-container {{show ? 'show' : ''}} {{darkMode ? 'dark' : ''}}">
  <view class="history-mask" bindtap="closeHistory"></view>
  <view class="history-panel" catchtap="stopPropagation">
    <!-- 面板头部 -->
    <view class="panel-header">
      <text class="panel-title">情感历史记录</text>
      <view class="close-btn" bindtap="closeHistory">×</view>
    </view>
    
    <!-- 加载中 -->
    <view class="loading-container" wx:if="{{loading}}">
      <view class="loading-spinner"></view>
      <text class="loading-text">加载中...</text>
    </view>
    
    <!-- 历史记录列表 -->
    <scroll-view class="history-list" scroll-y wx:if="{{!loading}}">
      <!-- 无记录提示 -->
      <view class="empty-tip" wx:if="{{historyRecords.length === 0}}">
        <text>暂无历史记录</text>
      </view>
      
      <!-- 记录列表 -->
      <view class="record-item" 
            wx:for="{{historyRecords}}" 
            wx:key="_id"
            data-index="{{index}}"
            bindtap="viewRecordDetail">
        <!-- 记录时间 -->
        <view class="record-time">{{item.formattedTime}}</view>
        
        <!-- 记录内容 -->
        <view class="record-content">
          <!-- 角色信息 -->
          <view class="record-role" wx:if="{{item.roleName}}">
            <text class="role-label">角色:</text>
            <text class="role-name">{{item.roleName}}</text>
          </view>
          
          <!-- 情感类型 -->
          <view class="record-emotion">
            <text class="emotion-label">情感:</text>
            <view class="emotion-type" style="background-color: {{emotionColors[item.analysis.type]}}">
              {{emotionLabels[item.analysis.type]}}
            </view>
            <text class="emotion-intensity">强度: {{item.analysis.intensity * 100}}%</text>
          </view>
        </view>
        
        <!-- 记录摘要 -->
        <view class="record-summary" wx:if="{{item.analysis.report}}">
          <text class="summary-text">{{item.analysis.report}}</text>
        </view>
        
        <!-- 查看详情按钮 -->
        <view class="detail-btn">查看详情</view>
      </view>
    </scroll-view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-history\emotion-history.wxss*#*#*begin*#*#*
/* components/emotion-history/emotion-history.wxss */
.history-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: flex;
  justify-content: center;
  align-items: center;
  visibility: hidden;
  opacity: 0;
  transition: all 0.3s ease;
}

/* 显示历史记录 */
.history-container.show {
  visibility: visible;
  opacity: 1;
}

/* 历史记录遮罩 */
.history-mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 1001;
}

/* 历史记录面板 */
.history-panel {
  position: relative;
  width: 90%;
  height: 80%;
  max-width: 600rpx;
  background-color: white;
  border-radius: 20rpx;
  box-shadow: 0 4rpx 20rpx rgba(0, 0, 0, 0.15);
  z-index: 1002;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: all 0.3s ease;
}

/* 面板头部 */
.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20rpx 30rpx;
  border-bottom: 1rpx solid #eee;
}

/* 面板标题 */
.panel-title {
  font-size: 36rpx;
  font-weight: bold;
}

/* 关闭按钮 */
.close-btn {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 40rpx;
  color: #999;
  cursor: pointer;
}

/* 加载中容器 */
.loading-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 30rpx;
}

/* 加载动画 */
.loading-spinner {
  width: 60rpx;
  height: 60rpx;
  border: 6rpx solid #f3f3f3;
  border-top: 6rpx solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 20rpx;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* 加载文本 */
.loading-text {
  font-size: 28rpx;
  color: #999;
}

/* 历史记录列表 */
.history-list {
  flex: 1;
  padding: 20rpx;
  overflow-y: auto;
}

/* 无记录提示 */
.empty-tip {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200rpx;
  color: #999;
  font-size: 28rpx;
}

/* 记录项 */
.record-item {
  margin-bottom: 30rpx;
  padding: 20rpx;
  background-color: #f9f9f9;
  border-radius: 10rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.05);
  transition: all 0.2s ease;
}

.record-item:active {
  background-color: #f0f0f0;
}

/* 记录时间 */
.record-time {
  font-size: 24rpx;
  color: #999;
  margin-bottom: 10rpx;
}

/* 记录内容 */
.record-content {
  margin-bottom: 15rpx;
}

/* 角色信息 */
.record-role {
  display: flex;
  align-items: center;
  margin-bottom: 10rpx;
}

/* 角色标签 */
.role-label {
  font-size: 26rpx;
  color: #666;
  margin-right: 10rpx;
}

/* 角色名称 */
.role-name {
  font-size: 28rpx;
  color: #333;
  font-weight: bold;
}

/* 情感信息 */
.record-emotion {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

/* 情感标签 */
.emotion-label {
  font-size: 26rpx;
  color: #666;
  margin-right: 10rpx;
}

/* 情感类型 */
.emotion-type {
  padding: 4rpx 12rpx;
  border-radius: 20rpx;
  font-size: 24rpx;
  color: white;
  margin-right: 15rpx;
}

/* 情感强度 */
.emotion-intensity {
  font-size: 24rpx;
  color: #666;
}

/* 记录摘要 */
.record-summary {
  margin-bottom: 15rpx;
  padding: 10rpx;
  background-color: #f0f0f0;
  border-radius: 8rpx;
}

/* 摘要文本 */
.summary-text {
  font-size: 26rpx;
  color: #555;
  line-height: 1.4;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
}

/* 查看详情按钮 */
.detail-btn {
  text-align: center;
  padding: 10rpx;
  background-color: #e1f5fe;
  border-radius: 8rpx;
  font-size: 26rpx;
  color: #0288d1;
}

/* 暗色主题 */
.history-container.dark .history-panel {
  background-color: #333;
  color: #eee;
}

.history-container.dark .panel-header {
  border-bottom-color: #555;
}

.history-container.dark .panel-title {
  color: #fff;
}

.history-container.dark .close-btn {
  color: #ccc;
}

.history-container.dark .loading-text {
  color: #ccc;
}

.history-container.dark .empty-tip {
  color: #ccc;
}

.history-container.dark .record-item {
  background-color: #444;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.2);
}

.history-container.dark .record-item:active {
  background-color: #555;
}

.history-container.dark .record-time {
  color: #aaa;
}

.history-container.dark .role-label,
.history-container.dark .emotion-label {
  color: #bbb;
}

.history-container.dark .role-name {
  color: #eee;
}

.history-container.dark .emotion-intensity {
  color: #bbb;
}

.history-container.dark .record-summary {
  background-color: #555;
}

.history-container.dark .summary-text {
  color: #ddd;
}

.history-container.dark .detail-btn {
  background-color: #01579b;
  color: #e1f5fe;
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-panel\emotion-panel.js*#*#*begin*#*#*
// components/emotion-panel/emotion-panel.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // 情感分析结果
    emotion: {
      type: Object,
      value: null,
      observer: function(newVal) {
        if (newVal) {
          // 计算各种属性
          const hasKeywords = !!(newVal.topic_keywords && newVal.topic_keywords.length) || !!(newVal.keywords && newVal.keywords.length);

          // 处理情感强度显示
          const intensityText = ((newVal.intensity || 0.5) * 100).toFixed(0) + '%';

          // 处理情感极性显示
          let polarityText = '中性';
          if (newVal.valence !== undefined) {
            if (newVal.valence > 0) {
              polarityText = (newVal.valence * 100).toFixed(0) + '% 正面';
            } else if (newVal.valence < 0) {
              polarityText = (newVal.valence * -100).toFixed(0) + '% 负面';
            }
          }

          // 处理情绪趋势显示
          let trendText = '未知';
          if (newVal.trend) {
            if (newVal.trend === 'rising') {
              trendText = '上升';
            } else if (newVal.trend === 'falling') {
              trendText = '下降';
            } else if (newVal.trend === 'stable') {
              trendText = '稳定';
            }
          }

          this.setData({
            hasEmotion: true,
            emotionData: newVal,
            hasKeywords: hasKeywords,
            intensityText: intensityText,
            polarityText: polarityText,
            trendText: trendText
          });
        }
      }
    },
    // 是否显示面板
    show: {
      type: Boolean,
      value: false
    },
    // 是否使用暗色主题
    darkMode: {
      type: Boolean,
      value: false
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    hasEmotion: false,
    emotionData: null,
    hasKeywords: false,
    // 情感类型标签
    emotionLabels: {
      joy: '喜悦',
      sadness: '伤感',
      anger: '愤怒',
      anxiety: '焦虑',
      neutral: '平静',
      // 新增情感类型标签
      calm: '平静',
      surprise: '惊讶',
      disgust: '厌恶',
      anticipation: '期待',
      urgency: '紧迫',
      disappointment: '失望',
      fatigue: '疲惫'
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    // 关闭面板
    closePanel() {
      this.triggerEvent('close');
    },

    // 切换角色
    switchRole() {
      this.triggerEvent('switchRole', { emotion: this.data.emotionData });
    },

    // 保存情感记录
    saveEmotion() {
      this.triggerEvent('save', { emotion: this.data.emotionData });
    },

    // 查看历史记录
    viewHistory() {
      this.triggerEvent('history');
    },

    // 阻止事件冒泡
    stopPropagation(e) {
      // 阻止事件冒泡
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-panel\emotion-panel.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {
    "emotion-pie": "/components/emotion-pie/emotion-pie"
  }
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-panel\emotion-panel.wxml*#*#*begin*#*#*
<!--components/emotion-panel/emotion-panel.wxml-->
<view class="emotion-panel-container {{show ? 'show' : ''}} {{darkMode ? 'dark' : ''}}">
  <view class="panel-mask" bindtap="closePanel"></view>
  <view class="emotion-panel {{emotionData.type}}" catchtap="stopPropagation">
    <!-- 面板头部 -->
    <view class="panel-header">
      <text class="panel-title">情感分析</text>
      <view class="close-btn" bindtap="closePanel">×</view>
    </view>

    <!-- 情感饼图 -->
    <view class="emotion-pie-container">
      <emotion-pie emotion="{{emotionData}}" darkMode="{{darkMode}}" bind:select="onEmotionSelect"></emotion-pie>
    </view>

    <!-- 情感报告 -->
    <view class="emotion-report">
      <text class="report-title">情感报告</text>
      <text class="report-content">{{emotionData.summary || emotionData.report}}</text>
    </view>

    <!-- 情感详情 -->
    <view class="emotion-details">
      <text class="details-title">情感详情</text>

      <view class="details-item">
        <text class="detail-label">主要情感：</text>
        <text class="detail-value">{{emotionLabels[emotionData.primary_emotion || emotionData.type] || emotionData.primary_emotion || emotionData.type}}</text>
      </view>

      <view class="details-item" wx:if="{{emotionData.secondary_emotions && emotionData.secondary_emotions.length}}">
        <text class="detail-label">次要情感：</text>
        <view class="detail-tags">
          <text wx:for="{{emotionData.secondary_emotions}}" wx:key="index" class="detail-tag">{{emotionLabels[item] || item}}</text>
        </view>
      </view>

      <view class="details-item">
        <text class="detail-label">情感强度：</text>
        <text class="detail-value">{{intensityText}}</text>
      </view>

      <view class="details-item" wx:if="{{emotionData.valence !== undefined}}">
        <text class="detail-label">情感极性：</text>
        <text class="detail-value">{{polarityText}}</text>
      </view>

      <view class="details-item" wx:if="{{emotionData.trend && emotionData.trend !== 'unknown'}}">
        <text class="detail-label">情绪趋势：</text>
        <text class="detail-value">{{trendText}}</text>
      </view>

      <view class="details-item">
        <text class="detail-label">主题关键词：</text>
        <view class="detail-tags">
          <text wx:for="{{emotionData.topic_keywords || emotionData.keywords}}" wx:key="index" class="detail-tag">{{item}}</text>
          <text wx:if="{{!hasKeywords}}" class="no-data">无关键词</text>
        </view>
      </view>

      <view class="details-item" wx:if="{{emotionData.emotion_triggers && emotionData.emotion_triggers.length}}">
        <text class="detail-label">情绪触发词：</text>
        <view class="detail-tags">
          <text wx:for="{{emotionData.emotion_triggers}}" wx:key="index" class="detail-tag">{{item}}</text>
        </view>
      </view>
    </view>

    <!-- 建议列表 -->
    <view class="emotion-suggestions">
      <text class="suggestions-title">建议</text>
      <view class="suggestions-list">
        <view class="suggestion-item" wx:for="{{emotionData.suggestions}}" wx:key="index">
          <text class="suggestion-icon">💡</text>
          <text class="suggestion-text">{{item}}</text>
        </view>
      </view>
    </view>

    <!-- 操作按钮 -->
    <view class="action-buttons">
      <button class="action-btn switch-role-btn" bindtap="switchRole">
        <text class="btn-icon">👤</text>
        <text class="btn-text">切换角色</text>
      </button>
      <button class="action-btn save-btn" bindtap="saveEmotion">
        <text class="btn-icon">💾</text>
        <text class="btn-text">保存记录</text>
      </button>
      <button class="action-btn history-btn" bindtap="viewHistory">
        <text class="btn-icon">📊</text>
        <text class="btn-text">历史记录</text>
      </button>
    </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-panel\emotion-panel.wxss*#*#*begin*#*#*
/* components/emotion-panel/emotion-panel.wxss */
.emotion-panel-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: flex;
  justify-content: center;
  align-items: center;
  visibility: hidden;
  opacity: 0;
  transition: all 0.3s ease;
}

/* 显示面板 */
.emotion-panel-container.show {
  visibility: visible;
  opacity: 1;
}

/* 面板遮罩 */
.panel-mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 1001;
}

/* 情感分析面板 */
.emotion-panel {
  position: relative;
  width: 90%;
  max-width: 600rpx;
  max-height: 90vh;
  background-color: white;
  border-radius: 20rpx;
  box-shadow: 0 4rpx 20rpx rgba(0, 0, 0, 0.15);
  z-index: 1002;
  overflow-y: auto;
  padding: 30rpx;
  transition: all 0.3s ease;
}

/* 面板头部 */
.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20rpx;
}

/* 面板标题 */
.panel-title {
  font-size: 36rpx;
  font-weight: bold;
}

/* 关闭按钮 */
.close-btn {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 40rpx;
  color: #999;
  cursor: pointer;
}

/* 情感饼图容器 */
.emotion-pie-container {
  margin: 20rpx 0;
}

/* 情感报告 */
.emotion-report {
  margin: 30rpx 0;
  padding: 20rpx;
  background-color: #f9f9f9;
  border-radius: 10rpx;
}

/* 报告标题 */
.report-title {
  display: block;
  font-size: 30rpx;
  font-weight: bold;
  margin-bottom: 10rpx;
  color: #333;
}

/* 报告内容 */
.report-content {
  font-size: 28rpx;
  line-height: 1.5;
  color: #666;
}

/* 情感详情 */
.emotion-details {
  margin: 30rpx 0;
  padding: 20rpx;
  background-color: #f9f9f9;
  border-radius: 10rpx;
}

/* 详情标题 */
.details-title {
  display: block;
  font-size: 30rpx;
  font-weight: bold;
  margin-bottom: 15rpx;
  color: #333;
}

/* 详情项 */
.details-item {
  margin-bottom: 15rpx;
  padding: 10rpx 0;
  border-bottom: 1rpx solid #eee;
}

/* 详情标签 */
.detail-label {
  font-size: 26rpx;
  color: #666;
  margin-right: 10rpx;
  display: block;
  margin-bottom: 5rpx;
}

/* 详情值 */
.detail-value {
  font-size: 28rpx;
  color: #333;
  font-weight: 500;
}

/* 标签容器 */
.detail-tags {
  display: flex;
  flex-wrap: wrap;
  margin-top: 10rpx;
}

/* 标签 */
.detail-tag {
  display: inline-block;
  padding: 6rpx 16rpx;
  margin: 6rpx;
  font-size: 24rpx;
  color: #fff;
  background-color: #3498db;
  border-radius: 30rpx;
}

/* 无数据 */
.no-data {
  font-size: 24rpx;
  color: #999;
  font-style: italic;
}

/* 建议列表 */
.emotion-suggestions {
  margin: 30rpx 0;
}

/* 建议标题 */
.suggestions-title {
  display: block;
  font-size: 30rpx;
  font-weight: bold;
  margin-bottom: 15rpx;
  color: #333;
}

/* 建议列表 */
.suggestions-list {
  padding: 10rpx;
}

/* 建议项 */
.suggestion-item {
  display: flex;
  align-items: flex-start;
  margin-bottom: 15rpx;
  padding: 10rpx;
  background-color: #f5f5f5;
  border-radius: 8rpx;
}

/* 建议图标 */
.suggestion-icon {
  margin-right: 10rpx;
  font-size: 28rpx;
}

/* 建议文本 */
.suggestion-text {
  font-size: 26rpx;
  line-height: 1.4;
  color: #555;
  flex: 1;
}

/* 操作按钮 */
.action-buttons {
  display: flex;
  justify-content: space-around;
  margin-top: 30rpx;
}

/* 按钮样式 */
.action-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 15rpx 20rpx;
  background-color: #f0f0f0;
  border-radius: 10rpx;
  width: 30%;
  height: 120rpx;
  line-height: 1.2;
}

/* 按钮图标 */
.btn-icon {
  font-size: 36rpx;
  margin-bottom: 8rpx;
}

/* 按钮文本 */
.btn-text {
  font-size: 24rpx;
  color: #555;
}

/* 切换角色按钮 */
.switch-role-btn {
  background-color: #e1f5fe;
}

/* 保存按钮 */
.save-btn {
  background-color: #e8f5e9;
}

/* 历史记录按钮 */
.history-btn {
  background-color: #fff3e0;
}

/* 情感类型特定样式 */
.emotion-panel.joy {
  border-top: 8rpx solid #2ECC71;
}

.emotion-panel.sadness {
  border-top: 8rpx solid #3498DB;
}

.emotion-panel.anger {
  border-top: 8rpx solid #E74C3C;
}

.emotion-panel.anxiety {
  border-top: 8rpx solid #F1C40F;
}

.emotion-panel.neutral {
  border-top: 8rpx solid #95A5A6;
}

/* 暗色主题 */
.emotion-panel-container.dark .emotion-panel {
  background-color: #333;
  color: #eee;
}

.emotion-panel-container.dark .panel-title {
  color: #fff;
}

.emotion-panel-container.dark .close-btn {
  color: #ccc;
}

.emotion-panel-container.dark .emotion-report,
.emotion-panel-container.dark .emotion-details {
  background-color: #444;
}

.emotion-panel-container.dark .report-title,
.emotion-panel-container.dark .suggestions-title,
.emotion-panel-container.dark .details-title {
  color: #eee;
}

.emotion-panel-container.dark .report-content,
.emotion-panel-container.dark .detail-label {
  color: #ccc;
}

.emotion-panel-container.dark .detail-value {
  color: #fff;
}

.emotion-panel-container.dark .details-item {
  border-bottom-color: #555;
}

.emotion-panel-container.dark .detail-tag {
  background-color: #2980b9;
}

.emotion-panel-container.dark .no-data {
  color: #777;
}

.emotion-panel-container.dark .suggestion-item {
  background-color: #555;
}

.emotion-panel-container.dark .suggestion-text {
  color: #ddd;
}

.emotion-panel-container.dark .action-btn {
  background-color: #555;
}

.emotion-panel-container.dark .btn-text {
  color: #eee;
}

.emotion-panel-container.dark .switch-role-btn {
  background-color: #01579b;
}

.emotion-panel-container.dark .save-btn {
  background-color: #1b5e20;
}

.emotion-panel-container.dark .history-btn {
  background-color: #e65100;
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-pie\emotion-pie.js*#*#*begin*#*#*
// components/emotion-pie/emotion-pie.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // 情感分析结果
    emotion: {
      type: Object,
      value: {
        type: 'neutral',
        intensity: 0.5
      },
      observer: function(newVal) {
        this.updatePieChart(newVal);
      }
    },
    // 是否使用暗色主题
    darkMode: {
      type: Boolean,
      value: false,
      observer: function(newVal) {
        this.updateTheme(newVal);
      }
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    // 情感类型颜色
    colors: {
      joy: '#2ECC71',    // 绿色
      sadness: '#3498DB', // 蓝色
      anger: '#E74C3C',   // 红色
      anxiety: '#F1C40F', // 黄色
      neutral: '#95A5A6',  // 灰色
      // 新增情感类型颜色
      calm: '#7FB3D5',    // 淡蓝色
      surprise: '#9B59B6', // 紫色
      disgust: '#E67E22',  // 橙色
      anticipation: '#1ABC9C', // 青绿色
      urgency: '#C0392B',  // 深红色
      disappointment: '#7F8C8D', // 深灰色
      fatigue: '#BDC3C7'   // 浅灰色
    },
    // 情感类型标签
    labels: {
      joy: '喜悦',
      sadness: '伤感',
      anger: '愤怒',
      anxiety: '焦虑',
      neutral: '平静',
      // 新增情感类型标签
      calm: '平静',
      surprise: '惊讶',
      disgust: '厌恶',
      anticipation: '期待',
      urgency: '紧迫',
      disappointment: '失望',
      fatigue: '疲惫'
    },
    // 当前主要情感
    currentEmotion: 'neutral',
    // 情感强度
    intensity: 0.5,
    // 饼图扇区角度
    sectors: {
      joy: { start: 0, end: 72 },
      sadness: { start: 72, end: 144 },
      anger: { start: 144, end: 216 },
      anxiety: { start: 216, end: 288 },
      neutral: { start: 288, end: 360 },
      // 新增情感类型扇区角度
      calm: { start: 0, end: 72 },
      surprise: { start: 72, end: 144 },
      disgust: { start: 144, end: 216 },
      anticipation: { start: 216, end: 288 },
      urgency: { start: 288, end: 360 },
      disappointment: { start: 0, end: 72 },
      fatigue: { start: 72, end: 144 }
    },
    // 高亮扇区
    highlightSector: 'neutral',
    // 是否显示饼图
    showPie: true
  },

  /**
   * 组件的方法列表
   */
  methods: {
    // 更新饼图
    updatePieChart(emotion) {
      if (!emotion) return;

      // 优先使用primary_emotion字段，兼容旧版type字段
      const type = emotion.primary_emotion || emotion.type || 'neutral';
      const intensity = emotion.intensity || 0.5;

      // 更新当前情感和强度
      this.setData({
        currentEmotion: type,
        intensity: intensity,
        highlightSector: type
      });

      // 触发更新事件
      this.triggerEvent('update', { type, intensity });
    },

    // 更新主题
    updateTheme(isDark) {
      // 根据主题调整颜色
      const colors = isDark ? {
        joy: '#26A65B',    // 深绿色
        sadness: '#2980B9', // 深蓝色
        anger: '#C0392B',   // 深红色
        anxiety: '#D4AC0D', // 深黄色
        neutral: '#7F8C8D',  // 深灰色
        // 新增情感类型颜色
        calm: '#5D8CAE',    // 深淡蓝色
        surprise: '#8E44AD', // 深紫色
        disgust: '#D35400',  // 深橙色
        anticipation: '#16A085', // 深青绿色
        urgency: '#A93226',  // 更深红色
        disappointment: '#707B7C', // 更深灰色
        fatigue: '#A6ACAF'   // 深浅灰色
      } : {
        joy: '#2ECC71',    // 绿色
        sadness: '#3498DB', // 蓝色
        anger: '#E74C3C',   // 红色
        anxiety: '#F1C40F', // 黄色
        neutral: '#95A5A6',  // 灰色
        // 新增情感类型颜色
        calm: '#7FB3D5',    // 淡蓝色
        surprise: '#9B59B6', // 紫色
        disgust: '#E67E22',  // 橙色
        anticipation: '#1ABC9C', // 青绿色
        urgency: '#C0392B',  // 深红色
        disappointment: '#7F8C8D', // 深灰色
        fatigue: '#BDC3C7'   // 浅灰色
      };

      this.setData({ colors });
    },

    // 点击情感扇区
    onSectorTap(e) {
      const { emotion } = e.currentTarget.dataset;

      // 更新高亮扇区
      this.setData({
        highlightSector: emotion
      });

      // 触发选择事件
      this.triggerEvent('select', { type: emotion });
    }
  },

  // 组件生命周期
  lifetimes: {
    attached() {
      // 组件加载时初始化饼图
      this.updatePieChart(this.properties.emotion);
      this.updateTheme(this.properties.darkMode);
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-pie\emotion-pie.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-pie\emotion-pie.wxml*#*#*begin*#*#*
<!--components/emotion-pie/emotion-pie.wxml-->
<view class="emotion-pie">
  <!-- 情感饼图 -->
  <view class="pie-container">
    <!-- 情感扇区 -->
    <view class="emotion-sectors">
      <!-- 基本情感类型扇区 -->
      <view class="emotion-sector {{highlightSector === 'joy' ? 'active' : ''}}"
            data-emotion="joy"
            bindtap="onSectorTap"
            style="background-color: {{colors.joy}}; transform: rotate(0deg) skew(30deg);">
      </view>
      <view class="emotion-sector {{highlightSector === 'sadness' ? 'active' : ''}}"
            data-emotion="sadness"
            bindtap="onSectorTap"
            style="background-color: {{colors.sadness}}; transform: rotate(72deg) skew(30deg);">
      </view>
      <view class="emotion-sector {{highlightSector === 'anger' ? 'active' : ''}}"
            data-emotion="anger"
            bindtap="onSectorTap"
            style="background-color: {{colors.anger}}; transform: rotate(144deg) skew(30deg);">
      </view>
      <view class="emotion-sector {{highlightSector === 'anxiety' ? 'active' : ''}}"
            data-emotion="anxiety"
            bindtap="onSectorTap"
            style="background-color: {{colors.anxiety}}; transform: rotate(216deg) skew(30deg);">
      </view>
      <view class="emotion-sector {{highlightSector === 'neutral' ? 'active' : ''}}"
            data-emotion="neutral"
            bindtap="onSectorTap"
            style="background-color: {{colors.neutral}}; transform: rotate(288deg) skew(30deg);">
      </view>
    </view>

    <!-- 中心圆 -->
    <view class="pie-center">
      <view class="intensity-indicator" style="transform: scale({{intensity}})"></view>
    </view>
  </view>

  <!-- 情感标签 -->
  <view class="emotion-labels">
    <!-- 基本情感类型 -->
    <view class="emotion-label {{currentEmotion === 'joy' ? 'active' : ''}}"
          data-emotion="joy"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.joy}}"></view>
      <text>{{labels.joy}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'sadness' ? 'active' : ''}}"
          data-emotion="sadness"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.sadness}}"></view>
      <text>{{labels.sadness}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'anger' ? 'active' : ''}}"
          data-emotion="anger"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.anger}}"></view>
      <text>{{labels.anger}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'anxiety' ? 'active' : ''}}"
          data-emotion="anxiety"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.anxiety}}"></view>
      <text>{{labels.anxiety}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'neutral' ? 'active' : ''}}"
          data-emotion="neutral"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.neutral}}"></view>
      <text>{{labels.neutral}}</text>
    </view>

    <!-- 新增情感类型 -->
    <view class="emotion-label {{currentEmotion === 'calm' ? 'active' : ''}}"
          data-emotion="calm"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.calm}}"></view>
      <text>{{labels.calm}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'surprise' ? 'active' : ''}}"
          data-emotion="surprise"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.surprise}}"></view>
      <text>{{labels.surprise}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'disgust' ? 'active' : ''}}"
          data-emotion="disgust"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.disgust}}"></view>
      <text>{{labels.disgust}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'anticipation' ? 'active' : ''}}"
          data-emotion="anticipation"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.anticipation}}"></view>
      <text>{{labels.anticipation}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'urgency' ? 'active' : ''}}"
          data-emotion="urgency"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.urgency}}"></view>
      <text>{{labels.urgency}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'disappointment' ? 'active' : ''}}"
          data-emotion="disappointment"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.disappointment}}"></view>
      <text>{{labels.disappointment}}</text>
    </view>
    <view class="emotion-label {{currentEmotion === 'fatigue' ? 'active' : ''}}"
          data-emotion="fatigue"
          bindtap="onSectorTap">
      <view class="label-color" style="background-color: {{colors.fatigue}}"></view>
      <text>{{labels.fatigue}}</text>
    </view>
  </view>

  <!-- 当前情感信息 -->
  <view class="current-emotion">
    <text class="emotion-type">{{labels[currentEmotion]}}</text>
    <text class="emotion-intensity">强度: {{intensity * 100}}%</text>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\emotion-pie\emotion-pie.wxss*#*#*begin*#*#*
/* components/emotion-pie/emotion-pie.wxss */
.emotion-pie {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  padding: 20rpx;
}

/* 饼图容器 */
.pie-container {
  position: relative;
  width: 300rpx;
  height: 300rpx;
  margin: 20rpx 0;
}

/* 情感扇区容器 */
.emotion-sectors {
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  overflow: hidden;
}

/* 情感扇区 */
.emotion-sector {
  position: absolute;
  top: 0;
  left: 0;
  width: 50%;
  height: 50%;
  transform-origin: 100% 100%;
  transition: all 0.3s ease;
}

/* 活跃扇区 */
.emotion-sector.active {
  transform-origin: 100% 100%;
  box-shadow: 0 0 10rpx rgba(0, 0, 0, 0.3);
  z-index: 10;
}

/* 中心圆 */
.pie-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100rpx;
  height: 100rpx;
  background-color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 10rpx rgba(0, 0, 0, 0.1);
  z-index: 20;
}

/* 强度指示器 */
.intensity-indicator {
  width: 80%;
  height: 80%;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.1);
  transition: transform 0.3s ease;
}

/* 情感标签容器 */
.emotion-labels {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 30rpx;
  width: 100%;
  max-height: 300rpx;
  overflow-y: auto;
}

/* 情感标签 */
.emotion-label {
  display: flex;
  align-items: center;
  margin: 10rpx 15rpx;
  padding: 6rpx 12rpx;
  border-radius: 20rpx;
  background-color: #f5f5f5;
  transition: all 0.3s ease;
}

/* 活跃标签 */
.emotion-label.active {
  background-color: #e0e0e0;
  box-shadow: 0 2rpx 5rpx rgba(0, 0, 0, 0.1);
}

/* 标签颜色指示器 */
.label-color {
  width: 20rpx;
  height: 20rpx;
  border-radius: 50%;
  margin-right: 8rpx;
}

/* 当前情感信息 */
.current-emotion {
  margin-top: 20rpx;
  text-align: center;
}

/* 情感类型 */
.emotion-type {
  font-size: 32rpx;
  font-weight: bold;
  margin-right: 20rpx;
}

/* 情感强度 */
.emotion-intensity {
  font-size: 28rpx;
  color: #666;
}

*#*#*end*#*#*

*#*#*miniprogram\components\interest-tag-cloud\interest-tag-cloud.js*#*#*begin*#*#*
// components/interest-tag-cloud/interest-tag-cloud.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    userId: {
      type: String,
      value: ''
    },
    maxTags: {
      type: Number,
      value: 20
    },
    minFontSize: {
      type: Number,
      value: 12
    },
    maxFontSize: {
      type: Number,
      value: 24
    },
    colorMap: {
      type: Object,
      value: {
        '学习': '#4285F4', // 蓝色
        '工作': '#34A853', // 绿色
        '娱乐': '#FBBC05', // 黄色
        '社交': '#EA4335', // 红色
        '健康': '#42A5F5', // 浅蓝色
        '生活': '#66BB6A', // 浅绿色
        '未分类': '#9E9E9E'  // 灰色
      }
    },
    darkModeColorMap: {
      type: Object,
      value: {
        '学习': '#74b9ff', // 暗夜蓝色
        '工作': '#55efc4', // 暗夜绿色
        '娱乐': '#ffeaa7', // 暗夜黄色
        '社交': '#ff7675', // 暗夜红色
        '健康': '#81ecec', // 暗夜浅蓝色
        '生活': '#81ecec', // 暗夜浅绿色
        '未分类': '#a0aec0'  // 暗夜灰色
      }
    },
    showCategory: {
      type: Boolean,
      value: true
    },
    autoRefresh: {
      type: Boolean,
      value: false
    },
    darkMode: {
      type: Boolean,
      value: false
    },
    showTitle: {
      type: Boolean,
      value: true
    },
    showRefreshButton: {
      type: Boolean,
      value: true
    },
    // 是否使用分类数据而不是关键词数据
    useCategories: {
      type: Boolean,
      value: true
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    tags: [],
    loading: false,
    error: null,
    randomColors: [
      '#4285F4', // 蓝色
      '#34A853', // 绿色
      '#FBBC05', // 黄色
      '#EA4335', // 红色
      '#42A5F5', // 浅蓝色
      '#66BB6A', // 浅绿色
      '#FF9800', // 橙色
      '#9C27B0', // 紫色
      '#00BCD4', // 青色
      '#FF5722'  // 深橙色
    ],
    darkModeRandomColors: [
      '#74b9ff', // 暗夜蓝色
      '#55efc4', // 暗夜绿色
      '#ffeaa7', // 暗夜黄色
      '#ff7675', // 暗夜红色
      '#81ecec', // 暗夜浅蓝色
      '#a0b9c0', // 暗夜浅绿色
      '#ffa502', // 暗夜橙色
      '#a29bfe', // 暗夜紫色
      '#00cec9', // 暗夜青色
      '#fd79a8'  // 暗夜粉色
    ]
  },

  /**
   * 组件的生命周期
   */
  lifetimes: {
    attached() {
      // 在组件实例进入页面节点树时执行
      if (this.data.autoRefresh) {
        this.loadTags();
      }
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    /**
     * 加载标签数据
     * @param {boolean} forceRefresh 是否强制刷新
     */
    async loadTags(forceRefresh = false) {
      const userId = this.data.userId;
      if (!userId) {
        this.setData({
          error: '用户ID不能为空'
        });
        return;
      }

      this.setData({
        loading: true,
        error: null
      });

      try {
        // 引入用户兴趣服务
        const userInterestsService = require('../../services/userInterestsService');

        // 获取标签云数据，传递 useCategories 参数
        const tagCloudData = await userInterestsService.getInterestTagCloudData(userId, forceRefresh, this.data.useCategories);

        if (!tagCloudData || tagCloudData.length === 0) {
          this.setData({
            tags: [],
            loading: false,
            error: '暂无兴趣数据'
          });
          return;
        }

        // 限制标签数量
        const limitedTags = tagCloudData.slice(0, this.data.maxTags);

        // 计算字体大小
        const minValue = Math.min(...limitedTags.map(tag => tag.value));
        const maxValue = Math.max(...limitedTags.map(tag => tag.value));
        const minFontSize = this.data.minFontSize;
        const maxFontSize = this.data.maxFontSize;

        const processedTags = limitedTags.map(tag => {
          // 计算字体大小
          let fontSize = minFontSize;
          if (maxValue > minValue) {
            fontSize = minFontSize + (tag.value - minValue) / (maxValue - minValue) * (maxFontSize - minFontSize);
          }

          // 获取颜色，根据暗夜模式状态选择颜色映射
          const colorMapToUse = this.data.darkMode ? this.data.darkModeColorMap : this.data.colorMap;
          let color;

          if (tag.category && tag.category !== '未分类' && colorMapToUse[tag.category]) {
            // 如果有分类且分类不是“未分类”，使用分类对应的颜色
            color = colorMapToUse[tag.category];
          } else {
            // 如果没有分类或分类是“未分类”，使用标签名称生成随机颜色
            color = this.getRandomColor(tag.name);
          }

          return {
            ...tag,
            fontSize,
            color
          };
        });

        // 随机排序，避免每次显示顺序相同
        processedTags.sort(() => Math.random() - 0.5);

        this.setData({
          tags: processedTags,
          loading: false
        });

        // 触发加载完成事件
        this.triggerEvent('loaded', { tags: processedTags });
      } catch (error) {
        console.error('加载标签失败:', error);
        this.setData({
          loading: false,
          error: '加载标签失败'
        });

        // 触发错误事件
        this.triggerEvent('error', { error });
      }
    },

    /**
     * 处理标签点击事件
     * @param {Object} e 事件对象
     */
    handleTagClick(e) {
      const tag = e.currentTarget.dataset.tag;

      // 触发标签点击事件
      this.triggerEvent('tagclick', { tag });
    },

    /**
     * 处理刷新按钮点击事件
     */
    handleRefresh() {
      this.loadTags(true);

      // 触发刷新事件
      this.triggerEvent('refresh');
    },

    /**
     * 获取随机颜色
     * @param {string} tagName 标签名称，用于生成一致的随机颜色
     * @returns {string} 颜色代码
     */
    getRandomColor(tagName) {
      // 使用标签名称的字符码之和作为随机种子
      let seed = 0;
      for (let i = 0; i < tagName.length; i++) {
        seed += tagName.charCodeAt(i);
      }

      // 选择颜色数组
      const colorArray = this.data.darkMode ? this.data.darkModeRandomColors : this.data.randomColors;

      // 使用种子选择颜色，确保同一标签始终得到相同的颜色
      const index = seed % colorArray.length;
      return colorArray[index];
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\components\interest-tag-cloud\interest-tag-cloud.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\components\interest-tag-cloud\interest-tag-cloud.wxml*#*#*begin*#*#*
<!-- components/interest-tag-cloud/interest-tag-cloud.wxml -->
<view class="interest-tag-cloud {{darkMode ? 'dark' : ''}}">
  <view class="tag-cloud-header">
    <view class="tag-cloud-title" wx:if="{{showTitle}}">兴趣标签</view>
    <view class="tag-cloud-title-placeholder" wx:else></view>
    <view class="tag-cloud-refresh" bindtap="handleRefresh" wx:if="{{showRefreshButton}}">
      <text class="refresh-icon">🔄</text>
    </view>
  </view>

  <view class="tag-cloud-content">
    <block wx:if="{{loading}}">
      <view class="tag-cloud-loading">
        <text>加载中...</text>
      </view>
    </block>

    <block wx:elif="{{error}}">
      <view class="tag-cloud-error">
        <text>{{error}}</text>
      </view>
    </block>

    <block wx:elif="{{tags.length === 0}}">
      <view class="tag-cloud-empty">
        <text>暂无兴趣标签</text>
      </view>
    </block>

    <block wx:else>
      <view class="tag-cloud-tags">
        <view
          wx:for="{{tags}}"
          wx:key="name"
          class="tag-item"
          style="font-size: {{item.fontSize}}px; color: {{item.color}};"
          data-tag="{{item}}"
          bindtap="handleTagClick"
        >
          <text>{{item.name}}</text>
          <text wx:if="{{showCategory && item.category !== '未分类'}}" class="tag-category">({{item.category}})</text>
        </view>
      </view>
    </block>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\interest-tag-cloud\interest-tag-cloud.wxss*#*#*begin*#*#*
/* components/interest-tag-cloud/interest-tag-cloud.wxss */
.interest-tag-cloud {
  width: 100%;
  padding: 16rpx;
  box-sizing: border-box;
}

.tag-cloud-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16rpx;
}

.tag-cloud-title {
  font-size: 32rpx;
  font-weight: bold;
  color: #333;
}

.dark .tag-cloud-title {
  color: #f8f9fa;
}

.tag-cloud-title-placeholder {
  flex: 1;
}

.tag-cloud-refresh {
  padding: 8rpx;
  border-radius: 50%;
  background-color: #f5f5f5;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 48rpx;
  height: 48rpx;
}

.dark .tag-cloud-refresh {
  background-color: #2d3748;
}

.refresh-icon {
  font-size: 28rpx;
}

.tag-cloud-content {
  min-height: 200rpx;
  background-color: #f9f9f9;
  border-radius: 12rpx;
  padding: 16rpx;
}

.dark .tag-cloud-content {
  background-color: #2d3748;
}

.tag-cloud-loading,
.tag-cloud-error,
.tag-cloud-empty {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200rpx;
  color: #999;
  font-size: 28rpx;
}

.dark .tag-cloud-loading,
.dark .tag-cloud-error,
.dark .tag-cloud-empty {
  color: #a0aec0;
}

.tag-cloud-tags {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 8rpx;
}

.tag-item {
  margin: 8rpx 12rpx;
  padding: 8rpx 16rpx;
  background-color: rgba(255, 255, 255, 0.8);
  border-radius: 8rpx;
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}

.dark .tag-item {
  background-color: rgba(45, 55, 72, 0.8);
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.2);
}

.tag-item:active {
  transform: scale(0.95);
  opacity: 0.8;
}

.tag-category {
  font-size: 0.8em;
  opacity: 0.7;
  margin-left: 4rpx;
}

*#*#*end*#*#*

*#*#*miniprogram\components\login\index.js*#*#*begin*#*#*
const app = getApp();

Component({
  properties: {
    show: {
      type: Boolean,
      value: false
    }
  },

  data: {
    loading: false,
    error: '',
    agreed: false
  },

  methods: {
    handleAgreementChange(e) {
      this.setData({
        agreed: e.detail.value
      });
    },

    async handleLogin() {
      if (!this.data.agreed) {
        wx.showToast({
          title: '请先同意服务协议',
          icon: 'none'
        });
        return;
      }

      if (this.data.loading) return;

      this.setData({
        loading: true,
        error: ''
      });

      try {
        // 获取用户信息
        const userProfile = await wx.getUserProfile({
          desc: '用于完善用户资料'
        });

        // 使用全局登录方法
        const loginSuccess = await app.login(userProfile.userInfo);

        if (!loginSuccess) {
          throw new Error('登录失败');
        }

        // 显示成功提示
        wx.showToast({
          title: '登录成功',
          icon: 'success',
          duration: 1500
        });

        // 触发登录成功事件
        this.triggerEvent('success', {
          userInfo: app.globalData.userInfo,
          isNewUser: false // 由于无法确定是否为新用户，默认为false
        });

        // 延迟隐藏登录组件，等待提示显示
        setTimeout(() => {
          this.triggerEvent('close');
        }, 1000);

      } catch (error) {
        console.error('Login failed:', error);
        let errorMsg = '登录失败，请重试';

        if (error.errMsg?.includes('getUserProfile:fail')) {
          errorMsg = '需要您的授权才能继续使用';
        }

        this.setData({
          error: errorMsg
        });

        wx.showToast({
          title: errorMsg,
          icon: 'none'
        });
      } finally {
        this.setData({
          loading: false
        });
      }
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\components\login\index.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
} 
*#*#*end*#*#*

*#*#*miniprogram\components\login\index.wxml*#*#*begin*#*#*
<view class="login-container {{show ? 'show' : ''}}">
  <view class="login-box">
    <!-- Logo -->
    <image class="logo" src="/images/logo.png" mode="aspectFit"></image>
    
    <!-- 品牌名称 -->
    <view class="brand">HeartChat</view>
    
    <!-- 标语 -->
    <view class="slogan">你的AI情商助手</view>

    <!-- 错误提示 -->
    <view class="error-tip" wx:if="{{error}}">{{error}}</view>

    <!-- 协议区域 -->
    <view class="agreement-box">
      <checkbox-group bindchange="handleAgreementChange">
        <label class="agreement-label">
          <checkbox value="agreed" />
          <text class="agreement-text">我已阅读并同意</text>
          <navigator url="/pages/agreement/service" class="link">《服务协议》</navigator>
          <text class="agreement-text">和</text>
          <navigator url="/pages/agreement/privacy" class="link">《隐私协议》</navigator>
        </label>
      </checkbox-group>
    </view>

    <!-- 登录按钮 -->
    <button 
      class="login-btn {{!agreed ? 'disabled' : ''}}"
      loading="{{loading}}"
      disabled="{{!agreed || loading}}"
      bindtap="handleLogin"
    >
      一键微信登录
    </button>
  </view>
</view> 
*#*#*end*#*#*

*#*#*miniprogram\components\login\index.wxss*#*#*begin*#*#*
.login-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #fff;
  z-index: 999;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s;
}

.login-container.show {
  opacity: 1;
  visibility: visible;
}

.login-box {
  width: 80%;
  max-width: 600rpx;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 40rpx;
}

.logo {
  width: 200rpx;
  height: 200rpx;
  margin-bottom: 40rpx;
}

.brand {
  font-size: 40rpx;
  font-weight: bold;
  color: #333;
  margin-bottom: 20rpx;
}

.slogan {
  font-size: 28rpx;
  color: #666;
  margin-bottom: 60rpx;
}

.error-tip {
  color: #ff4d4f;
  font-size: 24rpx;
  margin-bottom: 20rpx;
}

.agreement-box {
  width: 100%;
  margin-bottom: 40rpx;
}

.agreement-label {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24rpx;
  color: #666;
}

.agreement-text {
  margin: 0 4rpx;
}

.link {
  color: #07c160;
  display: inline;
}

.login-btn {
  width: 100% !important;
  height: 88rpx;
  line-height: 88rpx;
  background: #07c160;
  color: #fff;
  font-size: 32rpx;
  border-radius: 44rpx;
  border: none;
}

.login-btn.disabled {
  background: #ccc;
}

.login-btn::after {
  border: none;
} 
*#*#*end*#*#*

*#*#*miniprogram\components\model-selector\model-selector.js*#*#*begin*#*#*
/**
 * 模型选择器组件
 * 提供AI模型选择功能
 *
 * @architecture 该组件实现了AI模型的选择功能，支持在不同AI模型之间切换
 * @dependency modelService 模型服务
 * @history 2025-05-10 初始版本
 * @history 2025-05-15 添加动态模型列表支持
 */

// 导入模型服务
const modelService = require('../../services/modelService');

Component({
  /**
   * 组件的属性列表
   */
  properties: {
    darkMode: {
      type: Boolean,
      value: false
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    modelTypes: [],
    modelDisplayNames: {},
    selectedModelType: '',
    showSelector: false,
    loading: false,
    showModelList: false,
    currentModelList: [],
    selectedModel: '',
    modelDescriptions: {}
  },

  /**
   * 组件生命周期
   */
  lifetimes: {
    attached() {
      this.initModelSelector();
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    /**
     * 初始化模型选择器
     */
    async initModelSelector() {
      try {
        // 获取所有可用的模型类型
        const modelTypes = modelService.getAvailableModelTypes();

        // 获取当前选择的模型类型
        const selectedModelType = modelService.getSelectedModelType();

        // 构建模型显示名称映射
        const modelDisplayNames = {};
        const modelDescriptions = {};
        modelTypes.forEach(type => {
          modelDisplayNames[type] = modelService.getModelDisplayName(type);

          // 获取模型描述
          const config = modelService.getModelConfig(type);
          modelDescriptions[type] = config.description;
        });

        // 获取当前选择的模型
        const selectedModel = modelService.getSelectedModel(selectedModelType);

        // 获取当前模型类型的模型列表
        const currentModelList = await modelService.getModelList(selectedModelType);

        this.setData({
          modelTypes,
          modelDisplayNames,
          selectedModelType,
          modelDescriptions,
          selectedModel,
          currentModelList
        });
      } catch (error) {
        console.error('初始化模型选择器失败:', error.message || error);
        wx.showToast({
          title: '初始化模型选择器失败',
          icon: 'none'
        });
      }
    },

    /**
     * 显示模型选择器
     */
    showModelSelector() {
      this.setData({
        showSelector: true
      });
    },

    /**
     * 隐藏模型选择器
     */
    hideModelSelector() {
      this.setData({
        showSelector: false
      });
    },

    /**
     * 选择模型类型
     * @param {Object} e 事件对象
     */
    async selectModelType(e) {
      const { modelType } = e.currentTarget.dataset;

      if (modelType === this.data.selectedModelType) {
        // 如果点击的是当前选择的模型类型，则显示模型列表
        this.showModelListSelector();
        return;
      }

      this.setData({
        loading: true
      });

      try {
        // 测试模型连接
        const result = await modelService.testModelConnection(modelType);

        if (result.success) {
          // 设置选择的模型类型
          modelService.setSelectedModelType(modelType);

          // 获取该类型的模型列表
          const modelList = await modelService.getModelList(modelType);

          // 获取默认选择的模型
          const selectedModel = modelService.getSelectedModel(modelType);

          this.setData({
            selectedModelType: modelType,
            currentModelList: modelList,
            selectedModel: selectedModel,
            loading: false
          });

          // 触发模型变更事件
          this.triggerEvent('modelChange', {
            modelType,
            modelName: selectedModel
          });

          wx.showToast({
            title: '模型切换成功',
            icon: 'success'
          });
        } else {
          wx.showToast({
            title: '模型连接测试失败',
            icon: 'none'
          });

          this.setData({
            loading: false
          });
        }
      } catch (error) {
        console.error('测试模型连接失败:', error.message || error);

        wx.showToast({
          title: '测试模型连接失败',
          icon: 'none'
        });

        this.setData({
          loading: false
        });
      } finally {
        this.hideModelSelector();
      }
    },

    /**
     * 显示模型列表选择器
     */
    showModelListSelector() {
      this.setData({
        showModelList: true
      });
    },

    /**
     * 隐藏模型列表选择器
     */
    hideModelListSelector() {
      this.setData({
        showModelList: false
      });
    },

    /**
     * 选择具体模型
     * @param {Object} e 事件对象
     */
    async selectModel(e) {
      const { modelName } = e.currentTarget.dataset;

      if (modelName === this.data.selectedModel) {
        this.hideModelListSelector();
        return;
      }

      this.setData({
        loading: true
      });

      try {
        // 设置选择的模型
        modelService.setSelectedModel(this.data.selectedModelType, modelName);

        this.setData({
          selectedModel: modelName,
          loading: false
        });

        // 触发模型变更事件
        this.triggerEvent('modelChange', {
          modelType: this.data.selectedModelType,
          modelName
        });

        wx.showToast({
          title: '模型切换成功',
          icon: 'success'
        });
      } catch (error) {
        console.error('切换模型失败:', error.message || error);

        wx.showToast({
          title: '切换模型失败',
          icon: 'none'
        });

        this.setData({
          loading: false
        });
      } finally {
        this.hideModelListSelector();
      }
    },

    /**
     * 阻止事件冒泡
     */
    stopPropagation() {
      // 仅用于阻止事件冒泡
      return;
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\components\model-selector\model-selector.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\components\model-selector\model-selector.wxml*#*#*begin*#*#*
<!-- components/model-selector/model-selector.wxml -->
<view class="model-selector {{darkMode ? 'dark' : ''}}">
  <!-- 当前选择的模型 -->
  <view class="selected-model" bindtap="showModelSelector">
    <view class="model-icon">
      <image class="icon" src="/images/icons/ai.png" mode="aspectFit"></image>
    </view>
    <view class="model-name">
      <text>{{modelDisplayNames[selectedModelType]}}</text>
      <text class="model-subname">{{selectedModel}}</text>
    </view>
    <view class="arrow-icon">
      <image class="icon" src="/images/icons/arrow-down.png" mode="aspectFit"></image>
    </view>
  </view>

  <!-- 模型类型选择弹窗 -->
  <view class="model-selector-popup {{showSelector ? 'show' : ''}}" catchtap="hideModelSelector">
    <view class="model-selector-content" catchtap="stopPropagation">
      <view class="popup-header">
        <text class="popup-title">选择AI模型平台</text>
        <view class="close-btn" bindtap="hideModelSelector">
          <image class="icon" src="/images/icons/close.png" mode="aspectFit"></image>
        </view>
      </view>

      <view class="model-list">
        <block wx:for="{{modelTypes}}" wx:key="*this">
          <view class="model-item {{item === selectedModelType ? 'selected' : ''}}"
                data-model-type="{{item}}"
                bindtap="selectModelType">
            <view class="model-item-icon">
              <image class="icon" src="/images/icons/{{item}}.png" mode="aspectFit"></image>
            </view>
            <view class="model-item-info">
              <view class="model-item-name">{{modelDisplayNames[item]}}</view>
              <view class="model-item-desc">{{modelDescriptions[item]}}</view>
            </view>
            <view class="model-item-check" wx:if="{{item === selectedModelType}}">
              <image class="icon" src="/images/icons/check.png" mode="aspectFit"></image>
            </view>
          </view>
        </block>
      </view>
    </view>
  </view>

  <!-- 模型列表选择弹窗 -->
  <view class="model-selector-popup {{showModelList ? 'show' : ''}}" catchtap="hideModelListSelector">
    <view class="model-selector-content" catchtap="stopPropagation">
      <view class="popup-header">
        <text class="popup-title">选择{{modelDisplayNames[selectedModelType]}}模型</text>
        <view class="close-btn" bindtap="hideModelListSelector">
          <image class="icon" src="/images/icons/close.png" mode="aspectFit"></image>
        </view>
      </view>

      <view class="model-list">
        <block wx:for="{{currentModelList}}" wx:key="*this">
          <view class="model-item {{item === selectedModel ? 'selected' : ''}}"
                data-model-name="{{item}}"
                bindtap="selectModel">
            <view class="model-item-icon">
              <image class="icon" src="/images/icons/model.png" mode="aspectFit"></image>
            </view>
            <view class="model-item-info">
              <view class="model-item-name">{{item}}</view>
              <view class="model-item-desc">{{selectedModelType}} 模型</view>
            </view>
            <view class="model-item-check" wx:if="{{item === selectedModel}}">
              <image class="icon" src="/images/icons/check.png" mode="aspectFit"></image>
            </view>
          </view>
        </block>
      </view>
    </view>
  </view>

  <!-- 加载中遮罩 -->
  <view class="loading-mask" wx:if="{{loading}}">
    <view class="loading-spinner"></view>
    <text class="loading-text">正在连接模型...</text>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\model-selector\model-selector.wxss*#*#*begin*#*#*
/* components/model-selector/model-selector.wxss */
.model-selector {
  position: relative;
  width: 100%;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

/* 当前选择的模型 */
.selected-model {
  display: flex;
  align-items: center;
  padding: 8rpx 16rpx;
  background-color: #f5f5f5;
  border-radius: 8rpx;
  cursor: pointer;
  transition: all 0.3s ease;
}

.dark .selected-model {
  background-color: #333;
  color: #fff;
}

.model-icon {
  width: 40rpx;
  height: 40rpx;
  margin-right: 8rpx;
}

.model-name {
  flex: 1;
  display: flex;
  flex-direction: column;
  font-size: 28rpx;
  font-weight: 500;
}

.model-subname {
  font-size: 22rpx;
  color: #666;
  margin-top: 4rpx;
}

.dark .model-subname {
  color: #aaa;
}

.arrow-icon {
  width: 32rpx;
  height: 32rpx;
  transition: transform 0.3s ease;
}

.selected-model:active {
  opacity: 0.8;
}

.icon {
  width: 100%;
  height: 100%;
}

/* 模型选择弹窗 */
.model-selector-popup {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.model-selector-popup.show {
  opacity: 1;
  visibility: visible;
}

.model-selector-content {
  width: 80%;
  max-width: 600rpx;
  background-color: #fff;
  border-radius: 16rpx;
  overflow: hidden;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.1);
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.dark .model-selector-content {
  background-color: #222;
  color: #fff;
}

.model-selector-popup.show .model-selector-content {
  transform: scale(1);
}

.popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24rpx;
  border-bottom: 1rpx solid #eee;
}

.dark .popup-header {
  border-bottom-color: #333;
}

.popup-title {
  font-size: 32rpx;
  font-weight: 600;
}

.close-btn {
  width: 40rpx;
  height: 40rpx;
  cursor: pointer;
}

.model-list {
  max-height: 60vh;
  overflow-y: auto;
}

.model-item {
  display: flex;
  align-items: center;
  padding: 24rpx;
  border-bottom: 1rpx solid #eee;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.dark .model-item {
  border-bottom-color: #333;
}

.model-item:last-child {
  border-bottom: none;
}

.model-item:active {
  background-color: #f5f5f5;
}

.dark .model-item:active {
  background-color: #333;
}

.model-item.selected {
  background-color: #f0f7ff;
}

.dark .model-item.selected {
  background-color: #1a3a5f;
}

.model-item-icon {
  width: 64rpx;
  height: 64rpx;
  margin-right: 16rpx;
}

.model-item-info {
  flex: 1;
}

.model-item-name {
  font-size: 30rpx;
  font-weight: 500;
  margin-bottom: 4rpx;
}

.model-item-desc {
  font-size: 24rpx;
  color: #666;
}

.dark .model-item-desc {
  color: #aaa;
}

.model-item-check {
  width: 40rpx;
  height: 40rpx;
}

/* 加载中遮罩 */
.loading-mask {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 1001;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.loading-spinner {
  width: 80rpx;
  height: 80rpx;
  border: 6rpx solid rgba(255, 255, 255, 0.3);
  border-top-color: #fff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  margin-top: 24rpx;
  font-size: 28rpx;
  color: #fff;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

*#*#*end*#*#*

*#*#*miniprogram\components\role-card\role-card.js*#*#*begin*#*#*
// components/role-card/role-card.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    role: {
      type: Object,
      value: {}
    },
    selected: {
      type: Boolean,
      value: false
    },
    darkMode: {
      type: Boolean,
      value: false
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    defaultAvatar: '/images/avatars/default-avatar.png'
  },

  /**
   * 组件的方法列表
   */
  methods: {
    /**
     * 获取角色名称
     */
    getRoleName() {
      const role = this.properties.role;
      return role.name || role.role_name || '未命名角色';
    },

    /**
     * 获取角色描述
     */
    getRoleDescription() {
      const role = this.properties.role;
      return role.description || role.role_desc || '暂无描述';
    },

    /**
     * 获取角色分类
     */
    getRoleCategory() {
      const role = this.properties.role;
      return role.category || role.role_type || 'other';
    },

    /**
     * 获取角色头像
     */
    getRoleAvatar() {
      const role = this.properties.role;
      return role.avatar || role.avatar_url || this.data.defaultAvatar;
    },

    /**
     * 点击角色卡片
     */
    handleTap() {
      this.triggerEvent('select', { role: this.properties.role });
    },

    /**
     * 长按角色卡片
     */
    handleLongPress() {
      this.triggerEvent('longpress', { role: this.properties.role });
    },

    /**
     * 处理头像加载错误
     */
    handleAvatarError() {
      console.log('头像加载失败，使用默认头像');
      // 如果头像加载失败，使用默认头像
      const role = this.properties.role;
      if (role.avatar) {
        role.avatar = this.data.defaultAvatar;
        this.setData({ role });
      }
    }
  }
})

*#*#*end*#*#*

*#*#*miniprogram\components\role-card\role-card.json*#*#*begin*#*#*
{
    "component": true,
    "usingComponents": {}
}
*#*#*end*#*#*

*#*#*miniprogram\components\role-card\role-card.wxml*#*#*begin*#*#*
<!-- components/role-card/role-card.wxml -->
<view class="role-card {{selected ? 'selected' : ''}} {{darkMode ? 'dark' : ''}}"
      bindtap="handleTap"
      bindlongpress="handleLongPress">
  <view class="avatar-container">
    <image class="avatar"
           src="{{role.avatar || role.avatar_url || defaultAvatar}}"
           mode="aspectFill"
           binderror="handleAvatarError"></image>

    <!-- 系统角色标记 -->
    <view class="system-badge" wx:if="{{role.isSystem || role.creator === 'system'}}">
      <text>系统</text>
    </view>

    <!-- 分类标签 -->
    <view class="category-tag" wx:if="{{role.category || role.role_type}}">
      <text>{{(role.category || role.role_type) === 'emotion' ? '情感支持' :
             (role.category || role.role_type) === 'psychology' ? '心理咨询' :
             (role.category || role.role_type) === 'life' ? '生活伙伴' :
             (role.category || role.role_type) === 'career' || (role.category || role.role_type) === 'work' ? '职场导师' :
             (role.category || role.role_type) === 'other' ? '其他' : '其他'}}</text>
    </view>

    <!-- 推荐角色标记 - 基于消息数量或isRecommended字段 -->
    <view class="{{role.messageCount > 0 ? 'recommended-badge frequently-used' : 'recommended-badge'}}"
          wx:if="{{role.messageCount > 0 || role.isRecommended}}">
      <text>{{role.messageCount > 0 ? '常用' : '推荐'}}</text>
    </view>
  </view>

  <view class="info-container">
    <view class="name-container">
      <text class="name">{{role.name || role.role_name || '未命名角色'}}</text>
      <view class="usage-count" wx:if="{{role.usage && role.usage.usageCount > 0}}">
        <text>{{role.usage.usageCount}}次</text>
      </view>
    </view>
    <text class="description">{{role.description || role.role_desc || '暂无描述'}}</text>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\components\role-card\role-card.wxss*#*#*begin*#*#*
/* components/role-card/role-card.wxss */
.role-card {
  background-color: #ffffff;
  border-radius: 20rpx;
  box-shadow: 0 4rpx 20rpx rgba(0, 0, 0, 0.06);
  overflow: hidden;
  transition: all 0.3s ease;
  position: relative;
  border: 2rpx solid transparent;
  margin: 6rpx 0;
}

/* 暗夜模式 */
.role-card.dark {
  background-color: #212529;
  box-shadow: 0 4rpx 20rpx rgba(0, 0, 0, 0.15);
}

.role-card.selected {
  border: 2rpx solid #5e72e4;
  transform: translateY(-4rpx);
  box-shadow: 0 8rpx 24rpx rgba(94, 114, 228, 0.15);
}

.role-card.dark.selected {
  border: 2rpx solid #4dabf7;
  box-shadow: 0 8rpx 24rpx rgba(77, 171, 247, 0.2);
}

.avatar-container {
  position: relative;
  width: 100%;
  height: 220rpx;
  overflow: hidden;
  background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
}

.dark .avatar-container {
  background: linear-gradient(to bottom, #343a40, #212529);
}

.avatar {
  width: 100%;
  height: 100%;
  background-color: #f0f0f0;
  object-fit: cover;
  transition: transform 0.3s ease;
}

.dark .avatar {
  background-color: #343a40;
}

.role-card:hover .avatar {
  transform: scale(1.05);
}

.category-tag {
  position: absolute;
  top: 16rpx;
  right: 16rpx;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 30rpx;
  padding: 8rpx 18rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.1);
}

.category-tag text {
  color: #ffffff;
  font-size: 22rpx;
  font-weight: 500;
}

.info-container {
  padding: 24rpx;
  border-top: 1rpx solid rgba(0, 0, 0, 0.03);
}

.dark .info-container {
  border-top: 1rpx solid rgba(255, 255, 255, 0.05);
}

.name-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10rpx;
}

.name {
  font-size: 32rpx;
  font-weight: 600;
  color: #333333;
  line-height: 1.3;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 1;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dark .name {
  color: #f8f9fa;
}

.usage-count {
  background-color: rgba(94, 114, 228, 0.1);
  border-radius: 20rpx;
  padding: 6rpx 14rpx;
  min-width: 60rpx;
  text-align: center;
}

.dark .usage-count {
  background-color: rgba(77, 171, 247, 0.15);
}

.usage-count text {
  font-size: 22rpx;
  color: #5e72e4;
  font-weight: 500;
}

.dark .usage-count text {
  color: #4dabf7;
}

.description {
  font-size: 26rpx;
  color: #666666;
  line-height: 1.5;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-top: 8rpx;
  height: 78rpx;
}

.dark .description {
  color: #adb5bd;
}

/* 系统角色标记 */
.system-badge {
  position: absolute;
  top: 16rpx;
  left: 16rpx;
  background-color: rgba(94, 114, 228, 0.9);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 30rpx;
  padding: 6rpx 16rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.1);
}

.system-badge text {
  color: #ffffff;
  font-size: 20rpx;
  font-weight: 500;
}

/* 推荐角色标记 */
.recommended-badge {
  position: absolute;
  bottom: 16rpx;
  right: 16rpx;
  background-color: rgba(255, 193, 7, 0.9); /* 黄色 - 推荐 */
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 30rpx;
  padding: 6rpx 16rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.1);
}

/* 常用角色标记 - 使用不同的类名和颜色 */
.frequently-used {
  background-color: rgba(32, 201, 151, 0.9); /* 绿色 - 常用 */
}

.recommended-badge text {
  color: #ffffff;
  font-size: 20rpx;
  font-weight: 500;
}

*#*#*end*#*#*

*#*#*miniprogram\config\index.js*#*#*begin*#*#*
/**
 * 全局配置文件
 * 用于存储应用中的各种配置项，避免硬编码
 */

// 云环境配置
const cloudConfig = {
  // 云环境ID
  ENV_ID: 'cloud1-9gpfk3ie94d8630a',
  // 云函数超时时间（毫秒）
  TIMEOUT: 30000,
  // 云函数重试次数
  MAX_RETRY: 3
};

// 用户配置
const userConfig = {
  // 默认头像URL
  DEFAULT_AVATAR: 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0',
  // 默认用户名
  DEFAULT_USERNAME: '游客',
  // 默认情绪概览数据
  DEFAULT_EMOTION_DATA: {
    labels: ['疲惫', '压力', '担忧', '焦虑', '平静', '满足', '快乐'],
    values: [25, 20, 15, 10, 15, 10, 5],
    colors: [
      '#ffc107', // 疲惫
      '#f56565', // 压力
      '#4299e1', // 担忧
      '#ed64a6', // 焦虑
      '#48bb78', // 平静
      '#9f7aea', // 满足
      '#38b2ac'  // 快乐
    ],
    mainEmotion: '疲惫',
    secondEmotion: '压力'
  },
  // 默认个性分析数据
  DEFAULT_PERSONALITY_DATA: {
    labels: ['责任感', '完美主义', '同理心', '创造力', '社交性', '冒险精神', '耐心'],
    values: [85, 80, 70, 65, 50, 40, 60],
    summary: '根据你的对话内容和情绪反应，我们分析出你是一个责任感强、追求完美的人，同时也具有同理心和创造力。'
  },
  // 默认个性特质
  DEFAULT_PERSONALITY_TRAITS: [
    { name: '开朗', score: 85 },
    { name: '理性', score: 70 },
    { name: '创造力', score: 65 },
    { name: '耐心', score: 75 },
    { name: '好奇心', score: 90 }
  ],
  // 默认个性摘要
  DEFAULT_PERSONALITY_SUMMARY: '您的性格特点是开朗、乐观，善于与人沟通。在面对挑战时，您表现出较强的适应能力和解决问题的能力。您对新事物充满好奇心，喜欢探索和学习。',
  // 默认兴趣标签
  DEFAULT_INTEREST_TAGS: ['旅行', '摄影', '美食', '电影', '音乐', '阅读', '科技']
};

// 角色配置
const roleConfig = {
  // 角色分类 - 用于角色选择页面
  CATEGORIES: [
    { id: 'all', name: '全部' },
    { id: 'family', name: '家庭' },
    { id: 'friend', name: '朋友' },
    { id: 'work', name: '工作' },
    { id: 'love', name: '恋爱' },
    { id: 'other', name: '其他' }
  ],
  // 角色分类 - 用于角色编辑页面
  ROLE_CATEGORIES: [
    { id: 'emotion', name: '情感支持' },
    { id: 'psychology', name: '心理咨询' },
    { id: 'life', name: '生活伙伴' },
    { id: 'career', name: '职场导师' },
    { id: 'other', name: '其他' }
  ],
  // 关系选项
  RELATIONSHIPS: [
    { id: 'parent', name: '父母', category: 'family' },
    { id: 'child', name: '子女', category: 'family' },
    { id: 'sibling', name: '兄弟姐妹', category: 'family' },
    { id: 'friend', name: '朋友', category: 'friend' },
    { id: 'colleague', name: '同事', category: 'work' },
    { id: 'boss', name: '上司', category: 'work' },
    { id: 'subordinate', name: '下属', category: 'work' },
    { id: 'lover', name: '恋人', category: 'love' },
    { id: 'ex', name: '前任', category: 'love' },
    { id: 'other', name: '其他', category: 'other' }
  ],
  // 关系选项列表 - 用于角色编辑页面
  RELATIONSHIP_OPTIONS: [
    '父母', '子女', '兄弟姐妹', '朋友', '恋人', '配偶',
    '上级', '下级', '同事', '客户', '合作伙伴', '老师',
    '学生', '医生', '病人', '其他'
  ],
  // 关系与分类的映射 - 用于角色编辑页面
  RELATIONSHIP_TO_CATEGORY_MAP: {
    '父母': 'life',
    '子女': 'life',
    '兄弟姐妹': 'life',
    '朋友': 'life',
    '恋人': 'emotion',
    '配偶': 'emotion',
    '上级': 'career',
    '下级': 'career',
    '同事': 'career',
    '客户': 'career',
    '合作伙伴': 'career',
    '老师': 'psychology',
    '学生': 'psychology',
    '医生': 'psychology',
    '病人': 'psychology',
    '其他': 'other'
  },
  // 默认角色头像
  DEFAULT_ROLE_AVATAR: '/images/avatars/default-avatar.png'
};

// 主题配置
const themeConfig = {
  // TabBar页面列表
  TAB_BAR_PAGES: [
    'pages/home/home',
    'pages/role-select/role-select',
    'pages/user/user'
  ],
  // 情绪颜色映射
  EMOTION_COLORS: {
    // 亮色模式
    light: {
      'happy': '#4CAF50',
      'sad': '#2196F3',
      'angry': '#F44336',
      'fear': '#9C27B0',
      'surprise': '#FF9800',
      'disgust': '#795548',
      'neutral': '#607D8B'
    },
    // 暗色模式
    dark: {
      'happy': '#81C784',
      'sad': '#64B5F6',
      'angry': '#E57373',
      'fear': '#BA68C8',
      'surprise': '#FFB74D',
      'disgust': '#A1887F',
      'neutral': '#90A4AE'
    }
  }
};

// 导出配置
export default {
  cloud: cloudConfig,
  user: userConfig,
  role: roleConfig,
  theme: themeConfig
};

// 为了兼容CommonJS模块系统
module.exports = {
  cloud: cloudConfig,
  user: userConfig,
  role: roleConfig,
  theme: themeConfig
};

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-bubble\index.js*#*#*begin*#*#*
// packageChat/components/chat-bubble/index.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    message: {
      type: Object,
      value: {}
    },
    isSender: {
      type: Boolean,
      value: false
    },
    showTime: {
      type: Boolean,
      value: false
    },
    showEmotionTag: {
      type: Boolean,
      value: false
    },
    darkMode: {
      type: Boolean,
      value: false
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    formattedTime: ''
  },

  /**
   * 数据监听器
   */
  observers: {
    'message.timestamp': function(timestamp) {
      if (timestamp) {
        this.formatTime(timestamp);
      }
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    /**
     * 格式化时间
     * @param {number} timestamp 时间戳
     */
    formatTime(timestamp) {
      try {
        // 将timestamp转换为数字
        const ts = parseInt(timestamp);

        // 检查timestamp是否有效
        if (!ts || isNaN(ts)) {
          console.log('无效时间戳:', timestamp);
          this.setData({
            formattedTime: ''
          });
          return;
        }

        const date = new Date(ts);

        // 检查date是否有效
        if (date.toString() === 'Invalid Date') {
          console.log('无效日期:', timestamp);
          this.setData({
            formattedTime: ''
          });
          return;
        }

        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');

        this.setData({
          formattedTime: `${hours}:${minutes}`
        });

        console.log('格式化时间成功:', timestamp, ' -> ', `${hours}:${minutes}`);
      } catch (error) {
        console.error('格式化时间失败:', error);
        this.setData({
          formattedTime: ''
        });
      }
    },

    /**
     * 长按消息
     */
    handleLongPress() {
      wx.showActionSheet({
        itemList: ['复制', '删除'],
        success: (res) => {
          if (res.tapIndex === 0) {
            // 复制消息
            wx.setClipboardData({
              data: this.properties.message.content,
              success: () => {
                wx.showToast({
                  title: '复制成功',
                  icon: 'success'
                });
              }
            });
          } else if (res.tapIndex === 1) {
            // 删除消息
            this.triggerEvent('delete', { messageId: this.properties.message._id });
          }
        }
      });
    }
  }
})

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-bubble\index.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-bubble\index.wxml*#*#*begin*#*#*
<!-- packageChat/components/chat-bubble/index.wxml -->
<view class="chat-bubble-container {{isSender ? 'sender' : 'receiver'}} {{darkMode ? 'dark' : ''}}">
  <!-- 时间显示 - 根据消息的showTimestamp属性决定是否显示 -->
  <view class="message-time" wx:if="{{formattedTime && (message.showTimestamp || showTime)}}">{{formattedTime}}</view>

  <!-- 消息气泡 -->
  <view class="chat-bubble {{isSender ? 'sender-bubble' : 'receiver-bubble'}}" bindlongpress="handleLongPress">
    <text class="message-content" user-select="true">{{message.content}}</text>
  </view>

  <!-- 情绪标签容器 -->
  <view class="emotion-tag-container" wx:if="{{showEmotionTag && message.emotion_type}}">
    <!-- 情绪标签 -->
    <view class="emotion-tag">
      <text class="emotion-text">检测结果： {{message.emotion_type}}</text>
    </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-bubble\index.wxss*#*#*begin*#*#*
/* packageChat/components/chat-bubble/index.wxss */
.chat-bubble-container {
  margin: 24rpx 0; /* 进一步增加上下边距 */
  display: flex;
  flex-direction: column;
  width: 100%; /* 设置宽度为100% */
}

.sender {
  align-self: flex-end;
  align-items: flex-end;
  width: 100%; /* 设置宽度为100% */
}

.receiver {
  align-self: flex-start;
  align-items: flex-start;
  width: 100%; /* 设置宽度为100% */
}

.message-time {
  font-size: 24rpx;
  color: #666666;
  text-align: center;
  background-color: #f0f0f0;
  padding: 4rpx 16rpx;
  border-radius: 10rpx;
  display: inline-block;
  align-self: center;
  margin-top: 10rpx;
  margin-bottom: 6rpx;
  min-width: 80rpx;
  font-weight: 400;
}

/* 暗夜模式 - 消息时间 */
.dark .message-time {
  color: #f8f9fa;
  background-color: #343a40;
}

.chat-bubble {
  padding: 20rpx 24rpx; /* 增加内边距，使文本与气泡边缘有更好的间距 */
  border-radius: 20rpx; /* 增加圆角半径 */
  word-wrap: break-word;
  max-width: 100%;
  box-sizing: border-box;
  display: inline-block; /* 使气泡宽度自适应内容 */
  min-width: 80rpx; /* 设置最小宽度 */
  width: auto; /* 改回自适应宽度，避免气泡过宽 */
}

.sender-bubble {
  background-color: #95EC69; /* 参考微信绿色气泡 */
  color: #000000; /* 黑色文字 */
  border-bottom-right-radius: 8rpx; /* 增加右下角的圆角半径 */
  margin-left: auto; /* 将发送者气泡推到右边 */
  max-width: 85%; /* 调整最大宽度，使气泡不要太宽 */
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.1); /* 添加轻微阴影 */
}

/* 暗夜模式 - 发送者气泡 */
.dark .sender-bubble {
  background-color: #4d7a3c; /* 暗色绿色 */
  color: #f8f9fa; /* 浅色文字 */
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.2); /* 增强阴影 */
}

.receiver-bubble {
  background-color: #ffffff; /* 参考微信白色气泡 */
  color: #000000; /* 黑色文字 */
  border-bottom-left-radius: 8rpx; /* 增加左下角的圆角半径 */
  border: 1rpx solid #e2e2e2; /* 添加边框 */
  margin-right: auto; /* 将接收者气泡推到左边 */
  max-width: 85%; /* 调整最大宽度，使气泡不要太宽 */
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.05); /* 添加轻微阴影 */
}

/* 暗夜模式 - 接收者气泡 */
.dark .receiver-bubble {
  background-color: #2c3034; /* 暗色背景 */
  color: #f8f9fa; /* 浅色文字 */
  border: 1rpx solid #495057; /* 暗色边框 */
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.2); /* 增强阴影 */
}

.message-content {
  font-size: 34rpx; /* 进一步增大字体大小 */
  line-height: 48rpx; /* 增加行高 */
  word-break: break-word; /* 使用break-word而非break-all，避免单词被强制断开 */
  white-space: pre-wrap; /* 保留空白符并换行 */
  text-align: left; /* 文本左对齐 */
  width: 100%; /* 确保文本占据全宽 */
  letter-spacing: 0.5rpx; /* 增加字间距 */
}

/* 情绪标签容器 */
.emotion-tag-container {
  display: flex;
  justify-content: center; /* 水平居中 */
  width: 100%;
  margin-top: 10rpx;
  margin-bottom: 6rpx;
}

/* 情绪标签 */
.emotion-tag {
  background-color: rgba(94, 114, 228, 0.1);
  padding: 8rpx 20rpx;
  border-radius: 100rpx;
  display: inline-block;
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.05);
  width: fit-content; /* 根据内容自适应宽度 */
  border: 1rpx solid rgba(94, 114, 228, 0.2); /* 添加边框 */
}

/* 暗夜模式 - 情绪标签 */
.dark .emotion-tag {
  background-color: rgba(94, 114, 228, 0.2);
  box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.2);
  border: 1rpx solid rgba(94, 114, 228, 0.3);
}

.emotion-text {
  font-size: 24rpx;
  color: #5e72e4;
  font-weight: 500;
  line-height: 1.2;
  text-align: center;
  letter-spacing: 0.5rpx; /* 增加字间距 */
}

/* 暗夜模式 - 情绪文本 */
.dark .emotion-text {
  color: #8da2fb; /* 更亮的蓝色 */
}

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-input\index.js*#*#*begin*#*#*
// packageChat/components/chat-input/index.js
// 导入语音服务
const voiceService = require('../../../services/voiceService');

Component({
  /**
   * 组件的属性列表
   */
  properties: {
    placeholder: {
      type: String,
      value: '输入消息...'
    },
    disabled: {
      type: Boolean,
      value: false
    },
    darkMode: {
      type: Boolean,
      value: false
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    inputValue: '',
    isRecording: false,
    recordingTime: 0,
    recordingTimer: null,
    isRecognizing: false,
    recognitionText: '',
    showRecognitionResult: false,
    isVoiceMode: false,  // 是否为语音输入模式
    isCancelling: false, // 是否正在取消录音
    waveSizes: [20, 30, 40, 30, 40, 30, 20] // 波形高度数组
  },

  /**
   * 生命周期函数
   */
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
      if (this.data.recordingTimer) {
        clearInterval(this.data.recordingTimer);
      }

      // 清理波形动画定时器
      if (this.waveAnimationTimer) {
        clearInterval(this.waveAnimationTimer);
      }

      // 确保语音识别已停止
      if (this.data.isRecording || this.data.isRecognizing) {
        voiceService.stopRecognition();
      }
    }
  },

  /**
   * 组件所在页面的生命周期函数
   */
  pageLifetimes: {
    show: function() {
      // 页面被显示时执行
    },
    hide: function() {
      // 页面被隐藏时执行
    },
    resize: function(size) {
      // 页面尺寸变化时执行
      console.log('页面尺寸变化:', size);
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    /**
     * 输入框内容变化
     * @param {Object} e 事件对象
     */
    input: function(e) {
      this.setData({
        inputValue: e.detail.value
      });
    },

    /**
     * 发送消息
     */
    send: function() {
      const { inputValue } = this.data;
      if (!inputValue.trim()) return;

      this.triggerEvent('send', { content: inputValue });
      this.setData({
        inputValue: ''
      });
    },

    /**
     * 确认发送（回车键）
     */
    confirm: function() {
      this.send();
    },

    /**
     * 切换输入模式（文本/语音）
     */
    switchInputMode: function() {
      this.setData({
        isVoiceMode: !this.data.isVoiceMode
      });
    },

    /**
     * 开始录音 - 添加按钮位置记录，用于滑出区域检测
     */
    recordStart: function(e) {
      console.log('触发录音开始');

      // 重置起始触摸位置
      this.startY = null;
      this.startX = null;

      // 记录起始触摸位置，用于判断上滑取消和滑出区域取消
      if (e && e.touches && e.touches.length > 0) {
        const touch = e.touches[0];
        this.startY = touch.clientY;
        this.startX = touch.clientX;
        console.log('记录起始位置 - X:', this.startX, 'Y:', this.startY);

        // 记录按钮位置和尺寸，用于判断是否滑出按钮区域
        this._recordButtonRect();
      } else {
        console.warn('无法获取起始触摸位置');
      }

      // 显示用户授权请求
      wx.authorize({
        scope: 'scope.record',
        success: () => {
          console.log('录音权限授权成功');

          // 重置取消状态
          this.setData({
            isCancelling: false
          });

          // 直接开始语音识别
          this._startVoiceRecognition();
        },
        fail: (err) => {
          console.error('获取录音权限失败', err);
          wx.showToast({
            title: '请授权录音权限',
            icon: 'none'
          });
        }
      });
    },

    /**
     * 记录按钮位置和尺寸
     * @private
     */
    _recordButtonRect: function() {
      // 获取按钮元素
      const query = wx.createSelectorQuery().in(this);
      query.select('#voiceButton').boundingClientRect();
      query.exec((res) => {
        if (res && res[0]) {
          // 记录按钮的位置和尺寸
          this.buttonRect = res[0];
          console.log('按钮位置和尺寸:', this.buttonRect);
        } else {
          console.warn('无法获取按钮位置和尺寸');
        }
      });
    },

    /**
     * 开始波形动画
     * @private
     */
    _startWaveAnimation: function() {
      // 每200ms更新一次波形高度
      this.waveAnimationTimer = setInterval(() => {
        // 随机生成波形高度
        const newWaveSizes = this.data.waveSizes.map(() => {
          return Math.floor(Math.random() * 30) + 20; // 20-50之间的随机数
        });

        this.setData({
          waveSizes: newWaveSizes
        });
      }, 200);
    },

    /**
     * 开始语音识别
     * @private
     */
    _startVoiceRecognition: function() {
      console.log('开始语音识别函数被调用');

      // 立即开始波形动画
      this._startWaveAnimation();

      // 更新UI状态
      this.setData({
        isRecording: true,
        recordingTime: 0,
        isRecognizing: true,
        recognitionText: '',
        showRecognitionResult: false
      });

      // 计时器
      this.data.recordingTimer = setInterval(() => {
        this.setData({
          recordingTime: this.data.recordingTime + 1
        });
      }, 1000);

      // 开始语音识别
      try {
        console.log('调用语音服务开始识别');
        voiceService.startRecognition(
          // 识别结果回调 - 不再更新输入框
          (text) => {
            console.log('收到识别结果:', text);
            // 只更新识别文本，不更新输入框
            this.setData({
              recognitionText: text
            });
          },
          // 错误回调
          (error) => {
            console.error('语音识别错误', error);
            wx.showToast({
              title: '语音识别失败',
              icon: 'none'
            });
            this._resetRecordingState();
          },
          // 识别完成回调 - 不再更新输入框
          (finalText) => {
            console.log('收到最终识别结果:', finalText);
            if (finalText) {
              // 不再更新输入框，只保存识别结果用于发送
              this.finalRecognitionResult = finalText;
              this.setData({
                // 不再显示确认框
                showRecognitionResult: false,
                isRecognizing: false
              });
            } else {
              this._resetRecordingState();
            }
          }
        );
      } catch (err) {
        console.error('启动语音识别失败', err);
        wx.showToast({
          title: '启动语音识别失败',
          icon: 'none'
        });
        this._resetRecordingState();
      }
    },

    /**
     * 结束录音 - 优化结束逻辑，处理滑出按钮区域的情况
     */
    recordEnd: function() {
      // 如果不在录音状态，直接返回
      if (!this.data.isRecording) {
        console.log('不在录音状态，忽略结束录音');
        return;
      }

      // 停止波形动画
      if (this.waveAnimationTimer) {
        clearInterval(this.waveAnimationTimer);
      }

      clearInterval(this.data.recordingTimer);

      // 检查是否在按钮区域外松开
      if (this.isOutsideButton) {
        console.log('在按钮区域外松开，执行取消');
        this._cancelRecording();
        return;
      }

      // 再次检查取消状态，确保最新状态
      if (this.data.isCancelling) {
        console.log('取消录音状态，执行取消');
        this._cancelRecording();
        return;
      }

      // 如果录音时间太短（小于0.5秒），可能是误触
      if (this.data.recordingTime === 0) {
        wx.showToast({
          title: '说话时间太短',
          icon: 'none'
        });
        this._resetRecordingState();
        return;
      }

      // 显示加载中，提供视觉反馈
      wx.showLoading({
        title: '识别中...',
        mask: true
      });

      // 设置状态为识别中，但不再录音
      this.setData({
        isRecording: false,
        isRecognizing: true,
        isCancelling: false // 确保取消状态被重置
      });

      // 震动反馈
      wx.vibrateShort({
        type: 'medium'
      });

      // 保存当前输入值，用于比较是否有新的识别结果
      const currentInputValue = this.data.inputValue;
      console.log('当前识别文本:', currentInputValue);

      // 停止语音识别，但增加更长的延迟
      // 这样可以确保捕获完整的语音内容，特别是开头的部分
      setTimeout(() => {
        // 再次检查是否已经取消，避免重复处理
        if (this.data.isCancelling) {
          console.log('延迟期间检测到取消状态，中止识别');
          wx.hideLoading();
          return;
        }

        voiceService.stopRecognition();

        // 进一步延长等待时间，确保能够获取完整的识别结果
        setTimeout(() => {
          wx.hideLoading();

          // 再次检查是否已经取消，避免重复处理
          if (this.data.isCancelling) {
            console.log('等待识别结果期间检测到取消状态，中止发送');
            return;
          }

          // 使用保存的最终识别结果，而不是输入框的值
          const finalResult = this.finalRecognitionResult || this.data.recognitionText;
          console.log('准备发送的识别文本:', finalResult);

          if (finalResult && finalResult.trim()) {
            // 如果有识别结果，直接发送
            this.triggerEvent('sendVoice', { content: finalResult });
            // 重置状态，确保输入框不会显示识别结果
            this._resetRecordingState();
            // 清除保存的最终识别结果
            this.finalRecognitionResult = null;
          } else {
            this._resetRecordingState();
            // 清除保存的最终识别结果
            this.finalRecognitionResult = null;
            wx.showToast({
              title: '未能识别语音',
              icon: 'none'
            });
          }
        }, 1000); // 增加等待时间到1秒，确保获取完整结果
      }, 200); // 先延迟200ms再停止录音，给系统更多时间处理
    },

    /**
     * 取消录音 - 添加滑出区域检测
     */
    recordCancel: function(e) {
      // 确保事件对象存在
      if (!e) {
        console.error('recordCancel: 事件对象为空');
        return;
      }

      // 如果不在录音状态，直接返回
      if (!this.data.isRecording) {
        console.log('不在录音状态，忽略取消');
        return;
      }

      // 获取取消阈值
      const cancelThreshold = e.currentTarget.dataset.cancelThreshold || 30;

      // 检查触摸点
      if (e.touches && e.touches.length > 0) {
        const touch = e.touches[0];
        const currentX = touch.clientX;
        const currentY = touch.clientY;

        // 检查是否滑出按钮区域
        if (this.buttonRect) {
          const isOutsideButton =
            currentX < this.buttonRect.left - 10 ||
            currentX > this.buttonRect.right + 10 ||
            currentY < this.buttonRect.top - 10 ||
            currentY > this.buttonRect.bottom + 10;

          if (isOutsideButton) {
            console.log('检测到滑出按钮区域，进入取消状态');

            // 如果滑出按钮区域，进入取消状态
            if (!this.data.isCancelling) {
              this.setData({
                isCancelling: true
              });

              // 震动反馈
              wx.vibrateShort({
                type: 'medium'
              });

              // 记录滑出状态，用于在松开时判断
              this.isOutsideButton = true;
            }

            // 继续处理，不要return，让后续的上滑检测也能执行
          } else {
            // 如果不在按钮区域外，重置滑出状态
            this.isOutsideButton = false;
          }
        }

        // 如果没有滑出按钮区域，检查上滑取消
        // 如果没有记录起始位置，或者起始位置不合理，重新记录
        if (!this.startY || this.startY <= 0 || this.startY < currentY) {
          // 不要立即使用当前位置作为起始位置，而是使用稍微高一点的位置
          this.startY = currentY + cancelThreshold;
          console.log('重新记录起始位置Y:', this.startY, '(当前Y + 阈值)');
          return;
        }

        // 计算上滑距离
        const distance = this.startY - currentY;

        console.log('触摸移动 - 起始Y:', this.startY, '当前Y:', currentY, '上滑距离:', distance, '阈值:', cancelThreshold);

        // 判断是否达到上滑取消阈值
        const shouldCancel = distance > cancelThreshold;

        // 如果状态需要改变，才更新
        if (shouldCancel !== this.data.isCancelling) {
          console.log(shouldCancel ? '上滑达到阈值，进入取消状态' : '退出取消状态');

          this.setData({
            isCancelling: shouldCancel
          });

          // 进入取消状态时震动反馈
          if (shouldCancel) {
            wx.vibrateShort({
              type: 'medium'
            });
          }
        }
      } else if (e.type === 'touchcancel') {
        // 触摸被系统取消（如来电等），也视为取消录音
        console.log('触摸被系统取消，取消录音');
        this._cancelRecording();
      }
    },

    /**
     * 取消录音处理 - 优化取消逻辑，解决录音错误问题
     * @private
     */
    _cancelRecording: function() {
      console.log('执行取消录音处理');

      // 如果已经不在录音状态，直接返回
      if (!this.data.isRecording) {
        console.log('已经不在录音状态，忽略取消操作');
        return;
      }

      // 停止波形动画
      if (this.waveAnimationTimer) {
        clearInterval(this.waveAnimationTimer);
      }

      clearInterval(this.data.recordingTimer);

      // 先更新UI状态，避免用户看到延迟
      this.setData({
        isCancelling: true,
        isRecording: false, // 立即更新录音状态，避免重复操作
        // 立即清除输入框内容，确保不会显示语音识别结果
        inputValue: ''
      });

      // 清除保存的最终识别结果
      this.finalRecognitionResult = null;

      // 重置滑出按钮区域状态
      this.isOutsideButton = false;

      // 停止语音识别服务
      try {
        // 使用语音服务停止录音，而不是直接操作录音管理器
        // 这样可以确保状态一致性
        voiceService.stopRecognition();

        // 震动反馈
        wx.vibrateShort({
          type: 'light'
        });

        // 显示取消提示
        wx.showToast({
          title: '已取消',
          icon: 'none'
        });

        // 延迟一下再完全重置状态，确保录音确实停止
        setTimeout(() => {
          // 重置所有状态
          this._resetRecordingState();
        }, 300);
      } catch (e) {
        console.error('停止录音失败', e);
        // 即使出错也要重置状态
        this._resetRecordingState();
      }
    },

    /**
     * 重置录音状态 - 确保清除输入框内容
     * @private
     */
    _resetRecordingState: function() {
      // 清除所有录音相关状态，包括输入框内容
      this.setData({
        isRecording: false,
        recordingTime: 0,
        isRecognizing: false,
        recognitionText: '',
        showRecognitionResult: false,
        isCancelling: false,
        // 确保输入框内容不会显示语音识别结果
        inputValue: ''
      });

      // 重置起始触摸位置
      this.startY = 0;

      // 清除保存的最终识别结果
      this.finalRecognitionResult = null;
    },

    /**
     * 输入框获取焦点
     */
    onFocus: function(e) {
      // 触发父组件的输入框获取焦点事件
      this.triggerEvent('focus', e.detail);
    },

    /**
     * 输入框失去焦点
     */
    onBlur: function(e) {
      // 触发父组件的输入框失去焦点事件
      this.triggerEvent('blur', e.detail);
    }
  }
})

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-input\index.json*#*#*begin*#*#*
{
  "component": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-input\index.wxml*#*#*begin*#*#*
<!-- packageChat/components/chat-input/index.wxml -->
<view class="chat-input-container {{darkMode ? 'dark' : ''}}">
  <!-- 录音状态 - 添加点击停止录音功能 -->
  <view class="recording-container" wx:if="{{isRecording}}" catchtap="recordEnd">
    <!-- 录音内容 -->
    <view class="recording-content {{isCancelling ? 'hidden' : ''}}">
      <view class="recording-hint">
        <view class="recording-wave">
          <view class="wave-item" wx:for="{{[1,2,3,4,5,6,7]}}" wx:key="index" style="height: {{waveSizes[index]}}rpx;"></view>
        </view>
        <text class="recording-time">{{recordingTime}}s</text>
      </view>
      <text class="recording-tip">{{isCancelling ? '松开手指，取消发送' : '松开发送，上滑取消，点击界面停止'}}</text>
    </view>

    <!-- 取消区域 - 增强视觉效果 -->
    <view class="cancel-area" wx:if="{{isCancelling}}">
      <image class="cancel-icon" src="/images/icons/cancel.png" mode="aspectFit"></image>
      <text class="cancel-text">松开手指，取消发送</text>
    </view>
  </view>

  <!-- 语音识别中状态 - 不再显示确认框，直接发送 -->
  <view class="recognition-processing" wx:elif="{{isRecognizing && !isRecording}}">
    <view class="recognition-loading">
      <view class="loading-dot"></view>
      <view class="loading-dot"></view>
      <view class="loading-dot"></view>
    </view>
    <text class="recognition-status">正在识别...</text>
  </view>

  <!-- 输入区域 -->
  <view class="input-area" wx:else>
    <!-- 语音/键盘切换按钮 -->
    <view class="voice-button" bindtap="switchInputMode">
      <image class="voice-icon" src="{{isVoiceMode ? '/images/icons/keyboard.png' : '/images/icons/voice.png'}}" mode="aspectFit"></image>
    </view>

    <!-- 文本输入模式 -->
    <block wx:if="{{!isVoiceMode}}">
      <input class="text-input"
             type="text"
             value="{{inputValue}}"
             placeholder="{{placeholder}}"
             disabled="{{disabled}}"
             bindinput="input"
             bindfocus="onFocus"
             bindblur="onBlur"
             adjust-position="{{false}}"
             cursor-spacing="20"
             confirm-type="send"
             bindconfirm="confirm"></input>
    </block>

    <!-- 语音输入模式 -->
    <block wx:else>
      <view class="voice-record-button"
            id="voiceButton"
            bindtouchstart="recordStart"
            bindtouchend="recordEnd"
            bindtouchmove="recordCancel"
            bindtouchcancel="recordCancel"
            data-cancel-threshold="30">
        <text>{{isRecording ? (isCancelling ? '松开手指，取消发送' : '松开发送，滑出取消') : '按住 说话'}}</text>
      </view>
    </block>

    <!-- 发送按钮 -->
    <view class="send-button {{inputValue ? 'active' : ''}}" bindtap="send">
      <image class="send-icon" src="/images/icons/send.png" mode="aspectFit"></image>
    </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\packageChat\components\chat-input\index.wxss*#*#*begin*#*#*
/* packageChat/components/chat-input/index.wxss */
.chat-input-container {
  width: 100%;
  background-color: #ffffff;
  border-top: 0.5rpx solid #e5e5ea; /* 更细的边框，符合iOS风格 */
  padding: 16rpx 20rpx;
  box-sizing: border-box;
  /* 适配底部安全区域，但限制最大值 */
  padding-bottom: calc(16rpx + min(env(safe-area-inset-bottom), 20rpx));
  box-shadow: 0 -1rpx 3rpx rgba(0, 0, 0, 0.02); /* 添加轻微阴影 */
}

/* 暗夜模式 - 输入容器 */
.dark.chat-input-container {
  background-color: #212529;
  border-top: 0.5rpx solid #343a40;
  box-shadow: 0 -1rpx 3rpx rgba(0, 0, 0, 0.1);
}

.input-area {
  display: flex;
  align-items: center;
}

.voice-button {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  justify-content: center;
  align-items: center;
}

.voice-icon {
  width: 40rpx;
  height: 40rpx;
}

.text-input {
  flex: 1;
  height: 72rpx;
  background-color: #f5f5f7; /* 更浅的背景色，符合iOS风格 */
  border-radius: 36rpx;
  padding: 0 24rpx;
  margin: 0 20rpx;
  font-size: 28rpx;
  color: #333333;
  box-shadow: 0 1rpx 2rpx rgba(0, 0, 0, 0.03) inset; /* 内阴影增强层次感 */
}

/* 语音录音按钮 - 添加滑出区域提示 */
.voice-record-button {
  flex: 1;
  height: 72rpx;
  background-color: #f5f5f7;
  border-radius: 36rpx;
  margin: 0 20rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 28rpx;
  color: #666666;
  box-shadow: 0 1rpx 2rpx rgba(0, 0, 0, 0.03) inset;
  transition: all 0.2s ease;
  position: relative;
  overflow: visible; /* 改为visible，让提示箭头可见 */
}

.voice-record-button:active {
  background-color: #e0e0e0;
}

/* 上滑取消提示 */
.voice-record-button::before {
  content: "";
  position: absolute;
  top: -10rpx;
  left: 50%;
  transform: translateX(-50%);
  width: 30rpx;
  height: 30rpx;
  background-color: rgba(74, 108, 247, 0.2);
  border-radius: 50%;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.voice-record-button:active::before {
  opacity: 1;
  animation: upArrow 1.5s infinite;
}

/* 滑出区域提示 - 四个方向的箭头 */
.voice-record-button::after {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  border: 2rpx dashed transparent;
  border-radius: 36rpx;
  box-sizing: border-box;
  opacity: 0;
  transition: all 0.3s ease;
}

.voice-record-button:active::after {
  border-color: rgba(255, 77, 79, 0.5);
  box-shadow: 0 0 0 4rpx rgba(255, 77, 79, 0.1);
  opacity: 1;
  animation: borderPulse 1.5s infinite;
}

@keyframes borderPulse {
  0%, 100% {
    border-color: rgba(255, 77, 79, 0.5);
    box-shadow: 0 0 0 4rpx rgba(255, 77, 79, 0.1);
  }
  50% {
    border-color: rgba(255, 77, 79, 0.8);
    box-shadow: 0 0 0 6rpx rgba(255, 77, 79, 0.2);
  }
}

@keyframes upArrow {
  0% {
    transform: translateX(-50%) translateY(0);
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateX(-50%) translateY(-20rpx);
    opacity: 0;
  }
}

/* 暗夜模式 - 输入框 */
.dark .text-input {
  background-color: #343a40;
  color: #f8f9fa;
  box-shadow: 0 1rpx 2rpx rgba(0, 0, 0, 0.1) inset;
}

/* 暗夜模式 - 语音录音按钮 */
.dark .voice-record-button {
  background-color: #343a40;
  color: #adb5bd;
  box-shadow: 0 1rpx 2rpx rgba(0, 0, 0, 0.1) inset;
}

.dark .voice-record-button:active {
  background-color: #212529;
}

.send-button {
  width: 64rpx;
  height: 64rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0.5;
  transition: all 0.3s ease;
  background-color: #f5f5f7; /* 与输入框背景色一致 */
  border-radius: 32rpx; /* 圆形按钮 */
}

/* 暗夜模式 - 发送按钮 */
.dark .send-button {
  background-color: #343a40;
}

.send-button.active {
  opacity: 1;
  background-color: #4a6cf7; /* 激活时使用主色调 */
}

.send-icon {
  width: 36rpx;
  height: 36rpx;
  color: #ffffff; /* 激活时图标为白色 */
}

.recording-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 200rpx;
  position: relative;
  cursor: pointer;
  transition: all 0.2s ease;
}

.recording-container:active {
  opacity: 0.9;
  transform: scale(0.98);
}

.recording-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  transition: opacity 0.2s ease;
}

.recording-content.hidden {
  opacity: 0;
}

.recording-hint {
  display: flex;
  align-items: center;
  margin-bottom: 20rpx;
}

.recording-icon {
  width: 20rpx;
  height: 20rpx;
  background-color: #ff4d4f;
  border-radius: 50%;
  margin-right: 10rpx;
  animation: pulse 1s infinite;
}

.recording-time {
  font-size: 28rpx;
  color: #333333;
}

/* 暗夜模式 - 录音时间 */
.dark .recording-time {
  color: #f8f9fa;
}

.recording-tip {
  font-size: 24rpx;
  color: #999999;
  margin-bottom: 20rpx;
}

/* 暗夜模式 - 录音提示 */
.dark .recording-tip {
  color: #adb5bd;
}



/* 语音识别中状态 */
.recognition-processing {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 120rpx;
}

.recognition-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 10rpx;
}

.loading-dot {
  width: 12rpx;
  height: 12rpx;
  border-radius: 50%;
  background-color: #4a6cf7;
  margin: 0 6rpx;
  animation: loadingDot 1.4s infinite ease-in-out both;
}

.loading-dot:nth-child(1) {
  animation-delay: -0.32s;
}

.loading-dot:nth-child(2) {
  animation-delay: -0.16s;
}

.recognition-status {
  font-size: 24rpx;
  color: #666666;
}

.dark .loading-dot {
  background-color: #6c8cff;
}

.dark .recognition-status {
  color: #adb5bd;
}

@keyframes loadingDot {
  0%, 80%, 100% {
    transform: scale(0);
  }
  40% {
    transform: scale(1.0);
  }
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.7;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes waveAnimation {
  0%, 100% {
    height: 20rpx;
  }
  50% {
    height: 50rpx;
  }
}

/* 波形样式 */
.recording-wave {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 60rpx;
  width: 200rpx;
  margin-right: 20rpx;
  background-color: rgba(74, 108, 247, 0.1);
  border-radius: 30rpx;
  padding: 0 10rpx;
}

.wave-item {
  width: 6rpx;
  background-color: #4a6cf7;
  border-radius: 3rpx;
  margin: 0 4rpx;
  animation: waveAnimation 0.8s infinite ease-in-out;
}

.wave-item:nth-child(2) {
  animation-delay: 0.1s;
}

.wave-item:nth-child(3) {
  animation-delay: 0.2s;
}

.wave-item:nth-child(4) {
  animation-delay: 0.3s;
}

.wave-item:nth-child(5) {
  animation-delay: 0.2s;
}

.wave-item:nth-child(6) {
  animation-delay: 0.1s;
}

.wave-item:nth-child(7) {
  animation-delay: 0s;
}

.dark .wave-item {
  background-color: #6c8cff;
}

.dark .recording-wave {
  background-color: rgba(108, 140, 255, 0.1);
}

/* 取消区域 - 增强视觉效果 */
.cancel-area {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(255, 77, 79, 0.25);
  border: 4rpx solid rgba(255, 77, 79, 0.7);
  border-radius: 12rpx;
  z-index: 100; /* 提高z-index确保显示在最上层 */
  animation: cancelPulse 0.8s infinite;
  box-shadow: 0 0 20rpx rgba(255, 77, 79, 0.4);
}

@keyframes cancelPulse {
  0%, 100% {
    background-color: rgba(255, 77, 79, 0.25);
    transform: scale(1);
  }
  50% {
    background-color: rgba(255, 77, 79, 0.4);
    transform: scale(1.02);
  }
}

.cancel-icon {
  width: 70rpx;
  height: 70rpx;
  margin-bottom: 20rpx;
  animation: cancelIconShake 0.8s infinite;
}

@keyframes cancelIconShake {
  0%, 100% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-5rpx);
  }
  75% {
    transform: translateX(5rpx);
  }
}

.cancel-text {
  font-size: 32rpx;
  color: #ff4d4f;
  font-weight: 600;
  text-shadow: 0 1rpx 2rpx rgba(0, 0, 0, 0.1);
}

*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\chat\chat.js*#*#*begin*#*#*
// packageChat/pages/chat/chat.js
// 导入情感分析服务
const emotionService = require('../../../services/emotionService');
// 导入聊天缓存服务
const chatCacheService = require('../../../services/chatCacheService');
// 导入关键词服务
const keywordService = require('../../../services/keywordService');
// 导入用户兴趣服务
const userInterestsService = require('../../../services/userInterestsService');
// 导入模型服务
const modelService = require('../../../services/modelService');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

Page({
  /**
   * 页面的初始数据
   */
  data: {
    roleId: '',
    role: null,
    chatId: '',
    messages: [],
    loading: true,
    sending: false,
    loadingHistory: false,
    hasMoreHistory: true,
    showEmotionAnalysis: false,
    emotionAnalysis: null,
    statusBarHeight: 0,
    navBarHeight: 44,
    menuButtonInfo: null,
    systemInfo: null,
    refreshing: false,
    currentPage: 1,
    fromCache: false,
    pendingAiMessages: null,    // 待显示的AI消息数组
    currentAiMessageIndex: 0,   // 当前显示的AI消息索引
    darkMode: false,            // 暗夜模式状态
    keyboardHeight: 0,          // 键盘高度
    isKeyboardShow: false,      // 键盘是否显示
    manualScroll: false, // 是否手动滚动
    lastScrollTop: 0, // 上次滚动位置
    openId: '', // 用户ID
    selectedModelType: '', // 当前选择的模型类型
    selectedModel: '', // 当前选择的模型
    // 默认情绪分析数据结构
    defaultEmotionData: {
      primary_emotion: 'calm',
      secondary_emotions: [],
      intensity: 0.5,
      valence: 0,
      arousal: 0.5,
      trend: 'stable',
      attention_level: 'medium',
      topic_keywords: [],
      emotion_triggers: [],
      suggestions: ['继续保持对话'],
      summary: '您的情绪状态相对平静',
      radar_dimensions: {
        trust: 0.5,
        openness: 0.5,
        resistance: 0.5,
        stress: 0.5,
        control: 0.5
      }
    }
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    // 获取状态栏高度和胶囊按钮位置
    this.getSystemInfo();

    // 加载图片资源
    this.loadImageResources();

    // 获取用户画像数据
    this.getUserPerception();

    // 获取用户ID
    this.getUserId();

    // 获取全局暗夜模式设置
    const app = getApp();
    if (app && app.globalData) {
      this.setData({
        darkMode: app.globalData.darkMode || false
      });
    }

    // 获取当前选择的模型类型和模型
    const selectedModelType = modelService.getSelectedModelType();
    const selectedModel = modelService.getSelectedModel(selectedModelType);
    this.setData({
      selectedModelType,
      selectedModel
    });

    // 监听键盘高度变化
    this.watchKeyboard();

    // 启动定期记忆提取定时器（每5分钟提取一次）
    this.startMemoryExtractionTimer();

    if (isDev) {
      console.log('页面加载参数:', options);
    }
    if (options.roleId) {
      this.setData({
        roleId: options.roleId
      });

      // 先加载角色信息
      this.loadRoleInfo(options.roleId).then(roleInfo => {
        if (!roleInfo) {
          console.error('加载角色信息失败');
          return;
        }

        // 检查是否有与该角色的历史聊天记录
        wx.cloud.callFunction({
          name: 'chat',
          data: {
            action: 'checkChatExists',
            roleId: options.roleId
          }
        }).then(result => {
          if (result && result.result && result.result.exists) {
            // 存在历史聊天，先尝试从缓存加载
            const chatId = result.result.chatId;
            if (isDev) {
              console.log('存在历史聊天:', chatId);
            }

            // 尝试从缓存加载最新消息
            const cachedMessages = chatCacheService.loadMessagesFromCache(chatId || `temp_${options.roleId}`);

            if (cachedMessages && cachedMessages.length > 0) {
              if (isDev) {
                console.log('从缓存加载了最新消息:', cachedMessages.length);
              }
              this.setData({
                chatId,
                messages: cachedMessages,
                loading: false,
                fromCache: true
              });
              this.scrollToBottom();

              // 后台静默加载最新消息，确保数据是最新的
              this.loadChatHistory(true);
            } else {
              // 缓存中没有数据，但存在历史聊天，从服务器加载
              this.setData({ chatId });
              this.loadChatHistory();
            }
          } else {
            // 不存在历史聊天，创建新的聊天
            if (isDev) {
              console.log('不存在历史聊天，创建新的聊天');
            }
            this.loadChatHistory();
          }
        }).catch(error => {
          console.error('检查聊天存在失败:', error.message || error);
          // 出错时仍然尝试加载聊天历史
          this.loadChatHistory();
        });
      });
    } else {
      wx.showToast({
        title: '参数错误',
        icon: 'error'
      });
      setTimeout(() => {
        wx.navigateBack();
      }, 1500);
    }
  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload() {
    // 保存聊天记录到云端
    this.saveChatHistory();

    // 提取对话记忆
    this.extractChatMemories();

    // 保存聊天记录到本地缓存
    if (this.data.chatId && this.data.messages.length > 0) {
      chatCacheService.saveMessagesToCache(
        this.data.chatId,
        this.data.messages,
        true,
        null,
        this.data.role
      );
      if (isDev) {
        console.log('已保存聊天记录到本地缓存');
      }
    }

    // 移除键盘监听
    this.unwatchKeyboard();

    // 清除定时提取记忆的定时器
    if (this.memoryExtractionTimer) {
      clearInterval(this.memoryExtractionTimer);
      this.memoryExtractionTimer = null;
    }
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {
    // 如果页面已经加载完成，滚动到底部
    if (!this.data.loading && this.data.messages.length > 0) {
      this.scrollToBottom();
    }

    // 检查暗夜模式变化
    const app = getApp();
    if (app && app.globalData && this.data.darkMode !== app.globalData.darkMode) {
      this.setData({
        darkMode: app.globalData.darkMode
      });
    }
  },

  /**
   * 加载角色信息
   * @param {string} roleId 角色ID，可选，如果不提供则使用this.data.roleId
   * @returns {Promise} 返回一个Promise
   */
  async loadRoleInfo(roleId) {
    try {
      const targetRoleId = roleId || this.data.roleId;

      if (!targetRoleId) {
        throw new Error('角色ID不能为空');
      }

      // 使用新的roles云函数
      const result = await wx.cloud.callFunction({
        name: 'roles',
        data: {
          action: 'getRoleDetail',
          roleId: targetRoleId
        }
      });

      if (result && result.result && result.result.success && result.result.role) {
        this.setData({
          role: result.result.role,
          roleId: targetRoleId
        });

        // 更新角色系统提示，包含用户画像信息
        // 由于现在updateRoleSystemPrompt是异步函数，需要等待它完成
        await this.updateRoleSystemPrompt();

        return result.result.role;
      } else {
        throw new Error('获取角色信息失败: ' + JSON.stringify(result.result));
      }
    } catch (error) {
      console.error('加载角色信息失败:', error.message || error);
      wx.showToast({
        title: '加载角色信息失败',
        icon: 'none'
      });
      return null;
    }
  },

  /**
   * 加载聊天历史
   * @param {boolean} silentLoad 是否静默加载（不显示加载中状态）
   * @param {boolean} forceRefresh 是否强制从服务器刷新，忽略缓存
   */
  async loadChatHistory(silentLoad = false, forceRefresh = false) {
    try {
      if (!silentLoad) {
        this.setData({ loadingHistory: true });
      }

      // 计算跳过的消息数量
      const skip = (this.data.currentPage - 1) * chatCacheService.PAGE_SIZE;
      const limit = chatCacheService.PAGE_SIZE;

      // 首先尝试从缓存加载，除非强制刷新
      if (!forceRefresh && this.data.currentPage > 1) {
        const cachedMessages = chatCacheService.loadMessagesFromCache(
          this.data.chatId,
          this.data.currentPage
        );

        if (cachedMessages && cachedMessages.length > 0) {
          if (isDev) {
            console.log(`从缓存加载第${this.data.currentPage}页消息:`, cachedMessages.length);
          }

          // 合并消息，避免重复
          const existingIds = new Set(this.data.messages.map(msg => msg._id));
          const newMessages = cachedMessages.filter(msg => !existingIds.has(msg._id));

          if (newMessages.length > 0) {
            // 处理消息时间戳和显示标志
            const processedMessages = this.processMessages(newMessages);

            this.setData({
              messages: [...processedMessages.reverse(), ...this.data.messages],
              hasMoreHistory: processedMessages.length >= limit,
              loadingHistory: false
            });

            // 滚动到适当位置
            this.scrollToPosition('top');

            return; // 成功从缓存加载，直接返回
          }
        }
      }

      // 缓存未命中或强制刷新，从服务器加载
      const result = await wx.cloud.callFunction({
        name: 'chat',
        data: {
          action: 'getChatHistory',
          roleId: this.data.roleId,
          chatId: this.data.chatId, // 添加chatId参数，优化查询
          skip: skip,
          limit: limit,
          timestamp: Date.now() // 添加时间戳，避免缓存
        }
      });

      if (result && result.result) {
        const { chatId, messages, hasMore } = result.result;

        // 如果有历史消息，处理并添加到消息列表
        if (messages && messages.length > 0) {
          // 处理消息，包括时间戳、分段消息和显示标志
          const processedMessages = this.processMessages(messages);

          // 如果是首次加载或刷新，替换消息列表
          if (this.data.currentPage === 1 || forceRefresh) {
            this.setData({
              chatId,
              messages: processedMessages.reverse(),
              hasMoreHistory: hasMore,
              fromCache: false
            });

            // 保存到缓存，设置为最新消息
            chatCacheService.saveMessagesToCache(
              chatId,
              processedMessages,
              true, // 标记为最新消息
              null,
              this.data.role
            );

            // 滚动到底部
            this.scrollToBottom();
          } else {
            // 如果是加载更多，则添加到当前消息列表前面
            // 合并消息，避免重复
            const existingIds = new Set(this.data.messages.map(msg => msg._id));
            const newMessages = processedMessages.filter(msg => !existingIds.has(msg._id));

            if (newMessages.length > 0) {
              this.setData({
                chatId,
                messages: [...newMessages.reverse(), ...this.data.messages],
                hasMoreHistory: hasMore
              });

              // 保存到缓存，指定页码
              chatCacheService.saveMessagesToCache(
                chatId,
                newMessages,
                false, // 不是最新消息
                this.data.currentPage,
                this.data.role
              );

              // 滚动到加载的新消息位置
              this.scrollToPosition('top');
            } else {
              // 没有新消息，可能已经全部加载
              this.setData({
                hasMoreHistory: false
              });

              wx.showToast({
                title: '没有更多历史消息',
                icon: 'none'
              });
            }
          }
        } else if (chatId) {
          // 如果没有历史消息但有聊天ID，说明是新的聊天
          this.setData({
            chatId,
            hasMoreHistory: false
          });

          // 如果是新聊天，显示欢迎消息
          if (this.data.messages.length === 0 && this.data.role) {
            this.addWelcomeMessage();
          }
        }
      } else {
        throw new Error('获取聊天历史失败');
      }
    } catch (error) {
      console.error('加载聊天历史失败:', error.message || error);

      // 如果服务器加载失败，尝试从缓存恢复
      if (!silentLoad && !this.data.fromCache) {
        const cachedMessages = chatCacheService.loadMessagesFromCache(
          this.data.chatId || `temp_${this.data.roleId}`
        );

        if (cachedMessages && cachedMessages.length > 0) {
          this.setData({
            messages: cachedMessages,
            fromCache: true
          });

          wx.showToast({
            title: '已从缓存恢复',
            icon: 'none'
          });

          // 滚动到底部
          this.scrollToBottom();
        } else {
          wx.showToast({
            title: '加载历史失败',
            icon: 'none'
          });
        }
      } else if (!silentLoad) {
        wx.showToast({
          title: '加载历史失败',
          icon: 'none'
        });
      }
    } finally {
      this.setData({
        loading: false,
        loadingHistory: false,
        refreshing: false
      });
    }
  },

  /**
   * 处理消息数组，包括时间戳、分段消息和显示标志
   * @param {Array} messages 消息数组
   * @returns {Array} 处理后的消息数组
   */
  processMessages(messages) {
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return [];
    }

    // 首先按时间戳排序消息
    messages.sort((a, b) => {
      const aTime = parseInt(a.timestamp) || 0;
      const bTime = parseInt(b.timestamp) || 0;
      return aTime - bTime;
    });

    // 处理分段消息
    const messageMap = {};
    const segmentGroups = {};

    // 首先将所有消息按ID存入映射
    messages.forEach(msg => {
      messageMap[msg._id] = msg;

      // 如果是分段消息，按原始消息ID分组
      if (msg.isSegment && msg.originalMessageId) {
        if (!segmentGroups[msg.originalMessageId]) {
          segmentGroups[msg.originalMessageId] = [];
        }
        segmentGroups[msg.originalMessageId].push(msg);
      }
    });

    // 处理每个分段消息组，确保按分段索引排序
    Object.keys(segmentGroups).forEach(originalId => {
      segmentGroups[originalId].sort((a, b) => {
        return (a.segmentIndex || 0) - (b.segmentIndex || 0);
      });
    });

    // 处理消息时间戳和显示标志
    return messages.map((msg, index) => {
      // 确保消息有有效的时间戳
      if (!msg.timestamp || isNaN(msg.timestamp) || msg.timestamp === 'NaN') {
        msg.timestamp = Date.now();
        if (isDev) {
          console.log('修复历史消息时间戳:', msg.timestamp);
        }
      }

      // 添加时间戳显示标志
      msg.showTimestamp = this.shouldShowTimestamp(msg, messages[index - 1]);

      return msg;
    });
  },

  /**
   * 滚动到指定位置
   * @param {string} position 滚动位置，'top'或'bottom'
   */
  scrollToPosition(position) {
    wx.nextTick(() => {
      const query = wx.createSelectorQuery();

      if (position === 'top') {
        // 滚动到新加载消息的位置
        if (this.data.messages.length > 0) {
          const scrollView = this.selectComponent('#chat-container');
          if (scrollView) {
            scrollView.scrollTo({
              top: 0,
              animated: true
            });
          }
        }
      } else {
        // 默认滚动到底部
        this.scrollToBottom();
      }
    });
  },

  /**
   * 添加欢迎消息
   * @param {boolean} force 是否强制显示欢迎消息，即使有历史消息
   */
  addWelcomeMessage(force = false) {
    if (!this.data.role) return;

    // 如果有历史消息且不是强制显示，则不显示欢迎消息
    if (this.data.messages.length > 0 && !force) {
      if (isDev) {
        console.log('已有历史消息，不显示欢迎消息');
      }
      return;
    }

    const currentTime = Date.now();
    if (isDev) {
      console.log('欢迎消息时间戳:', currentTime);
    }

    // 根据角色类型生成不同的欢迎语
    let welcomeContent = '';

    // 如果角色有自定义欢迎语，优先使用
    if (this.data.role.welcome && this.data.role.welcome.trim()) {
      welcomeContent = this.data.role.welcome;
    } else {
      // 根据角色关系类型生成不同的欢迎语
      const relationshipType = this.data.role.relationship_type || '';

      switch (relationshipType.toLowerCase()) {
        case 'friend':
        case '朋友':
          welcomeContent = `嘉嘉，好久不见了！最近怎么样？有什么想聊的吗？`;
          break;
        case 'family':
        case '家人':
          welcomeContent = `亲爱的，最近身体还好吗？有什么想和我分享的吗？`;
          break;
        case 'colleague':
        case '同事':
          welcomeContent = `嘉嘉，工作还顺利吗？有什么我能帮到你的吗？`;
          break;
        case 'mentor':
        case '导师':
          welcomeContent = `很高兴再次见到你。你最近的学习和思考有什么新的发现吗？`;
          break;
        case 'partner':
        case '伴侣':
          welcomeContent = `亲爱的，我好想你啊！今天想聊什么呢？`;
          break;
        case 'therapist':
        case '心理医生':
          welcomeContent = `很高兴见到你。今天感觉怎么样？有什么想要分享或讨论的吗？`;
          break;
        case 'other':
        case '其他':
        default:
          welcomeContent = `你好，很高兴与你交流。今天有什么想聊的吗？`;
          break;
      }
    }

    const welcomeMessage = {
      _id: 'welcome_' + currentTime,
      chat_id: this.data.chatId,
      sender_type: 'ai',
      content: welcomeContent,
      timestamp: currentTime,
      showTimestamp: true // 欢迎消息始终显示时间戳
    };

    // 打印消息对象以检查结构
    if (isDev) {
      console.log('欢迎消息对象:', welcomeMessage);
    }

    // 确保时间戳是数字类型
    if (typeof welcomeMessage.timestamp !== 'number') {
      welcomeMessage.timestamp = parseInt(welcomeMessage.timestamp) || currentTime;
    }

    this.setData({
      messages: [...this.data.messages, welcomeMessage]
    });

    // 滚动到底部
    this.scrollToBottom();
  },

  /**
   * 加载更多历史消息
   * 当用户上拉聊天记录时触发，加载更早的历史消息
   */
  async loadMoreHistory() {
    // 如果正在加载或没有更多历史，直接返回
    if (this.data.loadingHistory || !this.data.hasMoreHistory) return;

    // 显示加载状态
    this.setData({ loadingHistory: true });

    if (isDev) {
      console.log('开始加载更多历史消息，当前页码:', this.data.currentPage);
    }

    try {
      // 计算下一页页码
      const nextPage = this.data.currentPage + 1;

      // 记录当前滚动位置，以便加载后恢复
      const scrollPosition = await this.getScrollPosition();

      // 使用优化后的历史记录加载函数，传入当前页码
      await this.loadChatHistory(false, false);

      // 更新页码
      this.setData({
        currentPage: nextPage
      });

      // 恢复滚动位置，确保用户体验连贯
      if (scrollPosition) {
        this.restoreScrollPosition(scrollPosition);
      }

      if (isDev) {
        console.log('加载更多历史消息完成，新页码:', nextPage);
      }
    } catch (error) {
      console.error('加载更多历史消息失败:', error);

      wx.showToast({
        title: '加载失败，请重试',
        icon: 'none'
      });
    } finally {
      this.setData({ loadingHistory: false });
    }
  },

  /**
   * 获取当前滚动位置
   * @returns {Promise<number>} 当前滚动位置
   */
  getScrollPosition() {
    return new Promise((resolve) => {
      const query = wx.createSelectorQuery();
      query.select('#chat-container').scrollOffset();
      query.exec((res) => {
        if (res && res[0]) {
          resolve(res[0].scrollTop);
        } else {
          resolve(0);
        }
      });
    });
  },

  /**
   * 恢复滚动位置
   * @param {number} position 要恢复的滚动位置
   */
  restoreScrollPosition(position) {
    wx.nextTick(() => {
      // 获取新加载的消息高度
      const query = wx.createSelectorQuery();
      query.select('#chat-container').boundingClientRect();
      query.exec((res) => {
        if (res && res[0]) {
          const scrollView = this.selectComponent('#chat-container');
          if (scrollView) {
            // 计算新的滚动位置，考虑新加载的消息高度
            const newPosition = position + 50; // 添加一点偏移，确保用户能看到新加载的内容

            scrollView.scrollTo({
              top: newPosition,
              duration: 100
            });

            if (isDev) {
              console.log('恢复滚动位置:', newPosition);
            }
          }
        }
      });
    });
  },

  /**
   * 下拉刷新
   * 当用户下拉聊天界面时触发，刷新最新消息
   */
  async onRefresh() {
    // 如果已经在刷新中，直接返回
    if (this.data.refreshing) return;

    // 设置刷新状态并重置页码
    this.setData({
      refreshing: true,
      currentPage: 1 // 重置到第一页
    });

    try {
      if (isDev) {
        console.log('开始下拉刷新，获取最新消息');
      }

      // 使用优化后的历史记录加载函数，强制从服务器刷新
      await this.loadChatHistory(false, true);

      // 显示刷新成功提示
      wx.showToast({
        title: '刷新成功',
        icon: 'success',
        duration: 1500
      });

      // 滚动到底部，查看最新消息
      this.scrollToBottom(100);

      if (isDev) {
        console.log('下拉刷新完成，已加载最新消息');
      }
    } catch (error) {
      console.error('下拉刷新失败:', error);

      wx.showToast({
        title: '刷新失败，请重试',
        icon: 'none'
      });
    } finally {
      // 无论成功失败，都结束刷新状态
      this.setData({
        refreshing: false
      });
    }
  },

  /**
   * 发送消息
   */
  async handleSendMessage(e) {
    const { content } = e.detail;
    if (!content.trim()) return;

    // 处理消息发送逻辑
    await this._processSendMessage(content);
  },

  /**
   * 处理语音输入
   */
  async handleSendVoice(e) {
    const { content } = e.detail;
    if (!content.trim()) return;

    // 处理消息发送逻辑，与文本输入相同
    await this._processSendMessage(content);
  },

  /**
   * 处理消息发送的核心逻辑
   * @param {string} content 消息内容
   * @private
   */
  async _processSendMessage(content) {

    // 添加用户消息到列表
    const currentTime = Date.now();
    console.log('用户消息时间戳:', currentTime);

    const userMessage = {
      _id: 'temp_' + currentTime,
      chat_id: this.data.chatId,
      sender_type: 'user',
      content,
      timestamp: currentTime
    };

    // 判断是否显示时间戳
    const messages = this.data.messages;
    const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;
    userMessage.showTimestamp = this.shouldShowTimestamp(userMessage, lastMessage);

    console.log('用户消息对象:', userMessage);

    // 确保时间戳是数字类型
    if (typeof userMessage.timestamp !== 'number') {
      userMessage.timestamp = parseInt(userMessage.timestamp) || currentTime;
    }

    this.setData({
      messages: [...this.data.messages, userMessage],
      sending: true
    });

    // 滚动到底部
    this.scrollToBottom(0);

    try {
      // 获取当前选择的模型类型和模型
      const modelType = this.data.selectedModelType || modelService.getSelectedModelType();
      const modelName = this.data.selectedModel || modelService.getSelectedModel(modelType);

      // 调用云函数发送消息
      const result = await wx.cloud.callFunction({
        name: 'chat',
        data: {
          action: 'sendMessage',
          chatId: this.data.chatId,
          roleId: this.data.roleId,
          content,
          systemPrompt: this.systemPrompt, // 使用包含用户画像的系统提示
          modelType: modelType, // 传递模型类型
          modelName: modelName // 传递具体模型名称
        }
      });

      if (result && result.result && result.result.success) {
        // 我们已经禁用了聊天回复中的情绪分析功能
        // 不再使用云函数返回的emotionAnalysis参数
        const { chatId, message, aiMessages } = result.result;

        // 更新用户消息
        const updatedMessages = [...this.data.messages];
        const userMessageIndex = updatedMessages.findIndex(msg => msg._id === userMessage._id);

        if (userMessageIndex !== -1) {
          // 更新用户消息
          updatedMessages[userMessageIndex] = message;

          // 我们已经禁用了聊天回复中的情绪分析功能
          // 情绪分析将完全由专门的云函数 @cloudfunctions\analysis/ 处理
          // 在analyzeUserEmotion函数中处理情绪标签
        }

        // 处理AI回复消息
        if (aiMessages && aiMessages.length > 0) {
          // 处理每个AI消息
          aiMessages.forEach(msg => {
            // 处理AI回复中的JSON标记
            if (msg.content) {
              msg.content = msg.content.replace(/```json[\s\S]*?```/g, '');
              msg.content = msg.content.trim();
            }

            // 确保消息有有效的时间戳
            if (!msg.timestamp || isNaN(msg.timestamp)) {
              msg.timestamp = Date.now();
            }
          });

          // 设置初始状态，准备分段显示消息
          this.setData({
            chatId,
            messages: updatedMessages,
            sending: true,
            pendingAiMessages: aiMessages,
            currentAiMessageIndex: 0
          });

          // 开始逐个显示AI消息，模拟打字效果
          this.showNextAiMessage();
        } else {
          // 没有AI消息，直接更新状态
          this.setData({
            chatId,
            messages: updatedMessages,
            sending: false
          });
        }

        // 保存最新消息到缓存
        chatCacheService.saveMessagesToCache(
          chatId,
          updatedMessages,
          true,
          null,
          this.data.role
        );

        // 我们已经禁用了聊天回复中的情绪分析功能
        // 情绪分析将完全由专门的云函数 @cloudfunctions\analysis/ 处理
        // 手动进行情绪分析
        this.analyzeUserEmotion(content, message._id);
      } else {
        throw new Error(result?.result?.error || '发送消息失败');
      }
    } catch (error) {
      console.error('发送消息失败:', error);
      wx.showToast({
        title: '发送失败，请重试',
        icon: 'none'
      });
      this.setData({ sending: false });
    }

    // 在消息发送完成后，再次滚动到底部
    wx.nextTick(() => {
      this.scrollToBottom(100);
    });
  },

  /**
   * 分析用户情绪
   * @param {string} text 用户消息文本
   * @param {string} messageId 可选，指定要更新情绪的消息 ID
   */
  async analyzeUserEmotion(text, messageId = null) {
    try {
      // 准备历史消息作为上下文
      const history = this.data.messages.slice(-5).map(msg => ({
        role: msg.sender_type === 'user' ? 'user' : 'assistant',
        content: msg.content
      }));

      console.log('开始分析情绪, 文本:', text);
      console.log('历史消息:', history);

      // 并行处理情绪分析和关键词提取
      const [emotionResult, keywords] = await Promise.all([
        // 调用情绪分析服务
        emotionService.analyzeEmotion(text, {
          history: history,
          saveRecord: true,
          roleId: this.data.roleId,
          chatId: this.data.chatId
        }),
        // 提取关键词
        keywordService.extractKeywords(text, 5)
      ]);

      console.log('情绪分析结果:', emotionResult);
      console.log('关键词提取结果:', keywords);

      // 如果提取到关键词，更新用户兴趣
      if (keywords && keywords.length > 0) {
        // 获取用户ID
        // 优先使用全局用户信息中的openid
        const app = getApp();
        const userInfo = app.globalData.userInfo;
        let openId = null;

        if (userInfo) {
          // 优先使用全局用户信息中的openid
          if (userInfo.openid) {
            openId = userInfo.openid;
          } else if (userInfo.stats && userInfo.stats.openid) {
            openId = userInfo.stats.openid;
          }
        }

        // 如果全局用户信息中没有openid，尝试从本地缓存中获取
        if (!openId) {
          openId = wx.getStorageSync('openId');
        }

        console.log('尝试获取用户ID结果:', openId);
        console.log('全局用户信息:', userInfo);

        if (openId) {
          // 1. 先将关键词分类
          wx.cloud.callFunction({
            name: 'analysis',
            data: {
              type: 'classify_keywords',
              keywords: keywords.map(k => k.word),
              batch: true
            }
          }).then(classifyResult => {
            console.log('关键词分类结果:', JSON.stringify(classifyResult, null, 2));

            // 如果分类成功，将分类结果应用到关键词上
            if (classifyResult.result && classifyResult.result.success &&
              classifyResult.result.data && classifyResult.result.data.classifications) {

              const classifications = classifyResult.result.data.classifications;
              console.log('分类结果详情:', JSON.stringify(classifications, null, 2));

              const categoryMap = {};
              classifications.forEach(item => {
                categoryMap[item.keyword] = item.category;
              });

              console.log('分类映射:', JSON.stringify(categoryMap, null, 2));

              // 更新关键词对象的分类
              keywords.forEach(keyword => {
                if (categoryMap[keyword.word]) {
                  keyword.category = categoryMap[keyword.word];
                  console.log(`关键词 ${keyword.word} 分类为 ${keyword.category}`);
                } else {
                  keyword.category = '未分类';
                  console.log(`关键词 ${keyword.word} 没有分类结果，使用默认分类`);
                }
              });

              console.log('分类后的关键词数据:', JSON.stringify(keywords, null, 2));

              // 创建分类统计数据
              const categoryStats = {};
              keywords.forEach(keyword => {
                if (keyword.category) {
                  categoryStats[keyword.category] = (categoryStats[keyword.category] || 0) + 1;
                }
              });

              console.log('分类统计:', JSON.stringify(categoryStats, null, 2));

              // 创建分类数组
              const categoriesArray = Object.entries(categoryStats).map(([name, count]) => ({
                name,
                count,
                firstSeen: new Date(),
                lastUpdated: new Date()
              }));

              console.log('分类数组:', JSON.stringify(categoriesArray, null, 2));
            } else {
              console.warn('关键词分类结果格式不正确:', classifyResult);
            }

            // 2. 更新用户兴趣
            console.log('准备更新的关键词数据:', JSON.stringify(keywords, null, 2));
            userInterestsService.batchUpdateUserInterests(
              openId,
              keywords,
              true, // 自动分类
              categoryStats, // 传递分类统计
              categoriesArray // 传递分类数组
            )
              .then(result => {
                const success = result && result.success;
                console.log('更新用户兴趣' + (success ? '成功' : '失败'));
                console.log('更新用户兴趣返回结果:', result);

                // 3. 如果有情绪分析结果，关联关键词与情绪
                if (emotionResult && emotionResult.data) {
                  // 异步调用云函数关联关键词与情绪
                  const emotionData = {
                    type: 'link_keywords_emotion',
                    userId: openId,
                    keywords: keywords.map(k => k.word),
                    emotionResult: emotionResult.data
                  };
                  console.log('准备关联关键词与情绪的数据:', JSON.stringify(emotionData, null, 2));

                  wx.cloud.callFunction({
                    name: 'analysis',
                    data: emotionData
                  }).then(linkResult => {
                    console.log('关联关键词与情绪结果:', linkResult);
                    // 获取最新的用户兴趣数据以验证更新
                    userInterestsService.getUserInterests(openId, true)
                      .then(interestsData => {
                        console.log('更新后的用户兴趣数据:', interestsData);
                      })
                      .catch(err => {
                        console.error('获取用户兴趣数据异常:', err);
                      });
                  }).catch(err => {
                    console.error('关联关键词与情绪异常:', err);
                  });
                }
              })
              .catch(err => {
                console.error('更新用户兴趣异常:', err);
              });
          }).catch(err => {
            console.error('关键词分类异常:', err);

            // 即使分类失败，也继续更新用户兴趣
            userInterestsService.batchUpdateUserInterests(openId, keywords)
              .then(success => {
                console.log('更新用户兴趣' + (success ? '成功' : '失败'));
              })
              .catch(err => {
                console.error('更新用户兴趣异常:', err);
              });
          });
        } else {
          console.warn('无法获取用户ID，无法更新用户兴趣');
        }
      }

      // 处理情绪分析结果
      // 即使服务返回错误，也尝试使用数据
      if (emotionResult && emotionResult.data) {
        // 即使没有 success 标志，也尝试使用数据
        // 将原始数据保存下来，便于调试
        const rawData = emotionResult.data;
        console.log('原始情绪数据:', rawData);

        // 直接使用原始数据，不再进行处理
        // 获取主要情绪类型用于显示标签
        const primaryEmotion = rawData.primary_emotion || rawData.type || '平静';

        // 直接使用原始数据，不再进行标准化处理
        // 标准化处理将由 emotion-dashboard 组件完成
        const standardizedData = rawData;

        console.log('使用原始情绪数据，不再进行标准化处理');

        // 更新情绪分析结果
        this.setData({
          emotionAnalysis: standardizedData
        });

        // 获取情绪类型的中文标签
        const emotionLabel = emotionService.EmotionTypeLabels[primaryEmotion] || primaryEmotion;

        // 如果指定了消息 ID，则更新该消息的情绪标签
        if (messageId) {
          const updatedMessages = [...this.data.messages];
          const messageIndex = updatedMessages.findIndex(msg => msg._id === messageId);

          if (messageIndex !== -1) {
            updatedMessages[messageIndex].emotion_type = emotionLabel;

            this.setData({
              messages: updatedMessages
            });

            console.log('更新消息情绪标签:', messageId, emotionLabel);
          }
        } else {
          // 找到最后一条用户消息并更新其情绪标签
          const updatedMessages = [...this.data.messages];
          const userMessages = updatedMessages.filter(msg => msg.sender_type === 'user');

          if (userMessages.length > 0) {
            const lastUserMessage = userMessages[userMessages.length - 1];
            const messageIndex = updatedMessages.findIndex(msg => msg._id === lastUserMessage._id);

            if (messageIndex !== -1) {
              updatedMessages[messageIndex].emotion_type = emotionLabel;

              this.setData({
                messages: updatedMessages
              });

              console.log('更新最后一条用户消息情绪标签:', lastUserMessage._id, emotionLabel);
            }
          }
        }

        return standardizedData;
      } else {
        console.error('情绪分析返回错误:', emotionResult?.error || '未知错误');
        // 使用默认数据
        this.setData({
          emotionAnalysis: this.data.defaultEmotionData
        });
        return this.data.defaultEmotionData;
      }
    } catch (error) {
      console.error('情绪分析失败:', error);
      // 失败不影响主流程，使用默认数据
      this.setData({
        emotionAnalysis: this.data.defaultEmotionData
      });
      return this.data.defaultEmotionData;
    }
  },

  /**
   * 显示情绪标签
   * @param {string} emotionType 情绪类型
   */
  showEmotionTag(emotionType) {
    // 获取情绪类型的中文标签
    const emotionLabel = emotionService.EmotionTypeLabels[emotionType] || emotionType;
    console.log('检测到情绪:', emotionLabel);

    // 不再显示Toast提示，而是直接在消息下方显示情绪标签
  },

  /**
   * 显示下一条AI消息
   */
  showNextAiMessage() {
    const { pendingAiMessages, currentAiMessageIndex } = this.data;

    if (!pendingAiMessages || currentAiMessageIndex >= pendingAiMessages.length) {
      // 所有消息已显示完毕
      this.setData({
        sending: false,
        pendingAiMessages: null,
        currentAiMessageIndex: 0
      });

      // 所有消息显示完毕后，强制滚动到底部
      wx.nextTick(() => {
        this.scrollToBottom(100, true);
      });

      return;
    }

    // 获取当前要显示的消息
    const aiMessage = pendingAiMessages[currentAiMessageIndex];

    // 计算显示延迟（根据消息长度、内容复杂度和上下文）
    const messageLength = aiMessage.content ? aiMessage.content.length : 0;

    // 计算平均字符长度（考虑中英文混合情况）
    const avgCharLength = this.calculateAverageCharLength(aiMessage.content);

    // 估算阅读和打字时间（每分钟200个字符的打字速度）
    const typingTimePerChar = 60 / 200; // 秒/字符
    const estimatedTypingTime = messageLength * typingTimePerChar * 1000; // 毫秒

    // 基础延迟：考虑消息长度和复杂度的动态延迟
    // 短消息使用较短延迟，长消息使用较长但有上限的延迟
    let baseDelay = Math.min(1500, 300 + estimatedTypingTime * 0.3);

    // 根据消息内容和上下文调整延迟

    // 1. 检查消息类型和内容特征
    const hasQuestion = aiMessage.content && (
      aiMessage.content.includes('？') ||
      aiMessage.content.includes('?') ||
      /你|您|怎么样|如何|什么|为什么/.test(aiMessage.content)
    );

    const isGreeting = /你好|早上好|下午好|晚上好|嗨|哈喽|Hello|Hi/.test(aiMessage.content);

    const isEmotional = /[！!]{2,}|[？?]{2,}|哈哈|呵呵|嘻嘻|哭|泪|笑|开心|难过|伤心|生气|愤怒/.test(aiMessage.content);

    const isThinking = /我想|我认为|我觉得|我相信|我猜|可能|也许|或许|应该|大概/.test(aiMessage.content);

    // 2. 根据内容特征调整延迟
    if (hasQuestion) {
      // 问题需要思考时间
      baseDelay += 300;
    }

    if (isGreeting && messageLength < 15) {
      // 简短的问候语应该快速回复
      baseDelay = Math.min(baseDelay, 400);
    }

    if (isEmotional) {
      // 情绪化的回复应该更快，表现出情感的即时性
      baseDelay *= 0.8;
    }

    if (isThinking) {
      // 思考性的回复应该稍慢，表现出思考的过程
      baseDelay *= 1.2;
    }

    // 3. 考虑消息在对话中的位置
    if (currentAiMessageIndex === 0) {
      // 第一条消息需要额外的"思考时间"
      baseDelay += Math.min(800, messageLength * 2);
    } else if (currentAiMessageIndex === pendingAiMessages.length - 1) {
      // 最后一条消息可以稍微延长，表示对话即将结束
      baseDelay *= 1.1;
    } else {
      // 中间消息根据与前一条消息的关联性调整
      const prevMessage = pendingAiMessages[currentAiMessageIndex - 1];

      // 如果当前消息是对前一条消息的直接延续，减少延迟
      if (prevMessage && this.areMessagesRelated(prevMessage.content, aiMessage.content)) {
        baseDelay *= 0.85;
      }
    }

    // 4. 考虑消息长度的非线性影响
    if (messageLength > 100) {
      // 长消息不应该等待太久，使用对数缩放
      baseDelay = Math.min(baseDelay, 300 + Math.log(messageLength) * 300);
    } else if (messageLength < 10) {
      // 非常短的消息应该快速显示
      baseDelay = Math.min(baseDelay, 400);
    }

    // 5. 添加随机性，使延迟看起来更自然
    // 使用更窄的随机范围，避免过大的波动
    const randomFactor = 0.9 + Math.random() * 0.2; // 0.9-1.1的随机因子

    // 6. 计算最终延迟，并设置合理的上下限
    const delay = Math.min(2500, Math.max(300, Math.floor(baseDelay * randomFactor)));

    if (isDev) {
      console.log(`显示第 ${currentAiMessageIndex + 1}/${pendingAiMessages.length} 条AI消息，长度: ${messageLength}，延迟: ${delay}ms`);
    }

    // 添加消息到列表
    setTimeout(() => {
      // 判断是否显示时间戳
      const messages = this.data.messages;
      const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;
      aiMessage.showTimestamp = this.shouldShowTimestamp(aiMessage, lastMessage);

      this.setData({
        messages: [...messages, aiMessage],
        currentAiMessageIndex: currentAiMessageIndex + 1
      });

      // 每显示一条消息就滚动到底部，确保用户能看到最新消息
      // 使用强制滚动，即使在手动滚动模式下也滚动到底部
      this.scrollToBottom(50, true);

      // 显示下一条消息
      if (currentAiMessageIndex + 1 < pendingAiMessages.length) {
        // 计算消息之间的延迟，根据当前消息和下一条消息的关系动态调整
        const nextMessage = pendingAiMessages[currentAiMessageIndex + 1];
        let interMessageDelay = 500; // 默认间隔

        if (nextMessage) {
          // 如果下一条消息是当前消息的直接延续，减少间隔
          if (this.areMessagesRelated(aiMessage.content, nextMessage.content)) {
            interMessageDelay = 300;
          }
          // 如果下一条消息是新话题或转折，增加间隔
          else if (this.isTopicChange(aiMessage.content, nextMessage.content)) {
            interMessageDelay = 800;
          }
          // 根据下一条消息的长度调整间隔
          if (nextMessage.content && nextMessage.content.length > 50) {
            interMessageDelay += 100;
          }
        }

        // 在消息之间添加动态延迟，模拟打字间隔
        setTimeout(() => {
          this.showNextAiMessage();
        }, interMessageDelay);
      } else {
        // 所有消息已显示完毕
        this.setData({
          sending: false,
          pendingAiMessages: null,
          currentAiMessageIndex: 0
        });

        // 所有消息显示完毕后，再次强制滚动到底部
        wx.nextTick(() => {
          this.scrollToBottom(100, true);
        });

        // 检查消息数量，当达到一定阈值时提取记忆
        // 每10条消息提取一次记忆
        if (this.data.messages.length % 10 === 0) {
          if (isDev) {
            console.log('消息数量达到阈值，触发记忆提取');
          }
          this.extractChatMemories();
        }
      }
    }, delay);
  },

  /**
   * 计算消息内容的平均字符长度（考虑中英文混合情况）
   * @param {string} content 消息内容
   * @returns {number} 平均字符长度
   */
  calculateAverageCharLength(content) {
    if (!content) return 1;

    // 计算中文字符数量
    const chineseChars = content.match(/[\u4e00-\u9fa5]/g) || [];
    const chineseCount = chineseChars.length;

    // 计算英文单词数量（粗略估计）
    const englishWords = content.match(/[a-zA-Z]+/g) || [];
    const englishCount = englishWords.length;

    // 计算数字和符号数量
    const otherChars = content.match(/[0-9\s\p{P}]/gu) || [];
    const otherCount = otherChars.length;

    // 计算总字符数
    const totalChars = content.length;

    // 如果主要是中文（中文字符占比超过50%）
    if (chineseCount / totalChars > 0.5) {
      return 1.5; // 中文阅读速度通常比英文慢
    }
    // 如果主要是英文
    else if (englishCount > 0) {
      return 1.0; // 英文标准
    }
    // 默认情况
    return 1.2;
  },

  /**
   * 判断两条消息是否相关（是否是同一话题的延续）
   * @param {string} prevContent 前一条消息内容
   * @param {string} currentContent 当前消息内容
   * @returns {boolean} 是否相关
   */
  areMessagesRelated(prevContent, currentContent) {
    if (!prevContent || !currentContent) return false;

    // 1. 检查是否有共同的关键词
    const prevWords = this.extractKeywords(prevContent);
    const currentWords = this.extractKeywords(currentContent);

    // 计算共同词的数量
    const commonWords = prevWords.filter(word => currentWords.includes(word));

    // 如果有多个共同词，可能是相关的
    if (commonWords.length >= 2) return true;

    // 2. 检查是否有连接词开头，表示承接上文
    const continuationPatterns = /^(所以|因此|因而|故而|于是|那么|不过|但是|然而|另外|此外|除此之外|总之|总的来说|换句话说)/;
    if (continuationPatterns.test(currentContent.trim())) return true;

    // 3. 检查是否是问答对
    const isQuestion = /[？?]$/.test(prevContent.trim());
    const isAnswer = /^(是的|没错|对|不是|不|可以|不可以|好的|嗯|这样|我认为|我觉得|我想)/i.test(currentContent.trim());

    if (isQuestion && isAnswer) return true;

    return false;
  },

  /**
   * 从文本中提取可能的关键词
   * @param {string} text 文本内容
   * @returns {Array} 关键词数组
   */
  extractKeywords(text) {
    if (!text) return [];

    // 简单实现：去除常见虚词和标点，分词
    const stopWords = ['的', '了', '是', '在', '我', '你', '他', '她', '它', '和', '与', '或', '这', '那', '有', '没有', '不', '也', '都', '就', '要', '会', '到', '可以', '能', '被', '把', '给', '让'];

    // 去除标点和空格
    const cleanText = text.replace(/[\p{P}\s]/gu, ' ');

    // 分词（简单实现，实际应使用专业分词库）
    // 这里假设中文每个字是一个词，英文按空格分词
    const words = cleanText.split(/\s+/).filter(word =>
      word.length > 0 &&
      !stopWords.includes(word) &&
      !/^[a-zA-Z]{1,2}$/.test(word) // 过滤掉1-2个字母的英文单词
    );

    return words;
  },

  /**
   * 判断是否是话题转换
   * @param {string} prevContent 前一条消息内容
   * @param {string} currentContent 当前消息内容
   * @returns {boolean} 是否是话题转换
   */
  isTopicChange(prevContent, currentContent) {
    if (!prevContent || !currentContent) return false;

    // 检查是否有明显的话题转换标记
    const topicChangePatterns = /^(说到这个|换个话题|另外|此外|对了|顺便说一下|还有|除此之外|不说这个了|回到刚才的话题|说起|提到|关于|至于)/;

    if (topicChangePatterns.test(currentContent.trim())) return true;

    // 检查共同关键词，如果几乎没有共同关键词，可能是话题转换
    const prevWords = this.extractKeywords(prevContent);
    const currentWords = this.extractKeywords(currentContent);

    // 如果两条消息都有足够的关键词，但几乎没有共同词，可能是话题转换
    if (prevWords.length >= 3 && currentWords.length >= 3) {
      const commonWords = prevWords.filter(word => currentWords.includes(word));
      if (commonWords.length === 0) return true;
    }

    return false;
  },

  /**
   * 删除消息
   */
  async handleDeleteMessage(e) {
    const { messageId } = e.detail;

    try {
      const confirmed = await new Promise((resolve) => {
        wx.showModal({
          title: '确认删除',
          content: '确定要删除这条消息吗？',
          success: (res) => {
            resolve(res.confirm);
          }
        });
      });

      if (!confirmed) return;

      // 调用云函数删除消息
      await wx.cloud.callFunction({
        name: 'chat',
        data: {
          action: 'deleteMessage',
          messageId
        }
      });

      // 更新消息列表
      const updatedMessages = this.data.messages.filter(msg => msg._id !== messageId);
      this.setData({
        messages: updatedMessages
      });

      wx.showToast({
        title: '删除成功',
        icon: 'success'
      });
    } catch (error) {
      console.error('删除消息失败:', error);
      wx.showToast({
        title: '删除失败，请重试',
        icon: 'none'
      });
    }
  },

  /**
   * 保存聊天历史
   */
  async saveChatHistory() {
    if (!this.data.chatId || this.data.messages.length === 0) return;

    try {
      await wx.cloud.callFunction({
        name: 'chat',
        data: {
          action: 'saveChatHistory',
          chatId: this.data.chatId
        }
      });
    } catch (error) {
      console.error('保存聊天历史失败:', error);
    }
  },

  /**
   * 提取对话记忆
   * @param {boolean} silent 是否静默提取（不显示提示）
   * @returns {Promise<boolean>} 提取是否成功
   */
  async extractChatMemories(silent = true) {
    // 如果消息数量太少，不提取记忆
    if (!this.data.roleId || !this.data.messages || this.data.messages.length < 5) {
      if (isDev) {
        console.log('消息数量不足，不提取记忆');
      }
      return false;
    }

    try {
      if (isDev) {
        console.log('开始提取对话记忆...');
      }

      // 调用云函数提取记忆
      const result = await wx.cloud.callFunction({
        name: 'roles',
        data: {
          action: 'extractMemories',
          roleId: this.data.roleId,
          messages: this.data.messages
        }
      });

      if (result && result.result && result.result.success) {
        if (isDev) {
          console.log('成功提取记忆:', result.result.memories.length, '条');
        }

        if (!silent) {
          wx.showToast({
            title: '记忆提取成功',
            icon: 'success'
          });
        }

        return true;
      } else {
        console.error('提取记忆失败:', result);
        return false;
      }
    } catch (error) {
      console.error('调用提取记忆云函数失败:', error);
      return false;
    }
  },

  /**
   * 清理聊天缓存
   */
  clearChatCache() {
    if (this.data.chatId) {
      chatCacheService.clearChatCache(this.data.chatId);
      wx.showToast({
        title: '缓存已清理',
        icon: 'success'
      });
    }
  },

  /**
   * 显示情绪分析
   */
  handleShowEmotionAnalysis() {
    console.log('当前情绪分析数据:', this.data.emotionAnalysis);

    if (!this.data.emotionAnalysis || this.data.emotionAnalysis === this.data.defaultEmotionData) {
      // 如果没有情绪分析数据或者是默认数据，尝试分析最后一条用户消息
      const userMessages = this.data.messages.filter(msg => msg.sender_type === 'user');
      if (userMessages.length > 0) {
        const lastUserMessage = userMessages[userMessages.length - 1];

        // 先使用默认数据显示弹窗，同时开始分析
        this.setData({
          emotionAnalysis: this.data.defaultEmotionData,
          showEmotionAnalysis: true
        });

        // 开始分析
        this.analyzeUserEmotion(lastUserMessage.content)
          .then(data => {
            // 分析完成后更新弹窗数据
            this.setData({
              emotionAnalysis: data
            });
          })
          .catch(err => {
            console.error('分析失败:', err);
          });

        wx.showToast({
          title: '正在分析情绪...',
          icon: 'loading',
          duration: 1000
        });
      } else {
        // 没有用户消息，使用默认数据
        this.setData({
          emotionAnalysis: this.data.defaultEmotionData,
          showEmotionAnalysis: true
        });
      }
      return;
    }

    // 已有情绪分析数据，直接显示
    this.setData({
      showEmotionAnalysis: true
    });
  },

  /**
   * 关闭情绪分析
   */
  handleCloseEmotionAnalysis() {
    this.setData({
      showEmotionAnalysis: false
    });
  },

  /**
   * 处理输入框获取焦点
   */
  handleInputFocus(e) {
    console.log('输入框获取焦点:', e);
    // 设置键盘显示状态
    this.setData({
      isKeyboardShow: true,
      manualScroll: false // 输入框获取焦点时重置为自动滚动
    });

    // 滚动到底部，使用多次延时滚动确保滚动到正确位置
    wx.nextTick(() => {
      // 第一次滚动，快速响应
      this.scrollToBottom(50, true);

      // 第二次滚动，等待键盘开始弹出
      setTimeout(() => {
        this.scrollToBottom(50, true);
      }, 200);

      // 第三次滚动，等待键盘完全弹出
      setTimeout(() => {
        this.scrollToBottom(50, true);
      }, 400);
    });
  },

  /**
   * 处理输入框失去焦点
   */
  handleInputBlur(e) {
    console.log('输入框失去焦点:', e);
    // 设置键盘隐藏状态
    this.setData({
      isKeyboardShow: false
    });

    // 滚动到底部，使用多次延时滚动确保滚动到正确位置
    wx.nextTick(() => {
      // 第一次滚动，快速响应
      this.scrollToBottom(50, true);

      // 第二次滚动，等待键盘开始收起
      setTimeout(() => {
        this.scrollToBottom(100, true);
      }, 200);
    });
  },

  /**
   * 查看详细情绪分析
   */
  handleViewEmotionDetail() {
    // 关闭弹窗
    this.setData({
      showEmotionAnalysis: false
    });

    // 跳转到情绪分析页面
    wx.navigateTo({
      url: `/packageChat/pages/emotion-analysis/emotion-analysis?chatId=${this.data.chatId}&roleId=${this.data.roleId}`
    });
  },

  /**
   * 阻止事件冒泡
   */
  stopPropagation() {
    // 仅用于阻止事件冒泡
    return;
  },

  /**
   * 获取系统信息
   */
  getSystemInfo() {
    try {
      // 获取系统信息
      const systemInfo = wx.getSystemInfoSync();
      // 获取胶囊按钮位置
      const menuButtonInfo = wx.getMenuButtonBoundingClientRect();

      // 计算导航栏高度 = 胶囊底部到状态栏底部的距离 + 胶囊高度 + 胶囊顶部到状态栏顶部的距离
      const navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height;

      this.setData({
        statusBarHeight: systemInfo.statusBarHeight,
        navBarHeight: navBarHeight,
        menuButtonInfo: menuButtonInfo,
        systemInfo: systemInfo
      });

      console.log('胶囊位置信息:', menuButtonInfo);
      console.log('系统信息:', systemInfo);
    } catch (e) {
      console.error('获取系统信息失败:', e);
      // 设置默认值
      this.setData({
        statusBarHeight: 20,
        navBarHeight: 44
      });
    }
  },

  /**
   * 获取用户画像
   */
  async getUserPerception() {
    try {
      const result = await wx.cloud.callFunction({
        name: 'user',
        data: {
          action: 'getUserPerception'
        }
      });

      if (result.result && result.result.success) {
        this.userPerception = result.result.data;
        console.log('获取用户画像成功:', this.userPerception);
      }
    } catch (error) {
      console.error('获取用户画像失败:', error);
    }
  },

  /**
   * 获取用户ID
   */
  getUserId() {
    try {
      // 优先使用全局用户信息中的openid
      const app = getApp();
      const userInfo = app.globalData.userInfo;
      let openId = null;

      if (userInfo) {
        // 优先使用全局用户信息中的openid
        if (userInfo.openid) {
          openId = userInfo.openid;
        } else if (userInfo.stats && userInfo.stats.openid) {
          openId = userInfo.stats.openid;
        }
      }

      // 如果全局用户信息中没有openid，尝试从本地缓存中获取
      if (!openId) {
        openId = wx.getStorageSync('openId');
      }

      console.log('获取用户ID:', openId);

      if (openId) {
        this.setData({ openId });
      } else {
        console.warn('无法获取用户ID');
      }

      return openId;
    } catch (error) {
      console.error('获取用户ID失败:', error);
      return null;
    }
  },

  /**
   * 启动定期记忆提取定时器
   * 每5分钟触发一次记忆提取
   */
  startMemoryExtractionTimer() {
    // 清除可能存在的旧定时器
    if (this.memoryExtractionTimer) {
      clearInterval(this.memoryExtractionTimer);
    }

    // 设置定时器，每5分钟（300000毫秒）触发一次
    const MEMORY_EXTRACTION_INTERVAL = 5 * 60 * 1000; // 5分钟

    this.memoryExtractionTimer = setInterval(() => {
      if (isDev) {
        console.log('定时触发记忆提取');
      }

      // 只有当消息数量足够且不在发送状态时才提取记忆
      if (this.data.messages.length >= 5 && !this.data.sending) {
        this.extractChatMemories();
      }
    }, MEMORY_EXTRACTION_INTERVAL);

    if (isDev) {
      console.log('已启动定期记忆提取定时器，间隔:', MEMORY_EXTRACTION_INTERVAL, '毫秒');
    }
  },

  /**
   * 更新角色系统提示
   */
  async updateRoleSystemPrompt() {
    if (!this.data.role) return;

    try {
      // 获取用户ID
      // 优先使用全局用户信息中的openid
      const app = getApp();
      const userInfo = app.globalData.userInfo;
      let openId = null;

      if (userInfo) {
        // 优先使用全局用户信息中的openid
        if (userInfo.openid) {
          openId = userInfo.openid;
        } else if (userInfo.stats && userInfo.stats.openid) {
          openId = userInfo.stats.openid;
        }
      }

      // 如果全局用户信息中没有openid，尝试从本地缓存中获取
      if (!openId) {
        openId = wx.getStorageSync('openId');
      }

      console.log('尝试获取用户ID结果:', openId);
      console.log('全局用户信息:', userInfo);

      if (!openId) {
        console.warn('无法获取用户ID，使用默认系统提示');
        // 优先使用prompt字段，其次是system_prompt字段
        this.originalSystemPrompt = this.data.role.prompt || this.data.role.system_prompt || '';
        this.systemPrompt = this.originalSystemPrompt;
        return;
      }

      // 并行获取用户画像和用户兴趣数据
      const [userPerceptionResult, userInterestsData] = await Promise.all([
        // 获取用户画像
        this.userPerception ? Promise.resolve(this.userPerception) : wx.cloud.callFunction({
          name: 'user',
          data: {
            action: 'getUserPerception'
          }
        }).then(result => result.result && result.result.success ? result.result.data : null),
        // 获取用户兴趣数据
        userInterestsService.getInterestTagCloudData(openId)
      ]);

      // 处理用户画像数据
      const userPerception = userPerceptionResult || {};
      const { personalitySummary } = userPerception;

      // 处理用户兴趣数据
      let interestsStr = '';
      if (userPerception.interests && userPerception.interests.length > 0) {
        // 优先使用用户画像中的兴趣数据
        interestsStr = userPerception.interests.join('、');
      } else if (userInterestsData && userInterestsData.length > 0) {
        // 如果用户画像中没有兴趣数据，使用兴趣标签云数据
        // 按权重排序
        userInterestsData.sort((a, b) => b.value - a.value);
        // 取前10个兴趣
        const topInterests = userInterestsData.slice(0, 10).map(item => item.name);
        interestsStr = topInterests.join('、');
      }

      // 将用户画像信息添加到角色系统提示中
      let userProfileInfo = '';
      if (personalitySummary) {
        userProfileInfo += `用户个性: ${personalitySummary}\n`;
      }
      if (interestsStr) {
        userProfileInfo += `用户兴趣: ${interestsStr}`;
      }

      // 更新角色系统提示
      // 优先使用prompt字段，其次是system_prompt字段
      this.originalSystemPrompt = this.data.role.prompt || this.data.role.system_prompt || '';
      this.systemPrompt = userProfileInfo ? `${this.originalSystemPrompt}\n\n${userProfileInfo}` : this.originalSystemPrompt;

      console.log('更新后的系统提示:', this.systemPrompt);
    } catch (error) {
      console.error('更新角色系统提示失败:', error);
      // 出错时使用原始提示
      // 优先使用prompt字段，其次是system_prompt字段
      this.originalSystemPrompt = this.data.role.prompt || this.data.role.system_prompt || '';
      this.systemPrompt = this.originalSystemPrompt;
    }
  },

  /**
   * 处理返回按钮点击
   */
  handleBack() {
    wx.navigateBack({
      fail: () => {
        wx.switchTab({
          url: '/pages/home/home'
        });
      }
    });
  },

  /**
   * 处理模型变更
   * @param {Object} e 事件对象
   */
  handleModelChange(e) {
    const { modelType, modelName } = e.detail;

    this.setData({
      selectedModelType: modelType,
      selectedModel: modelName
    });

    let toastText = `已切换到${modelService.getModelDisplayName(modelType)}`;
    if (modelName) {
      toastText += ` (${modelName})`;
    }

    wx.showToast({
      title: toastText,
      icon: 'none'
    });
  },

  /**
   * 加载图片资源
   */
  loadImageResources() {
    // 预加载图片资源
    wx.getImageInfo({
      src: '/images/icons/emotion.png',
      fail: (err) => {
        console.error('加载图片资源失败:', err);
      }
    });

    wx.getImageInfo({
      src: '/images/icons/back.png',
      fail: (err) => {
        console.error('加载返回图标失败:', err);
      }
    });
  },

  /**
   * 判断是否显示时间戳
   * @param {Object} currentMsg 当前消息
   * @param {Object} prevMsg 前一条消息
   * @returns {boolean} 是否显示时间戳
   */
  shouldShowTimestamp(currentMsg, prevMsg) {
    // 如果没有前一条消息，显示时间戳
    if (!prevMsg) return true;

    // 如果是欢迎消息，始终显示时间戳
    if (currentMsg._id && currentMsg._id.startsWith('welcome_')) return true;

    // 如果是分段消息的第一段，显示时间戳
    if (currentMsg.isSegment && currentMsg.segmentIndex === 0) return true;

    // 如果是分段消息的非第一段，且前一条消息是同一原始消息的分段，不显示时间戳
    if (currentMsg.isSegment && currentMsg.segmentIndex > 0 &&
      prevMsg.isSegment && prevMsg.originalMessageId === currentMsg.originalMessageId) {
      return false;
    }

    // 确保两条消息都有有效的时间戳
    const currentTime = parseInt(currentMsg.timestamp) || Date.now();
    const prevTime = parseInt(prevMsg.timestamp) || Date.now();

    // 如果时间差超过5分钟，显示时间戳
    const FIVE_MINUTES = 5 * 60 * 1000; // 5分钟的毫秒数
    return Math.abs(currentTime - prevTime) > FIVE_MINUTES;
  },

  /**
   * 监听键盘高度变化
   */
  watchKeyboard() {
    // 监听键盘高度变化
    this.keyboardHeightChangeListener = wx.onKeyboardHeightChange(res => {
      const isKeyboardShow = res.height > 0;
      console.log('键盘高度变化:', res.height, '是否显示:', isKeyboardShow);

      // 设置数据
      this.setData({
        keyboardHeight: res.height,
        isKeyboardShow: isKeyboardShow,
        manualScroll: false // 键盘弹出时重置为自动滚动
      });

      // 键盘弹出或收起后，滚动到底部
      if (isKeyboardShow) {
        // 键盘弹出时，等待页面重新渲染后再滚动
        wx.nextTick(() => {
          // 使用多次延时滚动，确保滚动到底部
          setTimeout(() => {
            this.scrollToBottom(50, true); // 强制滚动到底部
          }, 100);

          // 再次滚动，确保在键盘完全显示后滚动到底部
          setTimeout(() => {
            this.scrollToBottom(50, true);
          }, 300);
        });
      } else {
        // 键盘收起时，等待页面重新渲染后再滚动
        wx.nextTick(() => {
          setTimeout(() => {
            this.scrollToBottom(100, true); // 强制滚动到底部
          }, 200);
        });
      }
    });
  },


  /**
   * 移除键盘监听
   */
  unwatchKeyboard() {
    if (this.keyboardHeightChangeListener) {
      wx.offKeyboardHeightChange(this.keyboardHeightChangeListener);
      this.keyboardHeightChangeListener = null;
    }
  },

  /**
 * 监听滚动事件
 */
  onScroll(e) {
    // 获取当前滚动位置
    const scrollTop = e.detail.scrollTop;

    // 如果向上滚动，标记为手动滚动模式
    if (scrollTop < this.data.lastScrollTop && !this.data.manualScroll) {
      this.setData({
        manualScroll: true
      });
    }

    // 更新上次滚动位置
    this.setData({
      lastScrollTop: scrollTop
    });

    // 检测是否滚动到底部，如果是则切换回自动滚动模式
    const query = wx.createSelectorQuery();
    query.select('#chat-container').boundingClientRect(rect => {
      if (rect) {
        const scrollViewHeight = rect.height;
        // 如果滚动到接近底部，切换回自动滚动
        if (scrollViewHeight - scrollTop < 100) {
          this.setData({
            manualScroll: false
          });
        }
      }
    }).exec();
  },

  /**
   * 滚动到底部
   * @param {number|Object} delayOrEvent 延迟时间或事件对象
   * @param {boolean} forceParam 是否强制滚动
   */
  scrollToBottom(delayOrEvent, forceParam) {
    // 初始化参数
    let delay = 100;
    let force = false;

    // 检查第一个参数类型
    if (typeof delayOrEvent === 'object' && delayOrEvent !== null) {
      // 如果是事件对象，则从数据集中获取force参数
      if (delayOrEvent.currentTarget && delayOrEvent.currentTarget.dataset) {
        force = delayOrEvent.currentTarget.dataset.force === 'true' || delayOrEvent.currentTarget.dataset.force === true;
        console.log('点击回到底部按钮，强制滚动:', force);
      }
    } else if (typeof delayOrEvent === 'number') {
      // 如果是数字，则作为延迟时间
      delay = delayOrEvent;
      // 如果有第二个参数，则作为强制滚动标志
      if (typeof forceParam === 'boolean') {
        force = forceParam;
      }
    }

    // 如果是从缓存加载的数据，增加延迟时间确保渲染完成
    const actualDelay = this.data.fromCache ? 300 : delay;

    // 打印调试信息
    console.log('滚动到底部函数被调用:', {
      delay,
      force,
      actualDelay,
      manualScroll: this.data.manualScroll,
      isKeyboardShow: this.data.isKeyboardShow,
      keyboardHeight: this.data.keyboardHeight
    });

    // 如果是手动滚动模式且不是强制滚动，则不执行滚动
    if (this.data.manualScroll && !force) {
      console.log('手动滚动模式且非强制滚动，不执行滚动');
      return;
    }

    // 如果是强制滚动，重置为自动滚动模式
    if (force) {
      this.setData({
        manualScroll: false
      });
    }

    // 强制滚动到底部
    setTimeout(() => {
      console.log('开始执行滚动操作');

      try {
        // 获取滚动容器
        const query = wx.createSelectorQuery();
        query.select('#chat-container').boundingClientRect().exec(res => {
          if (res && res[0]) {
            const containerHeight = res[0].height;
            console.log('滚动容器高度:', containerHeight);

            // 获取滚动元素
            const scrollView = wx.createSelectorQuery().select('#chat-container');
            scrollView.node().exec(nodeRes => {
              if (nodeRes && nodeRes[0] && nodeRes[0].node) {
                console.log('使用 scrollView 滚动到底部');
                const node = nodeRes[0].node;

                // 如果键盘弹出，考虑键盘高度
                if (this.data.isKeyboardShow && this.data.keyboardHeight > 0) {
                  // 先滚动到底部
                  node.scrollTo({
                    top: 100000, // 使用一个很大的值
                    behavior: 'smooth'
                  });

                  // 等待一段时间后再次滚动，确保滚动到正确位置
                  setTimeout(() => {
                    node.scrollTo({
                      top: 100000, // 使用一个很大的值
                      behavior: 'smooth'
                    });
                  }, 150);
                } else {
                  // 正常滚动到底部
                  node.scrollTo({
                    top: 100000, // 使用一个很大的值
                    behavior: 'smooth'
                  });
                }
              } else {
                console.log('使用 pageScrollTo 滚动到底部');
                // 如果无法获取节点，则使用页面滚动
                wx.pageScrollTo({
                  scrollTop: 100000, // 使用一个很大的值
                  duration: 300
                });
              }
            });
          } else {
            console.error('无法获取聊天容器元素');
          }
        });
      } catch (error) {
        console.error('滚动到底部时发生错误:', error);
        // 备用方法，直接使用页面滚动
        wx.pageScrollTo({
          scrollTop: 100000,
          duration: 300
        });
      }
    }, actualDelay);
  }

})

*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\chat\chat.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "聊天",
  "navigationStyle": "custom",
  "usingComponents": {
    "chat-bubble": "../../components/chat-bubble/index",
    "chat-input": "../../components/chat-input/index",
    "emotion-dashboard": "/components/emotion-dashboard/emotion-dashboard"
  }
}

*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\chat\chat.wxml*#*#*begin*#*#*
<!-- packageChat/pages/chat/chat.wxml -->
<view class="chat-page {{darkMode ? 'dark' : ''}} {{isKeyboardShow ? 'keyboard-show' : ''}}" style="--keyboard-height: {{keyboardHeight}}px;">
  <!-- 自定义导航栏 -->
  <view class="custom-nav" style="height: {{statusBarHeight + navBarHeight}}px;">
    <view class="status-bar" style="height: {{statusBarHeight}}px;"></view>
    <view class="nav-bar" style="height: {{navBarHeight}}px;">
      <view class="nav-left">
        <view class="back-btn" bindtap="handleBack">
          <image class="back-icon" src="/images/icons/back.png" mode="aspectFit"></image>
        </view>
      </view>
      <view class="nav-center">
        <!-- 角色名称，当发送消息时显示"对方正在输入..." -->
        <view class="role-title">
          <text wx:if="{{!sending}}">{{role.name || '未知角色'}}</text>
          <view wx:else class="typing-text">
            <text>对方正在输入</text>
            <text class="typing-dots">...</text>
          </view>
        </view>
      </view>
      <view class="nav-right">
        <!-- 模型选择器 -->
        <view class="model-selector-container">
          <model-selector darkMode="{{darkMode}}" bind:modelChange="handleModelChange"></model-selector>
        </view>
      </view>
    </view>
  </view>

  <!-- 聊天内容 -->
  <scroll-view class="chat-container"
               style="margin-top: {{statusBarHeight + navBarHeight + 10}}px;"
               scroll-y
               enable-back-to-top
               scroll-with-animation
               scroll-anchoring="true"
               enhanced="true"
               show-scrollbar="false"
               bindscrolltoupper="loadMoreHistory"
               bindscroll="onScroll"
               refresher-enabled="{{true}}"
               refresher-threshold="{{80}}"
               refresher-triggered="{{refreshing}}"
               bindrefresherrefresh="onRefresh"
               id="chat-container">
    <!-- 加载更多 -->
    <view class="loading-more" wx:if="{{loadingHistory}}">
      <view class="loading-spinner"></view>
      <text class="loading-text">加载更多...</text>
    </view>

    <!-- 没有更多历史 -->
    <view class="no-more-history" wx:if="{{!loadingHistory && !hasMoreHistory && messages.length > 0}}">
      <text class="no-more-text">没有更多历史消息</text>
    </view>

    <!-- 消息列表 -->
    <block wx:for="{{messages}}" wx:key="_id">
      <!-- 消息气泡 - 已在气泡组件中显示时间 -->
      <chat-bubble message="{{item}}"
                  isSender="{{item.sender_type === 'user'}}"
                  showTime="{{false}}"
                  showEmotionTag="{{true}}"
                  darkMode="{{darkMode}}"
                  bind:delete="handleDeleteMessage"></chat-bubble>
    </block>

    <!-- 加载中 -->
    <view class="loading-container" wx:if="{{loading}}">
      <view class="loading-spinner"></view>
      <text class="loading-text">加载中...</text>
    </view>

    <!-- AI正在输入 -->
    <view class="typing-indicator" wx:if="{{sending}}">
      <view class="typing-dot"></view>
      <view class="typing-dot"></view>
      <view class="typing-dot"></view>
    </view>

    <!-- 底部空白区域，确保最后一条消息不被输入框遮挡 -->
    <view class="bottom-space"></view>

    <!-- 滚动锚点 -->
    <view id="scroll-bottom" class="scroll-anchor"></view>
  </scroll-view>

  <!-- 情绪分析按钮 - 位于胶囊旁边 -->
  <view class="emotion-btn-container" style="top: {{statusBarHeight + navBarHeight + 30}}px; right: 0px;">
    <view class="emotion-btn" bindtap="handleShowEmotionAnalysis">
      <image class="emotion-icon" src="/images/icons/emotion.png" mode="aspectFit"></image>
    </view>
  </view>

  <!-- 回到底部按钮 -->
  <view class="to-bottom-btn {{manualScroll ? 'show' : ''}}" catchtap="scrollToBottom" data-force="true">
    <image class="to-bottom-icon" src="/images/icons/arrow-down.png" mode="aspectFit"></image>
  </view>

  <!-- 输入框 -->
  <view class="input-container">
    <chat-input placeholder="输入消息..."
               disabled="{{sending}}"
               darkMode="{{darkMode}}"
               bind:send="handleSendMessage"
               bind:sendVoice="handleSendVoice"
               bind:focus="handleInputFocus"
               bind:blur="handleInputBlur"></chat-input>
  </view>

  <!-- 情绪分析弹窗 -->
  <view class="emotion-modal {{showEmotionAnalysis ? 'show' : ''}}" bindtap="handleCloseEmotionAnalysis">
    <view class="emotion-modal-content" catchtap="stopPropagation">
      <!-- 使用情绪分析仪表盘组件 -->
      <emotion-dashboard
        userId="{{openId}}"
        emotionData="{{emotionAnalysis}}"
        show="{{showEmotionAnalysis}}"
        darkMode="{{darkMode}}"
        showCloseButton="{{true}}"
        bind:close="handleCloseEmotionAnalysis"
        bind:viewMore="handleViewEmotionDetail"
      ></emotion-dashboard>
    </view>
  </view>
</view>

<!-- 辅助函数 -->
<wxs module="formatTime">
  function format(timestamp) {
    try {
      // 将timestamp转换为数字
      var ts = parseInt(timestamp);

      // 检查timestamp是否有效
      if (!ts || isNaN(ts)) {
        console.log('无效时间戳:', timestamp, '转换后:', ts);
        return '今天';
      }

      var date = getDate(ts);
      // 检查date是否有效
      if (date.toString() === 'Invalid Date') {
        console.log('无效日期:', timestamp, '转换后:', ts);
        return '今天';
      }

      var year = date.getFullYear();
      var month = date.getMonth() + 1;
      var day = date.getDate();
      var hour = date.getHours();
      var minute = date.getMinutes();

      var now = getDate();
      var isToday = now.getFullYear() === year && now.getMonth() + 1 === month && now.getDate() === day;

      // 始终返回固定的时间格式
      return padZero(hour) + ':' + padZero(minute);
    } catch (e) {
      // 发生错误时返回空字符串
      return '';
    }
  }

  function padZero(num) {
    return num < 10 ? '0' + num : '' + num;
  }

  module.exports = format;
</wxs>

*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\chat\chat.wxss*#*#*begin*#*#*
/* packageChat/pages/chat/chat.wxss */
.chat-page {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #ededed; /* 参考微信背景色 */
  position: relative;
  overflow: hidden;
}

/* 暗夜模式 */
.dark {
  background-color: #1a1d20;
  color: #f8f9fa;
}

/* 键盘弹出时的样式 */
.keyboard-show {
  height: calc(100vh - var(--keyboard-height, 0px)); /* 动态调整高度 */
  position: relative;
  overflow: hidden;
  transition: height 0.3s ease; /* 添加平滑过渡效果 */
}

/* 自定义导航栏 */
.custom-nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background-color: #ededed;
  z-index: 1000;
  /* 添加阴影增强层次感 */
  box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.1);
}

.dark .custom-nav {
  background-color: #1a1d20;
}

.status-bar {
  width: 100%;
}

.nav-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  box-sizing: border-box;
  padding: 0 10px;
}

.nav-left {
  width: 87rpx;
  display: flex;
  align-items: center;
}

.back-btn {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  justify-content: center;
  align-items: center;
}

.back-icon {
  width: 40rpx;
  height: 40rpx;
}

.nav-center {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}

.role-title {
  font-size: 34rpx;
  font-weight: 500;
  color: #000000;
  text-align: center;
}

.dark .role-title {
  color: #f8f9fa;
}

.typing-text {
  font-size: 30rpx;
  color: #666666;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dark .typing-text {
  color: #adb5bd;
}

.typing-dots {
  display: inline-block;
  animation: typingDots 1.5s infinite;
  margin-left: 2rpx;
}

@keyframes typingDots {
  0% { opacity: 0.3; }
  50% { opacity: 1; }
  100% { opacity: 0.3; }
}

.nav-right {
  width: 87rpx;
}

/* 情绪分析按钮容器 */
.emotion-btn-container {
  position: fixed;
  z-index: 1001;
}

/* 情绪分析按钮样式 */
.emotion-btn {
  width: 80rpx;
  height: 80rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.9);
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.15);
  transition: all 0.2s ease;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.dark .emotion-btn {
  background-color: rgba(33, 37, 41, 0.85);
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.3);
}

.emotion-btn:active {
  transform: scale(0.95);
  background-color: rgba(0, 0, 0, 0.05);
}

.dark .emotion-btn:active {
  background-color: rgba(255, 255, 255, 0.1);
}

.emotion-icon {
  width: 48rpx;
  height: 48rpx;
  opacity: 0.8;
}

.dark .emotion-icon {
  opacity: 0.9;
  filter: brightness(1.2);
}

/* 聊天内容 */
.chat-container {
  flex: 1;
  padding: 20rpx 10rpx; /* 稍微增加左右内边距，使消息气泡与屏幕边缘有一定间距 */
  /* 调整顶部距离，适应新的自定义导航栏高度 - 在WXML中设置 */
  margin-bottom: 0; /* 移除底部边距，使聊天内容与输入框无缝衔接 */
  box-sizing: border-box;
  width: 100%; /* 确保容器占满全宽 */
  padding-bottom: 20rpx; /* 减少底部内边距，使聊天内容与输入框无缝衔接 */
  position: relative; /* 添加相对定位，使其能够正确定位 */
  z-index: 1; /* 确保在导航栏之下，输入框之上 */
  height: auto; /* 使用自适应高度，而不是固定高度 */
  overflow-y: auto; /* 添加滚动条 */
  transition: padding-bottom 0.3s ease; /* 添加过渡效果 */
}

/* 键盘弹出时的聊天容器样式 */
.keyboard-show .chat-container {
  padding-bottom: 120rpx; /* 保持固定的底部内边距 */
  height: calc(100vh - var(--keyboard-height) - 120rpx); /* 动态调整高度，减去键盘高度和输入框高度 */
  transition: height 0.3s ease; /* 添加平滑过渡效果 */
}

.dark .chat-container {
  background-color: #1a1d20;
}

/* 时间分割线 */
.time-divider {
  display: flex;
  justify-content: center;
  margin: 20rpx 0;
  width: 100%;
  height: 40rpx;
}

.time-text {
  font-size: 26rpx;
  color: #333333;
  background-color: #f0f0f0;
  padding: 10rpx 30rpx;
  border-radius: 30rpx;
  box-shadow: 0 4rpx 8rpx rgba(0, 0, 0, 0.1);
  font-weight: 500;
  min-width: 120rpx;
  text-align: center;
  border: 1rpx solid #dddddd;
  line-height: 1.2;
}

.dark .time-text {
  color: #f8f9fa;
  background-color: #343a40;
  border-color: #495057;
  box-shadow: 0 4rpx 8rpx rgba(0, 0, 0, 0.3);
}

/* 加载更多 */
.loading-more {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20rpx 0;
  width: 100%;
  height: 80rpx;
  background-color: transparent;
  margin: 10rpx 0;
}

.loading-spinner {
  width: 40rpx;
  height: 40rpx;
  border: 4rpx solid #f3f3f3;
  border-top: 4rpx solid #5e72e4;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 10rpx;
}

.loading-text {
  font-size: 24rpx;
  color: #999999;
  margin-left: 10rpx;
}

.dark .loading-text {
  color: #adb5bd;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* 没有更多历史 */
.no-more-history {
  display: flex;
  justify-content: center;
  padding: 20rpx 0;
}

.no-more-text {
  font-size: 24rpx;
  color: #999999;
}

.dark .no-more-text {
  color: #adb5bd;
}

/* 加载中 */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60rpx 0;
}

/* AI正在输入 */
.typing-indicator {
  display: flex;
  align-items: center;
  padding: 16rpx 24rpx;
  background-color: #f0f0f0;
  border-radius: 18rpx;
  width: fit-content;
  margin-bottom: 20rpx;
}

.dark .typing-indicator {
  background-color: #343a40;
}

/* 底部空白区域 */
.bottom-space {
  height: 150rpx; /* 增加高度，确保最后一条消息不被输入框遮挡 */
  width: 100%;
  transition: height 0.3s ease; /* 添加平滑过渡效果 */
}

/* 键盘弹出时的底部空白区域 */
.keyboard-show .bottom-space {
  height: 200rpx; /* 键盘弹出时使用固定高度，确保最后一条消息不被键盘遮挡 */
  transition: height 0.3s ease; /* 添加平滑过渡效果 */
}

.typing-dot {
  width: 10rpx;
  height: 10rpx;
  background-color: #999999;
  border-radius: 50%;
  margin: 0 6rpx;
  animation: typing 1.4s infinite ease-in-out;
}

.dark .typing-dot {
  background-color: #adb5bd;
}

.typing-dot:nth-child(1) {
  animation-delay: 0s;
}

.typing-dot:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes typing {
  0%, 60%, 100% { transform: translateY(0); }
  30% { transform: translateY(-10rpx); }
}

/* 输入框 */
.input-container {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: #ffffff;
  border-top: 1rpx solid #e2e8f0;
  padding: 20rpx 30rpx;
  /* 添加安全区域适配，但限制最大值 */
  padding-bottom: calc(20rpx + min(env(safe-area-inset-bottom), 20rpx));
  box-sizing: border-box;
  z-index: 100; /* 确保输入框始终在最上层 */
  box-shadow: 0 -2rpx 10rpx rgba(0, 0, 0, 0.05); /* 添加阴影，增强层次感 */
  /* 添加过渡效果，使键盘弹出时更平滑 */
  transition: all 0.3s ease;
}

/* 键盘弹出时的输入框样式 */
.keyboard-show .input-container {
  position: fixed;
  bottom: var(--keyboard-height, 0px);
  left: 0;
  right: 0;
  z-index: 1001; /* 确保在最上层 */
  transition: bottom 0.3s ease; /* 添加平滑过渡效果 */
  transform: translateZ(0); /* 启用硬件加速，使过渡更平滑 */
  will-change: bottom; /* 提前告知浏览器属性将变化，优化性能 */
}

.dark .input-container {
  background-color: #212529;
  border-top: 1rpx solid #343a40;
  box-shadow: 0 -2rpx 10rpx rgba(0, 0, 0, 0.2);
}

/* 移除旧的键盘弹出样式 */
/* 键盘弹出时输入框样式 - 已合并到上面的样式中，此处移除 */

/* 情绪分析弹窗样式 */
.emotion-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.emotion-modal.show {
  opacity: 1;
  visibility: visible;
}

.emotion-modal-content {
  width: 85%;
  max-height: 85%;
  background-color: #ffffff;
  border-radius: 20rpx;
  overflow-y: auto; /* 修改为auto，允许内容滚动 */
  transform: scale(0.9);
  transition: transform 0.3s ease;
  box-shadow: 0 8rpx 24rpx rgba(0, 0, 0, 0.15);
  /* 添加滚动条样式 */
  -webkit-overflow-scrolling: touch; /* 使iOS滚动更流畅 */
}

.dark .emotion-modal-content {
  background-color: #212529;
  box-shadow: 0 8rpx 24rpx rgba(0, 0, 0, 0.3);
}

.emotion-modal.show .emotion-modal-content {
  transform: scale(1);
}

/* 回到底部按钮 */
.to-bottom-btn {
  position: fixed;
  right: 0rpx;
  bottom: 200rpx;
  width: 80rpx;
  height: 80rpx;
  border-radius: 50%;
  background-color: rgba(74, 108, 247, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.15);
  z-index: 900;
  opacity: 0;
  transform: scale(0);
  transition: all 0.3s ease;
}

.to-bottom-btn.show {
  opacity: 1;
  transform: scale(1);
}

.dark .to-bottom-btn {
  background-color: rgba(74, 108, 247, 0.7);
}

.to-bottom-icon {
  width: 40rpx;
  height: 40rpx;
}

/* 滚动锚点 - 不可见但可用于滚动定位 */
.scroll-anchor {
  height: 1px;
  width: 100%;
  opacity: 0;
}
*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\emotion-analysis\emotion-analysis.js*#*#*begin*#*#*
// packageChat/pages/emotion-analysis/emotion-analysis.js

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

Page({
  /**
   * 页面的初始数据
   */
  data: {
    messageId: '',
    chatId: '',
    recordId: '',
    userId: '',
    roleId: '',
    emotionAnalysis: null,
    loading: true,
    darkMode: false,  // 暗黑模式状态
    historyData: [],  // 历史情绪数据
    statusBarHeight: 20, // 状态栏高度，默认值
    navBarHeight: 44,    // 导航栏高度，默认值
    menuButtonInfo: null, // 胶囊按钮信息
    navTotalHeight: 64,   // 导航栏总高度，默认值
    refreshing: false,    // 是否正在刷新
    lastRefreshTime: 0    // 上次刷新时间戳
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    const app = getApp();
    const userInfo = app.globalData.userInfo || {};

    // 获取暗黑模式设置
    const darkMode = wx.getStorageSync('darkMode') || false;

    this.setData({
      userId: userInfo.userId || '',
      darkMode: darkMode
    });

    // 延迟获取系统信息，避免页面加载时间过长
    wx.nextTick(() => {
      this.getSystemInfo();
    });

    // 检查是否使用缓存数据
    if (options.useCache === 'true' || options.useCache === true) {
      if (isDev) {
        console.log('使用缓存的情绪分析结果');
      }

      // 从全局变量中获取缓存的情绪分析结果
      const cachedEmotionAnalysis = app.globalData.cachedEmotionAnalysis;

      if (cachedEmotionAnalysis && cachedEmotionAnalysis.data) {
        this.setData({
          emotionAnalysis: cachedEmotionAnalysis.data,
          loading: false
        });

        // 延迟加载历史情绪数据，避免页面加载时间过长
        setTimeout(() => {
          this.loadHistoryEmotionData();
        }, 500);
        return;
      } else {
        if (isDev) {
          console.warn('全局变量中没有缓存的情绪分析结果，尝试从本地缓存中获取');
        }

        // 如果全局变量中没有，尝试从本地缓存中获取
        try {
          const localCachedResult = wx.getStorageSync('latestEmotionAnalysis');
          if (localCachedResult && localCachedResult.data) {
            this.setData({
              emotionAnalysis: localCachedResult.data,
              loading: false
            });

            // 延迟加载历史情绪数据，避免页面加载时间过长
            setTimeout(() => {
              this.loadHistoryEmotionData();
            }, 500);
            return;
          }
        } catch (e) {
          console.error('从本地缓存获取情绪分析结果失败:', e.message || e);
        }
      }
    }

    // 如果没有缓存数据或者不使用缓存，则根据参数加载数据
    if (options.messageId) {
      this.setData({
        messageId: options.messageId
      });
      this.loadEmotionAnalysis(options.messageId);
    } else if (options.chatId) {
      this.setData({
        chatId: options.chatId,
        roleId: options.roleId || ''
      });
      this.loadChatEmotionAnalysis(options.chatId);
    } else if (options.recordId) {
      this.setData({
        recordId: options.recordId
      });
      this.loadEmotionRecordAnalysis(options.recordId);
    } else if (!options.useCache) { // 只有当不是使用缓存时才显示错误
      wx.showToast({
        title: '参数错误',
        icon: 'error'
      });
      setTimeout(() => {
        wx.navigateBack();
      }, 1500);
    } else {
      // 如果没有任何参数，但使用缓存，则显示空状态
      this.setData({
        loading: false
      });
    }

    // 延迟加载历史情绪数据，避免页面加载时间过长
    setTimeout(() => {
      this.loadHistoryEmotionData();
    }, 500);
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {
    // 检查暗黑模式设置是否发生变化
    const darkMode = wx.getStorageSync('darkMode') || false;
    if (this.data.darkMode !== darkMode) {
      this.setData({ darkMode });
    }
  },

  /**
   * 加载单条消息的情绪分析
   */
  async loadEmotionAnalysis(messageId) {
    try {
      this.setData({ loading: true });

      const result = await wx.cloud.callFunction({
        name: 'analysis',
        data: {
          type: 'emotion',
          messageId
        }
      });

      if (result && result.result && result.result.success) {
        this.setData({
          emotionAnalysis: result.result.data,
          loading: false,
          refreshing: false
        });
      } else {
        throw new Error('获取情绪分析失败');
      }
    } catch (error) {
      console.error('加载情绪分析失败:', error.message || error);
      wx.showToast({
        title: '加载失败',
        icon: 'none'
      });
      this.setData({
        loading: false,
        refreshing: false
      });
    }
  },

  /**
   * 加载聊天的情绪分析
   */
  async loadChatEmotionAnalysis(chatId) {
    try {
      this.setData({ loading: true });

      const result = await wx.cloud.callFunction({
        name: 'analysis',
        data: {
          type: 'chat_emotion',
          chatId
        }
      });

      if (isDev) {
        console.log('聊天情绪分析结果获取成功');
      }

      if (result && result.result && result.result.success) {
        // 处理返回结果，兼容两种不同的返回结构
        let emotionData;
        if (result.result.data) {
          // 直接返回了data字段
          emotionData = result.result.data;
        } else if (result.result.result) {
          // 返回了result字段
          emotionData = result.result.result;
        } else {
          // 其他情况，使用整个result.result
          emotionData = result.result;
        }

        this.setData({
          emotionAnalysis: emotionData,
          loading: false,
          refreshing: false
        });
      } else {
        throw new Error('获取聊天情绪分析失败');
      }
    } catch (error) {
      console.error('加载聊天情绪分析失败:', error.message || error);
      wx.showToast({
        title: '加载失败',
        icon: 'none'
      });
      this.setData({
        loading: false,
        refreshing: false
      });
    }
  },

  /**
   * 加载情绪记录的情绪分析
   */
  async loadEmotionRecordAnalysis(recordId) {
    try {
      this.setData({ loading: true });

      const result = await wx.cloud.callFunction({
        name: 'analysis',
        data: {
          type: 'emotion_record',
          recordId
        }
      });

      if (result && result.result && result.result.success) {
        this.setData({
          emotionAnalysis: result.result.data,
          loading: false,
          refreshing: false
        });
      } else {
        throw new Error('获取情绪记录分析失败');
      }
    } catch (error) {
      console.error('加载情绪记录分析失败:', error.message || error);
      wx.showToast({
        title: '加载失败',
        icon: 'none'
      });
      this.setData({
        loading: false,
        refreshing: false
      });
    }
  },

  // 移除自定义返回按钮相关代码

  /**
   * 加载历史情绪数据
   */
  async loadHistoryEmotionData() {
    try {
      const userId = this.data.userId;
      if (!userId) {
        this.setData({ refreshing: false });
        return;
      }

      // 先尝试从本地缓存获取历史数据
      try {
        const cachedHistoryData = wx.getStorageSync('emotionHistoryData_' + userId);
        if (cachedHistoryData && Array.isArray(cachedHistoryData) && cachedHistoryData.length > 0) {
          // 检查缓存时间是否在24小时内
          const cacheTime = wx.getStorageSync('emotionHistoryDataTime_' + userId) || 0;
          const now = Date.now();
          const cacheAge = now - cacheTime;

          // 如果缓存不超过24小时，直接使用缓存数据
          if (cacheAge < 24 * 60 * 60 * 1000) {
            if (isDev) {
              console.log('使用缓存的历史情绪数据');
            }
            this.setData({
              historyData: cachedHistoryData,
              refreshing: false
            });
            return;
          }
        }
      } catch (cacheError) {
        console.error('读取缓存历史情绪数据失败:', cacheError.message || cacheError);
      }

      // 如果没有缓存或缓存过期，从数据库获取
      if (isDev) {
        console.log('从数据库获取历史情绪数据');
      }

      // 从数据库中获取近7天的情绪记录
      const db = wx.cloud.database();
      const _ = db.command;
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

      const result = await db.collection('emotionRecords')
        .where({
          userId: userId,
          createTime: _.gte(sevenDaysAgo)
        })
        .orderBy('createTime', 'asc')
        .limit(20) // 限制返回数量，避免数据过多
        .get();

      if (result && result.data) {
        // 更新页面数据
        this.setData({
          historyData: result.data,
          refreshing: false
        });

        // 缓存数据
        try {
          wx.setStorageSync('emotionHistoryData_' + userId, result.data);
          wx.setStorageSync('emotionHistoryDataTime_' + userId, Date.now());
          if (isDev) {
            console.log('历史情绪数据已缓存');
          }
        } catch (storageError) {
          console.error('缓存历史情绪数据失败:', storageError.message || storageError);
        }
      } else {
        this.setData({ refreshing: false });
      }
    } catch (error) {
      console.error('加载历史情绪数据失败:', error.message || error);
      this.setData({ refreshing: false });
    }
  },

  /**
   * 切换暗黑模式
   */
  toggleDarkMode() {
    const newDarkMode = !this.data.darkMode;
    this.setData({ darkMode: newDarkMode });
    wx.setStorageSync('darkMode', newDarkMode);
  },

  /**
   * 获取系统信息和导航栏高度
   */
  getSystemInfo: function() {
    try {
      // 获取系统信息
      const systemInfo = wx.getSystemInfoSync();
      // 获取胶囊按钮位置信息
      const menuButtonInfo = wx.getMenuButtonBoundingClientRect();

      // 计算导航栏高度，增加一点高度使其更美观
      const navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + 10;
      // 计算导航栏总高度（状态栏 + 导航栏）
      const navTotalHeight = systemInfo.statusBarHeight + navBarHeight;

      this.setData({
        statusBarHeight: systemInfo.statusBarHeight,
        navBarHeight: navBarHeight,
        navTotalHeight: navTotalHeight,
        menuButtonInfo: menuButtonInfo
      });

      if (isDev) {
        console.log('系统信息已获取');
        console.log('导航栏高度:', navBarHeight);
        console.log('导航栏总高度:', navTotalHeight);
      }
    } catch (e) {
      console.error('获取系统信息失败:', e.message || e);
    }
  },

  /**
   * 返回上一页
   */
  navigateBack: function() {
    wx.navigateBack({
      fail: function() {
        wx.switchTab({
          url: '/pages/home/home'
        });
      }
    });
  },

  /**
   * 分享情绪分析结果
   */
  shareEmotionAnalysis: function() {
    // 调用微信分享接口
    wx.showShareMenu({
      withShareTicket: true,
      menus: ['shareAppMessage', 'shareTimeline']
    });
  },

  /**
   * 导出情绪分析结果
   */
  exportEmotionAnalysis: function() {
    if (!this.data.emotionAnalysis) {
      wx.showToast({
        title: '暂无数据可导出',
        icon: 'none'
      });
      return;
    }

    // 生成导出数据
    const exportData = this.generateExportData();

    // 将数据保存到副本
    wx.setClipboardData({
      data: exportData,
      success: () => {
        wx.showToast({
          title: '已复制到副本',
          icon: 'success'
        });
      },
      fail: () => {
        wx.showToast({
          title: '导出失败',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 生成导出数据
   */
  generateExportData: function() {
    const emotion = this.data.emotionAnalysis;
    const date = new Date();
    const dateStr = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
    const timeStr = `${date.getHours()}:${date.getMinutes()}`;

    // 情绪类型映射
    const emotionMap = {
      'joy': '喜悦',
      'happy': '开心',
      'calm': '平静',
      'stable': '平稳',
      'anxiety': '焦虑',
      'anxious': '担忧',
      'anger': '愤怒',
      'angry': '生气',
      'sadness': '悲伤',
      'sad': '伤感',
      'sorrow': '忧伤',
      'fatigue': '疲惫',
      'surprise': '惊讶',
      'anticipation': '期待',
      'disgust': '厌恶',
      'disappointment': '失望',
      'urgency': '急切',
      'neutral': '中性'
    };

    // 主要情绪
    const primaryEmotion = emotion.type || emotion.primary_emotion || 'neutral';
    const emotionName = emotionMap[primaryEmotion] || primaryEmotion;

    // 生成导出文本
    let exportText = `【心语精灵情绪分析报告】\n`;
    exportText += `日期：${dateStr} ${timeStr}\n\n`;
    exportText += `主要情绪：${emotionName}\n`;
    exportText += `情绪强度：${Math.round(emotion.intensity * 100)}%\n`;
    exportText += `愉悦度：${Math.round(emotion.valence * 100)}%\n`;
    exportText += `激活度：${Math.round(emotion.arousal * 100)}%\n\n`;

    // 添加情绪维度
    if (emotion.radar_dimensions) {
      exportText += `情绪维度：\n`;
      const dimensions = emotion.radar_dimensions;
      exportText += `- 信任度：${Math.round(dimensions.trust || 0)}%\n`;
      exportText += `- 开放度：${Math.round(dimensions.openness || 0)}%\n`;
      exportText += `- 控制感：${Math.round(dimensions.control || 0)}%\n`;
      exportText += `- 抗拒度：${Math.round(dimensions.resistance || 0)}%\n`;
      exportText += `- 压力水平：${Math.round(dimensions.stress || 0)}%\n\n`;
    }

    // 添加关键词
    if (emotion.keywords && emotion.keywords.length > 0) {
      exportText += `关键词：`;
      emotion.keywords.forEach((keyword, index) => {
        const word = typeof keyword === 'string' ? keyword : keyword.word;
        exportText += word;
        if (index < emotion.keywords.length - 1) {
          exportText += '、';
        }
      });
      exportText += '\n\n';
    }

    // 添加建议
    if (emotion.suggestions && emotion.suggestions.length > 0) {
      exportText += `建议：\n`;
      emotion.suggestions.forEach((suggestion, index) => {
        exportText += `${index + 1}. ${suggestion}\n`;
      });
    }

    return exportText;
  },

  /**
   * 刷新数据
   */
  onRefresh: function() {
    // 防止频繁刷新，设置3秒内不能再次刷新
    const now = Date.now();
    if (now - this.data.lastRefreshTime < 3000) {
      this.setData({ refreshing: false });
      return;
    }

    this.setData({
      refreshing: true,
      lastRefreshTime: now
    });

    // 根据当前页面的参数重新加载数据
    if (this.data.messageId) {
      this.loadEmotionAnalysis(this.data.messageId);
    } else if (this.data.chatId) {
      this.loadChatEmotionAnalysis(this.data.chatId);
    } else if (this.data.recordId) {
      this.loadEmotionRecordAnalysis(this.data.recordId);
    } else {
      this.setData({ refreshing: false });
    }

    // 重新加载历史情绪数据
    this.loadHistoryEmotionData();
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function() {
    const app = getApp();
    const userInfo = app.globalData.userInfo || {};
    const username = userInfo.username || userInfo.nickname || '用户';

    // 根据情绪分析结果生成分享标题
    let title = `${username}的情绪分析`;
    if (this.data.emotionAnalysis && this.data.emotionAnalysis.type) {
      const emotionType = this.data.emotionAnalysis.type;
      const emotionMap = {
        'joy': '喜悦',
        'happy': '开心',
        'calm': '平静',
        'stable': '平稳',
        'anxiety': '焦虑',
        'anxious': '担忧',
        'anger': '愤怒',
        'angry': '生气',
        'sadness': '悲伤',
        'sad': '伤感',
        'sorrow': '忧伤',
        'fatigue': '疲惫',
        'surprise': '惊讶',
        'anticipation': '期待',
        'disgust': '厌恶',
        'disappointment': '失望',
        'urgency': '急切',
        'neutral': '中性'
      };
      const emotionName = emotionMap[emotionType] || emotionType;
      title = `${username}的情绪分析: ${emotionName}`;
    }

    return {
      title: title,
      path: '/pages/home/home',
      imageUrl: '/images/share-emotion.png' // 需要在项目中添加这个图片
    };
  },

  /**
   * 用户点击右上角分享到朋友圈
   */
  onShareTimeline: function() {
    const app = getApp();
    const userInfo = app.globalData.userInfo || {};
    const username = userInfo.username || userInfo.nickname || '用户';

    // 根据情绪分析结果生成分享标题
    let title = `${username}的情绪分析`;
    if (this.data.emotionAnalysis && this.data.emotionAnalysis.type) {
      const emotionType = this.data.emotionAnalysis.type;
      const emotionMap = {
        'joy': '喜悦',
        'happy': '开心',
        'calm': '平静',
        'stable': '平稳',
        'anxiety': '焦虑',
        'anxious': '担忧',
        'anger': '愤怒',
        'angry': '生气',
        'sadness': '悲伤',
        'sad': '伤感',
        'sorrow': '忧伤',
        'fatigue': '疲惫',
        'surprise': '惊讶',
        'anticipation': '期待',
        'disgust': '厌恶',
        'disappointment': '失望',
        'urgency': '急切',
        'neutral': '中性'
      };
      const emotionName = emotionMap[emotionType] || emotionType;
      title = `${username}的情绪分析显示主要情绪是: ${emotionName}`;
    }

    return {
      title: title,
      query: 'from=timeline',
      imageUrl: '/images/share-emotion.png' // 需要在项目中添加这个图片
    };
  }
})

*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\emotion-analysis\emotion-analysis.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "情绪分析",
  "navigationStyle": "custom",
  "usingComponents": {
    "emotion-analysis": "/components/emotion-analysis/emotion-analysis",
    "emotion-dashboard": "/components/emotion-dashboard/emotion-dashboard"
  },
  "disableScroll": true,
  "enablePullDownRefresh": false
}

*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\emotion-analysis\emotion-analysis.wxml*#*#*begin*#*#*
<!-- packageChat/pages/emotion-analysis/emotion-analysis.wxml -->
<view class="container {{darkMode ? 'dark-mode' : ''}}">
  <!-- 导航栏容器 -->
  <view class="nav-container">
    <!-- 状态栏占位 -->
    <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

    <!-- 自定义导航栏 -->
    <view class="nav-bar" style="height: {{navBarHeight}}px;">
      <view class="nav-bar-left">
        <view class="back-btn" bindtap="navigateBack">
          <view class="back-icon"></view>
        </view>
      </view>
      <view class="nav-bar-title">
        <text>情绪分析</text>
      </view>
      <view class="nav-bar-right">
        <view class="theme-switch" bindtap="toggleDarkMode">
          <view class="{{darkMode ? 'icon-moon' : 'icon-sun'}}"></view>
        </view>
      </view>
    </view>
  </view>

  <!-- 内容区域 -->
  <scroll-view
    class="content"
    style="margin-top: {{navTotalHeight}}px;"
    scroll-y="true"
    refresher-enabled="{{true}}"
    refresher-threshold="80"
    refresher-default-style="black"
    refresher-background="{{darkMode ? '#1a1a1a' : '#f8f9fa'}}"
    refresher-triggered="{{refreshing}}"
    bindrefresherrefresh="onRefresh">
    <block wx:if="{{loading}}">
      <view class="loading">
        <view class="loading-spinner"></view>
        <text class="loading-text">加载中...</text>
      </view>
    </block>
    <block wx:elif="{{emotionAnalysis}}">
      <!-- 使用新的情绪仪表盘组件 -->
      <view class="dashboard-wrapper">
        <emotion-dashboard
          emotionData="{{emotionAnalysis}}"
          show="{{true}}"
          userId="{{userId}}"
          historyData="{{historyData}}"
          darkMode="{{darkMode}}">
        </emotion-dashboard>

        <!-- 导出和分享按钮 -->
        <view class="action-buttons {{darkMode ? 'dark-mode' : ''}}">
          <button class="action-btn share-btn" bindtap="shareEmotionAnalysis">
            <view class="btn-icon share-icon"></view>
            <text>分享</text>
          </button>
          <button class="action-btn export-btn" bindtap="exportEmotionAnalysis">
            <view class="btn-icon export-icon"></view>
            <text>导出</text>
          </button>
        </view>
      </view>
    </block>
    <block wx:else>
      <view class="empty">
        <view class="empty-icon">
          <!-- 内联SVG图标 -->
          <view class="svg-container">
            <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
              <g fill="{{darkMode ? '#555555' : '#cccccc'}}">
                <path d="M32 2C15.432 2 2 15.432 2 32s13.432 30 30 30 30-13.432 30-30S48.568 2 32 2zm0 52c-12.15 0-22-9.85-22-22s9.85-22 22-22 22 9.85 22 22-9.85 22-22 22z"/>
                <path d="M20 24c0 2.21 1.79 4 4 4s4-1.79 4-4-1.79-4-4-4-4 1.79-4 4zm16 0c0 2.21 1.79 4 4 4s4-1.79 4-4-1.79-4-4-4-4 1.79-4 4zM44 40c0-6.627-5.373-12-12-12s-12 5.373-12 12h4c0-4.418 3.582-8 8-8s8 3.582 8 8h4z"/>
              </g>
            </svg>
          </view>
        </view>
        <text class="empty-text">暂无情绪分析数据</text>
      </view>
    </block>
  </scroll-view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\packageChat\pages\emotion-analysis\emotion-analysis.wxss*#*#*begin*#*#*
/* packageChat/pages/emotion-analysis/emotion-analysis.wxss */
.container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f8f9fa;
  transition: all 0.3s ease;
}

/* 暗黑模式 */
.dark-mode {
  background-color: #1a1a1a;
  color: #f0f0f0;
}

/* 导航栏相关样式 */
.nav-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  background-color: #ffffff;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.05);
  transition: all 0.3s ease;
}

.dark-mode .nav-container {
  background-color: #222222;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.2);
}

.status-bar {
  width: 100%;
}

.nav-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 30rpx;
  box-sizing: border-box;
  width: 100%;
}

.nav-bar-left, .nav-bar-right {
  display: flex;
  align-items: center;
  width: 120rpx;
}

.nav-bar-title {
  flex: 1;
  text-align: center;
  font-size: 36rpx;
  font-weight: 500;
  color: #333333;
}

.dark-mode .nav-bar-title {
  color: #f0f0f0;
}

.back-btn {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  align-items: center;
  justify-content: center;
}

.back-icon {
  width: 20rpx;
  height: 20rpx;
  border-top: 4rpx solid #333333;
  border-left: 4rpx solid #333333;
  transform: rotate(-45deg);
}

.dark-mode .back-icon {
  border-top: 4rpx solid #f0f0f0;
  border-left: 4rpx solid #f0f0f0;
}

.theme-switch {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  align-items: center;
  justify-content: center;
}

.icon-sun, .icon-moon {
  width: 40rpx;
  height: 40rpx;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

.icon-sun {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23333333"><path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"/></svg>');
}

.icon-moon {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23f0f0f0"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z" clip-rule="evenodd"/></svg>');
}

/* 内容区域样式 */
.content {
  flex: 1;
  padding: 30rpx;
  overflow-y: auto;
  box-sizing: border-box;
  width: 100%;
}

.dashboard-wrapper {
  position: relative;
}

/* 导出和分享按钮样式 */
.action-buttons {
  display: flex;
  justify-content: space-around;
  padding: 30rpx;
  margin-top: 20rpx;
  margin-bottom: 30rpx;
}

.action-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20rpx 40rpx;
  border-radius: 40rpx;
  background-color: #ffffff;
  color: #333333;
  font-size: 28rpx;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
  border: none;
  width: 45%;
}

.dark-mode .action-btn {
  background-color: #333333;
  color: #f0f0f0;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.3);
}

.btn-icon {
  width: 36rpx;
  height: 36rpx;
  margin-right: 10rpx;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

.share-icon {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%235e72e4"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/></svg>');
}

.dark-mode .share-icon {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%237e90ff"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/></svg>');
}

.export-icon {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2310B981"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>');
}

.dark-mode .export-icon {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2334D399"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>');
}

.loading, .empty {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 400rpx;
  color: #999999;
  font-size: 28rpx;
}

.dark-mode .loading, .dark-mode .empty {
  color: #b0b0b0;
}

.loading-spinner {
  width: 60rpx;
  height: 60rpx;
  border: 6rpx solid #f3f3f3;
  border-top: 6rpx solid #5e72e4;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 20rpx;
}

.dark-mode .loading-spinner {
  border: 6rpx solid #333333;
  border-top: 6rpx solid #7e90ff;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-text, .empty-text {
  font-size: 28rpx;
  color: #999999;
}

.dark-mode .loading-text, .dark-mode .empty-text {
  color: #b0b0b0;
}

.empty-icon {
  width: 120rpx;
  height: 120rpx;
  margin-bottom: 20rpx;
  display: flex;
  justify-content: center;
  align-items: center;
}

.svg-container {
  width: 100%;
  height: 100%;
}

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\daily-report\daily-report.js*#*#*begin*#*#*
// packageEmotion/pages/daily-report/daily-report.js
const reportService = require('../../../services/reportService');
const { formatDate, formatTime } = require('../../../utils/date');

// 引入 echarts
const echarts = require('../../../components/ec-canvas/echarts');

Page({
  /**
   * 页面的初始数据
   */
  data: {
    loading: true,
    report: null,
    date: '',
    formattedDate: '',
    error: '',
    chartRendered: false,
    darkMode: false,
    statusBarHeight: 20, // 状态栏高度，默认值
    navBarHeight: 44, // 导航栏高度，默认值
    emotionColorMap: {}, // 情绪颜色映射
    keywordTags: [], // 关键词标签数据
    // 我们不再需要标准化关键词数据，因为我们使用了关键词云
    // 默认的今日运势数据，当API返回的数据不完整时使用
    defaultFortune: {
      "good": ["放松心情", "与朋友交流", "阅读书籍", "适度运动"],
      "bad": ["过度劳累", "钻牛角尖", "情绪化决策", "忽视休息"]
    },
    // 添加 ec 对象用于图表初始化
    ec: {
      lazyLoad: true
    },
    emotionColors: {
      'happy': '#FFD700',
      'sad': '#6495ED',
      'angry': '#FF6347',
      'anxious': '#9370DB',
      'neutral': '#90EE90',
      'excited': '#FF69B4',
      'tired': '#A9A9A9',
      'relaxed': '#87CEEB',
      'surprised': '#FFA500',
      'confused': '#BA55D3'
    },
    darkModeEmotionColors: {
      'happy': '#f6e05e',     // 更暗的金色
      'sad': '#63b3ed',      // 更暗的蓝色
      'angry': '#fc8181',    // 更暗的红色
      'anxious': '#b794f4',  // 更暗的紫色
      'neutral': '#68d391',  // 更暗的绿色
      'excited': '#f687b3',  // 更暗的粉色
      'tired': '#cbd5e0',    // 更暗的灰色
      'relaxed': '#76e4f7',  // 更暗的浅蓝色
      'surprised': '#fbd38d', // 更暗的橙色
      'confused': '#d6bcfa'  // 更暗的淡紫色
    }
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 获取当前日期
    const today = new Date();
    const dateStr = formatDate(today);

    // 如果有传入日期参数，使用传入的日期
    let targetDate = options.date || dateStr;
    let reportId = options.id || '';

    // 获取系统信息和导航栏高度
    this.getSystemInfo();

    // 检测系统暗夜模式
    this.checkDarkMode();

    // 监听系统主题变化
    wx.onThemeChange((result) => {
      this.setData({
        darkMode: result.theme === 'dark'
      });
      // 更新全局数据
      const app = getApp();
      if (app.globalData) {
        app.globalData.darkMode = result.theme === 'dark';
      }
    });

    this.setData({
      date: targetDate,
      formattedDate: this.formatDisplayDate(targetDate)
    });

    // 加载报告数据
    if (reportId) {
      this.loadReportById(reportId);
    } else {
      this.loadReport(targetDate);
    }
  },

  /**
   * 获取系统信息和导航栏高度
   */
  getSystemInfo: function() {
    try {
      // 获取系统信息
      const systemInfo = wx.getSystemInfoSync();
      // 获取胶囊按钮位置信息
      const menuButtonInfo = wx.getMenuButtonBoundingClientRect();

      // 计算导航栏高度，增加一点高度使其更美观
      const navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + 10;

      this.setData({
        statusBarHeight: systemInfo.statusBarHeight,
        navBarHeight: navBarHeight
      });

      console.log('导航栏高度:', navBarHeight);
    } catch (e) {
      console.error('获取系统信息失败:', e);
    }
  },

  /**
   * 处理返回按钮点击
   */
  handleBack: function() {
    wx.navigateBack({
      fail: () => {
        wx.switchTab({
          url: '/pages/home/home'
        });
      }
    });
  },

  /**
   * 页面渲染完成
   */
  onReady: function () {
    // 页面渲染完成后，如果有报告数据，渲染图表
    if (this.data.report && !this.data.chartRendered) {
      this.renderCharts();
    }
  },

  /**
   * 监听页面显示
   */
  onShow: function () {
    // 优先使用本地缓存中的 darkMode 设置
    let newDarkMode = this.data.darkMode;
    let shouldUpdateDarkMode = false;

    try {
      const localDarkMode = wx.getStorageSync('darkMode');
      if (localDarkMode !== undefined && localDarkMode !== null) {
        // 确保 localDarkMode 是布尔值
        newDarkMode = typeof localDarkMode === 'boolean' ? localDarkMode : localDarkMode === 'true';
        shouldUpdateDarkMode = this.data.darkMode !== newDarkMode;
        console.log('每日报告页面onShow从本地缓存读取暗黑模式设置:', newDarkMode, '是否需要更新:', shouldUpdateDarkMode);
      } else {
        // 如果本地缓存中没有设置，则使用全局状态
        const app = getApp();
        if (app.globalData && app.globalData.darkMode !== undefined) {
          newDarkMode = app.globalData.darkMode;
          shouldUpdateDarkMode = this.data.darkMode !== newDarkMode;
          console.log('每日报告页面onShow使用全局状态暗黑模式设置:', newDarkMode, '是否需要更新:', shouldUpdateDarkMode);
        }
      }
    } catch (e) {
      console.error('每日报告页面onShow从本地缓存读取darkMode失败:', e);
    }

    // 如果暗黑模式状态变化，更新UI和图表
    if (shouldUpdateDarkMode) {
      this.setData({
        darkMode: newDarkMode,
        // 清空颜色映射，强制重新生成颜色
        emotionColorMap: {}
      });

      // 重新渲染图表
      if (this.data.report) {
        this.renderCharts(this.data.report);
      }
    }

    // 如果图表实例已经初始化，刷新图表
    if (this.chart) {
      this.chart.resize();
    }
  },

  /**
   * 初始化图表组件
   */
  initChart: function(chartId, callback) {
    const chartComponent = this.selectComponent('#' + chartId);
    if (!chartComponent) {
      console.error(`图表组件 #${chartId} 不存在`);
      return;
    }

    chartComponent.init((canvas, width, height, dpr) => {
      // 初始化图表
      const chart = echarts.init(canvas, null, {
        width: width,
        height: height,
        devicePixelRatio: dpr
      });

      // 设置加载动画，根据暗夜模式调整样式
      const isDarkMode = this.data.darkMode;
      chart.showLoading({
        text: '数据加载中',
        color: isDarkMode ? '#63b3ed' : '#5470c6',
        textColor: isDarkMode ? '#e2e8f0' : '#000',
        maskColor: isDarkMode ? 'rgba(45, 55, 72, 0.8)' : 'rgba(255, 255, 255, 0.8)',
        zlevel: 0
      });

      // 调用回调函数设置图表选项
      callback(chart);

      // 隐藏加载动画
      chart.hideLoading();

      // 返回图表实例
      return chart;
    });
  },

  /**
   * 加载指定日期的报告
   */
  loadReport: async function (date, forceRegenerate = false) {
    try {
      this.setData({ loading: true, error: '' });

      const result = await reportService.getDailyReport(date, forceRegenerate);

      if (result.success) {
        // 检查报告中的今日运势数据是否完整
        const report = result.report;
        console.log('原始报告数据:', JSON.stringify(report));

        if (!report.fortune || (!report.fortune.good && !report.fortune.bad)) {
          // 如果今日运势数据不存在或不完整，使用默认数据
          console.log('今日运势数据不存在或不完整，使用默认数据');
          report.fortune = this.data.defaultFortune;
        } else {
          // 如果只缺少其中一项，补充缺失的部分
          if (!report.fortune.good || !Array.isArray(report.fortune.good) || report.fortune.good.length === 0) {
            console.log('今日运势缺少宜数据，使用默认数据');
            report.fortune.good = this.data.defaultFortune.good;
          }
          if (!report.fortune.bad || !Array.isArray(report.fortune.bad) || report.fortune.bad.length === 0) {
            console.log('今日运势缺少忌数据，使用默认数据');
            report.fortune.bad = this.data.defaultFortune.bad;
          }
        }

        console.log('处理后的报告数据:', JSON.stringify(report.fortune));

        this.setData({
          report: report,
          loading: false
        });

        // 标记报告为已读
        if (result.report._id) {
          reportService.markReportAsRead(result.report._id);
        }

        // 渲染图表
        this.renderCharts();
      } else {
        this.setData({
          loading: false,
          error: result.error || '加载报告失败'
        });
      }
    } catch (error) {
      console.error('加载报告失败:', error);
      this.setData({
        loading: false,
        error: error.message || '加载报告失败'
      });
    }
  },

  /**
   * 通过ID加载报告
   */
  loadReportById: async function (reportId) {
    try {
      this.setData({ loading: true, error: '' });

      const db = wx.cloud.database();
      const { data } = await db.collection('userReports').doc(reportId).get();

      if (data) {
        // 检查报告中的今日运势数据是否完整
        const report = data;
        console.log('通过ID加载的原始报告数据:', JSON.stringify(report));

        if (!report.fortune || (!report.fortune.good && !report.fortune.bad)) {
          // 如果今日运势数据不存在或不完整，使用默认数据
          console.log('通过ID加载: 今日运势数据不存在或不完整，使用默认数据');
          report.fortune = this.data.defaultFortune;
        } else {
          // 如果只缺少其中一项，补充缺失的部分
          if (!report.fortune.good || !Array.isArray(report.fortune.good) || report.fortune.good.length === 0) {
            console.log('通过ID加载: 今日运势缺少宜数据，使用默认数据');
            report.fortune.good = this.data.defaultFortune.good;
          }
          if (!report.fortune.bad || !Array.isArray(report.fortune.bad) || report.fortune.bad.length === 0) {
            console.log('通过ID加载: 今日运势缺少忌数据，使用默认数据');
            report.fortune.bad = this.data.defaultFortune.bad;
          }
        }

        console.log('通过ID加载: 处理后的报告数据:', JSON.stringify(report.fortune));

        this.setData({
          report: report,
          date: formatDate(new Date(report.date)),
          formattedDate: this.formatDisplayDate(formatDate(new Date(report.date))),
          loading: false
        });

        // 标记报告为已读
        reportService.markReportAsRead(reportId);

        // 渲染图表
        this.renderCharts();
      } else {
        this.setData({
          loading: false,
          error: '报告不存在'
        });
      }
    } catch (error) {
      console.error('通过ID加载报告失败:', error);
      this.setData({
        loading: false,
        error: error.message || '加载报告失败'
      });
    }
  },

  /**
   * 渲染图表
   */
  renderCharts: function () {
    if (!this.data.report || !this.data.report.chartData) {
      return;
    }

    const report = this.data.report;

    // 生成随机颜色数组
    const generateRandomColors = (count, isDarkMode) => {
      const brightColors = [
        '#FF6347', '#FFD700', '#6495ED', '#9370DB', '#90EE90',
        '#FF69B4', '#87CEEB', '#FFA500', '#BA55D3', '#20B2AA',
        '#FF7F50', '#7B68EE', '#00FA9A', '#FF1493', '#00BFFF',
        '#F4A460', '#D8BFD8', '#1E90FF', '#FF6347', '#32CD32'
      ];

      const darkColors = [
        '#fc8181', '#f6e05e', '#63b3ed', '#b794f4', '#68d391',
        '#f687b3', '#76e4f7', '#fbd38d', '#d6bcfa', '#38b2ac',
        '#fc8181', '#9f7aea', '#48bb78', '#ed64a6', '#4299e1',
        '#ed8936', '#b794f4', '#3182ce', '#fc8181', '#48bb78'
      ];

      const colors = isDarkMode ? darkColors : brightColors;
      const result = [];

      for (let i = 0; i < count; i++) {
        result.push(colors[i % colors.length]);
      }

      return result;
    };

    // 生成随机颜色并保存到数据中
    const randomColors = generateRandomColors(report.chartData.emotionDistribution.length, this.data.darkMode);

    // 创建情绪颜色映射对象
    const emotionColorMap = {};
    report.chartData.emotionDistribution.forEach((item, index) => {
      emotionColorMap[item.type] = randomColors[index];
    });

    // 我们不再需要标准化关键词数据，因为我们使用了关键词云
    this.setData({
      emotionColorMap: emotionColorMap
    });

    // 渲染情绪分布饼图
    this.renderEmotionDistributionChart(report.chartData.emotionDistribution);

    // 渲染情绪强度趋势图
    if (report.chartData.intensityTrend && report.chartData.intensityTrend.length > 0) {
      this.renderIntensityTrendChart(report.chartData.intensityTrend);
    }

    // 渲染关键词云
    this.renderKeywordCloud(report.keywords);

    // 渲染关注点分析图
    if (report.focusPoints && report.focusPoints.length > 0) {
      this.renderFocusPointsChart(report.focusPoints);
    }

    this.setData({ chartRendered: true });
  },

  /**
   * 渲染情绪分布饼图
   */
  renderEmotionDistributionChart: function (emotionDistribution) {
    if (!emotionDistribution || emotionDistribution.length === 0) {
      return;
    }

    // 使用已生成的颜色映射
    const emotionColorMap = this.data.emotionColorMap || {};

    // 准备数据
    const pieData = emotionDistribution.map(item => ({
      name: item.type,
      value: item.count,
      percent: parseFloat(item.percentage),
      itemStyle: {
        color: emotionColorMap[item.type] || (this.data.darkMode ? '#4a5568' : '#CCCCCC')
      }
    }));

    // 使用新的 initChart 方法初始化图表
    this.initChart('emotionPieChart', (chart) => {
      // 根据暗夜模式设置图表样式
      const isDarkMode = this.data.darkMode;
      const textColor = isDarkMode ? '#e2e8f0' : '#333333';
      const tooltipBgColor = isDarkMode ? 'rgba(45, 55, 72, 0.9)' : 'rgba(255, 255, 255, 0.9)';
      const tooltipBorderColor = isDarkMode ? '#4a5568' : '#ccc';
      const tooltipTextColor = isDarkMode ? '#e2e8f0' : '#333';
      const tooltipShadow = isDarkMode ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
      const borderColor = isDarkMode ? '#2d3748' : '#fff';

      const option = {
        title: {
          text: '情绪分布',
          left: 'center',
          top: 0,
          textStyle: {
            fontSize: 14,
            fontWeight: 'normal',
            color: textColor
          }
        },
        tooltip: {
          trigger: 'item',
          formatter: '{b}: {c} 次 ({d}%)',
          backgroundColor: tooltipBgColor,
          borderColor: tooltipBorderColor,
          borderWidth: 1,
          textStyle: {
            color: tooltipTextColor
          },
          extraCssText: `box-shadow: 0 0 8px ${tooltipShadow};`
        },
        legend: {
          type: 'scroll',
          orient: 'horizontal',
          bottom: 0,
          data: pieData.map(item => item.name),
          textStyle: {
            fontSize: 12,
            color: textColor
          },
          pageIconColor: textColor,
          pageIconInactiveColor: isDarkMode ? '#4a5568' : '#ccc',
          pageIconSize: 12,
          pageTextStyle: {
            fontSize: 12,
            color: textColor
          },
          selectedMode: false
        },
        series: [{
          name: '情绪分布',
          type: 'pie',
          radius: ['40%', '60%'],
          center: ['50%', '45%'],
          avoidLabelOverlap: true,
          itemStyle: {
            borderRadius: 4,
            borderColor: borderColor,
            borderWidth: 2
          },
          label: {
            show: true,
            position: 'outside',
            formatter: '{b}: {d}%',
            fontSize: 12,
            color: textColor
          },
          labelLine: {
            show: true,
            length: 10,
            length2: 10,
            smooth: true,
            lineStyle: {
              color: isDarkMode ? 'rgba(226, 232, 240, 0.3)' : 'rgba(0, 0, 0, 0.3)'
            }
          },
          emphasis: {
            label: {
              show: true,
              fontSize: 14,
              fontWeight: 'bold',
              color: textColor
            },
            itemStyle: {
              shadowBlur: 10,
              shadowOffsetX: 0,
              shadowColor: isDarkMode ? 'rgba(0, 0, 0, 0.7)' : 'rgba(0, 0, 0, 0.5)'
            }
          },
          data: pieData,
          animationType: 'scale',
          animationEasing: 'elasticOut',
          animationDelay: function () {
            return Math.random() * 200;
          }
        }]
      };

      chart.setOption(option);
    });
  },

  /**
   * 渲染情绪强度趋势图
   */
  renderIntensityTrendChart: function (intensityTrend) {
    if (!intensityTrend || intensityTrend.length === 0) {
      return;
    }

    // 准备数据
    const times = intensityTrend.map(item => formatTime(new Date(item.timestamp)));
    const intensities = intensityTrend.map(item => item.intensity);

    // 计算移动平均线，平滑展示趋势
    const movingAvg = [];
    const windowSize = 3; // 移动平均窗口大小

    for (let i = 0; i < intensities.length; i++) {
      let sum = 0;
      let count = 0;

      for (let j = Math.max(0, i - windowSize + 1); j <= i; j++) {
        sum += intensities[j];
        count++;
      }

      movingAvg.push(sum / count);
    }

    // 使用新的 initChart 方法初始化图表
    this.initChart('intensityChart', (chart) => {
      // 根据暗夜模式设置图表样式
      const isDarkMode = this.data.darkMode;
      const textColor = isDarkMode ? '#e2e8f0' : '#333333';
      const tooltipBgColor = isDarkMode ? 'rgba(45, 55, 72, 0.9)' : 'rgba(255, 255, 255, 0.9)';
      const tooltipBorderColor = isDarkMode ? '#4a5568' : '#ccc';
      const tooltipTextColor = isDarkMode ? '#e2e8f0' : '#333';
      const axisLineColor = isDarkMode ? '#4a5568' : '#ccc';
      const splitLineColor = isDarkMode ? 'rgba(74, 85, 104, 0.3)' : 'rgba(0, 0, 0, 0.1)';

      const option = {
        title: {
          text: '情绪强度变化',
          left: 'center',
          top: 0,
          textStyle: {
            fontSize: 14,
            fontWeight: 'normal',
            color: textColor
          }
        },
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'cross',
            label: {
              backgroundColor: isDarkMode ? '#4a5568' : '#6a7985',
              color: textColor
            }
          },
          backgroundColor: tooltipBgColor,
          borderColor: tooltipBorderColor,
          borderWidth: 1,
          textStyle: {
            color: tooltipTextColor
          },
          formatter: function(params) {
            const time = params[0].axisValue;
            let result = `${time}<br/>`;

            params.forEach(param => {
              const marker = `<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>`;
              result += `${marker}${param.seriesName}: ${(param.value * 100).toFixed(0)}%<br/>`;
            });

            return result;
          }
        },
        legend: {
          data: ['实际强度', '趋势线'],
          bottom: 0,
          textStyle: {
            color: textColor
          }
        },
        grid: {
          left: '3%',
          right: '4%',
          bottom: '10%',
          top: '15%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          boundaryGap: false,
          data: times,
          axisLabel: {
            interval: Math.floor(times.length / 5),
            rotate: 30,
            color: textColor
          },
          axisLine: {
            lineStyle: {
              color: axisLineColor
            }
          },
          axisTick: {
            lineStyle: {
              color: axisLineColor
            }
          }
        },
        yAxis: {
          type: 'value',
          min: 0,
          max: 1,
          axisLabel: {
            formatter: function(value) {
              return (value * 100).toFixed(0) + '%';
            },
            color: textColor
          },
          axisLine: {
            lineStyle: {
              color: axisLineColor
            }
          },
          axisTick: {
            lineStyle: {
              color: axisLineColor
            }
          },
          splitLine: {
            lineStyle: {
              color: splitLineColor,
              type: 'dashed'
            }
          }
        },
        series: [
          {
            name: '实际强度',
            type: 'line',
            symbol: 'emptyCircle',
            symbolSize: 6,
            sampling: 'average',
            itemStyle: {
              color: isDarkMode ? '#63b3ed' : '#5470c6'
            },
            lineStyle: {
              width: 3,
              color: isDarkMode ? '#63b3ed' : '#5470c6'
            },
            areaStyle: {
              color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                {
                  offset: 0,
                  color: isDarkMode ? 'rgba(99, 179, 237, 0.5)' : 'rgba(84, 112, 198, 0.5)'
                },
                {
                  offset: 1,
                  color: isDarkMode ? 'rgba(99, 179, 237, 0.1)' : 'rgba(84, 112, 198, 0.1)'
                }
              ])
            },
            data: intensities
          },
          {
            name: '趋势线',
            type: 'line',
            symbol: 'none',
            smooth: true,
            lineStyle: {
              width: 2,
              type: 'dashed',
              color: isDarkMode ? '#68d391' : '#91cc75'
            },
            data: movingAvg
          }
        ],
        animationDuration: 1000,
        animationEasing: 'cubicOut'
      };

      chart.setOption(option);
    });
  },

  /**
   * 处理关键词数据
   */
  renderKeywordCloud: function (keywords) {
    if (!keywords || keywords.length === 0) {
      return;
    }

    // 准备数据
    const keywordsToUse = keywords.slice(0, 20); // 使用前20个关键词

    // 计算权重总和，用于标准化
    let totalWeight = 0;
    keywordsToUse.forEach(item => {
      totalWeight += item.weight;
    });

    // 生成颜色列表
    const isDarkMode = this.data.darkMode;
    const colorList = isDarkMode ? [
      '#63b3ed', '#68d391', '#fbd38d', '#fc8181', '#76e4f7',
      '#4fd1c5', '#fbd38d', '#b794f4', '#f687b3', '#cbd5e0'
    ] : [
      '#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de',
      '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc', '#6e7079'
    ];

    // 处理关键词数据
    const keywordTags = keywordsToUse.map((item) => {
      // 标准化权重
      const percentage = totalWeight > 0 ? (item.weight / totalWeight * 100) : 0;
      // 计算字体大小，范围从14到30
      const fontSize = Math.max(14, Math.min(30, 14 + percentage * 0.5));

      // 使用关键词名称生成一致的颜色
      let seed = 0;
      for (let i = 0; i < item.word.length; i++) {
        seed += item.word.charCodeAt(i);
      }
      const colorIndex = seed % colorList.length;
      const color = colorList[colorIndex];

      return {
        word: item.word,
        weight: item.weight,
        percentage: percentage,
        fontSize: fontSize,
        color: color
      };
    });

    // 随机排序，避免每次显示顺序相同
    keywordTags.sort(() => Math.random() - 0.5);

    // 更新到页面数据
    this.setData({
      keywordTags: keywordTags
    });
  },

  /**
   * 获取随机颜色
   */
  getRandomColor: function () {
    const colors = [
      '#6495ED', '#FF6347', '#FFD700', '#9370DB',
      '#90EE90', '#FF69B4', '#A9A9A9', '#87CEEB',
      '#FFA500', '#BA55D3'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  },

  /**
   * 格式化显示日期
   */
  formatDisplayDate: function (dateStr) {
    const date = new Date(dateStr);
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const weekdays = ['日', '一', '二', '三', '四', '五', '六'];
    const weekday = weekdays[date.getDay()];

    return `${year}年${month}月${day}日 星期${weekday}`;
  },

  /**
   * 渲染关注点分析图
   */
  renderFocusPointsChart: function (focusPoints) {
    if (!focusPoints || focusPoints.length === 0) {
      return;
    }

    // 准备数据
    const data = focusPoints.map(item => ({
      name: item.category,
      value: item.percentage
    }));

    // 按百分比排序
    data.sort((a, b) => b.value - a.value);

    // 生成颜色映射，为每个关注点类别分配不同的颜色
    const isDarkMode = this.data.darkMode;
    const colorPalette = isDarkMode ? [
      '#63b3ed', '#68d391', '#fbd38d', '#fc8181', '#76e4f7',
      '#4fd1c5', '#fbd38d', '#b794f4', '#f687b3', '#cbd5e0'
    ] : [
      '#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de',
      '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc', '#6e7079'
    ];

    // 为每个关注点类别分配颜色
    const categoryColors = {};
    data.forEach((item, index) => {
      categoryColors[item.name] = colorPalette[index % colorPalette.length];
    });

    // 将颜色映射保存到页面数据中，供列表使用
    this.setData({
      categoryColors: categoryColors
    });

    // 使用新的 initChart 方法初始化图表
    this.initChart('focusChart', (chart) => {
      // 根据暗夜模式设置图表样式
      const textColor = isDarkMode ? '#e2e8f0' : '#333333';
      const tooltipBgColor = isDarkMode ? 'rgba(45, 55, 72, 0.9)' : 'rgba(255, 255, 255, 0.9)';
      const tooltipBorderColor = isDarkMode ? '#4a5568' : '#ccc';
      const tooltipTextColor = isDarkMode ? '#e2e8f0' : '#333';
      const axisLineColor = isDarkMode ? '#4a5568' : '#ccc';
      const splitLineColor = isDarkMode ? 'rgba(74, 85, 104, 0.3)' : 'rgba(0, 0, 0, 0.1)';

      const option = {
        title: {
          text: '关注点分析',
          left: 'center',
          top: 0,
          textStyle: {
            fontSize: 16,  // 增大标题字体
            fontWeight: 'bold',  // 加粗标题
            color: textColor
          }
        },
        color: colorPalette,
        tooltip: {
          trigger: 'item',
          formatter: '{b}: {c}%',
          backgroundColor: tooltipBgColor,
          borderColor: tooltipBorderColor,
          borderWidth: 1,
          textStyle: {
            color: tooltipTextColor
          }
        },
        radar: {
          indicator: data.map(item => ({
            name: item.name,
            max: 100
          })),
          radius: '70%',  // 增大雷达图半径
          center: ['50%', '55%'],
          name: {
            textStyle: {
              color: textColor,
              fontSize: 14,  // 增大指示器文字大小
              fontWeight: 'bold',  // 加粗指示器文字
              backgroundColor: isDarkMode ? 'rgba(45, 55, 72, 0.7)' : 'rgba(255, 255, 255, 0.7)',  // 添加背景色
              borderRadius: 3,  // 添加圆角
              padding: [3, 5]  // 添加内边距
            }
          },
          splitArea: {
            areaStyle: {
              color: isDarkMode ? [
                'rgba(45, 55, 72, 0.4)',  // 增强对比度
                'rgba(45, 55, 72, 0.3)',
                'rgba(45, 55, 72, 0.2)',
                'rgba(45, 55, 72, 0.1)'
              ] : [
                'rgba(250, 250, 250, 0.6)',  // 增强对比度
                'rgba(240, 240, 240, 0.6)',
                'rgba(230, 230, 230, 0.6)',
                'rgba(220, 220, 220, 0.6)'
              ]
            }
          },
          axisLine: {
            lineStyle: {
              color: axisLineColor,
              width: 2  // 增加轴线宽度
            }
          },
          splitLine: {
            lineStyle: {
              color: splitLineColor,
              width: 2  // 增加分割线宽度
            }
          }
        },
        series: [{
          name: '关注点分布',
          type: 'radar',
          data: [{
            value: data.map(item => item.value),
            name: '关注度',
            areaStyle: {
              color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
                offset: 0,
                color: isDarkMode ? 'rgba(99, 179, 237, 0.8)' : 'rgba(84, 112, 198, 0.8)'  // 增强透明度
              }, {
                offset: 1,
                color: isDarkMode ? 'rgba(99, 179, 237, 0.2)' : 'rgba(84, 112, 198, 0.2)'  // 增强透明度
              }])
            },
            lineStyle: {
              color: isDarkMode ? '#63b3ed' : '#5470c6',
              width: 3  // 增加线条宽度
            },
            itemStyle: {
              color: isDarkMode ? '#63b3ed' : '#5470c6',
              borderColor: isDarkMode ? '#fff' : '#fff',  // 添加白色边框
              borderWidth: 2,  // 设置边框宽度
              shadowBlur: 5,  // 添加阴影
              shadowColor: 'rgba(0, 0, 0, 0.3)'  // 阴影颜色
            },
            emphasis: {  // 添加鼠标悬停效果
              itemStyle: {
                borderColor: isDarkMode ? '#fff' : '#fff',
                borderWidth: 3,
                shadowBlur: 10,
                shadowColor: 'rgba(0, 0, 0, 0.5)'
              }
            }
          }]
        }],
        animationDuration: 1000,
        animationEasing: 'elasticOut'  // 使用弹性动画效果
      };

      chart.setOption(option);
    });
  },

  /**
   * 日期选择器变化事件
   */
  bindDateChange: function (e) {
    const date = e.detail.value;
    this.setData({
      date: date,
      formattedDate: this.formatDisplayDate(date)
    });

    // 加载新日期的报告
    this.loadReport(date);
  },

  /**
   * 重新生成报告
   */
  regenerateReport: function () {
    this.loadReport(this.data.date, true);
  },

  /**
   * 分享报告
   */
  shareReport: function () {
    // 实现分享功能
    wx.showToast({
      title: '分享功能开发中',
      icon: 'none'
    });
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {
    const reportId = this.data.report ? this.data.report._id : '';
    return {
      title: `${this.data.formattedDate}的心情报告`,
      path: `/packageEmotion/pages/daily-report/daily-report?id=${reportId}`
    };
  },

  /**
   * 页面卸载时清理资源
   */
  onUnload: function () {
    // 清理图表实例
    if (this.chart) {
      this.chart.dispose();
    }

    // 取消监听系统主题变化
    wx.offThemeChange();
  },

  /**
   * 检测系统暗夜模式
   */
  checkDarkMode: function() {
    // 优先使用本地缓存中的 darkMode 设置
    try {
      const localDarkMode = wx.getStorageSync('darkMode');
      if (localDarkMode !== undefined && localDarkMode !== null) {
        // 确保 localDarkMode 是布尔值
        const darkModeValue = typeof localDarkMode === 'boolean' ? localDarkMode : localDarkMode === 'true';
        this.setData({ darkMode: darkModeValue });
        console.log('每日报告页面从本地缓存读取暗黑模式设置:', darkModeValue);
        return;
      }
    } catch (e) {
      console.error('从本地缓存读取darkMode失败:', e);
    }

    // 如果本地缓存中没有设置，则使用全局状态
    const app = getApp();
    if (app.globalData && app.globalData.darkMode !== undefined) {
      this.setData({
        darkMode: app.globalData.darkMode
      });
      console.log('每日报告页面使用全局状态暗黑模式设置:', app.globalData.darkMode);
    } else {
      // 如果全局状态也没有设置，则使用系统主题
      wx.getSystemInfo({
        success: (res) => {
          const darkMode = res.theme === 'dark';
          this.setData({ darkMode });
          console.log('每日报告页面使用系统主题设置暗黑模式:', darkMode);

          // 如果全局数据存在，更新全局数据
          if (app.globalData) {
            app.globalData.darkMode = darkMode;
          }
        }
      });
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\daily-report\daily-report.json*#*#*begin*#*#*
{
    "navigationBarTitleText": "每日心情报告",
    "navigationStyle": "custom",
    "usingComponents": {
        "ec-canvas": "../../../components/ec-canvas/ec-canvas"
    },
    "enablePullDownRefresh": false
}

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\daily-report\daily-report.wxml*#*#*begin*#*#*
<!-- packageEmotion/pages/daily-report/daily-report.wxml -->
<view class="container {{darkMode ? 'dark' : ''}}">
  <!-- 自定义导航栏 -->
  <view class="custom-nav">
    <!-- 状态栏占位 -->
    <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

    <!-- 导航栏内容 -->
    <view class="nav-bar" style="height: {{navBarHeight}}px">
      <view class="nav-left">
        <view class="back-btn" bindtap="handleBack">
          <image class="back-icon" src="/images/icons/back.png" mode="aspectFit"></image>
        </view>
      </view>
      <view class="nav-center">
        <text class="nav-title">每日心情报告</text>
      </view>
      <view class="nav-right"></view>
    </view>
  </view>

  <!-- 顶部日期选择和分享 -->
  <view class="header" style="margin-top: {{statusBarHeight + navBarHeight}}px">
    <picker mode="date" value="{{date}}" end="{{today}}" bindchange="bindDateChange">
      <view class="date-picker">
        <text class="date-text">{{formattedDate}}</text>
        <text class="date-icon">▼</text>
      </view>
    </picker>
    <view class="action-buttons">
      <button class="btn-refresh" bindtap="regenerateReport" size="mini">
        <text class="icon-refresh">↻</text>
      </button>
      <button class="btn-share" bindtap="shareReport" size="mini">
        <text class="icon-share">分享</text>
      </button>
    </view>
  </view>

  <!-- 加载中 -->
  <view class="loading-container" wx:if="{{loading}}">
    <view class="loading">
      <text class="loading-text">正在生成心情报告...</text>
    </view>
  </view>

  <!-- 错误提示 -->
  <view class="error-container" wx:elif="{{error}}">
    <view class="error">
      <text class="error-text">{{error}}</text>
      <button class="btn-retry" bindtap="regenerateReport">重新生成</button>
    </view>
  </view>

  <!-- 报告内容 -->
  <scroll-view scroll-y="true" class="report-container" wx:elif="{{report}}">
    <!-- 今日心情总结 -->
    <view class="section summary-section">
      <view class="section-title">今日心情总结</view>
      <view class="summary-content">
        <text>{{report.emotionSummary}}</text>
      </view>
    </view>

    <!-- 情绪分布 -->
    <view class="section chart-section">
      <view class="section-title">情绪分布</view>
      <view class="chart-container">
        <ec-canvas id="emotionPieChart" canvas-id="emotionPieChart" ec="{{ ec }}"></ec-canvas>
      </view>
      <view class="emotion-stats">
        <view class="emotion-stat-item" wx:for="{{report.chartData.emotionDistribution}}" wx:key="type">
          <view class="emotion-color" style="background-color: {{emotionColorMap[item.type] || '#CCCCCC'}}"></view>
          <view class="emotion-name">{{item.type}}</view>
          <view class="emotion-value">{{item.percentage}}%</view>
        </view>
      </view>
    </view>

    <!-- 情绪波动 -->
    <view class="section chart-section" wx:if="{{report.chartData.intensityTrend.length > 0}}">
      <view class="section-title">情绪波动</view>
      <view class="volatility-meter">
        <view class="volatility-label">波动指数</view>
        <view class="volatility-value">{{report.emotionalVolatility}}</view>
        <view class="volatility-bar">
          <view class="volatility-progress" style="width: {{report.emotionalVolatility}}%"></view>
        </view>
        <view class="volatility-scale">
          <text>平稳</text>
          <text>波动</text>
        </view>
      </view>
      <view class="chart-container">
        <ec-canvas id="intensityChart" canvas-id="intensityChart" ec="{{ ec }}"></ec-canvas>
      </view>
    </view>

    <!-- 关键词云 -->
    <view class="section keyword-section">
      <view class="section-title">关键词分析</view>
      <view class="keyword-cloud" wx:if="{{report.keywords.length > 0}}">
        <view
          wx:for="{{keywordTags}}"
          wx:key="word"
          class="keyword-tag"
          style="font-size: {{item.fontSize}}px; color: {{item.color}};"
        >
          <text>{{item.word}}</text>
        </view>
      </view>
      <view class="empty-keywords" wx:if="{{!report.keywords || report.keywords.length === 0}}">
        <text>暂无关键词数据</text>
      </view>
    </view>

    <!-- 关注点分析 -->
    <view class="section focus-section" wx:if="{{report.focusPoints && report.focusPoints.length > 0}}">
      <view class="section-title">关注点分析</view>
      <view class="chart-container">
        <ec-canvas id="focusChart" canvas-id="focusChart" ec="{{ ec }}"></ec-canvas>
      </view>
      <view class="focus-list">
        <view class="focus-item" wx:for="{{report.focusPoints}}" wx:key="category" style="border-left: 6rpx solid {{categoryColors[item.category] || '#ccc'}}">
          <view class="focus-header">
            <view class="focus-category-container">
              <view class="focus-color-dot" style="background-color: {{categoryColors[item.category] || '#ccc'}}"></view>
              <text class="focus-category">{{item.category}}</text>
            </view>
            <text class="focus-percentage" style="color: {{categoryColors[item.category] || '#5e72e4'}}">{{item.percentage}}%</text>
          </view>
          <view class="focus-keywords">
            <text class="focus-keyword"
              wx:for="{{item.keywords}}"
              wx:for-item="keyword"
              wx:key="*this"
              style="background-color: {{categoryColors[item.category] ? categoryColors[item.category] + '20' : '#e2e8f0'}}; color: {{categoryColors[item.category] || '#4a5568'}};"
            >{{keyword}}</text>
          </view>
        </view>
      </view>
    </view>

    <!-- 洞察 -->
    <view class="section insights-section">
      <view class="section-title">情绪洞察</view>
      <view class="insights-list">
        <view class="insight-item" wx:for="{{report.insights}}" wx:key="index">
          <text class="insight-number">{{index + 1}}.</text>
          <text class="insight-text">{{item}}</text>
        </view>
      </view>
    </view>

    <!-- 今日运势 -->
    <view class="section fortune-section">
      <view class="section-title">今日运势</view>
      <view class="fortune-content">
        <view class="fortune-row">
          <view class="fortune-label">宜:</view>
          <view class="fortune-items">
            <view class="fortune-item" wx:for="{{report.fortune.good || defaultFortune.good}}" wx:key="index">{{item}}</view>
          </view>
        </view>
        <view class="fortune-row">
          <view class="fortune-label">忌:</view>
          <view class="fortune-items">
            <view class="fortune-item" wx:for="{{report.fortune.bad || defaultFortune.bad}}" wx:key="index">{{item}}</view>
          </view>
        </view>
      </view>
    </view>

    <!-- 小建议 -->
    <view class="section suggestions-section">
      <view class="section-title">小建议</view>
      <view class="suggestions-list">
        <view class="suggestion-item" wx:for="{{report.suggestions}}" wx:key="index">
          <text class="suggestion-number">{{index + 1}}.</text>
          <text class="suggestion-text">{{item}}</text>
        </view>
      </view>
    </view>

    <!-- 鼓励语 -->
    <view class="section encouragement-section">
      <view class="encouragement-content">
        <text class="encouragement-text">{{report.encouragement}}</text>
      </view>
    </view>

    <!-- 底部信息 -->
    <view class="footer">
      <text class="footer-text">生成于 {{report.generatedAt ? (report.generatedAt.toLocaleString ? report.generatedAt.toLocaleString() : report.generatedAt) : '未知时间'}}</text>
    </view>
  </scroll-view>

  <!-- 无报告提示 -->
  <view class="no-report-container" wx:else>
    <view class="no-report">
      <text class="no-report-text">暂无心情报告</text>
      <button class="btn-generate" bindtap="regenerateReport">生成报告</button>
    </view>
  </view>
</view>
*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\daily-report\daily-report.wxss*#*#*begin*#*#*
/* packageEmotion/pages/daily-report/daily-report.wxss */
.container {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    background-color: #f8f9fa;
    padding-bottom: 40rpx;
    width: 100%;
    box-sizing: border-box;
    overflow-x: hidden;
}

/* 暗夜模式容器 */
.container.dark {
    background-color: #1a202c;
    color: #e2e8f0;
}

/* 自定义导航栏 */
.custom-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background-color: #f8f9fa;
    box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.08);
    padding-bottom: 10rpx; /* 底部增加一点空间 */
    transition: all 0.3s ease;
}

.dark .custom-nav {
    background-color: #1a202c;
    box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.15);
}

/* 状态栏和导航栏 */
.status-bar, .nav-bar {
    width: 100%;
}

/* 状态栏 */
.status-bar {
    background-color: #f8f9fa;
}

.dark .status-bar {
    background-color: #1a202c;
}

/* 导航栏 */
.nav-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #f8f9fa;
    box-sizing: border-box;
    padding: 10rpx 30rpx; /* 增加上下内边距 */
    min-height: 100rpx; /* 确保最小高度 */
}

.dark .nav-bar {
    background-color: #1a202c;
}

.nav-left {
    display: flex;
    align-items: center;
    min-width: 80rpx;
    padding: 6rpx 0;
}

.back-btn {
    width: 60rpx;
    height: 60rpx;
    display: flex;
    justify-content: center;
    align-items: center;
}

.back-icon {
    width: 40rpx;
    height: 40rpx;
}

.nav-center {
    flex: 1;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0 10rpx;
}

.nav-title {
    font-size: 36rpx;
    font-weight: bold;
    color: #333333;
}

.dark .nav-title {
    color: #f8f9fa;
}

.nav-right {
    min-width: 80rpx;
}

/* 顶部日期选择和分享 */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 40rpx 50rpx;
    background-color: #ffffff;
    border-bottom: 1rpx solid #e2e8f0;
    width: 100%;
    box-sizing: border-box;
    box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.03);
    margin-bottom: 20rpx;
    border-radius: 0 0 24rpx 24rpx;
}

.dark .header {
    background-color: #2d3748;
    border-bottom: 1rpx solid #4a5568;
    box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.1);
}

.date-picker {
    display: flex;
    align-items: center;
}

.date-text {
    font-size: 34rpx;
    font-weight: 600;
    color: #2d3748;
}

.dark .date-text {
    color: #e2e8f0;
}

.date-icon {
    font-size: 24rpx;
    color: #666666;
    margin-left: 10rpx;
}

.dark .date-icon {
    color: #a0aec0;
}

.action-buttons {
    display: flex;
    align-items: center;
    justify-content: flex-end;
}

.btn-refresh,
.btn-share {
    margin-left: 20rpx;
    background-color: #f7fafc;
    color: #2d3748;
    border: none;
    padding: 0 24rpx;
    height: 64rpx;
    line-height: 64rpx;
    border-radius: 10rpx;
    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.05);
    transition: all 0.2s ease;
}

.dark .btn-refresh,
.dark .btn-share {
    background-color: #4a5568;
    color: #e2e8f0;
    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.2);
}

.icon-refresh,
.icon-share {
    font-size: 30rpx;
    font-weight: 500;
}

/* 加载中 */
.loading-container,
.error-container,
.no-report-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 400rpx;
    width: 100%;
    box-sizing: border-box;
}

.loading,
.error,
.no-report {
    text-align: center;
    padding: 40rpx;
    background-color: #ffffff;
    border-radius: 12rpx;
    box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.05);
    width: 80%;
    margin: 0 auto;
}

.dark .loading,
.dark .error,
.dark .no-report {
    background-color: #2d3748;
    box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.2);
}

.loading-text,
.error-text,
.no-report-text {
    font-size: 30rpx;
    color: #666666;
    margin-bottom: 30rpx;
    display: block;
}

.dark .loading-text,
.dark .error-text,
.dark .no-report-text {
    color: #a0aec0;
}

.btn-retry,
.btn-generate {
    margin-top: 20rpx;
    background-color: #6495ED;
    color: #ffffff;
    border: none;
    border-radius: 30rpx;
    font-size: 28rpx;
}

/* 报告内容 */
.report-container {
    flex: 1;
    padding: 0 30rpx;
    width: 100%;
    box-sizing: border-box;
    max-width: 750rpx;
    margin: 0 auto;
    padding-bottom: 40rpx; /* 底部增加一些空间 */
}

.section {
    margin: 0 auto 30rpx;
    background-color: #ffffff;
    border-radius: 16rpx;
    padding: 30rpx;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
    width: 100%;
    box-sizing: border-box;
}

.dark .section {
    background-color: #2d3748;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.2);
}

.section-title {
    font-size: 36rpx;
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 24rpx;
    border-left: 8rpx solid #5e72e4;
    padding-left: 20rpx;
}

.dark .section-title {
    color: #e2e8f0;
}

/* 今日心情总结 */
.summary-content {
    font-size: 30rpx;
    color: #2d3748;
    line-height: 1.6;
    padding: 0 10rpx;
}

.dark .summary-content {
    color: #e2e8f0;
}

/* 图表容器 */
.chart-container {
    width: 100%;
    height: 300px;
    margin: 20rpx auto;
    display: block;
    position: relative;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 12rpx;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
    overflow: hidden;
    padding: 10rpx;
}

.dark .chart-container {
    background-color: rgba(45, 55, 72, 0.5);
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
}

.chart-container ec-canvas {
    width: 100%;
    height: 100%;
    display: block;
}

/* 关注点分析图表容器特殊样式 */
.focus-section .chart-container {
    height: 350px; /* 关注点分析图表更高 */
    margin-bottom: 30rpx;
}

/* 情绪分布 */
.emotion-stats {
    display: flex;
    flex-wrap: wrap;
    margin-top: 20rpx;
    justify-content: center;
}

.emotion-stat-item {
    display: flex;
    align-items: center;
    width: 45%;
    margin: 0 2.5% 15rpx;
    justify-content: flex-start;
}

.emotion-color {
    width: 24rpx;
    height: 24rpx;
    border-radius: 50%;
    margin-right: 12rpx;
}

.emotion-name {
    font-size: 28rpx;
    color: #2d3748;
    margin-right: 10rpx;
    font-weight: 500;
}

.dark .emotion-name {
    color: #e2e8f0;
}

.emotion-value {
    font-size: 28rpx;
    color: #a0aec0;
    font-weight: 500;
}

.dark .emotion-value {
    color: #718096;
}

/* 情绪波动 */
.volatility-meter {
    margin: 20rpx 0;
}

.volatility-label {
    font-size: 28rpx;
    color: #666666;
    margin-bottom: 10rpx;
}

.dark .volatility-label {
    color: #a0aec0;
}

.volatility-value {
    font-size: 40rpx;
    font-weight: bold;
    color: #333333;
    margin-bottom: 10rpx;
}

.dark .volatility-value {
    color: #e2e8f0;
}

.volatility-bar {
    height: 20rpx;
    background-color: #f0f0f0;
    border-radius: 10rpx;
    overflow: hidden;
    margin-bottom: 5rpx;
}

.dark .volatility-bar {
    background-color: #4a5568;
}

.volatility-progress {
    height: 100%;
    background: linear-gradient(to right, #90EE90, #FFA500, #FF6347);
    border-radius: 10rpx;
}

.volatility-scale {
    display: flex;
    justify-content: space-between;
    font-size: 24rpx;
    color: #999999;
}

.dark .volatility-scale {
    color: #718096;
}

/* 关键词云 */
.keyword-cloud {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    padding: 20rpx;
    min-height: 300rpx;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 12rpx;
    margin: 20rpx 0;
}

.dark .keyword-cloud {
    background-color: rgba(45, 55, 72, 0.5);
}

.keyword-tag {
    margin: 10rpx 12rpx;
    padding: 8rpx 16rpx;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 8rpx;
    box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    display: inline-block;
    font-weight: bold;
}

.dark .keyword-tag {
    background-color: rgba(45, 55, 72, 0.8);
    box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.2);
}

.keyword-tag:active {
    transform: scale(0.95);
    opacity: 0.8;
}

.empty-keywords {
    text-align: center;
    padding: 30rpx 0;
    color: #999999;
    font-size: 28rpx;
}

.dark .empty-keywords {
    color: #718096;
}

/* 关注点分析 */
.focus-list {
    margin-top: 30rpx;
}

.focus-item {
    margin-bottom: 30rpx;
    padding: 20rpx;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 12rpx;
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.dark .focus-item {
    background-color: rgba(45, 55, 72, 0.8);
    box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.2);
}

.focus-item:active {
    transform: translateY(2rpx);
    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.1);
}

.focus-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16rpx;
    padding-bottom: 12rpx;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.dark .focus-header {
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.focus-category-container {
    display: flex;
    align-items: center;
}

.focus-color-dot {
    width: 16rpx;
    height: 16rpx;
    border-radius: 50%;
    margin-right: 10rpx;
}

.focus-category {
    font-size: 32rpx;
    font-weight: 600;
    color: #2d3748;
}

.dark .focus-category {
    color: #e2e8f0;
}

.focus-percentage {
    font-size: 32rpx;
    font-weight: 700;
    padding: 4rpx 12rpx;
    border-radius: 20rpx;
    background-color: rgba(255, 255, 255, 0.8);
}

.dark .focus-percentage {
    background-color: rgba(45, 55, 72, 0.8);
}

.focus-keywords {
    display: flex;
    flex-wrap: wrap;
    gap: 12rpx;
    margin-top: 16rpx;
}

.focus-keyword {
    font-size: 24rpx;
    padding: 8rpx 16rpx;
    border-radius: 20rpx;
    font-weight: 500;
    transition: all 0.3s ease;
    box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.05);
}

.focus-keyword:active {
    transform: scale(0.95);
    opacity: 0.8;
}

.dark .focus-keyword {
    box-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.1);
}

/* 洞察 */
.insights-list {
    margin-top: 10rpx;
}

.insight-item {
    display: flex;
    margin-bottom: 15rpx;
    width: 100%;
}

.insight-number {
    font-size: 28rpx;
    font-weight: bold;
    color: #6495ED;
    margin-right: 10rpx;
    min-width: 30rpx;
}

.dark .insight-number {
    color: #90cdf4;
}

.insight-text {
    font-size: 28rpx;
    color: #333333;
    line-height: 1.5;
    flex: 1;
}

.dark .insight-text {
    color: #e2e8f0;
}

/* 今日运势 */
.fortune-content {
    margin-top: 10rpx;
}

.fortune-row {
    display: flex;
    margin-bottom: 20rpx;
    width: 100%;
}

.fortune-label {
    font-size: 28rpx;
    font-weight: bold;
    color: #333333;
    width: 60rpx;
}

.dark .fortune-label {
    color: #e2e8f0;
}

.fortune-items {
    display: flex;
    flex-wrap: wrap;
    flex: 1;
    justify-content: flex-start;
}

.fortune-item {
    background-color: #f0f0f0;
    border-radius: 30rpx;
    padding: 10rpx 20rpx;
    font-size: 26rpx;
    color: #333333;
    margin-right: 15rpx;
    margin-bottom: 15rpx;
}

.dark .fortune-item {
    background-color: #4a5568;
    color: #e2e8f0;
}

/* 小建议 */
.suggestions-list {
    margin-top: 10rpx;
}

.suggestion-item {
    display: flex;
    margin-bottom: 15rpx;
    width: 100%;
}

.suggestion-number {
    font-size: 28rpx;
    font-weight: bold;
    color: #6495ED;
    margin-right: 10rpx;
    min-width: 30rpx;
}

.dark .suggestion-number {
    color: #90cdf4;
}

.suggestion-text {
    font-size: 28rpx;
    color: #333333;
    line-height: 1.5;
    flex: 1;
}

.dark .suggestion-text {
    color: #e2e8f0;
}

/* 鼓励语 */
.encouragement-section {
    background-color: #5e72e4;
    width: 100%;
    border-radius: 16rpx;
}

.encouragement-content {
    text-align: center;
    padding: 20rpx 0;
}

.encouragement-text {
    font-size: 32rpx;
    color: #ffffff;
    line-height: 1.5;
    font-weight: bold;
}

/* 底部信息 */
.footer {
    text-align: center;
    margin-top: 30rpx;
    padding: 20rpx 0;
    width: 100%;
    color: #a0aec0;
}

.footer-text {
    font-size: 26rpx;
    color: #a0aec0;
    font-style: italic;
}

.dark .footer-text {
    color: #718096;
}

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\emotion-history\emotion-history.js*#*#*begin*#*#*
// packageEmotion/pages/emotion-history/emotion-history.js
const emotionService = require('../../../services/emotionService');
const echarts = require('../../../components/ec-canvas/echarts');

// 初始化情绪趋势图
function initTrendChart(canvas, width, height, dpr) {
  const chart = echarts.init(canvas, null, {
    width: width,
    height: height,
    devicePixelRatio: dpr
  });
  canvas.setChart(chart);

  const option = {
    tooltip: {
      trigger: 'axis',
      formatter: function(params) {
        let result = params[0].name + '<br/>';
        params.forEach(param => {
          result += `${param.marker}${param.seriesName}: ${param.value}%<br/>`;
        });
        return result;
      }
    },
    legend: {
      data: ['积极情绪', '中性情绪', '消极情绪'],
      bottom: 0
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '15%',
      top: '3%',
      containLabel: true
    },
    xAxis: {
      type: 'category',
      boundaryGap: false,
      data: ['4/20', '4/21', '4/22', '4/23', '4/24', '4/25', '4/26'],
      axisLine: {
        lineStyle: {
          color: '#ccc'
        }
      }
    },
    yAxis: {
      type: 'value',
      axisLabel: {
        formatter: '{value}%'
      },
      max: 100,
      axisLine: {
        show: false
      },
      splitLine: {
        lineStyle: {
          type: 'dashed',
          color: '#eee'
        }
      }
    },
    series: [
      {
        name: '积极情绪',
        type: 'line',
        stack: '总量',
        data: [65, 70, 60, 55, 45, 40, 35],
        smooth: true,
        symbol: 'emptyCircle',
        symbolSize: 6,
        lineStyle: {
          width: 3,
          color: '#5e72e4'
        },
        itemStyle: {
          color: '#5e72e4'
        },
        areaStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            {
              offset: 0,
              color: 'rgba(94, 114, 228, 0.3)'
            },
            {
              offset: 1,
              color: 'rgba(94, 114, 228, 0.1)'
            }
          ])
        }
      },
      {
        name: '中性情绪',
        type: 'line',
        stack: '总量',
        data: [20, 15, 25, 30, 25, 30, 25],
        smooth: true,
        symbol: 'emptyCircle',
        symbolSize: 6,
        lineStyle: {
          width: 3,
          color: '#ffc107'
        },
        itemStyle: {
          color: '#ffc107'
        },
        areaStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            {
              offset: 0,
              color: 'rgba(255, 193, 7, 0.3)'
            },
            {
              offset: 1,
              color: 'rgba(255, 193, 7, 0.1)'
            }
          ])
        }
      },
      {
        name: '消极情绪',
        type: 'line',
        stack: '总量',
        data: [15, 15, 15, 15, 30, 30, 40],
        smooth: true,
        symbol: 'emptyCircle',
        symbolSize: 6,
        lineStyle: {
          width: 3,
          color: '#f56565'
        },
        itemStyle: {
          color: '#f56565'
        },
        areaStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            {
              offset: 0,
              color: 'rgba(245, 101, 101, 0.3)'
            },
            {
              offset: 1,
              color: 'rgba(245, 101, 101, 0.1)'
            }
          ])
        }
      }
    ]
  };

  chart.setOption(option);
  return chart;
}

// 初始化情绪分布图
function initDistributionChart(canvas, width, height, dpr) {
  const chart = echarts.init(canvas, null, {
    width: width,
    height: height,
    devicePixelRatio: dpr
  });
  canvas.setChart(chart);

  const option = {
    tooltip: {
      trigger: 'item',
      formatter: '{b}: {c} ({d}%)'
    },
    legend: {
      orient: 'vertical',
      right: 10,
      top: 'center',
      data: ['疲惫', '压力', '担忧', '焦虑', '平静', '满足', '快乐']
    },
    series: [
      {
        name: '情绪分布',
        type: 'pie',
        radius: ['40%', '70%'],
        center: ['40%', '50%'],
        avoidLabelOverlap: false,
        label: {
          show: false,
          position: 'center'
        },
        emphasis: {
          label: {
            show: true,
            fontSize: '18',
            fontWeight: 'bold'
          }
        },
        labelLine: {
          show: false
        },
        data: [
          { value: 25, name: '疲惫', itemStyle: { color: '#ffc107' } },
          { value: 20, name: '压力', itemStyle: { color: '#f56565' } },
          { value: 15, name: '担忧', itemStyle: { color: '#4299e1' } },
          { value: 10, name: '焦虑', itemStyle: { color: '#ed64a6' } },
          { value: 15, name: '平静', itemStyle: { color: '#48bb78' } },
          { value: 10, name: '满足', itemStyle: { color: '#9f7aea' } },
          { value: 5, name: '快乐', itemStyle: { color: '#38b2ac' } }
        ]
      }
    ]
  };

  chart.setOption(option);
  return chart;
}

// 初始化情绪波动指数图
function initVolatilityChart(canvas, width, height, dpr) {
  const chart = echarts.init(canvas, null, {
    width: width,
    height: height,
    devicePixelRatio: dpr
  });
  canvas.setChart(chart);

  // 获取页面实例
  const page = getCurrentPages()[getCurrentPages().length - 1];

  // 获取页面数据中的波动指数数据
  const volatilityIndex = page.data.volatilityIndex || {
    current: 0,
    previous: 0,
    twoWeeksAgo: 0
  };

  // 获取颜色函数
  const getColorByValue = (value) => {
    if (value <= 20) return '#48bb78'; // 非常稳定 - 绿色
    if (value <= 40) return '#68d391'; // 稳定 - 浅绿色
    if (value <= 60) return '#f6e05e'; // 中等 - 黄色
    if (value <= 80) return '#ed8936'; // 波动 - 橙色
    return '#f56565';                  // 剧烈波动 - 红色
  };

  // 准备图表数据
  const seriesData = [
    {
      value: volatilityIndex.twoWeeksAgo || 0,
      itemStyle: { color: getColorByValue(volatilityIndex.twoWeeksAgo || 0) }
    },
    {
      value: volatilityIndex.previous || 0,
      itemStyle: { color: getColorByValue(volatilityIndex.previous || 0) }
    },
    {
      value: volatilityIndex.current || 0,
      itemStyle: { color: getColorByValue(volatilityIndex.current || 0) }
    }
  ];

  const option = {
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'shadow'
      }
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '3%',
      top: '3%',
      containLabel: true
    },
    xAxis: [
      {
        type: 'category',
        data: ['上上周', '上周', '本周'],
        axisTick: {
          alignWithLabel: true
        }
      }
    ],
    yAxis: [
      {
        type: 'value',
        max: 100,
        axisLabel: {
          formatter: '{value}'
        }
      }
    ],
    series: [
      {
        name: '波动指数',
        type: 'bar',
        barWidth: '60%',
        data: seriesData,
        label: {
          show: true,
          position: 'top',
          formatter: '{c}'
        }
      }
    ]
  };

  chart.setOption(option);
  return chart;
}

Page({
  /**
   * 页面的初始数据
   */
  data: {
    darkMode: false,
    loading: true,
    hasData: false,
    timeRange: 'week', // 默认时间范围：一周
    weekdays: ['一', '二', '三', '四', '五', '六', '日'],
    calendarDays: [],
    recentRecords: [],
    hasMoreRecords: false,
    volatilityIndex: {
      current: 65,
      previous: 58,
      changePercent: 12
    },
    volatilityLevel: '中等',
    volatilityReason: '这可能与近期工作压力增加有关',
    ec: {
      lazyLoad: true
    },
    statusBarHeight: 20, // 状态栏高度，默认值
    navBarHeight: 44 // 导航栏高度，默认值
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 获取系统信息
    const systemInfo = wx.getSystemInfoSync();

    // 获取全局应用实例
    const app = getApp();

    // 优先使用本地缓存中的 darkMode 设置
    let darkMode = false;
    try {
      const localDarkMode = wx.getStorageSync('darkMode');
      if (localDarkMode !== undefined && localDarkMode !== null) {
        // 确保 localDarkMode 是布尔值
        darkMode = typeof localDarkMode === 'boolean' ? localDarkMode : localDarkMode === 'true';
        console.log('情绪历史页面加载时从本地缓存读取暗黑模式设置:', darkMode);
      } else if (app && app.globalData && app.globalData.darkMode !== undefined) {
        // 如果本地缓存中没有设置，则使用全局状态
        darkMode = app.globalData.darkMode;
        console.log('情绪历史页面加载时使用全局状态暗黑模式设置:', darkMode);
      } else {
        // 如果全局状态也没有设置，则使用系统主题
        darkMode = systemInfo.theme === 'dark';
        console.log('情绪历史页面加载时使用系统主题设置暗黑模式:', darkMode);
      }
    } catch (e) {
      console.error('获取暗黑模式设置失败:', e);
      // 如果出错，使用系统主题
      darkMode = systemInfo.theme === 'dark';
    }

    // 获取状态栏高度
    const statusBarHeight = systemInfo.statusBarHeight || 20;

    // 计算导航栏高度，根据机型调整
    let navBarHeight = 44; // 默认值
    if (systemInfo.platform === 'ios') {
      navBarHeight = 44; // iOS平台
    } else if (systemInfo.platform === 'android') {
      navBarHeight = 48; // 安卓平台
    }

    this.setData({
      darkMode,
      statusBarHeight,
      navBarHeight
    });

    // 检查用户登录状态
    let isLoggedIn = app && app.globalData ? app.globalData.isLoggedIn : false;

    console.log('初始登录状态:', isLoggedIn);

    // 尝试从本地存储中检查登录状态
    try {
      const token = wx.getStorageSync('token');
      const userInfo = wx.getStorageSync('userInfo');
      console.log('本地存储中token:', token ? '存在' : '不存在');
      console.log('本地存储中userInfo:', userInfo);

      if (token && userInfo) {
        // 更新全局登录状态
        if (app && app.globalData) {
          app.globalData.isLoggedIn = true;
          app.globalData.userInfo = userInfo;
          isLoggedIn = true;
          console.log('更新全局登录状态为已登录');
        }
      }
    } catch (error) {
      console.error('检查登录状态失败:', error);
    }

    // 如果仍然未登录，提示用户登录
    if (!isLoggedIn) {
      console.log('用户未登录，显示提示');
      wx.showToast({
        title: '请先登录后查看情绪历史',
        icon: 'none',
        duration: 2000
      });

      // 返回上一页
      setTimeout(() => {
        wx.navigateBack();
      }, 2000);

      return;
    }

    // 加载数据
    this.loadEmotionHistoryData().then(() => {
      // 生成日历数据
      this.generateCalendarData().catch(error => {
        console.error('生成日历数据失败:', error);
      });
    }).catch(error => {
      console.error('加载情绪历史数据失败:', error);
    });
  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {
    // 初始化图表
    this.initCharts();
  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    console.log('用户下拉刷新，强制从数据库获取最新数据');

    // 清除当前时间范围的缓存
    try {
      // 尝试从多个来源获取openId
      let userId = null;
      let openId = wx.getStorageSync('openId');

      // 如果没有，尝试从用户信息的stats对象中获取openid
      if (!openId) {
        const userInfo = wx.getStorageSync('userInfo');
        if (userInfo && userInfo.stats && userInfo.stats.openid) {
          openId = userInfo.stats.openid;
          console.log('从用户信息的stats对象中获取的openid:', openId);

          // 将openId存入本地存储，以便下次使用
          wx.setStorageSync('openId', openId);
          console.log('将openId存入本地存储:', openId);
        }
      }

      if (openId) {
        userId = openId;
        console.log('将使用openId作为缓存键的一部分:', openId);
      } else {
        console.log('未找到openId，无法清除缓存');
        // 如果没有openId，则无法清除缓存
        // 尝试从本地存储中获取token，如果有token则提示用户重新登录
        const token = wx.getStorageSync('token');
        if (token) {
          console.log('找到token，可能是openId未正确缓存');
          wx.showToast({
            title: '请重新登录后再试',
            icon: 'none',
            duration: 2000
          });
        }
      }

      if (userId) {
        const cacheKey = `emotionHistory_${userId}_${this.data.timeRange}`;
        wx.removeStorageSync(cacheKey);
        console.log('已清除缓存:', cacheKey);
      }
    } catch (error) {
      console.error('清除缓存失败:', error);
    }

    // 重新加载数据
    this.loadEmotionHistoryData().then(() => {
      wx.stopPullDownRefresh();
    }).catch(error => {
      console.error('下拉刷新加载数据失败:', error);
      wx.stopPullDownRefresh();

      wx.showToast({
        title: '刷新失败，请重试',
        icon: 'none',
        duration: 2000
      });
    });
  },

  /**
   * 切换时间范围
   */
  switchTimeRange: function (e) {
    const range = e.currentTarget.dataset.range;
    const oldRange = this.data.timeRange;

    if (range === oldRange) {
      console.log('时间范围未变化，不重新加载');
      return;
    }

    console.log(`切换时间范围：${oldRange} -> ${range}`);

    this.setData({
      timeRange: range,
      loading: true
    });

    // 尝试从缓存加载数据
    try {
      // 尝试从多个来源获取openId
      let userId = null;
      let openId = wx.getStorageSync('openId');

      // 如果没有，尝试从用户信息的stats对象中获取openid
      if (!openId) {
        const userInfo = wx.getStorageSync('userInfo');
        if (userInfo && userInfo.stats && userInfo.stats.openid) {
          openId = userInfo.stats.openid;
          console.log('从用户信息的stats对象中获取的openid:', openId);

          // 将openId存入本地存储，以便下次使用
          wx.setStorageSync('openId', openId);
          console.log('将openId存入本地存储:', openId);
        }
      }

      if (openId) {
        userId = openId;
        console.log('切换时间范围，将使用openId作为缓存键的一部分:', openId);
      } else {
        console.log('未找到openId，无法从缓存加载数据');
        // 如果没有openId，则无法从缓存加载数据
        // 尝试从本地存储中获取token，如果有token则提示用户重新登录
        const token = wx.getStorageSync('token');
        if (token) {
          console.log('找到token，可能是openId未正确缓存');
          wx.showToast({
            title: '请重新登录后再试',
            icon: 'none',
            duration: 2000
          });
        }
        return; // 如果没有openId，直接返回
      }

      if (userId) {
        const cacheKey = `emotionHistory_${userId}_${range}`;
        const cachedData = wx.getStorageSync(cacheKey);

        if (cachedData && cachedData.data && cachedData.timestamp) {
          // 检查缓存是否过期（超过30分钟）
          const now = Date.now();
          const cacheAge = now - cachedData.timestamp;
          const cacheExpiry = 30 * 60 * 1000; // 30分钟

          if (cacheAge < cacheExpiry) {
            console.log('使用缓存数据，缓存时间:', new Date(cachedData.timestamp).toLocaleString());

            // 处理缓存数据
            this.processEmotionData(cachedData.data);

            // 生成最近记录列表
            this.generateRecentRecords(cachedData.data);

            this.setData({
              hasData: true,
              loading: false,
              hasMoreRecords: cachedData.data.length >= 10
            });

            // 重新初始化图表
            this.initCharts();

            // 显示提示
            wx.showToast({
              title: '当前显示的是缓存数据',
              icon: 'none',
              duration: 1000
            });

            // 同时在后台加载最新数据
            this.loadEmotionHistoryData().catch(error => {
              console.error('后台加载最新数据失败:', error);
            });

            return;
          }
        }
      }
    } catch (error) {
      console.error('从缓存加载数据失败:', error);
    }

    // 如果没有缓存或缓存过期，从数据库加载
    this.loadEmotionHistoryData();
  },

  /**
   * 加载情绪历史数据
   */
  loadEmotionHistoryData: async function () {
    try {
      this.setData({ loading: true });

      // 获取用户ID
      let userId = null;
      let openId = null;

      // 尝试从多个来源获取openId，这是数据库中实际使用的用户标识
      try {
        // 先尝试从本地存储中获取openId
        openId = wx.getStorageSync('openId');
        console.log('从本地存储获取的openId:', openId);

        // 如果没有，尝试从用户信息的stats对象中获取openid
        if (!openId) {
          const userInfo = wx.getStorageSync('userInfo');
          if (userInfo && userInfo.stats && userInfo.stats.openid) {
            openId = userInfo.stats.openid;
            console.log('从用户信息的stats对象中获取的openid:', openId);
          }
        }

        if (openId) {
          userId = openId;
          console.log('将使用openId作为数据库查询的userId字段值:', userId);

          // 将openId存入本地存储，以便下次使用
          if (!wx.getStorageSync('openId')) {
            wx.setStorageSync('openId', openId);
            console.log('将openId存入本地存储:', openId);
          }
        }
      } catch (storageError) {
        console.error('获取openId失败:', storageError);
      }

      // 如果没有获取到openId，则无法查询数据库
      if (!userId) {
        console.error('未获取到openId，无法查询数据库');

        // 尝试从本地存储中获取token，如果有token则提示用户刷新页面
        const token = wx.getStorageSync('token');
        if (token) {
          console.log('找到token，可能是openId未正确缓存');
          wx.showToast({
            title: '请下拉刷新页面',
            icon: 'none',
            duration: 2000
          });
        }
      }

      if (!userId) {
        console.error('未获取到用户ID，请先登录');
        this.setData({
          loading: false,
          hasData: false
        });

        // 提示用户登录
        wx.showToast({
          title: '请先登录后查看情绪历史',
          icon: 'none',
          duration: 2000
        });

        return;
      }

      // 根据时间范围获取数据
      const limit = this.getRecordLimitByTimeRange();

      console.log('开始获取情绪历史记录, 用户ID:', userId, '限制数量:', limit);

      // 获取情绪历史记录
      let records = [];
      try {
        records = await emotionService.getEmotionHistory(userId, null, limit);
        console.log('获取情绪历史记录成功, 数量:', records ? records.length : 0);
      } catch (fetchError) {
        console.error('获取情绪历史记录失败:', fetchError);
        // 使用空数组继续
        records = [];
      }

      if (records && records.length > 0) {
        console.log('成功获取到情绪历史记录，数量:', records.length);

        // 将数据存入本地缓存
        try {
          const cacheKey = `emotionHistory_${userId}_${this.data.timeRange}`;
          wx.setStorageSync(cacheKey, {
            timestamp: Date.now(),
            data: records
          });
          console.log('已将情绪历史数据存入本地缓存:', cacheKey);
        } catch (cacheError) {
          console.error('存入本地缓存失败:', cacheError);
        }

        // 处理数据
        this.processEmotionData(records);

        // 生成最近记录列表 (异步)
        await this.generateRecentRecords(records);

        this.setData({
          hasData: true,
          loading: false,
          hasMoreRecords: records.length >= 10
        });

        // 重新初始化图表
        this.initCharts();
      } else {
        console.log('没有找到情绪历史记录，尝试从缓存加载');

        // 尝试从缓存加载数据
        const cachedData = this.loadFromCache(userId);

        if (cachedData && cachedData.length > 0) {
          console.log('从缓存加载到情绪历史记录，数量:', cachedData.length);

          // 处理缓存数据
          this.processEmotionData(cachedData);

          // 生成最近记录列表 (异步)
          await this.generateRecentRecords(cachedData);

          this.setData({
            hasData: true,
            loading: false,
            hasMoreRecords: false
          });

          // 重新初始化图表
          this.initCharts();

          // 显示提示
          wx.showToast({
            title: '当前显示的是缓存数据',
            icon: 'none',
            duration: 2000
          });
        } else {
          console.log('缓存中也没有数据，显示空状态');

          this.setData({
            hasData: false,
            loading: false
          });

          wx.showToast({
            title: '暂无情绪历史数据',
            icon: 'none',
            duration: 2000
          });
        }
      }
    } catch (error) {
      console.error('加载情绪历史数据失败:', error);
      this.setData({
        loading: false,
        hasData: false
      });

      wx.showToast({
        title: '加载数据失败',
        icon: 'none'
      });
    }
  },

  /**
   * 根据时间范围获取记录限制数
   */
  getRecordLimitByTimeRange: function () {
    const rangeMap = {
      'week': 20,
      'month': 50,
      'quarter': 100,
      'halfYear': 150,
      'year': 200
    };

    return rangeMap[this.data.timeRange] || 20;
  },

  /**
   * 从缓存加载数据
   */
  loadFromCache: function (userId) {
    try {
      // 确保有有效的用户ID（必须是openId）
      if (!userId) {
        // 尝试从本地存储中获取openId
        let openId = wx.getStorageSync('openId');

        // 如果没有，尝试从用户信息的stats对象中获取openid
        if (!openId) {
          const userInfo = wx.getStorageSync('userInfo');
          if (userInfo && userInfo.stats && userInfo.stats.openid) {
            openId = userInfo.stats.openid;
            console.log('从用户信息的stats对象中获取的openid:', openId);

            // 将openId存入本地存储，以便下次使用
            wx.setStorageSync('openId', openId);
            console.log('将openId存入本地存储:', openId);
          }
        }

        if (openId) {
          userId = openId;
          console.log('从存储中获取openId作为缓存键:', userId);
        } else {
          console.error('无法获取openId用于缓存加载');
          return null;
        }
      } else if (userId !== wx.getStorageSync('openId')) {
        // 如果传入的userId不是openId，则尝试使用openId替换
        let openId = wx.getStorageSync('openId');

        // 如果没有，尝试从用户信息的stats对象中获取openid
        if (!openId) {
          const userInfo = wx.getStorageSync('userInfo');
          if (userInfo && userInfo.stats && userInfo.stats.openid) {
            openId = userInfo.stats.openid;
            console.log('从用户信息的stats对象中获取的openid:', openId);

            // 将openId存入本地存储，以便下次使用
            wx.setStorageSync('openId', openId);
            console.log('将openId存入本地存储:', openId);
          }
        }

        if (openId) {
          console.log('传入的userId不是openId，使用openId替换:', openId);
          userId = openId;
        }
      }

      // 尝试从当前时间范围的缓存中加载
      const cacheKey = `emotionHistory_${userId}_${this.data.timeRange}`;
      const cachedData = wx.getStorageSync(cacheKey);

      if (cachedData && cachedData.data && cachedData.timestamp) {
        // 检查缓存是否过期（超过30分钟）
        const now = Date.now();
        const cacheAge = now - cachedData.timestamp;
        const cacheExpiry = 30 * 60 * 1000; // 30分钟

        if (cacheAge < cacheExpiry) {
          console.log('使用缓存数据，缓存时间:', new Date(cachedData.timestamp).toLocaleString());
          return cachedData.data;
        } else {
          console.log('缓存数据已过期，缓存时间:', new Date(cachedData.timestamp).toLocaleString());
          return null;
        }
      }

      // 如果当前时间范围没有缓存，尝试使用其他时间范围的缓存
      const timeRanges = ['week', 'month', 'quarter', 'halfYear', 'year'];
      for (const range of timeRanges) {
        if (range === this.data.timeRange) continue; // 跳过当前时间范围

        const otherCacheKey = `emotionHistory_${userId}_${range}`;
        const otherCachedData = wx.getStorageSync(otherCacheKey);

        if (otherCachedData && otherCachedData.data && otherCachedData.data.length > 0) {
          console.log(`使用${range}时间范围的缓存数据，数量:`, otherCachedData.data.length);
          return otherCachedData.data;
        }
      }

      return null;
    } catch (error) {
      console.error('从缓存加载数据失败:', error);
      return null;
    }
  },

  /**
   * 处理情绪数据
   */
  processEmotionData: function (records) {
    console.log('处理情绪数据:', records.length);

    // 使用emotionService计算情绪波动指数数据
    const volatilityData = emotionService.getEmotionalVolatilityData(records);
    console.log('情绪波动指数数据:', volatilityData);

    // 更新页面数据
    this.setData({
      volatilityIndex: volatilityData.volatilityIndex,
      volatilityLevel: volatilityData.volatilityLevel,
      volatilityReason: volatilityData.volatilityReason
    });

    // 更新图表数据
    this.updateVolatilityChart(volatilityData.chartData);

    // 处理情绪趋势数据
    // 处理情绪分布数据
    // 处理情绪日历数据
  },

  /**
   * 更新情绪波动指数图表
   */
  updateVolatilityChart: function(chartData) {
    // 获取图表组件
    const volatilityChart = this.selectComponent('#volatilityChart');
    if (!volatilityChart || !volatilityChart.chart) {
      console.log('图表组件未初始化，无法更新数据');
      return;
    }

    // 获取图表实例
    const chart = volatilityChart.chart;

    // 获取颜色函数
    const getColorByValue = (value) => {
      if (value <= 20) return '#48bb78'; // 非常稳定 - 绿色
      if (value <= 40) return '#68d391'; // 稳定 - 浅绿色
      if (value <= 60) return '#f6e05e'; // 中等 - 黄色
      if (value <= 80) return '#ed8936'; // 波动 - 橙色
      return '#f56565';                  // 剧烈波动 - 红色
    };

    // 准备图表数据
    const seriesData = [];

    // 处理不同类型的图表数据
    if (Array.isArray(chartData)) {
      // 如果是数组形式，直接处理
      chartData.forEach(item => {
        seriesData.push({
          value: item.value,
          itemStyle: { color: getColorByValue(item.value) }
        });
      });
    } else if (chartData && typeof chartData === 'object') {
      // 如果是对象形式，处理为数组
      seriesData.push({
        value: chartData.twoWeeksAgo || 0,
        itemStyle: { color: getColorByValue(chartData.twoWeeksAgo || 0) }
      });
      seriesData.push({
        value: chartData.previous || 0,
        itemStyle: { color: getColorByValue(chartData.previous || 0) }
      });
      seriesData.push({
        value: chartData.current || 0,
        itemStyle: { color: getColorByValue(chartData.current || 0) }
      });
    } else {
      // 如果数据格式不正确，使用默认值
      console.warn('图表数据格式不正确:', chartData);
      seriesData.push({ value: 0, itemStyle: { color: getColorByValue(0) } });
      seriesData.push({ value: 0, itemStyle: { color: getColorByValue(0) } });
      seriesData.push({ value: 0, itemStyle: { color: getColorByValue(0) } });
    }

    // 更新数据
    const option = {
      series: [{
        data: seriesData
      }]
    };

    chart.setOption(option);
  },

  /**
   * 获取角色信息
   * @param {string} roleId 角色ID
   * @returns {Promise<Object>} 角色信息
   */
  getRoleInfo: async function(roleId) {
    if (!roleId) return null;

    // 先尝试从本地缓存中获取
    try {
      const roleCache = wx.getStorageSync('roleCache') || {};
      if (roleCache[roleId]) {
        return roleCache[roleId];
      }
    } catch (error) {
      // 忽略错误
    }

    // 如果缓存中没有，尝试从云函数获取
    try {
      const result = await wx.cloud.callFunction({
        name: 'getRoleInfo',
        data: { roleId }
      });

      if (result && result.result && result.result.success && result.result.data) {
        // 将角色信息存入缓存
        try {
          const roleCache = wx.getStorageSync('roleCache') || {};
          roleCache[roleId] = result.result.data;
          wx.setStorageSync('roleCache', roleCache);
        } catch (cacheError) {
          // 忽略缓存错误
        }

        return result.result.data;
      }
    } catch (error) {
      // 忽略错误
    }

    return null;
  },

  /**
   * 生成最近记录列表
   */
  generateRecentRecords: async function (records) {
    // 取最近的10条记录
    const recordsToProcess = records.slice(0, 10);
    const recentRecords = [];

    // 创建角色ID到角色信息的映射
    const roleInfoMap = {};

    // 收集所有需要查询的角色ID
    const roleIdsToQuery = [];
    for (const record of recordsToProcess) {
      if (record.roleId && !roleInfoMap[record.roleId]) {
        roleIdsToQuery.push(record.roleId);
      }
    }

    // 批量查询角色信息
    if (roleIdsToQuery.length > 0) {
      try {
        // 先从缓存中获取
        const roleCache = wx.getStorageSync('roleCache') || {};

        // 对于缓存中没有的角色，从数据库查询
        const roleIdsToQueryFromDB = [];
        for (const roleId of roleIdsToQuery) {
          if (roleCache[roleId]) {
            roleInfoMap[roleId] = roleCache[roleId];
          } else {
            roleIdsToQueryFromDB.push(roleId);
          }
        }

        // 如果还有需要从数据库查询的角色
        if (roleIdsToQueryFromDB.length > 0) {
          // 使用云函数查询角色信息
          const db = wx.cloud.database();
          const _ = db.command;

          const result = await db.collection('roles')
            .where({
              _id: _.in(roleIdsToQueryFromDB)
            })
            .get();

          if (result && result.data && result.data.length > 0) {
            // 将查询结果存入映射和缓存
            for (const role of result.data) {
              roleInfoMap[role._id] = role;
              roleCache[role._id] = role;
            }

            // 更新缓存
            wx.setStorageSync('roleCache', roleCache);
          }
        }
      } catch (error) {
        // 忽略错误
      }
    }

    // 处理每条记录
    for (const record of recordsToProcess) {
      // 获取情绪类型
      let emotionType = record.analysis?.primary_emotion || record.analysis?.type || 'neutral';
      let emotionLabel = '';

      // 尝试获取中文情绪类型
      if (record.analysis?.primary_emotion_cn) {
        emotionLabel = record.analysis.primary_emotion_cn;
      } else if (record.analysis?.type && typeof record.analysis.type === 'string' && /[\u4e00-\u9fa5]/.test(record.analysis.type)) {
        // 如果 type 字段是中文，直接使用
        emotionLabel = record.analysis.type;
      } else {
        // 如果没有中文情绪类型，使用映射表
        emotionLabel = emotionService.EmotionTypeLabels[emotionType] || '未知情绪';
      }

      // 获取情绪图标和背景色
      const iconInfo = this.getEmotionIconInfo(emotionType);

      // 格式化时间
      const time = this.formatRecordTime(record.createTime);

      // 获取角色名称
      let roleName = record.roleName || record.role_name || '';

      // 如果没有角色名称，尝试从角色信息中获取
      if (!roleName && record.roleId && roleInfoMap[record.roleId]) {
        const roleInfo = roleInfoMap[record.roleId];
        roleName = roleInfo.name || roleInfo.role_name || '';
      }

      // 构建源信息文本
      let source = '对话记录';
      if (roleName) {
        source = `与 ${roleName} 的对话`;
      }

      recentRecords.push({
        id: record._id,
        emotions: [emotionLabel],
        time: time,
        source: source,
        roleName: roleName,  // 角色名称
        roleId: record.roleId || '',  // 角色ID
        chatId: record.chatId || '',  // 聊天ID
        iconBg: iconInfo.bg,
        iconName: iconInfo.icon
      });
    }

    this.setData({
      recentRecords
    });
  },

  /**
   * 获取情绪图标信息
   */
  getEmotionIconInfo: function (emotionType) {
    // 如果情绪类型为空，返回默认图标
    if (!emotionType) {
      return { icon: 'icon-neutral', bg: '#f0f0f0' };
    }

    // 尝试获取中文情绪类型
    let emotionTypeCN = '';
    if (typeof emotionType === 'object' && emotionType.analysis) {
      emotionTypeCN = emotionType.analysis.primary_emotion_cn || '';
      emotionType = emotionType.analysis.primary_emotion || 'neutral';
    }

    // 情绪类型对应的图标和背景色
    const emotionIcons = {
      // 英文情绪类型
      'joy': { icon: 'icon-smile', bg: '#e6ffec' },
      'sadness': { icon: 'icon-sad', bg: '#e6f7ff' },
      'anger': { icon: 'icon-angry', bg: '#ffece6' },
      'anxiety': { icon: 'icon-meh', bg: '#fff7e6' },
      'neutral': { icon: 'icon-neutral', bg: '#f0f0f0' },
      'tired': { icon: 'icon-tired', bg: '#f0f0f0' },
      'surprise': { icon: 'icon-surprise', bg: '#e6f7ff' },
      'calm': { icon: 'icon-neutral', bg: '#e6f7ff' },
      'happy': { icon: 'icon-smile', bg: '#e6ffec' },
      'sad': { icon: 'icon-sad', bg: '#e6f7ff' },
      'angry': { icon: 'icon-angry', bg: '#ffece6' },
      'fear': { icon: 'icon-meh', bg: '#fff7e6' },
      'disgust': { icon: 'icon-meh', bg: '#ffece6' },
      'anticipation': { icon: 'icon-smile', bg: '#fff7e6' },
      'trust': { icon: 'icon-smile', bg: '#e6ffec' },

      // 中文情绪类型
      '喜悦': { icon: 'icon-smile', bg: '#e6ffec' },
      '伤感': { icon: 'icon-sad', bg: '#e6f7ff' },
      '愤怒': { icon: 'icon-angry', bg: '#ffece6' },
      '焦虑': { icon: 'icon-meh', bg: '#fff7e6' },
      '平静': { icon: 'icon-neutral', bg: '#f0f0f0' },
      '疲惫': { icon: 'icon-tired', bg: '#f0f0f0' },
      '惊讶': { icon: 'icon-surprise', bg: '#e6f7ff' },
      '期待': { icon: 'icon-smile', bg: '#fff7e6' },
      '信任': { icon: 'icon-smile', bg: '#e6ffec' },
      '忧虑': { icon: 'icon-meh', bg: '#fff7e6' },
      '厌恶': { icon: 'icon-meh', bg: '#ffece6' },
      '恐惧': { icon: 'icon-meh', bg: '#fff7e6' },
      '开心': { icon: 'icon-smile', bg: '#e6ffec' },
      '难过': { icon: 'icon-sad', bg: '#e6f7ff' },
      '生气': { icon: 'icon-angry', bg: '#ffece6' }
    };

    // 先尝试使用中文情绪类型，如果没有再使用英文情绪类型
    if (emotionTypeCN && emotionIcons[emotionTypeCN]) {
      return emotionIcons[emotionTypeCN];
    }

    return emotionIcons[emotionType] || { icon: 'icon-neutral', bg: '#f0f0f0' };
  },

  /**
   * 格式化记录时间
   */
  formatRecordTime: function (timestamp) {
    if (!timestamp) return '未知时间';

    let recordTime;

    // 处理不同的时间格式
    if (typeof timestamp === 'object' && timestamp.$date) {
      // 如果是 MongoDB 格式的时间对象
      recordTime = new Date(timestamp.$date);
    } else if (typeof timestamp === 'string') {
      // 如果是字符串
      recordTime = new Date(timestamp);
    } else if (timestamp instanceof Date) {
      // 如果已经是 Date 对象
      recordTime = timestamp;
    } else {
      // 其他情况，尝试直接创建 Date 对象
      try {
        recordTime = new Date(timestamp);
      } catch (error) {
        console.error('无法解析时间格式:', timestamp, error);
        return '未知时间';
      }
    }

    // 检查时间是否有效
    if (isNaN(recordTime.getTime())) {
      console.error('无效的时间对象:', recordTime);
      return '未知时间';
    }

    const now = new Date();

    // 计算时间差（毫秒）
    const diff = now - recordTime;

    // 小于24小时，显示"今天 HH:MM"
    if (diff < 24 * 60 * 60 * 1000 && recordTime.getDate() === now.getDate()) {
      const hours = recordTime.getHours().toString().padStart(2, '0');
      const minutes = recordTime.getMinutes().toString().padStart(2, '0');
      return `今天 ${hours}:${minutes}`;
    }

    // 小于48小时，显示"昨天 HH:MM"
    if (diff < 48 * 60 * 60 * 1000 &&
        recordTime.getDate() === new Date(now - 24 * 60 * 60 * 1000).getDate()) {
      const hours = recordTime.getHours().toString().padStart(2, '0');
      const minutes = recordTime.getMinutes().toString().padStart(2, '0');
      return `昨天 ${hours}:${minutes}`;
    }

    // 小于7天，显示"N天前"
    if (diff < 7 * 24 * 60 * 60 * 1000) {
      const days = Math.floor(diff / (24 * 60 * 60 * 1000));
      return `${days}天前`;
    }

    // 其他情况，显示完整日期
    const year = recordTime.getFullYear();
    const month = (recordTime.getMonth() + 1).toString().padStart(2, '0');
    const day = recordTime.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
  },

  /**
   * 生成日历数据
   */
  generateCalendarData: async function () {
    // 获取当前日期
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();

    // 获取当月第一天是星期几
    const firstDay = new Date(year, month, 1).getDay() || 7; // 将周日(0)转换为7

    // 获取当月天数
    const daysInMonth = new Date(year, month + 1, 0).getDate();

    // 获取上月天数
    const daysInPrevMonth = new Date(year, month, 0).getDate();

    // 生成日历数据
    const calendarDays = [];

    // 添加上月剩余天数
    for (let i = firstDay - 1; i > 0; i--) {
      calendarDays.push({
        day: daysInPrevMonth - i + 1,
        date: `${year}-${month === 0 ? 12 : month}-${daysInPrevMonth - i + 1}`,
        current: false,
        emotion: null
      });
    }

    // 获取当月的情绪数据
    const monthStart = new Date(year, month, 1);
    const monthEnd = new Date(year, month + 1, 0, 23, 59, 59);

    // 获取用户ID
    let userId = null;
    try {
      const openId = wx.getStorageSync('openId');
      if (openId) {
        userId = openId;
      } else {
        const userInfo = wx.getStorageSync('userInfo');
        if (userInfo && userInfo.stats && userInfo.stats.openid) {
          userId = userInfo.stats.openid;
        }
      }
    } catch (error) {
      console.error('获取用户ID失败:', error);
    }

    // 如果没有用户ID，使用随机数据
    if (!userId) {
      console.warn('未获取到用户ID，使用随机数据');
      // 添加当月天数，使用随机情绪
      for (let i = 1; i <= daysInMonth; i++) {
        calendarDays.push({
          day: i,
          date: `${year}-${month + 1}-${i}`,
          current: true,
          emotion: this.getEmotionForDay(null) // 使用随机情绪
        });
      }
    } else {
      // 从数据库获取当月的情绪记录
      try {
        const db = wx.cloud.database();
        const _ = db.command;

        const result = await db.collection('emotionRecords')
          .where({
            userId: userId,
            createTime: _.gte(monthStart).and(_.lte(monthEnd))
          })
          .orderBy('createTime', 'asc')
          .get();

        console.log('获取到当月情绪记录:', result.data.length);

        // 按日期分组情绪记录
        const emotionsByDay = {};

        result.data.forEach(record => {
          if (!record.createTime) return;

          let recordDate;
          if (typeof record.createTime === 'object' && record.createTime.$date) {
            recordDate = new Date(record.createTime.$date);
          } else {
            recordDate = new Date(record.createTime);
          }

          const day = recordDate.getDate();

          if (!emotionsByDay[day]) {
            emotionsByDay[day] = [];
          }

          // 获取情绪类型
          let emotionType = record.analysis?.primary_emotion ||
                           record.analysis?.type ||
                           'neutral';

          emotionsByDay[day].push(emotionType);
        });

        // 添加当月天数，使用实际情绪数据
        for (let i = 1; i <= daysInMonth; i++) {
          const dayEmotions = emotionsByDay[i] || [];

          calendarDays.push({
            day: i,
            date: `${year}-${month + 1}-${i}`,
            current: true,
            emotion: this.getEmotionForDay(dayEmotions)
          });
        }
      } catch (error) {
        console.error('获取情绪记录失败:', error);

        // 如果获取失败，使用随机数据
        for (let i = 1; i <= daysInMonth; i++) {
          calendarDays.push({
            day: i,
            date: `${year}-${month + 1}-${i}`,
            current: true,
            emotion: this.getEmotionForDay(null) // 使用随机情绪
          });
        }
      }
    }

    // 添加下月开始天数，补满42个格子（6行）
    const remaining = 42 - calendarDays.length;
    for (let i = 1; i <= remaining; i++) {
      calendarDays.push({
        day: i,
        date: `${year}-${month + 2 > 12 ? 1 : month + 2}-${i}`,
        current: false,
        emotion: null
      });
    }

    this.setData({
      calendarDays
    });
  },

  /**
   * 根据一天的情绪记录确定主要情绪
   * @param {Array} emotions 情绪类型数组
   * @returns {String} 主要情绪类型
   */
  getEmotionForDay: function (emotions) {
    if (!emotions || emotions.length === 0) {
      // 如果没有情绪记录，返回随机情绪或null
      if (Math.random() < 0.3) { // 30%的概率返回null，表示没有记录
        return null;
      }
      const emotions = ['positive', 'negative', 'neutral', 'calm'];
      const randomIndex = Math.floor(Math.random() * emotions.length);
      return emotions[randomIndex];
    }

    // 统计各种情绪类型的出现次数
    const emotionCounts = {};
    emotions.forEach(emotion => {
      emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
    });

    // 找出出现次数最多的情绪类型
    let mainEmotion = 'neutral';
    let maxCount = 0;

    for (const [emotion, count] of Object.entries(emotionCounts)) {
      if (count > maxCount) {
        maxCount = count;
        mainEmotion = emotion;
      }
    }

    return mainEmotion;
  },

  /**
   * 初始化所有图表
   */
  initCharts: function () {
    if (!this.data.hasData) return;

    // 初始化情绪趋势图
    this.trendChart = this.selectComponent('#trendChart');
    this.trendChart && this.trendChart.init((canvas, width, height, dpr) => {
      return initTrendChart(canvas, width, height, dpr);
    });

    // 初始化情绪分布图
    this.distributionChart = this.selectComponent('#distributionChart');
    this.distributionChart && this.distributionChart.init((canvas, width, height, dpr) => {
      return initDistributionChart(canvas, width, height, dpr);
    });

    // 初始化情绪波动指数图
    this.volatilityChart = this.selectComponent('#volatilityChart');
    this.volatilityChart && this.volatilityChart.init((canvas, width, height, dpr) => {
      return initVolatilityChart(canvas, width, height, dpr);
    });
  },

  /**
   * 处理返回按钮点击
   */
  handleBack: function () {
    wx.navigateBack({
      fail: function() {
        // 如果返回失败，可能是没有上一页，跳转到首页
        wx.switchTab({
          url: '/pages/user/user'
        });
      }
    });
  },

  /**
   * 查看记录详情
   */
  viewRecordDetail: function (e) {
    const recordId = e.currentTarget.dataset.id;
    const roleId = e.currentTarget.dataset.roleId;
    const chatId = e.currentTarget.dataset.chatId;

    console.log('点击记录:', { recordId, roleId, chatId });

    if (!recordId) return;

    // 如果有角色ID，先跳转到角色页面
    if (roleId) {
      // 尝试获取角色信息
      try {
        const roleCache = wx.getStorageSync('roleCache') || {};
        const role = roleCache[roleId];

        if (role) {
          console.log('找到角色信息:', role);

          // 跳转到聊天页面
          wx.navigateTo({
            url: `/pages/chat/chat?roleId=${roleId}${chatId ? '&chatId=' + chatId : ''}`,
            success: () => {
              console.log('跳转到聊天页面成功');
            },
            fail: (error) => {
              console.error('跳转到聊天页面失败:', error);

              // 如果跳转失败，尝试跳转到情绪分析页面
              this.navigateToEmotionAnalysis(recordId);
            }
          });
          return;
        }
      } catch (error) {
        console.error('获取角色信息失败:', error);
      }
    }

    // 如果没有角色ID或跳转失败，跳转到情绪分析详情页
    this.navigateToEmotionAnalysis(recordId);
  },

  /**
   * 跳转到情绪分析页面
   */
  navigateToEmotionAnalysis: function(recordId) {
    console.log('准备跳转到情绪分析页面，recordId:', recordId);
    wx.navigateTo({
      url: '/packageChat/pages/emotion-analysis/emotion-analysis?recordId=' + recordId,
      success: () => {
        console.log('跳转到情绪分析页面成功');
      },
      fail: (error) => {
        console.error('跳转到情绪分析页面失败:', error);

        // 如果跳转失败，提示用户
        wx.showToast({
          title: '无法打开详情页面',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 点击日历日期
   */
  onDayClick: function (e) {
    const date = e.currentTarget.dataset.date;
    if (!date) return;

    // 获取当前日期的情绪记录
    console.log('查看日期情绪:', date);

    // 可以跳转到该日期的情绪记录列表或详情页
    wx.navigateTo({
      url: '/packageEmotion/pages/daily-report/daily-report?date=' + date
    });
  },

  // 已删除未使用的 loadMoreRecords 函数

  // 已删除未使用的 abs 函数

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    // 获取全局应用实例
    const app = getApp();

    // 优先使用本地缓存中的 darkMode 设置
    let newDarkMode = false;
    try {
      const localDarkMode = wx.getStorageSync('darkMode');
      if (localDarkMode !== undefined && localDarkMode !== null) {
        // 确保 localDarkMode 是布尔值
        newDarkMode = typeof localDarkMode === 'boolean' ? localDarkMode : localDarkMode === 'true';
        console.log('情绪历史页面从本地缓存读取暗黑模式设置:', newDarkMode);
      } else if (app && app.globalData && app.globalData.darkMode !== undefined) {
        // 如果本地缓存中没有设置，则使用全局状态
        newDarkMode = app.globalData.darkMode;
        console.log('情绪历史页面使用全局状态暗黑模式设置:', newDarkMode);
      } else {
        // 如果全局状态也没有设置，则使用系统主题
        const systemInfo = wx.getSystemInfoSync();
        newDarkMode = systemInfo.theme === 'dark';
        console.log('情绪历史页面使用系统主题设置暗黑模式:', newDarkMode);
      }
    } catch (e) {
      console.error('获取暗黑模式设置失败:', e);
      // 如果出错，使用系统主题
      const systemInfo = wx.getSystemInfoSync();
      newDarkMode = systemInfo.theme === 'dark';
    }

    // 检查暗黑模式是否变化
    if (this.data.darkMode !== newDarkMode) {
      this.setData({ darkMode: newDarkMode });
      console.log('情绪历史页面更新暗黑模式为:', newDarkMode);

      // 如果图表已初始化，重新初始化以适应主题变化
      if (this.data.hasData) {
        this.initCharts();
      }
    }
  },

  // 已删除未使用的 onHide 函数

  // 已删除未使用的 onUnload 函数

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    // 如果有更多记录，加载更多
    if (this.data.hasMoreRecords) {
      // 已删除对未使用函数的调用
      wx.showToast({
        title: '加载更多记录',
        icon: 'none'
      });
    }
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {
    return {
      title: '我的情绪历史',
      path: '/packageEmotion/pages/emotion-history/emotion-history'
    };
  }
});

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\emotion-history\emotion-history.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "情绪历史",
  "usingComponents": {
    "ec-canvas": "/components/ec-canvas/ec-canvas"
  },
  "navigationStyle": "custom",
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark"
}

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\emotion-history\emotion-history.plan.md*#*#*begin*#*#*
# 情绪历史页面开发计划书

## 1. 页面概述

情绪历史页面将展示用户的情绪变化趋势、情绪分布、情绪波动指数和情绪日历等数据，帮助用户了解自己的情绪变化规律。页面将包含多种图表和数据可视化组件，以直观的方式呈现用户的情绪数据。

## 2. 页面结构

### 2.1 文件结构
```
miniprogram/packageEmotion/pages/emotion-history/
├── emotion-history.js       // 页面逻辑
├── emotion-history.json     // 页面配置
├── emotion-history.wxml     // 页面结构
└── emotion-history.wxss     // 页面样式
```

### 2.2 页面布局
- 顶部导航栏：包含返回按钮和页面标题
- 时间范围选择：一周、一个月、三个月、半年、一年
- 情绪趋势图：展示不同情绪类型随时间的变化趋势
- 情绪分布图：展示各种情绪类型的占比分布
- 情绪波动指数：展示情绪波动程度及与上周的对比
- 情绪日历：以日历形式展示每天的主要情绪状态
- 最近情绪记录列表：展示最近的情绪分析记录

## 3. 数据结构

### 3.1 情绪历史数据
```javascript
{
  // 情绪趋势数据
  emotionTrend: [
    {
      date: '4/20', // 日期
      positive: 65, // 积极情绪占比
      neutral: 20,  // 中性情绪占比
      negative: 15  // 消极情绪占比
    },
    // 更多日期数据...
  ],
  
  // 情绪分布数据
  emotionDistribution: [
    { type: '疲惫', value: 25, color: '#ffc107' },
    { type: '压力', value: 20, color: '#f56565' },
    // 更多情绪类型...
  ],
  
  // 情绪波动指数
  volatilityIndex: {
    current: 65,      // 当前波动指数
    previous: 58,     // 上周波动指数
    changePercent: 12 // 变化百分比
  },
  
  // 情绪日历数据
  emotionCalendar: [
    { date: '2023-04-01', emotion: 'positive', color: 'green-100' },
    { date: '2023-04-02', emotion: 'positive', color: 'green-100' },
    // 更多日期数据...
  ],
  
  // 最近情绪记录
  recentRecords: [
    {
      id: 'record1',
      emotions: ['疲惫', '压力'],
      time: '今天 15:30',
      source: '与知心姐姐的对话',
      iconColor: 'red-100',
      iconName: 'tired'
    },
    // 更多记录...
  ]
}
```

## 4. 功能实现

### 4.1 数据获取
- 使用 `emotionService.js` 中的方法获取情绪历史数据
- 根据选择的时间范围调整数据查询参数
- 处理数据格式，适配图表组件需要的数据结构

### 4.2 图表实现
- 使用 `ec-canvas` 组件实现各种图表
- 情绪趋势图：使用折线图展示情绪随时间的变化
- 情绪分布图：使用饼图或环形图展示情绪类型分布
- 情绪波动指数：使用柱状图展示波动指数变化

### 4.3 情绪日历
- 使用网格布局实现日历视图
- 根据情绪类型设置不同的背景颜色
- 支持点击日期查看详细情绪记录

### 4.4 最近情绪记录列表
- 使用列表组件展示最近的情绪记录
- 支持点击记录查看详情
- 根据情绪类型显示不同的图标和颜色

## 5. 交互设计

### 5.1 时间范围选择
- 点击不同的时间范围选项，切换数据展示范围
- 选中的时间范围高亮显示
- 切换时间范围后，所有图表和数据同步更新

### 5.2 图表交互
- 支持图表的缩放、平移等基本交互
- 点击图表元素显示详细数据提示
- 长按图表可保存图表图片

### 5.3 记录列表交互
- 点击记录项跳转到详细的情绪分析页面
- 支持下拉刷新加载最新数据
- 支持上拉加载更多历史记录

## 6. 样式设计

### 6.1 整体风格
- 遵循 iOS 设计规范，使用卡片式布局
- 使用圆角元素和适当的阴影效果
- 保持视觉体验现代简洁

### 6.2 配色方案
- 积极情绪：#5e72e4（蓝紫色）
- 中性情绪：#ffc107（黄色）
- 消极情绪：#f56565（红色）
- 平静情绪：#90EE90（浅绿色）
- 背景色：#f8f9fa（浅灰色）
- 卡片背景：#ffffff（白色）

### 6.3 响应式设计
- 适配不同尺寸的设备屏幕
- 在小屏幕设备上优化布局和元素大小
- 支持横屏和竖屏模式

## 7. 开发步骤

### 7.1 基础结构搭建
1. 创建页面文件结构
2. 实现基本页面布局
3. 添加页面配置和路由

### 7.2 数据服务实现
1. 在 `emotionService.js` 中添加获取情绪历史数据的方法
2. 实现数据处理和格式转换功能
3. 添加数据缓存机制，优化加载性能

### 7.3 UI 组件实现
1. 实现时间范围选择组件
2. 集成 `ec-canvas` 图表组件
3. 实现情绪日历组件
4. 实现情绪记录列表组件

### 7.4 功能联调和优化
1. 连接数据服务和 UI 组件
2. 实现页面交互逻辑
3. 优化加载性能和用户体验
4. 添加错误处理和加载状态提示

### 7.5 测试和调试
1. 进行功能测试，确保所有功能正常工作
2. 进行性能测试，优化加载速度和响应时间
3. 进行兼容性测试，确保在不同设备上正常显示
4. 修复发现的问题和 bug

## 8. 注意事项

### 8.1 性能优化
- 使用分页加载大量数据
- 实现数据缓存，避免重复请求
- 优化图表渲染性能，避免卡顿

### 8.2 兼容性考虑
- 考虑低端设备的性能限制
- 提供数据加载失败的备选显示方案
- 确保在不同尺寸屏幕上的良好显示效果

### 8.3 用户体验优化
- 添加适当的加载动画和过渡效果
- 提供清晰的操作反馈
- 优化空数据状态的显示

## 9. 与现有系统的集成

### 9.1 与情绪分析系统的集成
- 使用现有的情绪分析结果数据
- 保持情绪类型和颜色的一致性
- 复用情绪分析相关的组件和服务

### 9.2 与导航系统的集成
- 在首页和用户页面添加入口链接
- 实现与其他页面的无缝导航
- 保持导航体验的一致性

## 10. 后续优化方向

### 10.1 功能扩展
- 添加情绪数据导出功能
- 实现情绪预测和建议功能
- 增加情绪比较和分析功能

### 10.2 UI/UX 优化
- 增加更多的动画和交互效果
- 优化图表的视觉呈现
- 提供更多的自定义选项

### 10.3 性能提升
- 优化数据查询和处理逻辑
- 实现更高效的图表渲染
- 优化页面加载和响应速度

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\emotion-history\emotion-history.wxml*#*#*begin*#*#*
<!-- packageEmotion/pages/emotion-history/emotion-history.wxml -->
<view class="container {{darkMode ? 'dark-mode' : ''}}">
  <!-- 自定义导航栏 -->
  <view class="custom-nav">
    <view class="status-bar" style="height: {{statusBarHeight}}px"></view>
    <view class="nav-bar" style="height: {{navBarHeight}}px">
      <view class="nav-left">
        <view class="back-btn" bindtap="handleBack">
          <image class="back-icon" src="/images/icons/back_{{darkMode ? 'dark' : 'light'}}.png" mode="aspectFit"></image>
        </view>
      </view>
      <view class="nav-center">
        <text class="nav-title">情绪历史</text>
      </view>
      <view class="nav-right"></view>
    </view>
  </view>

  <!-- 内容区域 -->
  <view class="content-area" style="margin-top: {{statusBarHeight + navBarHeight}}px">
    <!-- 时间范围选择 -->
    <view class="time-range-selector">
      <scroll-view scroll-x enable-flex class="time-range-scroll">
        <view class="time-range-item {{timeRange === 'week' ? 'active' : ''}}"
              bindtap="switchTimeRange" data-range="week">一周</view>
        <view class="time-range-item {{timeRange === 'month' ? 'active' : ''}}"
              bindtap="switchTimeRange" data-range="month">一个月</view>
        <view class="time-range-item {{timeRange === 'quarter' ? 'active' : ''}}"
              bindtap="switchTimeRange" data-range="quarter">三个月</view>
        <view class="time-range-item {{timeRange === 'halfYear' ? 'active' : ''}}"
              bindtap="switchTimeRange" data-range="halfYear">半年</view>
        <view class="time-range-item {{timeRange === 'year' ? 'active' : ''}}"
              bindtap="switchTimeRange" data-range="year">一年</view>
      </scroll-view>
    </view>

    <!-- 加载中提示 -->
    <view class="loading-container" wx:if="{{loading}}">
      <view class="loading-spinner"></view>
      <text class="loading-text">加载数据中...</text>
    </view>

    <!-- 无数据提示 -->
    <view class="no-data-container" wx:elif="{{!hasData}}">
      <view class="no-data-icon">
        <text class="iconfont icon-empty"></text>
      </view>
      <text class="no-data-text">暂无情绪历史数据</text>
      <text class="no-data-tip">与AI角色多聊聊，积累更多情绪数据吧</text>
    </view>

    <!-- 数据内容 -->
    <block wx:elif="{{hasData}}">
      <!-- 情绪趋势图 -->
      <view class="emotion-card">
        <view class="card-title">情绪趋势</view>
        <view class="chart-container">
          <ec-canvas id="trendChart" canvas-id="trendChart" ec="{{ ec }}"></ec-canvas>
        </view>

        <view class="legend-container">
          <view class="legend-item">
            <view class="legend-color" style="background-color: #5e72e4;"></view>
            <text class="legend-text">积极情绪</text>
          </view>
          <view class="legend-item">
            <view class="legend-color" style="background-color: #ffc107;"></view>
            <text class="legend-text">中性情绪</text>
          </view>
          <view class="legend-item">
            <view class="legend-color" style="background-color: #f56565;"></view>
            <text class="legend-text">消极情绪</text>
          </view>
        </view>
      </view>

      <!-- 情绪分布 -->
      <view class="emotion-card">
        <view class="card-title">情绪分布</view>
        <view class="chart-container">
          <ec-canvas id="distributionChart" canvas-id="distributionChart" ec="{{ ec }}"></ec-canvas>
        </view>
      </view>

      <!-- 情绪波动指数 -->
      <view class="emotion-card">
        <view class="card-title">情绪波动指数</view>
        <view class="chart-container volatility-container">
          <ec-canvas id="volatilityChart" canvas-id="volatilityChart" ec="{{ ec }}"></ec-canvas>
        </view>

        <view class="volatility-summary">
          <text>你的情绪波动指数为<text class="volatility-value">{{volatilityIndex.current}}</text>，属于{{volatilityLevel}}水平。</text>
          <text wx:if="{{volatilityIndex.changePercent !== 0}}">
            相比上周，波动性<text class="{{volatilityIndex.changePercent > 0 ? 'increase' : 'decrease'}}">
              {{volatilityIndex.changePercent > 0 ? '增加' : '减少'}}了{{abs(volatilityIndex.changePercent)}}%
            </text>，
            {{volatilityReason}}
          </text>
        </view>
      </view>

      <!-- 情绪日历 -->
      <view class="emotion-card">
        <view class="card-title">情绪日历</view>
        <!-- 星期标题 -->
        <view class="calendar-weekdays">
          <view class="weekday-item" wx:for="{{weekdays}}" wx:key="index">{{item}}</view>
        </view>

        <!-- 日历网格 -->
        <view class="calendar-grid">
          <view class="calendar-day {{item.current ? '' : 'other-month'}} {{item.emotion ? 'emotion-' + item.emotion : ''}}"
                wx:for="{{calendarDays}}"
                wx:key="date"
                bindtap="onDayClick"
                data-date="{{item.date}}">
            <text class="day-number">{{item.day}}</text>
          </view>
        </view>

        <!-- 日历图例 -->
        <view class="calendar-legend">
          <view class="legend-item">
            <view class="legend-color" style="background-color: #e6ffec;"></view>
            <text class="legend-text">积极</text>
          </view>
          <view class="legend-item">
            <view class="legend-color" style="background-color: #e6f7ff;"></view>
            <text class="legend-text">平静</text>
          </view>
          <view class="legend-item">
            <view class="legend-color" style="background-color: #fff7e6;"></view>
            <text class="legend-text">中性</text>
          </view>
          <view class="legend-item">
            <view class="legend-color" style="background-color: #ffece6;"></view>
            <text class="legend-text">消极</text>
          </view>
        </view>
      </view>

      <!-- 最近情绪记录 -->
      <view class="recent-records-section">
        <view class="section-title">最近情绪记录</view>
        <view class="records-list">
          <view class="record-item"
                wx:for="{{recentRecords}}"
                wx:key="id"
                bindtap="viewRecordDetail"
                data-id="{{item.id}}"
                data-role-id="{{item.roleId}}"
                data-chat-id="{{item.chatId}}">
            <view class="record-icon-container" style="background-color: {{item.iconBg}};">
              <text class="record-icon {{item.iconName}}"></text>
            </view>
            <view class="record-content">
              <view class="record-emotions">{{item.emotions.join(' & ')}}</view>
              <view class="record-meta">
                <text>{{item.time}}</text>
                <text wx:if="{{item.roleName}}" class="record-role"> · 与 {{item.roleName}} 的对话</text>
                <text wx:else> · 对话记录</text>
              </view>
            </view>
            <view class="record-arrow">
              <text class="iconfont icon-right"></text>
            </view>
          </view>
        </view>

        <!-- 加载更多按钮 -->
        <view class="load-more" wx:if="{{hasMoreRecords}}" bindtap="loadMoreRecords">
          <text>加载更多</text>
        </view>
      </view>
    </block>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\packageEmotion\pages\emotion-history\emotion-history.wxss*#*#*begin*#*#*
/* packageEmotion/pages/emotion-history/emotion-history.wxss */

/* 容器样式 */
.container {
  min-height: 100vh;
  background-color: #f8f9fa;
  padding-bottom: 40rpx;
}

/* 暗黑模式 */
.container.dark-mode {
  background-color: #1a1a1a;
  color: #f0f0f0;
}

/* 自定义导航栏 */
.custom-nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background-color: #f8f9fa;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.08);
  padding-bottom: 10rpx; /* 底部增加一点空间 */
  transition: all 0.3s ease;
}

.dark-mode .custom-nav {
  background-color: #1a1a1a;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.15);
}

/* 状态栏和导航栏 */
.status-bar, .nav-bar {
  width: 100%;
}

/* 状态栏 */
.status-bar {
  background-color: #f8f9fa;
}

.dark-mode .status-bar {
  background-color: #1a1a1a;
}

/* 导航栏 */
.nav-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f8f9fa;
  box-sizing: border-box;
  padding: 10rpx 30rpx; /* 增加上下内边距 */
  min-height: 100rpx; /* 确保最小高度 */
}

.dark-mode .nav-bar {
  background-color: #1a1a1a;
}

.nav-left {
  display: flex;
  align-items: center;
  min-width: 80rpx;
  padding: 6rpx 0;
}

.back-btn {
  width: 60rpx;
  height: 60rpx;
  display: flex;
  justify-content: center;
  align-items: center;
}

.back-icon {
  width: 40rpx;
  height: 40rpx;
}

.nav-center {
  flex: 1;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 10rpx;
}

.nav-title {
  font-size: 36rpx;
  font-weight: bold;
  color: #333333;
}

.dark-mode .nav-title {
  color: #f8f9fa;
}

.nav-right {
  min-width: 80rpx;
}

/* 内容区域 */
.content-area {
  padding: 30rpx;
  width: 100%;
  box-sizing: border-box;
}

/* 时间范围选择器 */
.time-range-selector {
  margin-bottom: 30rpx;
  width: 100%;
}

.time-range-scroll {
  white-space: nowrap;
  display: flex;
  padding: 10rpx 0;
}

.time-range-item {
  display: inline-block;
  padding: 16rpx 30rpx;
  margin-right: 20rpx;
  background-color: #f0f0f0;
  color: #333;
  border-radius: 30rpx;
  font-size: 28rpx;
  transition: all 0.3s ease;
}

.time-range-item.active {
  background-color: #5e72e4;
  color: white;
}

.dark-mode .time-range-item {
  background-color: #333;
  color: #e0e0e0;
}

.dark-mode .time-range-item.active {
  background-color: #5e72e4;
  color: white;
}

/* 卡片样式 */
.emotion-card {
  background-color: white;
  border-radius: 16rpx;
  padding: 30rpx;
  margin-bottom: 30rpx;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.dark-mode .emotion-card {
  background-color: #2a2a2a;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.2);
}

.card-title {
  font-size: 32rpx;
  font-weight: 600;
  color: #333;
  margin-bottom: 20rpx;
}

.dark-mode .card-title {
  color: #e0e0e0;
}

/* 图表容器 */
.chart-container {
  width: 100%;
  height: 500rpx;
  margin-bottom: 20rpx;
}

.volatility-container {
  height: 400rpx;
}

/* 图例样式 */
.legend-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 20rpx;
}

.legend-item {
  display: flex;
  align-items: center;
  margin: 0 20rpx 10rpx;
}

.legend-color {
  width: 24rpx;
  height: 24rpx;
  border-radius: 50%;
  margin-right: 10rpx;
}

.legend-text {
  font-size: 24rpx;
  color: #666;
}

.dark-mode .legend-text {
  color: #aaa;
}

/* 情绪波动指数摘要 */
.volatility-summary {
  font-size: 28rpx;
  color: #666;
  line-height: 1.6;
  margin-top: 20rpx;
}

.dark-mode .volatility-summary {
  color: #aaa;
}

.volatility-value {
  font-weight: bold;
  color: #333;
  margin: 0 6rpx;
}

.dark-mode .volatility-value {
  color: #e0e0e0;
}

.increase {
  color: #e74c3c;
  font-weight: bold;
  margin: 0 6rpx;
}

.decrease {
  color: #2ecc71;
  font-weight: bold;
  margin: 0 6rpx;
}

/* 日历样式 */
.calendar-weekdays {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  margin-bottom: 10rpx;
}

.weekday-item {
  text-align: center;
  font-size: 24rpx;
  color: #999;
  padding: 10rpx 0;
}

.dark-mode .weekday-item {
  color: #777;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 10rpx;
}

.calendar-day {
  aspect-ratio: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #f5f5f5;
  border-radius: 10rpx;
  position: relative;
}

.dark-mode .calendar-day {
  background-color: #333;
}

.day-number {
  font-size: 24rpx;
  color: #333;
}

.dark-mode .day-number {
  color: #e0e0e0;
}

.other-month .day-number {
  color: #ccc;
}

.dark-mode .other-month .day-number {
  color: #666;
}

/* 情绪日历颜色 */
.emotion-positive {
  background-color: #e6ffec; /* 浅绿色 */
}

.emotion-calm {
  background-color: #e6f7ff; /* 浅蓝色 */
}

.emotion-neutral {
  background-color: #fff7e6; /* 浅黄色 */
}

.emotion-negative {
  background-color: #ffece6; /* 浅红色 */
}

.dark-mode .emotion-positive {
  background-color: rgba(46, 204, 113, 0.2);
}

.dark-mode .emotion-calm {
  background-color: rgba(52, 152, 219, 0.2);
}

.dark-mode .emotion-neutral {
  background-color: rgba(241, 196, 15, 0.2);
}

.dark-mode .emotion-negative {
  background-color: rgba(231, 76, 60, 0.2);
}

/* 日历图例 */
.calendar-legend {
  display: flex;
  justify-content: space-between;
  margin-top: 20rpx;
  flex-wrap: wrap;
}

/* 最近情绪记录 */
.recent-records-section {
  margin-top: 30rpx;
}

.section-title {
  font-size: 32rpx;
  font-weight: 600;
  color: #333;
  margin-bottom: 20rpx;
}

.dark-mode .section-title {
  color: #e0e0e0;
}

.records-list {
  background-color: white;
  border-radius: 16rpx;
  overflow: hidden;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.dark-mode .records-list {
  background-color: #2a2a2a;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.2);
}

.record-item {
  display: flex;
  align-items: center;
  padding: 30rpx;
  border-bottom: 1rpx solid #f0f0f0;
}

.dark-mode .record-item {
  border-bottom: 1rpx solid #333;
}

.record-item:last-child {
  border-bottom: none;
}

.record-icon-container {
  width: 80rpx;
  height: 80rpx;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-right: 20rpx;
  flex-shrink: 0;
}

.record-icon {
  font-size: 40rpx;
  color: #333;
}

.record-content {
  flex: 1;
}

.record-emotions {
  font-size: 30rpx;
  font-weight: 500;
  color: #333;
  margin-bottom: 6rpx;
}

.dark-mode .record-emotions {
  color: #e0e0e0;
}

.record-meta {
  font-size: 24rpx;
  color: #999;
}

.dark-mode .record-meta {
  color: #777;
}

.record-role {
  color: #5e72e4;
  font-weight: 500;
}

.dark-mode .record-role {
  color: #7986cb;
}

.record-arrow {
  color: #ccc;
  font-size: 24rpx;
}

.dark-mode .record-arrow {
  color: #666;
}

/* 加载更多 */
.load-more {
  text-align: center;
  padding: 30rpx 0;
  color: #5e72e4;
  font-size: 28rpx;
}

/* 加载中 */
.loading-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 400rpx;
}

.loading-spinner {
  width: 60rpx;
  height: 60rpx;
  border: 6rpx solid #f3f3f3;
  border-top: 6rpx solid #5e72e4;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 20rpx;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-text {
  font-size: 28rpx;
  color: #999;
}

.dark-mode .loading-text {
  color: #777;
}

/* 无数据提示 */
.no-data-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 400rpx;
}

.no-data-icon {
  font-size: 80rpx;
  color: #ccc;
  margin-bottom: 20rpx;
}

.dark-mode .no-data-icon {
  color: #666;
}

.no-data-text {
  font-size: 32rpx;
  color: #666;
  margin-bottom: 10rpx;
}

.dark-mode .no-data-text {
  color: #aaa;
}

.no-data-tip {
  font-size: 28rpx;
  color: #999;
}

.dark-mode .no-data-tip {
  color: #777;
}

*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\agreement-common.wxss*#*#*begin*#*#*
/* 协议页面公共样式 */
.agreement-page {
  padding: 30rpx;
  background-color: var(--bg-color, #fff);
  min-height: 100vh;
}

.agreement-header {
  margin-bottom: 40rpx;
}

.agreement-title {
  font-size: 36rpx;
  font-weight: bold;
  margin-bottom: 10rpx;
  text-align: center;
}

.agreement-date {
  font-size: 24rpx;
  color: var(--text-secondary, #999);
  text-align: center;
}

.agreement-content {
  font-size: 28rpx;
  line-height: 1.6;
  color: var(--text-primary, #333);
}

.section {
  margin-bottom: 30rpx;
}

.section-title {
  font-size: 32rpx;
  font-weight: bold;
  margin-bottom: 20rpx;
}

.section-content {
  padding-left: 20rpx;
}

.paragraph {
  margin-bottom: 20rpx;
}

.list-item {
  margin-bottom: 10rpx;
  padding-left: 20rpx;
}

/* 暗黑模式样式 */
@media (prefers-color-scheme: dark) {
  .agreement-page {
    background-color: var(--bg-color-dark, #1a1a1a);
  }
  
  .agreement-title {
    color: var(--text-primary-dark, #f0f0f0);
  }
  
  .agreement-date {
    color: var(--text-secondary-dark, #aaa);
  }
  
  .agreement-content {
    color: var(--text-primary-dark, #f0f0f0);
  }
  
  .section-title {
    color: var(--text-primary-dark, #f0f0f0);
  }
}

/* 返回按钮样式 */
.nav-bar {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  background-color: var(--bg-color, #fff);
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.1);
}

.status-bar {
  width: 100%;
}

.nav-content {
  height: 44px;
  display: flex;
  align-items: center;
  padding: 0 30rpx;
}

.back-button {
  padding: 10rpx;
  font-size: 36rpx;
  color: var(--text-primary, #333);
}

.page-title {
  flex: 1;
  text-align: center;
  font-size: 34rpx;
  font-weight: bold;
  color: var(--text-primary, #333);
}

/* 暗黑模式导航栏样式 */
@media (prefers-color-scheme: dark) {
  .nav-bar {
    background-color: var(--bg-color-dark, #1a1a1a);
    box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.3);
  }
  
  .back-button {
    color: var(--text-primary-dark, #f0f0f0);
  }
  
  .page-title {
    color: var(--text-primary-dark, #f0f0f0);
  }
}

*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\agreement.wxss*#*#*begin*#*#*
.agreement-page {
  padding: 30rpx;
  background: #fff;
  min-height: 100vh;
}

.agreement-header {
  text-align: center;
  margin-bottom: 40rpx;
  padding-bottom: 20rpx;
  border-bottom: 1px solid #eee;
}

.agreement-title {
  font-size: 36rpx;
  font-weight: bold;
  color: #333;
  margin-bottom: 10rpx;
}

.agreement-date {
  font-size: 24rpx;
  color: #999;
}

.agreement-content {
  padding-bottom: 40rpx;
}

.section {
  margin-bottom: 30rpx;
}

.section-title {
  font-size: 32rpx;
  font-weight: bold;
  color: #333;
  margin-bottom: 20rpx;
}

.section-content {
  color: #666;
  font-size: 28rpx;
  line-height: 1.6;
}

.paragraph {
  margin-bottom: 16rpx;
}

.list-item {
  margin-bottom: 12rpx;
  padding-left: 20rpx;
} 
*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\privacy.js*#*#*begin*#*#*
// pages/agreement/privacy.js
Page({
  data: {
    statusBarHeight: wx.getSystemInfoSync().statusBarHeight || 20,
    navBarHeight: 44,
    lastUpdated: '2024年3月10日'
  },

  onLoad: function (options) {
    // 设置页面标题
    wx.setNavigationBarTitle({
      title: '隐私政策'
    });

    // 检查是否从欢迎页面跳转而来
    if (options && options.from === 'welcome') {
      this.setData({
        showBackButton: false
      });
    } else {
      this.setData({
        showBackButton: true
      });
    }
  },

  onReady: function() {
    // 页面渲染完成
  },

  onShow: function() {
    // 页面显示
  },

  onHide: function() {
    // 页面隐藏
  },

  onUnload: function() {
    // 页面卸载
  },

  // 返回上一页
  navigateBack: function() {
    wx.navigateBack({
      delta: 1
    });
  }
})

*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\privacy.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "隐私协议"
}

*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\privacy.ts*#*#*begin*#*#*
Page({
  data: {
    title: '隐私协议'
  },

  onShareAppMessage() {
    return {
      title: 'HeartChat隐私协议',
      path: '/pages/agreement/privacy'
    };
  }
}); 
*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\privacy.wxml*#*#*begin*#*#*
<view class="agreement-page">
  <!-- 自定义导航栏 -->
  <block wx:if="{{showBackButton}}">
    <view class="nav-bar">
      <view class="status-bar" style="height: {{statusBarHeight}}px"></view>
      <view class="nav-content">
        <view class="back-button" bindtap="navigateBack">←</view>
        <view class="page-title">隐私政策</view>
        <view style="width: 30rpx;"></view>
      </view>
    </view>
    <!-- 导航栏占位 -->
    <view style="height: {{statusBarHeight + navBarHeight}}px"></view>
  </block>

  <view class="agreement-header">
    <view class="agreement-title">隐私政策</view>
    <view class="agreement-date">更新日期：{{lastUpdated}}</view>
  </view>

  <view class="agreement-content">
    <view class="section">
      <view class="section-title">1. 引言</view>
      <view class="section-content">
        <view class="paragraph">本隐私协议说明了HeartChat如何收集、使用和保护您的个人信息。请您仔细阅读并理解本协议的全部内容。</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">2. 信息收集</view>
      <view class="section-content">
        <view class="paragraph">我们收集的信息包括：</view>
        <view class="list-item">• 账号信息（微信头像、昵称等）</view>
        <view class="list-item">• 使用数据（对话记录、使用时长等）</view>
        <view class="list-item">• 设备信息（设备型号、系统版本等）</view>
        <view class="list-item">• 网络数据（IP地址、访问时间等）</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">3. 信息使用</view>
      <view class="section-content">
        <view class="paragraph">我们使用收集的信息用于：</view>
        <view class="list-item">• 提供和改进服务</view>
        <view class="list-item">• 个性化用户体验</view>
        <view class="list-item">• 数据分析和研究</view>
        <view class="list-item">• 安全防护</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">4. 信息保护</view>
      <view class="section-content">
        <view class="paragraph">4.1 我们采用业界标准的安全技术保护您的信息。</view>
        <view class="paragraph">4.2 我们不会将您的信息用于本协议未载明的其他用途。</view>
        <view class="paragraph">4.3 我们不会向第三方出售或出租您的个人信息。</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">5. 信息共享</view>
      <view class="section-content">
        <view class="paragraph">除以下情况外，我们不会共享您的个人信息：</view>
        <view class="list-item">• 获得您的明确授权</view>
        <view class="list-item">• 法律法规要求</view>
        <view class="list-item">• 保护用户或公众的权益</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">6. 您的权利</view>
      <view class="section-content">
        <view class="paragraph">您对个人信息享有以下权利：</view>
        <view class="list-item">• 访问和查看</view>
        <view class="list-item">• 更正和补充</view>
        <view class="list-item">• 删除</view>
        <view class="list-item">• 撤回授权同意</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">7. Cookie的使用</view>
      <view class="section-content">
        <view class="paragraph">我们使用Cookie和类似技术来提供和改进服务。您可以通过浏览器设置管理Cookie。</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">8. 协议更新</view>
      <view class="section-content">
        <view class="paragraph">我们可能适时修改本隐私协议，并通过应用内通知或其他方式告知您。继续使用我们的服务表示您同意修改后的协议。</view>
      </view>
    </view>
  </view>
</view>
*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\privacy.wxss*#*#*begin*#*#*
/* pages/agreement/privacy.wxss */
@import "./agreement-common.wxss";

/* 隐私政策特定样式可以在这里添加 */

*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\service.js*#*#*begin*#*#*
// pages/agreement/service.js
Page({
  data: {
    statusBarHeight: wx.getSystemInfoSync().statusBarHeight || 20,
    navBarHeight: 44,
    lastUpdated: '2024年3月10日'
  },

  onLoad: function (options) {
    // 设置页面标题
    wx.setNavigationBarTitle({
      title: '服务协议'
    });

    // 检查是否从欢迎页面跳转而来
    if (options && options.from === 'welcome') {
      this.setData({
        showBackButton: false
      });
    } else {
      this.setData({
        showBackButton: true
      });
    }
  },

  onReady: function() {
    // 页面渲染完成
  },

  onShow: function() {
    // 页面显示
  },

  onHide: function() {
    // 页面隐藏
  },

  onUnload: function() {
    // 页面卸载
  },

  // 返回上一页
  navigateBack: function() {
    wx.navigateBack({
      delta: 1
    });
  }
})

*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\service.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "服务协议"
}

*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\service.ts*#*#*begin*#*#*
Page({
  data: {
    title: '服务协议'
  },

  onShareAppMessage() {
    return {
      title: 'HeartChat服务协议',
      path: '/pages/agreement/service'
    };
  }
}); 
*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\service.wxml*#*#*begin*#*#*
<view class="agreement-page">
  <!-- 自定义导航栏 -->
  <block wx:if="{{showBackButton}}">
    <view class="nav-bar">
      <view class="status-bar" style="height: {{statusBarHeight}}px"></view>
      <view class="nav-content">
        <view class="back-button" bindtap="navigateBack">←</view>
        <view class="page-title">服务协议</view>
        <view style="width: 30rpx;"></view>
      </view>
    </view>
    <!-- 导航栏占位 -->
    <view style="height: {{statusBarHeight + navBarHeight}}px"></view>
  </block>

  <view class="agreement-header">
    <view class="agreement-title">服务协议</view>
    <view class="agreement-date">更新日期：{{lastUpdated}}</view>
  </view>

  <view class="agreement-content">
    <view class="section">
      <view class="section-title">1. 协议的范围</view>
      <view class="section-content">
        <view class="paragraph">欢迎您使用HeartChat（以下简称"本服务"）。本协议是您与HeartChat之间关于使用本服务所订立的协议。</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">2. 服务内容</view>
      <view class="section-content">
        <view class="paragraph">HeartChat是一款基于人工智能的情商训练应用，为用户提供情感交流、情商提升等服务。具体功能包括但不限于：</view>
        <view class="list-item">• AI对话训练</view>
        <view class="list-item">• 情感分析</view>
        <view class="list-item">• 情商提升建议</view>
        <view class="list-item">• 角色扮演练习</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">3. 账号注册与使用</view>
      <view class="section-content">
        <view class="paragraph">3.1 您需要使用微信账号授权登录使用本服务。</view>
        <view class="paragraph">3.2 您应当对账号的使用和安全负责。</view>
        <view class="paragraph">3.3 您不得将账号转让或授权他人使用。</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">4. 用户行为规范</view>
      <view class="section-content">
        <view class="paragraph">您在使用本服务时应当遵守以下规定：</view>
        <view class="list-item">• 遵守法律法规</view>
        <view class="list-item">• 尊重他人权益</view>
        <view class="list-item">• 维护网络秩序</view>
        <view class="list-item">• 保护知识产权</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">5. 知识产权</view>
      <view class="section-content">
        <view class="paragraph">5.1 本服务的所有内容，包括但不限于文字、图片、音频、视频、软件、程序、数据均受知识产权法律法规保护。</view>
        <view class="paragraph">5.2 未经授权，您不得复制、修改、传播或使用上述内容。</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">6. 服务变更、中断或终止</view>
      <view class="section-content">
        <view class="paragraph">6.1 我们保留随时修改或中断服务的权利。</view>
        <view class="paragraph">6.2 如您违反本协议，我们有权终止向您提供服务。</view>
      </view>
    </view>

    <view class="section">
      <view class="section-title">7. 免责声明</view>
      <view class="section-content">
        <view class="paragraph">7.1 本服务按"现状"提供，我们不对服务的适用性、可靠性、准确性等做出任何承诺。</view>
        <view class="paragraph">7.2 对于因不可抗力、网络问题等导致的服务中断或数据丢失，我们不承担责任。</view>
      </view>
    </view>
  </view>
</view>
*#*#*end*#*#*

*#*#*miniprogram\pages\agreement\service.wxss*#*#*begin*#*#*
/* pages/agreement/service.wxss */
@import "./agreement-common.wxss";

/* 服务协议特定样式可以在这里添加 */

*#*#*end*#*#*

*#*#*miniprogram\pages\home\home.js*#*#*begin*#*#*
// pages/home/home.js
const app = getApp();
const userService = require('../../services/userService');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

Page({
  /**
   * 页面的初始数据
   */
  data: {
    userInfo: null,
    darkMode: false,
    recentChats: [],
    loading: true,
    statusBarHeight: 20, // 状态栏高度，默认值
    navBarHeight: 44, // 导航栏高度，默认值
    menuButtonInfo: null, // 胶囊按钮信息
    defaultAvatar: require('../../config/index').user.DEFAULT_AVATAR // 默认头像
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function () {
    if (isDev) {
      console.log('首页加载，用户信息：', app.globalData.userInfo);
    }
    // 获取系统信息和导航栏高度
    this.getSystemInfo();

    // 获取用户信息
    this.setData({
      userInfo: app.globalData.userInfo,
      darkMode: app.globalData.darkMode
    });

    // 延迟加载最近对话，确保用户信息已加载
    setTimeout(() => {
      this.loadRecentChats();
    }, 500);
  },

  /**
   * 获取系统信息和导航栏高度
   */
  getSystemInfo: function() {
    try {
      // 获取系统信息
      const systemInfo = wx.getSystemInfoSync();
      // 获取胶囊按钮位置信息
      const menuButtonInfo = wx.getMenuButtonBoundingClientRect();

      // 计算导航栏高度，增加一点高度使其更美观
      const navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + 10;
      // 计算导航栏总高度（状态栏 + 导航栏）
      const navTotalHeight = systemInfo.statusBarHeight + navBarHeight;

      this.setData({
        statusBarHeight: systemInfo.statusBarHeight,
        navBarHeight: navBarHeight,
        navTotalHeight: navTotalHeight,
        menuButtonInfo: menuButtonInfo
      });

      // 将导航高度信息存入全局数据
      app.globalData.navHeight = navBarHeight;
      app.globalData.statusBarHeight = systemInfo.statusBarHeight;
      app.globalData.navTotalHeight = navTotalHeight;
    } catch (e) {
      console.error('获取系统信息失败:', e.message || e);
    }
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    // 检查主题变化
    if (this.data.darkMode !== app.globalData.darkMode) {
      this.setData({
        darkMode: app.globalData.darkMode
      });

      // 更新TabBar样式
      if (app.updateTheme) {
        app.updateTheme(app.globalData.darkMode);
      }
    }

    // 检查用户信息变化
    if (app.globalData.userInfo && (!this.data.userInfo || this.data.userInfo._id !== app.globalData.userInfo._id)) {
      this.setData({
        userInfo: app.globalData.userInfo
      });
    }

    // 刷新最近对话
    this.loadRecentChats();
  },

  /**
   * 加载最近对话
   */
  loadRecentChats: function () {
    this.setData({ loading: true });

    // 获取用户ID
    const userInfo = app.globalData.userInfo;
    if (isDev) {
      console.log('加载最近对话，用户信息：', userInfo);
    }

    if (!userInfo) {
      if (isDev) {
        console.log('用户未登录，无法加载最近对话');
      }
      this.setData({ loading: false });
      return;
    }

    // 使用userService获取用户ID和openid
    const { userId, openid } = userService.getUserIdentifiers(userInfo);

    // 检查用户是否有效
    if (!userService.isValidUser(userInfo)) {
      if (isDev) {
        console.log('无法获取用户ID或openid');
      }
      this.setData({ loading: false });
      return;
    }

    // 直接从数据库查询最近对话
    const db = wx.cloud.database();

    // 使用userService构建查询条件，确保只查询当前用户的聊天记录
    const query = userService.buildUserQuery(userInfo);

    // 使用数据库查询条件，直接获取当前用户的聊天记录
    // 这样可以减少数据传输量，提高查询效率
    db.collection('chats')
      .where(query) // 使用构建好的查询条件
      .orderBy('last_message_time', 'desc')
      .limit(10) // 限制返回记录数量
      .get()
      .then(async res => {
        let chats = res.data || [];
        if (isDev) {
          console.log('获取到的原始聊天数据数量:', chats.length);
        }

        // 在前端过滤当前用户的聊天记录
        if (openid) {
          chats = chats.filter(chat => chat.openId === openid);
          if (isDev) {
            console.log('根据openId过滤后的聊天数据数量:', chats.length);
          }
        } else if (userId) {
          chats = chats.filter(chat => chat.userId === userId || chat.user_id === userId);
          if (isDev) {
            console.log('根据userId过滤后的聊天数据数量:', chats.length);
          }
        }

        // 如果没有数据，直接返回
        if (chats.length === 0) {
          this.setData({
            recentChats: [],
            loading: false
          });
          return;
        }

        // 获取所有角色ID，用于批量查询角色信息
        // 注意大小写，兼容roleId和role_id两种形式
        const roleIds = chats.map(chat => chat.roleId || chat.role_id).filter(id => id);
        const uniqueRoleIds = [...new Set(roleIds)];

        // 角色信息映射表
        let roleInfoMap = {};

        // 如果有角色ID，批量获取角色信息
        if (uniqueRoleIds.length > 0) {
          try {
            // 从roles集合获取角色信息
            const roleResult = await db.collection('roles')
              .where({
                _id: db.command.in(uniqueRoleIds)
              })
              .get();

            // 构建角色信息映射表
            roleResult.data.forEach(role => {
              roleInfoMap[role._id] = role;
            });
          } catch (error) {
            console.error('获取角色信息失败:', error.message || error);
          }
        }

        // 处理时间显示和角色信息
        const processedChats = chats.map(chat => {
          // 格式化时间
          const timeText = this.formatChatTime(chat);

          // 处理角色信息
          const { roleId, roleName, roleAvatar } = this.processRoleInfo(chat, roleInfoMap);

          // 获取最后一条消息内容，兼容不同的字段名称
          const lastMessage = chat.lastMessage || chat.last_message || chat.last_message_content || '开始一段新的对话吧';

          return {
            ...chat,
            roleId: roleId, // 使用驼峰命名法，与数据库中的字段保持一致
            roleName: roleName, // 使用驼峰命名法，与数据库中的字段保持一致
            roleAvatar: roleAvatar, // 使用驼峰命名法，与数据库中的字段保持一致
            lastMessage: lastMessage, // 使用驼峰命名法，与数据库中的字段保持一致
            time_text: timeText
          };
        });

        // 过滤掉没有roleId的聊天
        const filteredChats = processedChats.filter(chat => chat.roleId);

        this.setData({
          recentChats: filteredChats,
          loading: false
        });
      })
      .catch(err => {
        console.error('获取最近对话失败:', err.message || err);
        this.setData({ loading: false });
      });
  },

  /**
   * 跳转到心情树洞（现为role-select tab页）
   */
  navigateToEmotionVault: function () {
    // 使用switchTab方法跳转到tab页面
    wx.switchTab({
      url: '/pages/role-select/role-select',
      success: function() {
        if (isDev) {
          console.log('成功跳转到角色选择页面');
        }
      },
      fail: function(err) {
        console.error('跳转失败:', err.message || err);
        wx.showToast({
          title: '跳转失败',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 跳转到情绪分析
   */
  navigateToEmotionAnalysis: function () {
    // 获取用户ID
    const userInfo = app.globalData.userInfo;
    if (!userInfo) {
      wx.showToast({
        title: '请先登录',
        icon: 'none'
      });
      return;
    }

    // 尝试从本地缓存中获取最新的情绪分析结果
    const emotionService = require('../../services/emotionService');
    const cachedEmotionAnalysis = emotionService.getLatestEmotionAnalysis();

    // 如果有缓存的情绪分析结果，直接使用
    if (cachedEmotionAnalysis && cachedEmotionAnalysis.data) {
      if (isDev) {
        console.log('使用缓存的情绪分析结果');
      }

      // 将缓存的情绪分析结果存入全局变量，供情绪分析页面使用
      app.globalData.cachedEmotionAnalysis = cachedEmotionAnalysis;

      // 跳转到情绪分析页面，带上缓存标记
      wx.navigateTo({
        url: '/packageChat/pages/emotion-analysis/emotion-analysis?useCache=true',
        fail: (err) => {
          console.error('跳转失败:', err.message || err);
          wx.showToast({
            title: '跳转失败',
            icon: 'none'
          });
        }
      });

      // 同时在后台查询最新数据，以便刷新缓存
      this.queryLatestEmotionDataInBackground();
      return;
    }

    // 如果没有缓存数据，则查询最近的聊天记录
    if (isDev) {
      console.log('没有缓存的情绪分析结果，查询最近的聊天记录');
    }

    // 使用userService获取用户ID和openid
    const { userId, openid } = userService.getUserIdentifiers(userInfo);

    // 检查用户是否有效
    if (!userService.isValidUser(userInfo)) {
      wx.showToast({
        title: '无法获取用户信息',
        icon: 'none'
      });
      return;
    }

    // 显示加载中提示
    wx.showLoading({
      title: '加载中...'
    });

    // 查询最近的聊天记录
    const db = wx.cloud.database();
    const query = userService.buildUserQuery(userInfo);

    db.collection('chats')
      .where(query)
      .orderBy('last_message_time', 'desc')
      .limit(1)
      .get()
      .then(res => {
        wx.hideLoading();
        const chats = res.data || [];

        if (chats.length > 0) {
          const latestChat = chats[0];
          const chatId = latestChat._id;
          const roleId = latestChat.roleId || latestChat.role_id;

          // 跳转到情绪分析页面，带上聊天ID和角色ID
          this.navigate(`/packageChat/pages/emotion-analysis/emotion-analysis?chatId=${chatId}&roleId=${roleId}`);
        } else {
          // 如果没有聊天记录，直接跳转到情绪分析页面
          this.navigate('/packageChat/pages/emotion-analysis/emotion-analysis');
        }
      })
      .catch(err => {
        wx.hideLoading();
        console.error('获取最近聊天失败:', err.message || err);
        // 出错时也直接跳转到情绪分析页面
        this.navigate('/packageChat/pages/emotion-analysis/emotion-analysis');
      });
  },

  /**
   * 在后台查询最新的情绪数据，用于更新缓存
   */
  queryLatestEmotionDataInBackground: function() {
    const userInfo = app.globalData.userInfo;
    if (!userInfo) return;

    // 检查用户是否有效
    if (!userService.isValidUser(userInfo)) return;

    const db = wx.cloud.database();
    const query = userService.buildUserQuery(userInfo);

    // 查询最近的聊天记录
    db.collection('chats')
      .where(query)
      .orderBy('last_message_time', 'desc')
      .limit(1)
      .get()
      .then(res => {
        const chats = res.data || [];
        if (chats.length > 0) {
          const latestChat = chats[0];
          const chatId = latestChat._id;

          // 查询该聊天的情绪分析结果
          wx.cloud.callFunction({
            name: 'analysis',
            data: {
              type: 'chat_emotion',
              chatId: chatId
            }
          }).then(result => {
            if (result && result.result && result.result.success) {
              // 更新缓存
              const finalResult = {
                success: true,
                data: {
                  ...result.result.data || result.result.result || {},
                  timestamp: new Date().getTime()
                }
              };

              try {
                wx.setStorageSync('latestEmotionAnalysis', finalResult);
                if (isDev) {
                  console.log('后台更新情绪分析缓存成功');
                }
              } catch (e) {
                console.error('后台更新情绪分析缓存失败:', e.message || e);
              }
            }
          }).catch(err => {
            console.error('后台查询情绪分析失败:', err.message || err);
          });
        }
      })
      .catch(err => {
        console.error('后台查询最近聊天失败:', err.message || err);
      });
  },

  /**
   * 通用导航方法
   * @param {string} url - 导航URL
   * @param {string} method - 导航方法，可选值：navigateTo, switchTab, redirectTo, reLaunch
   * @param {Function} successCallback - 成功回调函数
   */
  navigate: function(url, method = 'navigateTo', successCallback = null) {
    if (!url) {
      console.error('导航URL不能为空');
      return;
    }

    // 默认的成功回调
    const defaultSuccess = function() {
      console.log(`成功跳转到: ${url}`);
    };

    // 默认的失败回调
    const defaultFail = function(err) {
      console.error(`跳转失败: ${url}`, err);
      wx.showToast({
        title: '跳转失败',
        icon: 'none'
      });
    };

    // 根据method选择不同的导航方法
    switch (method) {
      case 'switchTab':
        wx.switchTab({
          url: url,
          success: successCallback || defaultSuccess,
          fail: defaultFail
        });
        break;
      case 'redirectTo':
        wx.redirectTo({
          url: url,
          success: successCallback || defaultSuccess,
          fail: defaultFail
        });
        break;
      case 'reLaunch':
        wx.reLaunch({
          url: url,
          success: successCallback || defaultSuccess,
          fail: defaultFail
        });
        break;
      case 'navigateTo':
      default:
        wx.navigateTo({
          url: url,
          success: successCallback || defaultSuccess,
          fail: defaultFail
        });
        break;
    }
  },

  /**
   * 跳转到情绪历史页面
   */
  navigateToEmotionHistory: function () {
    this.navigate('/packageEmotion/pages/emotion-history/emotion-history');
  },

  /**
   * 跳转到关键词测试
   */
  navigateToKeywordTest: function () {
    this.navigate('/pages/keywordTest/keywordTest');
  },

  /**
   * 跳转到Gemini测试页面
   */
  navigateToTestGemini: function () {
    this.navigate('/pages/test-gemini/test-gemini');
  },

  /**
   * 跳转到每日报告
   */
  navigateToDailyReport: function () {
    this.navigate('/packageEmotion/pages/daily-report/daily-report');
  },

  /**
   * 跳转到聊天页面
   */
  navigateToChat: function (e) {
    const { chatId, roleId } = e.currentTarget.dataset;
    if (isDev) {
      console.log('跳转到聊天页面，参数：', chatId, roleId);
    }

    if (!roleId) {
      wx.showToast({
        title: '角色ID不能为空',
        icon: 'none'
      });
      return;
    }

    // 构建跳转参数
    let url = '/packageChat/pages/chat/chat?roleId=' + roleId;

    // 如果有chatId，添加到URL
    if (chatId) {
      url += `&chatId=${chatId}`;
    }

    if (isDev) {
      console.log('跳转到聊天页面:', url);
    }

    // 将角色ID和聊天ID存入全局变量，确保聊天页面可以获取到正确的角色ID
    app.globalData.chatParams = { roleId: roleId, chatId: chatId };

    // 尝试从最近对话中获取角色信息
    const chat = this.data.recentChats.find(item => item._id === chatId);
    if (chat) {
      // 如果找到了对应的聊天记录，将角色信息也存入全局变量
      app.globalData.chatParams.roleName = chat.roleName;
      app.globalData.chatParams.roleAvatar = chat.roleAvatar;
      if (isDev) {
        console.log('存入全局变量的角色信息:', app.globalData.chatParams);
      }
    }

    // 跳转到聊天页面
    wx.navigateTo({
      url: url,
      fail: function(err) {
        console.error('跳转失败:', err.message || err);
        wx.showToast({
          title: '跳转失败',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 跳转到用户资料
   */
  navigateToProfile: function () {
    this.navigate('/pages/user/profile/profile');
  },

  /**
   * 处理角色信息
   * @param {Object} chat - 聊天记录对象
   * @param {Object} roleInfoMap - 角色信息映射表
   * @returns {Object} 处理后的角色信息
   */
  processRoleInfo: function(chat, roleInfoMap) {
    // 确保有roleId字段，兼容不同的字段名称，注意大小写
    const roleId = chat.roleId || chat.role_id;

    // 获取角色信息，兼容不同的字段名称，注意大小写
    let roleName = chat.roleName || chat.role_name;
    let roleAvatar = chat.roleAvatar || chat.role_avatar;

    // 如果有角色ID且角色信息映射表中有该角色，使用映射表中的角色信息
    if (roleId && roleInfoMap[roleId]) {
      const roleInfo = roleInfoMap[roleId];
      roleName = roleName || roleInfo.name || roleInfo.role_name;
      roleAvatar = roleAvatar || roleInfo.avatar || roleInfo.avatar_url;
    }

    // 如果还是没有角色名称，使用默认值
    if (!roleName) {
      roleName = '对话角色';
    }

    // 如果还是没有角色头像，使用默认值
    if (!roleAvatar) {
      roleAvatar = require('../../config/index').user.DEFAULT_AVATAR;
    }

    return { roleId, roleName, roleAvatar };
  },

  /**
   * 格式化聊天时间
   * @param {Object} chat - 聊天记录对象
   * @returns {string} 格式化后的时间文本
   */
  formatChatTime: function(chat) {
    // 格式化时间 - 优先使用updateTime，其次是last_message_time
    const messageTime = chat.updateTime ? new Date(chat.updateTime) :
                      chat.last_message_time ? new Date(chat.last_message_time) : new Date();

    // 确保时间是有效的Date对象
    const validTime = isNaN(messageTime.getTime()) ? new Date() : messageTime;

    const now = new Date();
    const diffMs = now - validTime;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    let timeText = '';
    if (diffDays === 0) {
      // 今天，显示具体时间
      const hours = validTime.getHours();
      const minutes = validTime.getMinutes();
      timeText = `${hours}:${minutes < 10 ? '0' + minutes : minutes}`;
    } else if (diffDays === 1) {
      timeText = '昨天';
    } else if (diffDays < 7) {
      timeText = `${diffDays}天前`;
    } else {
      // 超过7天，显示具体日期
      timeText = `${validTime.getMonth() + 1}-${validTime.getDate()}`;
    }

    return timeText;
  },

  /**
   * 获取角色信息映射表
   * @param {Array} chats - 聊天记录数组
   * @returns {Object} 角色信息映射表
   */
  fetchRoleInfoMap: async function(chats) {
    // 角色信息映射表
    let roleInfoMap = {};

    try {
      // 获取所有角色ID，用于批量查询角色信息
      // 注意大小写，兼容roleId和role_id两种形式
      const roleIds = chats.map(chat => chat.roleId || chat.role_id).filter(id => id);
      const uniqueRoleIds = [...new Set(roleIds)];

      console.log('提取的角色ID:', uniqueRoleIds);

      // 如果有角色ID，批量获取角色信息
      if (uniqueRoleIds.length > 0) {
        // 从roles集合获取角色信息
        const db = wx.cloud.database();
        const roleResult = await db.collection('roles')
          .where({
            _id: db.command.in(uniqueRoleIds)
          })
          .get();

        // 构建角色信息映射表
        roleResult.data.forEach(role => {
          roleInfoMap[role._id] = role;
        });

        console.log('获取到的角色信息:', roleInfoMap);
      }
    } catch (error) {
      console.error('获取角色信息失败:', error);
    }

    return roleInfoMap;
  }
});

*#*#*end*#*#*

*#*#*miniprogram\pages\home\home.json*#*#*begin*#*#*
{
  "navigationStyle": "custom",
  "backgroundColor": "#f8f9fa",
  "enablePullDownRefresh": true,
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\pages\home\home.wxml*#*#*begin*#*#*
<!--pages/home/home.wxml-->
<view class="container {{darkMode ? 'dark' : ''}}">
  <!-- 导航栏容器 -->
  <view class="nav-container">
    <!-- 状态栏占位 -->
    <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

    <!-- 自定义导航栏 -->
    <view class="nav-bar" style="height: {{navBarHeight}}px;">
    <view class="nav-bar-left">
      <view class="avatar" bindtap="navigateToProfile">
        <image src="{{userInfo.avatarUrl || userInfo.avatar_url || defaultAvatar}}" mode="aspectFill"></image>
      </view>
    </view>
    <view class="nav-bar-title">
      <text class="greeting">你好，{{userInfo.username || userInfo.nickname || '朋友'}}</text>
    </view>
    <view class="nav-bar-right"></view>
    </view>
  </view>

  <!-- 内容区域 -->
  <view class="content-area" style="margin-top: {{navTotalHeight + 10}}px;">
    <!-- 每日心情卡片 -->
    <view class="daily-mood-card" bindtap="navigateToDailyReport">
    <view class="card-content">
      <view class="card-text">
        <text class="card-title">今日心情</text>
        <text class="card-desc">查看你的每日心情报告，了解情绪变化</text>
        <view class="card-btn">查看报告</view>
      </view>
      <view class="card-icon">
        <text class="icon-sun">☀️</text>
      </view>
    </view>
  </view>

  <!-- 主要功能区 -->
  <view class="section-title">主要功能</view>
  <view class="feature-grid">
    <view class="feature-card" bindtap="navigateToEmotionVault">
      <view class="feature-icon emotion-vault-icon">
        <text class="iconfont">💬</text>
      </view>
      <text class="feature-name">心情树洞</text>
      <text class="feature-desc">与AI角色对话，倾诉心事</text>
    </view>

    <view class="feature-card" bindtap="navigateToEmotionAnalysis">
      <view class="feature-icon emotion-analysis-icon">
        <text class="iconfont">🧠</text>
      </view>
      <text class="feature-name">情绪分析</text>
      <text class="feature-desc">分析你的情感状态</text>
    </view>

    <view class="feature-card" bindtap="navigateToEmotionHistory">
      <view class="feature-icon emotion-history-icon">
        <text class="iconfont">📊</text>
      </view>
      <text class="feature-name">情绪追踪</text>
      <text class="feature-desc">查看你的情绪历史记录</text>
    </view>

    <view class="feature-card" bindtap="navigateToKeywordTest">
      <view class="feature-icon keyword-test-icon">
        <text class="iconfont">🔍</text>
      </view>
      <text class="feature-name">关键词提取</text>
      <text class="feature-desc">提取文本中的关键词</text>
    </view>

    <view class="feature-card" bindtap="navigateToTestGemini">
      <view class="feature-icon gemini-test-icon">
        <text class="iconfont">🤖</text>
      </view>
      <text class="feature-name">Gemini测试</text>
      <text class="feature-desc">测试Gemini API连接</text>
    </view>
  </view>

  <!-- 最近对话 -->
  <view class="section-title">最近对话</view>
  <view class="recent-chats">
    <block wx:if="{{recentChats.length > 0}}">
      <view class="chat-item" wx:for="{{recentChats}}" wx:key="_id"
            data-chat-id="{{item._id}}" data-role-id="{{item.roleId}}"
            bindtap="navigateToChat">
        <view class="chat-avatar">
          <image src="{{item.roleAvatar}}" mode="aspectFill"></image>
        </view>
        <view class="chat-info">
          <text class="chat-name">{{item.roleName}}</text>
          <text class="chat-message">{{item.lastMessage}}</text>
        </view>
        <view class="chat-time">
          <text>{{item.time_text}}</text>
        </view>
      </view>
    </block>
    <view class="empty-chats" wx:if="{{!loading && recentChats.length === 0}}">
      <text>暂无最近对话</text>
      <view class="start-chat-btn" bindtap="navigateToEmotionVault">选择角色聊天</view>
    </view>
    <view class="loading" wx:if="{{loading}}">
      <text>加载中...</text>
    </view>
  </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\home\home.wxss*#*#*begin*#*#*
/* pages/home/home.wxss */
page {
  background-color: #f8f9fa;
}

.container {
  padding: 0;
  padding-top: 0;
  min-height: 100vh;
  box-sizing: border-box;
}

/* 暗黑模式 */
.dark {
  background-color: #1a1d20;
  color: #f8f9fa;
}

/* 导航栏容器 */
.nav-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background-color: #f8f9fa;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.08);
  border-bottom-left-radius: 24rpx;
  border-bottom-right-radius: 24rpx;
  padding-bottom: 10rpx; /* 底部增加一点空间 */
  transition: all 0.3s ease;
}

.dark .nav-container {
  background-color: #1a1d20;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.15);
}

/* 状态栏和导航栏 */
.status-bar, .nav-bar {
  width: 100%;
}

/* 状态栏 */
.status-bar {
  background-color: #f8f9fa;
}

.dark .status-bar {
  background-color: #1a1d20;
}

/* 自定义导航栏 */
.nav-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f8f9fa;
  box-sizing: border-box;
  padding: 10rpx 30rpx; /* 增加上下内边距 */
  min-height: 100rpx; /* 确保最小高度 */
}

.dark .nav-bar {
  background-color: #1a1d20;
}

.nav-bar-left {
  display: flex;
  align-items: center;
  min-width: 80rpx;
  padding: 6rpx 0;
}

.nav-bar-title {
  flex: 1;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 10rpx;
}

.nav-bar-right {
  min-width: 80rpx;
}

.greeting {
  font-size: 36rpx;
  font-weight: bold;
  background: linear-gradient(135deg, #5e72e4, #825ee4);
  -webkit-background-clip: text;
  color: transparent;
  text-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.1);
  padding: 6rpx 0;
}

.dark .greeting {
  background: linear-gradient(135deg, #74b9ff, #a29bfe);
  -webkit-background-clip: text;
  color: transparent;
  text-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.2);
}

.avatar {
  width: 80rpx;
  height: 80rpx;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 6rpx 16rpx rgba(0, 0, 0, 0.15);
  border: 3rpx solid #ffffff;
  transition: transform 0.3s ease;
}

.dark .avatar {
  border-color: #2c3e50;
  box-shadow: 0 6rpx 16rpx rgba(0, 0, 0, 0.25);
}

.avatar:active {
  transform: scale(0.95);
}

.avatar image {
  width: 100%;
  height: 100%;
}

/* 内容区域 */
.content-area {
  padding: 30rpx;
}

/* 每日心情卡片 */
.daily-mood-card {
  background: linear-gradient(135deg, #5e72e4, #825ee4);
  border-radius: 24rpx;
  padding: 40rpx;
  margin-bottom: 40rpx;
  color: white;
  box-shadow: 0 8rpx 20rpx rgba(94, 114, 228, 0.3);
}

.card-content {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
}

.card-text {
  flex: 1;
}

.card-title {
  font-size: 36rpx;
  font-weight: bold;
  margin-bottom: 16rpx;
  display: block;
}

.card-desc {
  font-size: 26rpx;
  opacity: 0.9;
  margin-bottom: 30rpx;
  display: block;
}

.card-btn {
  display: inline-block;
  background-color: white;
  color: #5e72e4;
  font-size: 26rpx;
  font-weight: bold;
  padding: 12rpx 30rpx;
  border-radius: 30rpx;
}

.card-icon {
  font-size: 80rpx;
  line-height: 1;
}

/* 主要功能区 */
.section-title {
  font-size: 32rpx;
  font-weight: bold;
  margin: 40rpx 0 20rpx;
}

.feature-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20rpx;
  margin-bottom: 40rpx;
}

.feature-card {
  background-color: white;
  border-radius: 20rpx;
  padding: 30rpx;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
  transition: transform 0.2s ease;
}

.dark .feature-card {
  background-color: #212529;
}

.feature-card:active {
  transform: scale(0.98);
}

.feature-icon {
  font-size: 60rpx;
  margin-bottom: 20rpx;
  width: 100rpx;
  height: 100rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 20rpx;
}

.emotion-vault-icon {
  background-color: rgba(94, 114, 228, 0.1);
  color: #5e72e4;
}

.emotion-analysis-icon {
  background-color: rgba(130, 94, 228, 0.1);
  color: #825ee4;
}

.emotion-test-icon {
  background-color: rgba(45, 206, 137, 0.1);
  color: #2dce89;
}

.keyword-test-icon {
  background-color: rgba(251, 99, 64, 0.1);
  color: #fb6340;
}

.feature-name {
  font-size: 28rpx;
  font-weight: bold;
  margin-bottom: 10rpx;
}

.feature-desc {
  font-size: 24rpx;
  color: #6c757d;
}

.dark .feature-desc {
  color: #adb5bd;
}

/* 最近对话 */
.recent-chats {
  background-color: white;
  border-radius: 20rpx;
  overflow: hidden;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
  margin-bottom: 40rpx;
}

.dark .recent-chats {
  background-color: #212529;
}

.chat-item {
  display: flex;
  align-items: center;
  padding: 30rpx;
  border-bottom: 1rpx solid #f1f1f1;
}

.dark .chat-item {
  border-bottom: 1rpx solid #343a40;
}

.chat-item:last-child {
  border-bottom: none;
}

.chat-avatar {
  width: 80rpx;
  height: 80rpx;
  border-radius: 50%;
  overflow: hidden;
  margin-right: 20rpx;
}

.chat-avatar image {
  width: 100%;
  height: 100%;
}

.chat-info {
  flex: 1;
}

.chat-name {
  font-size: 28rpx;
  font-weight: bold;
  margin-bottom: 8rpx;
  display: block;
}

.chat-message {
  font-size: 24rpx;
  color: #6c757d;
  display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 400rpx;
}

.dark .chat-message {
  color: #adb5bd;
}

.chat-time {
  font-size: 22rpx;
  color: #adb5bd;
}

.empty-chats {
  padding: 60rpx 30rpx;
  text-align: center;
  color: #6c757d;
  font-size: 28rpx;
}

.dark .empty-chats {
  color: #adb5bd;
}

.start-chat-btn {
  display: inline-block;
  background-color: #5e72e4;
  color: white;
  font-size: 26rpx;
  padding: 12rpx 30rpx;
  border-radius: 30rpx;
  margin-top: 20rpx;
}

.loading {
  padding: 30rpx;
  text-align: center;
  color: #6c757d;
  font-size: 28rpx;
}

.dark .loading {
  color: #adb5bd;
}

*#*#*end*#*#*

*#*#*miniprogram\pages\keywordTest\keywordTest.js*#*#*begin*#*#*
// pages/keywordTest/keywordTest.js
const keywordService = require('../../services/keywordService');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

Page({
  /**
   * 页面的初始数据
   */
  data: {
    text: '',
    keywords: [],
    loading: false
  },

  /**
   * 输入文本变化
   */
  onInput: function(e) {
    this.setData({
      text: e.detail.value
    });
  },

  /**
   * 提取关键词
   */
  extractKeywords: function() {
    const { text } = this.data;
    if (!text.trim()) {
      wx.showToast({
        title: '请输入文本',
        icon: 'none'
      });
      return;
    }

    this.setData({ loading: true });

    // 调用关键词提取服务
    keywordService.extractKeywords(text)
      .then(keywords => {
        if (isDev) {
          console.log('提取到的关键词:', keywords);
        }

        // 为每个关键词添加格式化后的权重值
        const formattedKeywords = keywords.map(item => {
          return {
            ...item,
            weightFormatted: Math.round(item.weight * 100)
          };
        });

        this.setData({
          keywords: formattedKeywords,
          loading: false
        });
      })
      .catch(err => {
        console.error('关键词提取失败:', err.message || err);
        wx.showToast({
          title: '提取失败，请重试',
          icon: 'none'
        });
        this.setData({ loading: false });
      });
  },

  /**
   * 清空输入
   */
  clearInput: function() {
    this.setData({
      text: '',
      keywords: []
    });
  }
});

*#*#*end*#*#*

*#*#*miniprogram\pages\keywordTest\keywordTest.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "关键词提取测试",
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\pages\keywordTest\keywordTest.wxml*#*#*begin*#*#*
<!--pages/keywordTest/keywordTest.wxml-->
<view class="container">
  <view class="header">
    <text class="title">关键词提取测试</text>
  </view>

  <view class="input-area">
    <textarea
      class="input"
      placeholder="输入文字进行关键词提取..."
      bindinput="onInput"
      value="{{text}}"
      maxlength="500"
      auto-height
    />
    <view class="btn-area">
      <button
        class="clear-btn"
        bindtap="clearInput"
        disabled="{{!text || loading}}"
      >
        清空
      </button>
      <button
        class="extract-btn {{text ? 'active' : ''}}"
        bindtap="extractKeywords"
        loading="{{loading}}"
        disabled="{{!text || loading}}"
      >
        提取关键词
      </button>
    </view>
  </view>

  <!-- 关键词展示 -->
  <view class="keyword-area" wx:if="{{keywords.length > 0}}">
    <view class="section-title">提取结果</view>
    <view class="keyword-cloud">
      <view
        class="keyword-tag"
        wx:for="{{keywords}}"
        wx:key="index"
        style="font-size: {{14 + item.weight * 10}}px; opacity: {{0.6 + item.weight * 0.4}};"
      >
        {{item.word}}
        <text class="weight">{{item.weightFormatted}}%</text>
      </view>
    </view>
  </view>

  <!-- 提示信息 -->
  <view class="tips" wx:if="{{!keywords.length && !loading}}">
    <text>输入文本并点击"提取关键词"按钮</text>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\keywordTest\keywordTest.wxss*#*#*begin*#*#*
/* pages/keywordTest/keywordTest.wxss */
.container {
  padding: 20rpx;
  background-color: #f8f8f8;
  min-height: 100vh;
}

.header {
  margin: 20rpx 0 40rpx;
  text-align: center;
}

.title {
  font-size: 36rpx;
  font-weight: 500;
  color: #333;
}

.input-area {
  background-color: #fff;
  border-radius: 12rpx;
  padding: 20rpx;
  margin-bottom: 30rpx;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.05);
}

.input {
  width: 100%;
  min-height: 200rpx;
  padding: 20rpx;
  box-sizing: border-box;
  border: 1px solid #e0e0e0;
  border-radius: 8rpx;
  font-size: 28rpx;
  color: #333;
  background-color: #fafafa;
}

.btn-area {
  display: flex;
  justify-content: space-between;
  margin-top: 20rpx;
}

.clear-btn {
  flex: 1;
  margin-right: 20rpx;
  background-color: #f5f5f5;
  color: #666;
  font-size: 28rpx;
  padding: 16rpx 0;
  border-radius: 8rpx;
}

.extract-btn {
  flex: 2;
  background-color: #e0e0e0;
  color: #666;
  font-size: 28rpx;
  padding: 16rpx 0;
  border-radius: 8rpx;
}

.extract-btn.active {
  background-color: #007aff;
  color: #fff;
}

.keyword-area {
  background-color: #fff;
  border-radius: 12rpx;
  padding: 30rpx 20rpx;
  margin-top: 30rpx;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.05);
}

.section-title {
  font-size: 30rpx;
  font-weight: 500;
  color: #333;
  margin-bottom: 20rpx;
  padding-left: 10rpx;
  border-left: 6rpx solid #007aff;
}

.keyword-cloud {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 20rpx 0;
}

.keyword-tag {
  display: inline-block;
  margin: 10rpx;
  padding: 10rpx 20rpx;
  background-color: rgba(0, 122, 255, 0.1);
  border-radius: 30rpx;
  color: #007aff;
  font-weight: 500;
  transition: all 0.3s;
}

.keyword-tag:hover {
  transform: scale(1.05);
}

.weight {
  font-size: 24rpx;
  opacity: 0.7;
  margin-left: 8rpx;
}

.tips {
  text-align: center;
  color: #999;
  font-size: 28rpx;
  margin-top: 100rpx;
}

*#*#*end*#*#*

*#*#*miniprogram\pages\prompt-editor\prompt-editor.js*#*#*begin*#*#*
// pages/prompt-editor/prompt-editor.js
Page({
  /**
   * 页面的初始数据
   */
  data: {
    roleId: '',
    roleName: '',
    prompt: '',
    isEdit: false,
    statusBarHeight: 20, // 默认状态栏高度
    submitting: false
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log('提示词编辑页面加载，参数:', options);

    // 获取状态栏高度
    try {
      const systemInfo = wx.getSystemInfoSync();
      this.setData({
        statusBarHeight: systemInfo.statusBarHeight
      });
    } catch (e) {
      console.error('获取状态栏高度失败:', e);
    }

    // 检查是否有角色ID和提示词
    if (options.roleId) {
      this.setData({
        roleId: options.roleId,
        roleName: options.roleName ? decodeURIComponent(options.roleName) : '未命名角色',
        isEdit: true
      });

      // 如果有提示词，直接设置
      if (options.prompt) {
        this.setData({ prompt: decodeURIComponent(options.prompt) });
      } else {
        // 否则从云函数获取角色详情
        this.loadRolePrompt(options.roleId);
      }
    } else {
      wx.showToast({
        title: '缺少角色ID',
        icon: 'none'
      });
      setTimeout(() => {
        wx.navigateBack();
      }, 1500);
    }
  },

  /**
   * 加载角色提示词
   */
  async loadRolePrompt(roleId) {
    try {
      wx.showLoading({ title: '加载中...' });

      // 调用云函数获取角色详情
      const result = await wx.cloud.callFunction({
        name: 'roles',
        data: {
          action: 'getRoleDetail',
          roleId: roleId
        }
      });

      if (result && result.result && result.result.success && result.result.role) {
        const role = result.result.role;
        console.log('获取到角色数据:', role);

        this.setData({
          prompt: role.prompt || '',
          roleName: role.name || '未命名角色'
        });
      } else {
        throw new Error('获取角色信息失败');
      }

      wx.hideLoading();
    } catch (error) {
      console.error('加载角色提示词失败:', error);
      wx.hideLoading();
      wx.showToast({
        title: '加载提示词失败',
        icon: 'none'
      });
    }
  },

  /**
   * 处理提示词输入
   */
  handlePromptInput(e) {
    this.setData({
      prompt: e.detail.value
    });
  },

  /**
   * 生成提示词
   */
  async generatePrompt() {
    try {
      wx.showLoading({ title: '生成提示词中...' });

      // 调用云函数获取角色详情
      const result = await wx.cloud.callFunction({
        name: 'roles',
        data: {
          action: 'getRoleDetail',
          roleId: this.data.roleId
        }
      });

      if (result && result.result && result.result.success && result.result.role) {
        const role = result.result.role;

        // 调用云函数生成提示词
        const promptResult = await wx.cloud.callFunction({
          name: 'roles',
          data: {
            action: 'generatePrompt',
            roleInfo: role
          }
        });

        if (promptResult && promptResult.result && promptResult.result.success) {
          this.setData({
            prompt: promptResult.result.prompt
          });
        } else {
          throw new Error('生成提示词失败');
        }
      } else {
        throw new Error('获取角色信息失败');
      }

      wx.hideLoading();
    } catch (error) {
      console.error('生成提示词失败:', error);
      wx.hideLoading();
      wx.showToast({
        title: '生成提示词失败',
        icon: 'none'
      });
    }
  },

  /**
   * 保存提示词
   */
  async savePrompt() {
    try {
      if (this.data.submitting) return;
      this.setData({ submitting: true });

      wx.showLoading({ title: '保存中...' });

      // 获取用户ID
      const app = getApp();
      const userId = app.globalData.userInfo ? app.globalData.userInfo.userId : '';

      if (!userId) {
        throw new Error('用户未登录，请先登录');
      }

      console.log('当前用户ID:', userId);

      // 调用云函数更新角色提示词
      const result = await wx.cloud.callFunction({
        name: 'roles',
        data: {
          action: 'updateRole',
          roleId: this.data.roleId,
          userId: userId,  // 添加用户ID
          role: {
            prompt: this.data.prompt
          }
        }
      });

      if (result && result.result && result.result.success) {
        wx.hideLoading();
        wx.showToast({
          title: '保存成功',
          icon: 'success'
        });

        // 返回上一页
        setTimeout(() => {
          // 返回上一页并传递更新后的提示词
          const pages = getCurrentPages();
          const prevPage = pages[pages.length - 2]; // 上一个页面

          // 如果上一页是角色编辑页面，更新其提示词
          if (prevPage && prevPage.route.includes('role-editor')) {
            prevPage.setData({
              'form.prompt': this.data.prompt
            });
          }

          wx.navigateBack();
        }, 1500);
      } else {
        throw new Error(result.result?.error || '保存失败');
      }
    } catch (error) {
      console.error('保存提示词失败:', error);
      wx.hideLoading();
      // 显示更详细的错误信息
      const errorMsg = error.message || '保存失败';
      console.error('保存提示词失败:', errorMsg);

      wx.showToast({
        title: errorMsg.length > 20 ? errorMsg.substring(0, 20) + '...' : errorMsg,
        icon: 'none',
        duration: 3000
      });
    } finally {
      this.setData({ submitting: false });
    }
  },

  /**
   * 返回上一页
   */
  handleBack() {
    // 如果有未保存的修改，提示用户
    const pages = getCurrentPages();
    const prevPage = pages[pages.length - 2]; // 上一个页面

    // 如果上一页是角色编辑页面，检查提示词是否有修改
    if (prevPage && prevPage.route.includes('role-editor')) {
      const originalPrompt = prevPage.data.form.prompt || '';
      if (this.data.prompt !== originalPrompt) {
        wx.showModal({
          title: '提示',
          content: '您有未保存的修改，确定要返回吗？',
          success: (res) => {
            if (res.confirm) {
              wx.navigateBack();
            }
          }
        });
        return;
      }
    }

    wx.navigateBack();
  },

  /**
   * 清空提示词
   */
  clearPrompt() {
    wx.showModal({
      title: '确认清空',
      content: '确定要清空当前提示词吗？',
      success: (res) => {
        if (res.confirm) {
          this.setData({ prompt: '' });
        }
      }
    });
  }
});

*#*#*end*#*#*

*#*#*miniprogram\pages\prompt-editor\prompt-editor.json*#*#*begin*#*#*
{
  "navigationStyle": "custom",
  "usingComponents": {},
  "disableScroll": false,
  "backgroundColor": "#f5f7fa"
}

*#*#*end*#*#*

*#*#*miniprogram\pages\prompt-editor\prompt-editor.wxml*#*#*begin*#*#*
<view class="container">
  <!-- 状态栏占位 -->
  <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

  <!-- 顶部导航栏 -->
  <view class="nav-bar">
    <view class="nav-bar-left">
      <text class="nav-bar-btn" bindtap="handleBack">返回</text>
    </view>
    <view class="nav-bar-title">编辑提示词</view>
    <view class="nav-bar-right">
      <text class="nav-bar-btn primary" bindtap="savePrompt" wx:if="{{!submitting}}">保存</text>
      <text class="nav-bar-btn" wx:else>保存中...</text>
    </view>
  </view>

  <!-- 主要内容区域 -->
  <view class="content">
    <!-- 角色信息 -->
    <view class="role-info">
      <text class="role-name">{{roleName}}</text>
      <text class="role-id">ID: {{roleId}}</text>
    </view>

    <!-- 提示词编辑区 -->
    <view class="prompt-editor-container">
      <view class="editor-header">
        <text class="editor-title">提示词模板</text>
        <view class="editor-actions">
          <text class="action-btn" bindtap="generatePrompt">重新生成</text>
          <text class="action-btn" bindtap="clearPrompt">清空</text>
        </view>
      </view>
      <textarea class="prompt-textarea" 
                value="{{prompt}}" 
                bindinput="handlePromptInput" 
                placeholder="输入或生成提示词模板..." 
                maxlength="-1" 
                auto-height 
                show-confirm-bar="{{false}}"
                cursor-spacing="100"></textarea>
    </view>

    <!-- 提示词说明 -->
    <view class="prompt-guide">
      <view class="guide-title">提示词编写指南</view>
      <view class="guide-content">
        <text>1. 提示词是AI扮演角色的关键指令，决定了角色的行为方式</text>
        <text>2. 好的提示词应包含角色的身份、性格、说话风格等信息</text>
        <text>3. 可以使用"你是..."开头，明确角色定位</text>
        <text>4. 添加具体的行为指导，如"你应该..."或"避免..."</text>
        <text>5. 留空将根据角色信息自动生成提示词</text>
      </view>
    </view>
  </view>

  <!-- 底部按钮 -->
  <view class="bottom-buttons">
    <button class="bottom-btn cancel" bindtap="handleBack">取消</button>
    <button class="bottom-btn save" bindtap="savePrompt" loading="{{submitting}}">
      {{submitting ? '保存中...' : '保存提示词'}}
    </button>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\prompt-editor\prompt-editor.wxss*#*#*begin*#*#*
/* pages/prompt-editor/prompt-editor.wxss */
.container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f5f7fa;
  font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

/* 状态栏样式 */
.status-bar {
  width: 100%;
  background-color: #ffffff;
}

/* 导航栏样式 */
.nav-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 44px;
  padding: 0 16px;
  background-color: #ffffff;
  border-bottom: 1rpx solid #e2e8f0;
  position: relative;
  z-index: 100;
}

.nav-bar-left, .nav-bar-right {
  min-width: 60px;
  display: flex;
  align-items: center;
}

.nav-bar-left {
  justify-content: flex-start;
}

.nav-bar-right {
  justify-content: flex-end;
}

.nav-bar-title {
  font-size: 17px;
  font-weight: 600;
  color: #000000;
  text-align: center;
  flex: 1;
}

.nav-bar-btn {
  font-size: 16px;
  color: #007AFF;
  padding: 8px;
  display: block;
  min-width: 44px; /* 增加最小宽度，提高可点击性 */
  text-align: center;
}

.nav-bar-btn.primary {
  color: #007AFF;
  font-weight: 500;
}

/* 内容区域样式 */
.content {
  flex: 1;
  padding: 20rpx 30rpx;
  overflow-y: auto;
}

/* 角色信息样式 */
.role-info {
  margin-bottom: 30rpx;
  padding: 20rpx;
  background-color: #ffffff;
  border-radius: 12rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.05);
}

.role-name {
  font-size: 32rpx;
  font-weight: 600;
  color: #333333;
  display: block;
  margin-bottom: 10rpx;
}

.role-id {
  font-size: 24rpx;
  color: #999999;
}

/* 提示词编辑区样式 */
.prompt-editor-container {
  background-color: #ffffff;
  border-radius: 12rpx;
  padding: 20rpx;
  margin-bottom: 30rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.05);
}

.editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20rpx;
}

.editor-title {
  font-size: 28rpx;
  font-weight: 600;
  color: #333333;
}

.editor-actions {
  display: flex;
  gap: 20rpx;
}

.action-btn {
  font-size: 24rpx;
  color: #5e72e4;
  padding: 6rpx 12rpx;
  border-radius: 6rpx;
  background-color: rgba(94, 114, 228, 0.1);
}

.prompt-textarea {
  width: 100%;
  min-height: 600rpx;
  border-radius: 8rpx;
  background-color: #f5f7fa;
  padding: 20rpx;
  font-size: 28rpx;
  color: #333333;
  box-sizing: border-box;
  border: 1rpx solid #e2e8f0;
  line-height: 1.6;
  white-space: pre-wrap;
  word-break: break-all;
  margin-bottom: 20rpx;
}

/* 提示词说明样式 */
.prompt-guide {
  background-color: #ffffff;
  border-radius: 12rpx;
  padding: 20rpx;
  margin-bottom: 30rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.05);
}

.guide-title {
  font-size: 28rpx;
  font-weight: 600;
  color: #333333;
  margin-bottom: 16rpx;
}

.guide-content {
  display: flex;
  flex-direction: column;
  gap: 10rpx;
}

.guide-content text {
  font-size: 24rpx;
  color: #666666;
  line-height: 1.5;
}

/* 底部按钮样式 */
.bottom-buttons {
  display: flex;
  justify-content: space-between;
  padding: 20rpx 30rpx;
  background-color: #ffffff;
  border-top: 1rpx solid #e2e8f0;
  box-shadow: 0 -2rpx 10rpx rgba(0, 0, 0, 0.05);
  padding-bottom: calc(20rpx + env(safe-area-inset-bottom));
}

.bottom-btn {
  flex: 1;
  height: 88rpx;
  border-radius: 44rpx;
  font-size: 32rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 0 10rpx;
}

.bottom-btn.cancel {
  background-color: #f5f7fa;
  color: #666666;
  border: 1rpx solid #e2e8f0;
}

.bottom-btn.save {
  background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
  color: #ffffff;
  font-weight: 600;
  box-shadow: 0 4rpx 12rpx rgba(94, 114, 228, 0.3);
}

*#*#*end*#*#*

*#*#*miniprogram\pages\role-editor\index.js*#*#*begin*#*#*
// pages/role-editor/index.js
Page({
  /**
   * 页面的初始数据
   */
  data: {
    isEdit: false,
    submitting: false,
    currentStep: 1,
    showPromptPreview: false,
    previewPromptText: '',
    defaultAvatar: require('../../config/index').role.DEFAULT_ROLE_AVATAR,
    statusBarHeight: 20, // 默认状态栏高度
    darkMode: false, // 暗夜模式状态

    // 表单数据
    form: {
      name: '',
      relationship: '',
      customRelationship: '',  // 自定义关系
      category: '',
      age: '',
      gender: '',
      occupation: '',
      education: '',
      hobbies: '',
      background: '',
      personality_traits: '',
      communication_style: '',
      emotional_tendency: '',
      taboo: '',
      prompt: '', // 确保初始值为空字符串
      avatar: ''
    },

    // 是否显示自定义关系输入框
    showCustomRelationship: false,

    // 关系选项
    relationshipOptions: require('../../config/index').role.RELATIONSHIP_OPTIONS,
    relationshipIndex: 0,

    // 分类选项
    categoryOptions: require('../../config/index').role.ROLE_CATEGORIES,
    categoryIndex: -1,

    // 关系与分类的映射
    relationshipToCategoryMap: require('../../config/index').role.RELATIONSHIP_TO_CATEGORY_MAP
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log('角色编辑页面加载，参数:', options);

    // 获取状态栏高度和检测暗夜模式
    try {
      const systemInfo = wx.getSystemInfoSync();
      const app = getApp();

      // 检测暗夜模式
      let darkMode = false;
      if (app.globalData && app.globalData.darkMode !== undefined) {
        darkMode = app.globalData.darkMode;
      } else {
        darkMode = systemInfo.theme === 'dark';
        // 更新全局数据
        if (app.globalData) {
          app.globalData.darkMode = darkMode;
        }
      }

      this.setData({
        statusBarHeight: systemInfo.statusBarHeight,
        darkMode: darkMode
      });

      // 监听系统主题变化
      wx.onThemeChange && wx.onThemeChange((result) => {
        const isDark = result.theme === 'dark';
        this.setData({ darkMode: isDark });
        // 更新全局数据
        if (app.globalData) {
          app.globalData.darkMode = isDark;
        }
      });
    } catch (e) {
      console.error('获取系统信息失败:', e);
    }

    // 初始化云开发环境
    if (!wx.cloud) {
      wx.showToast({
        title: '请使用 2.2.3 或以上的基础库以使用云能力',
        icon: 'none'
      });
      return;
    }

    try {
      wx.cloud.init({
        env: wx.cloud.DYNAMIC_CURRENT_ENV,
        traceUser: true
      });
    } catch (e) {
      console.error('初始化云开发环境失败:', e);
    }

    // 如果是编辑模式，加载角色数据
    if (options.id) {
      console.log('检测到角色ID，进入编辑模式:', options.id);
      this.setData({ isEdit: true });
      this.loadRole(options.id);
    } else {
      console.log('未检测到角色ID，进入创建模式');
    }
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function() {
    // 检查暗夜模式变化
    const app = getApp();
    if (app && app.globalData && this.data.darkMode !== app.globalData.darkMode) {
      this.setData({
        darkMode: app.globalData.darkMode
      });
    }
  },

  /**
   * 加载角色数据
   */
  async loadRole(roleId) {
    console.log('开始加载角色数据，角色ID:', roleId);

    try {
      wx.showLoading({ title: '加载中...' });

      // 调用云函数获取角色详情
      console.log('准备调用云函数获取角色详情');
      const result = await wx.cloud.callFunction({
        name: 'roles',
        data: {
          action: 'getRoleDetail',
          roleId: roleId
        }
      });

      console.log('云函数返回结果:', result);

      if (result && result.result && result.result.success && result.result.role) {
        const role = result.result.role;
        console.log('获取到角色数据:', role);

        // 判断是否是自定义关系
        let relationship = role.relationship || '';
        let customRelationship = role.customRelationship || '';
        let showCustomRelationship = false;

        // 如果关系不在预设选项中，则认为是自定义关系
        if (relationship && !this.data.relationshipOptions.includes(relationship)) {
          customRelationship = relationship;
          relationship = '其他';
          showCustomRelationship = true;
        }

        // 设置表单数据
        const formData = {
          _id: role._id,
          name: role.name || '',
          relationship: relationship,
          customRelationship: customRelationship,
          category: role.category || '',
          age: role.age || '',
          gender: role.gender || '',
          occupation: role.occupation || '',
          education: role.education || '',
          hobbies: Array.isArray(role.hobbies) ? role.hobbies.join(', ') : (role.hobbies || ''),
          background: role.background || '',
          personality_traits: Array.isArray(role.personality_traits) ? role.personality_traits.join(', ') : (role.personality_traits || ''),
          communication_style: role.communication_style || '',
          emotional_tendency: role.emotional_tendency || '',
          taboo: role.taboo || '',
          // 确保 prompt 始终是字符串类型，并且非 null 或 undefined
          prompt: (typeof role.prompt === 'string' && role.prompt !== null) ? role.prompt : '',
          avatar: role.avatar || this.data.defaultAvatar
        };

        console.log('准备设置表单数据:', formData);
        console.log('提示词类型:', typeof formData.prompt, '提示词值:', formData.prompt);

        this.setData({
          form: formData
        });

        // 设置关系索引
        const relationshipIndex = this.data.relationshipOptions.findIndex(item => item === relationship);
        if (relationshipIndex !== -1) {
          this.setData({ relationshipIndex });
          console.log('设置关系索引:', relationshipIndex);
        }

        // 设置分类索引
        if (role.category) {
          const categoryIndex = this.data.categoryOptions.findIndex(item => item.id === role.category);
          if (categoryIndex !== -1) {
            this.setData({ categoryIndex });
            console.log('设置分类索引:', categoryIndex);
          }
        }

        // 设置是否显示自定义关系输入框
        this.setData({ showCustomRelationship });
        console.log('角色数据加载完成');
      } else {
        console.error('获取角色信息失败，返回结果不符合预期:', result);
        throw new Error('获取角色信息失败');
      }

      wx.hideLoading();
    } catch (error) {
      console.error('加载角色信息失败:', error);
      wx.hideLoading();
      wx.showToast({
        title: '加载角色信息失败',
        icon: 'none',
        duration: 3000
      });

      // 尝试获取更多错误信息
      if (error.errMsg) {
        console.error('错误信息:', error.errMsg);
      }
      if (error.stack) {
        console.error('错误堆栈:', error.stack);
      }
    }
  },

  /**
   * 处理输入变化
   */
  handleInput(e) {
    const { field } = e.currentTarget.dataset;
    const { value } = e.detail;

    this.setData({
      [`form.${field}`]: value
    });
  },

  /**
   * 处理关系选择
   */
  handleRelationshipChange(e) {
    const index = e.detail.value;
    const relationship = this.data.relationshipOptions[index];

    this.setData({
      'form.relationship': relationship,
      relationshipIndex: index
    });

    // 判断是否需要显示自定义关系输入框
    if (relationship === '其他') {
      this.setData({
        showCustomRelationship: true,
        'form.customRelationship': ''
      });
    } else {
      this.setData({
        showCustomRelationship: false,
        'form.customRelationship': ''
      });
    }

    // 根据关系推荐分类
    const recommendedCategory = this.data.relationshipToCategoryMap[relationship];
    if (recommendedCategory) {
      const categoryIndex = this.data.categoryOptions.findIndex(item => item.id === recommendedCategory);
      if (categoryIndex >= 0) {
        this.setData({
          categoryIndex: categoryIndex,
          'form.category': recommendedCategory
        });
      }
    }
  },

  /**
   * 处理自定义关系输入
   */
  handleCustomRelationshipInput(e) {
    this.setData({
      'form.customRelationship': e.detail.value
    });
  },

  /**
   * 处理分类选择
   */
  handleCategoryChange(e) {
    const index = e.detail.value;
    const category = this.data.categoryOptions[index].id;

    this.setData({
      'form.category': category,
      categoryIndex: index
    });
  },

  /**
   * 处理性别选择
   */
  handleGenderChange(e) {
    this.setData({
      'form.gender': e.detail.value
    });
  },

  /**
   * 选择头像
   */
  chooseAvatar() {
    const app = getApp();

    wx.chooseImage({
      count: 1,
      sizeType: ['compressed'],
      sourceType: ['album', 'camera'],
      success: async (res) => {
        try {
          // 获取用户ID
          const userId = app.globalData.userInfo ? app.globalData.userInfo.userId : '';

          // 使用图片服务上传头像
          const fileID = await app.globalData.imageService.uploadAvatar(res.tempFilePaths[0], userId, 'role');

          // 设置头像
          this.setData({
            'form.avatar': fileID
          });

          wx.showToast({
            title: '上传成功',
            icon: 'success'
          });
        } catch (error) {
          console.error('上传头像失败:', error);
          // 错误处理已在imageService中实现
        }
      }
    });
  },

  /**
   * 下一步
   */
  nextStep() {
    // 表单验证
    if (this.data.currentStep === 1) {
      if (!this.data.form.name) {
        wx.showToast({
          title: '请输入角色名称',
          icon: 'none'
        });
        return;
      }

      if (!this.data.form.relationship) {
        wx.showToast({
          title: '请选择与您的关系',
          icon: 'none'
        });
        return;
      }

      // 如果选择了“其他”关系，验证自定义关系名称
      if (this.data.form.relationship === '其他' && !this.data.form.customRelationship) {
        wx.showToast({
          title: '请输入具体关系名称',
          icon: 'none'
        });
        return;
      }
    }

    // 切换到下一步
    if (this.data.currentStep < 3) {
      this.setData({
        currentStep: this.data.currentStep + 1
      });
    }
  },

  /**
   * 上一步
   */
  prevStep() {
    if (this.data.currentStep > 1) {
      this.setData({
        currentStep: this.data.currentStep - 1
      });
    }
  },

  /**
   * 跳转到指定步骤
   */
  goToStep(e) {
    const { step } = e.currentTarget.dataset;

    // 只允许跳转到已完成的步骤
    if (step <= this.data.currentStep) {
      this.setData({ currentStep: parseInt(step) });
    }
  },

  /**
   * 预览提示词
   */
  async previewPrompt() {
    try {
      wx.showLoading({ title: '生成提示词中...' });

      // 准备角色信息
      const roleInfo = this.prepareRoleData();

      // 如果有自定义提示词，直接使用
      if (roleInfo.prompt) {
        this.setData({
          showPromptPreview: true,
          previewPromptText: roleInfo.prompt
        });
        wx.hideLoading();
        return;
      }

      // 调用云函数生成提示词
      try {
        const result = await wx.cloud.callFunction({
          name: 'roles',
          data: {
            action: 'generatePrompt',
            roleInfo: roleInfo
          }
        });

        if (result && result.result && result.result.success) {
          this.setData({
            showPromptPreview: true,
            previewPromptText: result.result.prompt
          });
        } else {
          throw new Error('生成提示词失败');
        }
      } catch (error) {
        console.error('调用云函数生成提示词失败:', error);
        // 如果云函数调用失败，使用本地生成
        const prompt = this.generateLocalPrompt();
        this.setData({
          showPromptPreview: true,
          previewPromptText: prompt
        });
      }

      wx.hideLoading();
    } catch (error) {
      console.error('预览提示词失败:', error);
      wx.hideLoading();
      wx.showToast({
        title: '生成提示词失败',
        icon: 'none'
      });
    }
  },

  /**
   * 关闭提示词预览
   */
  closePromptPreview() {
    this.setData({
      showPromptPreview: false
    });
  },

  /**
   * 跳转到提示词编辑页面
   */
  navigateToPromptEditor() {
    // 检查是否有角色ID（编辑模式）
    if (this.data.isEdit && this.data.form._id) {
      // 跳转到提示词编辑页面，并传递角色ID和当前提示词
      wx.navigateTo({
        url: `/pages/prompt-editor/prompt-editor?roleId=${this.data.form._id}&roleName=${encodeURIComponent(this.data.form.name || '')}&prompt=${encodeURIComponent(this.data.form.prompt || '')}`,
        success: () => {
          console.log('成功跳转到提示词编辑页面');
        },
        fail: (err) => {
          console.error('跳转到提示词编辑页面失败:', err);
          wx.showToast({
            title: '跳转失败',
            icon: 'none'
          });
        }
      });
    } else {
      // 如果是新建角色，提示用户先保存角色
      wx.showToast({
        title: '请先保存角色后再编辑提示词',
        icon: 'none',
        duration: 2000
      });
    }
  },

  /**
   * 本地生成提示词
   */
  generateLocalPrompt() {
    const { form } = this.data;

    let prompt = `你是${form.name || '一个角色'}`;

    // 处理关系
    let displayRelationship = form.relationship;
    if (form.relationship === '其他' && form.customRelationship) {
      displayRelationship = form.customRelationship;
    }

    if (displayRelationship) {
      prompt += `，作为我的${displayRelationship}`;
    }

    // 添加分类信息
    if (form.category) {
      const categoryName = this.data.categoryOptions.find(item => item.id === form.category)?.name;
      if (categoryName) {
        prompt += `，你是一个${categoryName}类型的角色`;
      }
    }

    if (form.gender || form.age) {
      prompt += `。你是一个`;
      if (form.gender) {
        prompt += form.gender;
      }
      if (form.age) {
        prompt += `${form.age}岁`;
      }
      prompt += '的人';
    }

    if (form.occupation) {
      prompt += `。你的职业是${form.occupation}`;
    }

    if (form.personality_traits) {
      prompt += `。你的性格特点是${form.personality_traits}`;
    }

    if (form.emotional_tendency) {
      prompt += `。你的情感倾向是${form.emotional_tendency}`;
    }

    if (form.communication_style) {
      prompt += `。你的说话风格是${form.communication_style}`;
    }

    if (form.education) {
      prompt += `\n\n你的教育背景是：${form.education}`;
    }

    if (form.hobbies) {
      prompt += `\n\n你的爱好是：${form.hobbies}`;
    }

    if (form.background) {
      prompt += `\n\n你的背景故事：${form.background}`;
    }

    if (form.taboo) {
      prompt += `\n\n请避免讨论以下话题：${form.taboo}`;
    }

    prompt += '\n\n请以符合你角色设定的方式与我对话。在适当的时候，你可以安慰我或给我建议。在对话中，你应该自然地了解我的兴趣和偏好，但不要显得像在进行调查。';

    return prompt;
  },

  /**
   * 准备角色数据
   */
  prepareRoleData() {
    const { form } = this.data;

    // 处理数组字段
    const personality_traits = form.personality_traits ? form.personality_traits.split(',').map(item => item.trim()) : [];
    const hobbies = form.hobbies ? form.hobbies.split(',').map(item => item.trim()) : [];

    // 处理自定义关系
    let actualRelationship = form.relationship;
    if (form.relationship === '其他' && form.customRelationship) {
      actualRelationship = form.customRelationship;
    }

    // 如果没有设置category，根据relationship自动设置
    let category = form.category;
    if (!category && form.relationship) {
      category = this.data.relationshipToCategoryMap[form.relationship] || 'other';
    }

    // 构建角色数据
    return {
      name: form.name,
      relationship: actualRelationship,
      customRelationship: form.customRelationship,
      category: category,
      age: form.age,
      gender: form.gender,
      occupation: form.occupation,
      education: form.education,
      hobbies: hobbies,
      background: form.background,
      personality_traits: personality_traits,
      communication_style: form.communication_style,
      emotional_tendency: form.emotional_tendency,
      taboo: form.taboo,
      prompt: form.prompt,
      system_prompt: form.prompt, // 同时保存到system_prompt字段，确保聊天功能可以正确获取
      avatar: form.avatar,

      // 兼容旧字段
      role_name: form.name,
      role_type: category === 'career' ? 'work' : 'life',
      role_desc: form.background,
      style: form.personality_traits,
      speaking_style: form.communication_style
    };
  },

  /**
   * 处理提交
   */
  async handleSubmit() {
    try {
      // 表单验证
      if (!this.data.form.name) {
        wx.showToast({
          title: '请输入角色名称',
          icon: 'none'
        });
        return;
      }

      if (!this.data.form.relationship) {
        wx.showToast({
          title: '请选择与您的关系',
          icon: 'none'
        });
        return;
      }

      // 如果选择了“其他”关系，验证自定义关系名称
      if (this.data.form.relationship === '其他' && !this.data.form.customRelationship) {
        wx.showToast({
          title: '请输入具体关系名称',
          icon: 'none'
        });
        return;
      }

      this.setData({ submitting: true });

      // 准备角色数据
      const roleData = this.prepareRoleData();

      // 如果有预览的提示词，使用预览的提示词
      if (this.data.showPromptPreview && this.data.previewPromptText) {
        roleData.prompt = this.data.previewPromptText;
        roleData.system_prompt = this.data.previewPromptText; // 同时更新system_prompt字段
      }

      // 获取用户ID
      const app = getApp();
      const userId = app.globalData.userInfo ? app.globalData.userInfo.userId : '';

      if (!userId) {
        throw new Error('用户未登录');
      }

      // 调用云函数创建或更新角色
      const action = this.data.isEdit ? 'updateRole' : 'createRole';
      const params = {
        name: 'roles',
        data: {
          action: action,
          role: roleData,
          userId: userId
        }
      };

      // 如果是编辑模式，添加角色ID
      if (this.data.isEdit && this.data.form._id) {
        params.data.role._id = this.data.form._id;
      }

      const result = await wx.cloud.callFunction(params);

      if (result && result.result && result.result.success) {
        // 清除角色列表缓存，确保新创建的角色能够显示
        const app = getApp();
        const userInfo = app.globalData.userInfo;
        if (userInfo) {
          const userId = userInfo.userId || userInfo.user_id || userInfo._id || userInfo.openid;
          const cacheKey = `roles_cache_${userId}`;
          const cacheTimeKey = `roles_cache_time_${userId}`;

          try {
            wx.removeStorageSync(cacheKey);
            wx.removeStorageSync(cacheTimeKey);
            console.log('成功清除角色列表缓存');
          } catch (error) {
            console.error('清除角色列表缓存失败:', error);
          }
        }

        // 显示成功提示
        wx.showToast({
          title: this.data.isEdit ? '角色更新成功' : '角色创建成功',
          icon: 'success',
          duration: 1500
        });

        // 等待提示显示完毕后自动跳转回角色选择页面
        setTimeout(() => {
          // 跳转到 role-select 页面（现在是tab页面）
          wx.switchTab({
            url: '/pages/role-select/role-select',
            success: () => {
              console.log('成功跳转到 role-select 页面');
            },
            fail: (err) => {
              console.error('跳转到 role-select 失败:', err);
              // 如果跳转失败，尝试返回上一页
              wx.navigateBack();
            }
          });
        }, 1500); // 等待提示显示完毕
      } else {
        throw new Error(result.result?.error || '操作失败');
      }
    } catch (error) {
      console.error('提交失败:', error);

      // 处理特定错误
      let errorMessage = error.message || '操作失败';

      // 检查是否是重复名称错误
      if (error.message && (error.message.includes('duplicate key') ||
          error.message.includes('角色名称已存在'))) {
        errorMessage = `角色名称 "${this.data.form.name}" 已存在，请使用其他名称`;

        // 聚焦到名称输入框
        this.setData({
          currentStep: 1 // 返回第一步
        });

        // 稍后选中名称输入框
        setTimeout(() => {
          const nameInput = this.selectComponent('#nameInput');
          if (nameInput) {
            nameInput.focus();
          }
        }, 500);
      }

      wx.showToast({
        title: errorMessage,
        icon: 'none',
        duration: 3000
      });
    } finally {
      this.setData({ submitting: false });
    }
  },

  /**
   * 取消编辑
   */
  handleCancel(e) {
    console.log('点击了取消按钮', e);

    // 显示确认对话框
    wx.showModal({
      title: '确认取消',
      content: '您确定要取消编辑吗？未保存的内容将会丢失。',
      confirmText: '确定',
      cancelText: '继续编辑',
      success: (res) => {
        if (res.confirm) {
          // 用户确认取消，直接跳转到 role-select 页面（现在是tab页面）
          wx.switchTab({
            url: '/pages/role-select/role-select',
            success: () => {
              console.log('成功跳转到 role-select 页面');
            },
            fail: (err) => {
              console.error('跳转到 role-select 失败:', err);

              // 如果跳转失败，尝试返回上一页
              wx.navigateBack({
                fail: (backErr) => {
                  console.error('返回失败:', backErr);

                  // 如果返回也失败，尝试重定向到首页
                  wx.switchTab({
                    url: '/pages/home/home',
                    fail: (switchErr) => {
                      console.error('重定向失败:', switchErr);

                      // 最后的备选方案，显示提示
                      wx.showModal({
                        title: '提示',
                        content: '无法返回，请尝试使用微信小程序自带的返回按钮',
                        showCancel: false
                      });
                    }
                  });
                }
              });
            }
          });
        }
        // 如果用户点击取消，则不做任何操作，继续编辑
      }
    });
  }
});

*#*#*end*#*#*

*#*#*miniprogram\pages\role-editor\index.json*#*#*begin*#*#*
{
  "navigationStyle": "custom",
  "usingComponents": {},
  "navigationBarTextStyle": "white",
  "backgroundColor": "#f5f7fa"
}

*#*#*end*#*#*

*#*#*miniprogram\pages\role-editor\index.wxml*#*#*begin*#*#*
<view class="container {{darkMode ? 'dark' : ''}}">
  <!-- 状态栏占位 -->
  <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

  <!-- 顶部导航栏 -->
  <view class="nav-bar">
    <view class="nav-bar-left">
      <text class="nav-bar-btn" bindtap="handleCancel" data-action="cancel">取消</text>
    </view>
    <view class="nav-bar-title">{{isEdit ? '编辑角色' : '创建角色'}}</view>
    <view class="nav-bar-right"></view>
  </view>

  <!-- 主要内容区域 -->
  <scroll-view scroll-y="true" class="content-scroll">
    <view class="content">
      <!-- 步骤指示器 -->
      <view class="step-indicator">
        <view class="step {{currentStep >= 1 ? 'active' : ''}}" bindtap="goToStep" data-step="1">
          <view class="step-circle">1</view>
          <text class="step-text">基本信息</text>
        </view>
        <view class="step-line {{currentStep >= 2 ? 'active' : ''}}"></view>
        <view class="step {{currentStep >= 2 ? 'active' : ''}}" bindtap="goToStep" data-step="2">
          <view class="step-circle">2</view>
          <text class="step-text">详细背景</text>
        </view>
        <view class="step-line {{currentStep >= 3 ? 'active' : ''}}"></view>
        <view class="step {{currentStep >= 3 ? 'active' : ''}}" bindtap="goToStep" data-step="3">
          <view class="step-circle">3</view>
          <text class="step-text">性格特点</text>
        </view>
      </view>

      <!-- 第一步：基本信息 -->
      <view class="step-content" hidden="{{currentStep !== 1}}">
        <!-- 头像上传 -->
        <view class="avatar-section">
          <view class="avatar-container" bindtap="chooseAvatar">
            <image class="avatar" src="{{form.avatar || defaultAvatar}}" mode="aspectFill"></image>
            <view class="avatar-overlay">
              <text class="icon-camera"></text>
              <text class="upload-text">更换头像</text>
            </view>
          </view>
        </view>

        <!-- 基本信息表单 -->
        <view class="form-card">
          <view class="form-group">
            <text class="label required">角色名称</text>
            <input id="nameInput" class="input" value="{{form.name}}" bindinput="handleInput" data-field="name" placeholder="给这个角色起个名字" maxlength="20" />
          </view>

          <view class="form-group">
            <text class="label required">与您的关系</text>
            <picker mode="selector" range="{{relationshipOptions}}" value="{{relationshipIndex}}" bindchange="handleRelationshipChange">
              <view class="picker">
                <text>{{form.relationship || '请选择关系'}}</text>
                <text class="icon-arrow-down"></text>
              </view>
            </picker>
          </view>

          <!-- 自定义关系输入框 -->
          <view class="form-group" wx:if="{{showCustomRelationship}}">
            <text class="label required">请输入具体关系</text>
            <input class="input" value="{{form.customRelationship}}" bindinput="handleCustomRelationshipInput" placeholder="请输入具体关系名称" maxlength="20" />
          </view>

          <view class="form-group">
            <text class="label">角色分类</text>
            <picker mode="selector" range="{{categoryOptions}}" range-key="name" value="{{categoryIndex}}" bindchange="handleCategoryChange">
              <view class="picker">
                <text>{{categoryIndex >= 0 ? categoryOptions[categoryIndex].name : '自动根据关系设置'}}</text>
                <text class="icon-arrow-down"></text>
              </view>
            </picker>
            <view class="hint-text">默认根据关系自动推荐分类</view>
          </view>

          <view class="form-group">
            <text class="label">年龄</text>
            <input class="input" type="number" value="{{form.age}}" bindinput="handleInput" data-field="age" placeholder="请输入年龄" />
          </view>

          <view class="form-group">
            <text class="label">性别</text>
            <radio-group class="radio-group" bindchange="handleGenderChange">
              <label class="radio-label {{form.gender === '男' ? 'active' : ''}}">
                <radio value="男" checked="{{form.gender === '男'}}" color="{{darkMode ? '#4dabf7' : '#5e72e4'}}"/>
                <text>男</text>
              </label>
              <label class="radio-label {{form.gender === '女' ? 'active' : ''}}">
                <radio value="女" checked="{{form.gender === '女'}}" color="{{darkMode ? '#4dabf7' : '#5e72e4'}}"/>
                <text>女</text>
              </label>
              <label class="radio-label {{form.gender === '其他' ? 'active' : ''}}">
                <radio value="其他" checked="{{form.gender === '其他'}}" color="{{darkMode ? '#4dabf7' : '#5e72e4'}}"/>
                <text>其他</text>
              </label>
            </radio-group>
          </view>
        </view>

        <view class="button-container">
          <button class="next-button" bindtap="nextStep">下一步</button>
        </view>
      </view>

      <!-- 第二步：详细背景 -->
      <view class="step-content" hidden="{{currentStep !== 2}}">
        <view class="form-card">
          <view class="form-group">
            <text class="label">职业</text>
            <input class="input" value="{{form.occupation}}" bindinput="handleInput" data-field="occupation" placeholder="角色的职业或工作" />
          </view>

          <view class="form-group">
            <text class="label">教育背景</text>
            <input class="input" value="{{form.education}}" bindinput="handleInput" data-field="education" placeholder="角色的教育经历" />
          </view>

          <view class="form-group">
            <text class="label">爱好</text>
            <input class="input" value="{{form.hobbies}}" bindinput="handleInput" data-field="hobbies" placeholder="角色的爱好，用逗号分隔" />
          </view>

          <view class="form-group">
            <text class="label">生活经历</text>
            <textarea class="textarea background-textarea" value="{{form.background}}" bindinput="handleInput" data-field="background" placeholder="添加角色的生活经历和背景故事，让对话更有代入感" maxlength="500" />
          </view>
        </view>

        <view class="button-container">
          <button class="prev-button" bindtap="prevStep">上一步</button>
          <button class="next-button" bindtap="nextStep">下一步</button>
        </view>
      </view>

      <!-- 第三步：性格特点 -->
      <view class="step-content" hidden="{{currentStep !== 3}}">
        <view class="form-card">
          <view class="form-group">
            <text class="label">性格特点</text>
            <input class="input" value="{{form.personality_traits}}" bindinput="handleInput" data-field="personality_traits" placeholder="描述角色的性格特点，用逗号分隔" />
          </view>

          <view class="form-group">
            <text class="label">说话风格</text>
            <textarea class="textarea speaking-style-textarea" value="{{form.communication_style}}" bindinput="handleInput" data-field="communication_style" placeholder="描述角色说话的特点，如：温和有礼、幽默风趣" />
          </view>

          <view class="form-group">
            <text class="label">情感倾向</text>
            <input class="input" value="{{form.emotional_tendency}}" bindinput="handleInput" data-field="emotional_tendency" placeholder="角色的情感倾向，如：乐观、悲观、理性、感性" />
          </view>

          <view class="form-group">
            <text class="label">禁忌话题</text>
            <input class="input" value="{{form.taboo}}" bindinput="handleInput" data-field="taboo" placeholder="设置不想谈论的话题" />
          </view>

          <view class="form-group prompt-template-group">
            <text class="label">提示词</text>
            <view class="prompt-card" bindtap="navigateToPromptEditor">
              <view class="prompt-card-content">
                <view class="prompt-card-icon">
                  <text class="iconfont icon-edit"></text>
                </view>
                <view class="prompt-card-text">
                  <text class="prompt-card-title">{{form.prompt && form.prompt.length > 0 ? '点击编辑提示词' : '点击创建提示词'}}</text>
                  <text class="prompt-card-desc">{{form.prompt && form.prompt.length > 0 ? '已设置自定义提示词' : '留空将根据角色信息自动生成提示词'}}</text>
                </view>
                <view class="prompt-card-arrow">
                  <text class="iconfont icon-right"></text>
                </view>
              </view>
              <block wx:if="{{form.prompt && form.prompt.length > 0}}">
                <view class="prompt-card-preview">
                  <text class="prompt-preview-snippet">{{form.prompt.length > 50 ? form.prompt.substring(0, 50) + '...' : form.prompt}}</text>
                </view>
              </block>
            </view>
            <view class="hint-text">点击卡片进入提示词专业编辑器</view>
          </view>
        </view>

        <view class="button-container">
          <button class="prev-button" bindtap="prevStep">上一步</button>
          <button class="preview-button" bindtap="previewPrompt">预览提示词</button>
        </view>
      </view>
    </view>
  </scroll-view>
</view>

<!-- 提示词预览弹窗 -->
<view class="prompt-preview-modal {{darkMode ? 'dark' : ''}}" hidden="{{!showPromptPreview}}">
  <view class="prompt-preview-content">
    <view class="prompt-preview-header">
      <text class="prompt-preview-title">提示词预览</text>
      <text class="prompt-preview-close" bindtap="closePromptPreview">×</text>
    </view>
    <scroll-view scroll-y="true" class="prompt-preview-body">
      <view class="prompt-preview-text-container">
        <text class="prompt-preview-text">{{previewPromptText}}</text>
      </view>
    </scroll-view>
    <view class="prompt-preview-footer">
      <button class="prompt-preview-button" bindtap="closePromptPreview">关闭</button>
      <button class="prompt-preview-button primary" bindtap="handleSubmit" loading="{{submitting}}">
        {{submitting ? '保存中...' : '确认并保存角色'}}
      </button>
    </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\role-editor\index.wxss*#*#*begin*#*#*
/* 全局样式 */
.container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f5f7fa;
  font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

/* 暗夜模式容器 */
.container.dark {
  background-color: #1a1d20;
  color: #f8f9fa;
}

/* 状态栏样式 */
.status-bar {
  width: 100%;
  background-color: #ffffff;
}

.dark .status-bar {
  background-color: #212529;
}

/* 导航栏样式 */
.nav-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 44px;
  padding: 0 16px;
  background-color: #ffffff;
  border-bottom: 1rpx solid #e2e8f0;
  position: relative;
  z-index: 100;
}

.dark .nav-bar {
  background-color: #212529;
  border-bottom: 1rpx solid #343a40;
}

.nav-bar-left, .nav-bar-right {
  min-width: 60px;
  display: flex;
  align-items: center;
}

.nav-bar-left {
  padding: 10px 0;
  position: relative;
  z-index: 101; /* 确保在其他元素之上 */
}

.nav-bar-title {
  font-size: 17px;
  font-weight: 600;
  color: #000000;
  text-align: center;
  flex: 1;
}

.dark .nav-bar-title {
  color: #ffffff;
}

.nav-bar-btn {
  font-size: 16px;
  color: #007AFF;
  padding: 8px;
  display: block;
  min-width: 44px; /* 增加最小宽度，提高可点击性 */
  text-align: center;
}

.dark .nav-bar-btn {
  color: #4dabf7;
}

.nav-bar-btn.primary {
  color: #007AFF;
  font-weight: 500;
}

/* 内容区域样式 */
.content-scroll {
  flex: 1;
  padding-bottom: env(safe-area-inset-bottom);
}

.content {
  padding: 30rpx;
}

/* 步骤指示器样式 */
.step-indicator {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 40rpx;
}

.step {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  z-index: 2;
}

.step-circle {
  width: 60rpx;
  height: 60rpx;
  border-radius: 50%;
  background-color: #e2e8f0;
  color: #666666;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 28rpx;
  font-weight: 600;
  margin-bottom: 10rpx;
  transition: all 0.3s ease;
}

.dark .step-circle {
  background-color: #343a40;
  color: #adb5bd;
}

.step.active .step-circle {
  background-color: #5e72e4;
  color: #ffffff;
}

.step-text {
  font-size: 24rpx;
  color: #666666;
  transition: all 0.3s ease;
}

.dark .step-text {
  color: #adb5bd;
}

.step.active .step-text {
  color: #5e72e4;
  font-weight: 500;
}

.step-line {
  flex: 1;
  height: 4rpx;
  background-color: #e2e8f0;
  position: relative;
  z-index: 1;
  transition: all 0.3s ease;
}

.dark .step-line {
  background-color: #343a40;
}

.step-line.active {
  background-color: #5e72e4;
}

/* 表单卡片样式 */
.form-card {
  background-color: #ffffff;
  border-radius: 16rpx;
  padding: 30rpx;
  margin-bottom: 30rpx;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.05);
}

.dark .form-card {
  background-color: #212529;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.15);
}

.form-group {
  margin-bottom: 30rpx;
}

.form-group:last-child {
  margin-bottom: 0;
}

.label {
  display: block;
  font-size: 28rpx;
  color: #333333;
  margin-bottom: 10rpx;
  font-weight: 500;
}

.dark .label {
  color: #e2e8f0;
}

.label.required::after {
  content: '*';
  color: #ff4d4f;
  margin-left: 8rpx;
}

.input {
  width: 100%;
  height: 80rpx;
  border-radius: 8rpx;
  background-color: #f5f7fa;
  padding: 0 20rpx;
  font-size: 28rpx;
  color: #333333;
  box-sizing: border-box;
  border: 1rpx solid #e2e8f0;
}

.dark .input {
  background-color: #2c3034;
  color: #f8f9fa;
  border: 1rpx solid #495057;
}

.textarea {
  width: 100%;
  height: 400rpx; /* 增加高度，从200rpx增加到400rpx */
  border-radius: 8rpx;
  background-color: #f5f7fa;
  padding: 20rpx;
  font-size: 28rpx;
  color: #333333;
  box-sizing: border-box;
  border: 1rpx solid #e2e8f0;
  line-height: 1.6; /* 增加行高，提高可读性 */
  white-space: pre-wrap; /* 保留空白符和换行符 */
}

.dark .textarea {
  background-color: #2c3034;
  color: #f8f9fa;
  border: 1rpx solid #495057;
}

/* 特殊文本区域样式 */
.speaking-style-textarea {
  height: 120rpx; /* 缩短高度 */
  min-height: 120rpx; /* 设置最小高度 */
}

.background-textarea {
  height: 400rpx; /* 增加高度，从200rpx增加到400rpx */
  min-height: 400rpx; /* 设置最小高度 */
}

.picker {
  width: 100%;
  height: 80rpx;
  border-radius: 8rpx;
  background-color: #f5f7fa;
  padding: 0 20rpx;
  font-size: 28rpx;
  color: #333333;
  box-sizing: border-box;
  border: 1rpx solid #e2e8f0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.dark .picker {
  background-color: #2c3034;
  color: #f8f9fa;
  border: 1rpx solid #495057;
}

.icon-arrow-down::after {
  content: '\25BC';
  font-size: 24rpx;
  color: #999999;
}

.dark .icon-arrow-down::after {
  color: #adb5bd;
}

.radio-group {
  display: flex;
  flex-wrap: wrap;
}

.radio-label {
  display: flex;
  align-items: center;
  margin-right: 40rpx;
  margin-bottom: 20rpx;
  font-size: 28rpx;
  color: #333333;
}

.dark .radio-label {
  color: #e2e8f0;
}

.radio-label.active {
  color: #5e72e4;
}

.dark .radio-label.active {
  color: #4dabf7;
}

.radio-label radio {
  margin-right: 8rpx;
}

.hint-text {
  font-size: 24rpx;
  color: #999999;
  margin-top: 10rpx;
}

.dark .hint-text {
  color: #6c757d;
}

/* 头像上传区域样式 */
.avatar-section {
  display: flex;
  justify-content: center;
  margin-bottom: 40rpx;
}

.avatar-container {
  position: relative;
  width: 160rpx;
  height: 160rpx;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
}

.avatar {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.avatar-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.avatar-container:hover .avatar-overlay {
  opacity: 1;
}

.icon-camera::before {
  content: '\1F4F7';
  font-size: 40rpx;
  color: #ffffff;
  margin-bottom: 10rpx;
}

.upload-text {
  font-size: 24rpx;
  color: #ffffff;
}

/* 按钮样式 */
.button-container {
  display: flex;
  justify-content: space-between;
  margin-top: 40rpx;
  padding: 0 20rpx;
}

.next-button, .prev-button, .preview-button {
  height: 88rpx;
  border-radius: 44rpx;
  font-size: 32rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
}

.next-button {
  background-color: #5e72e4;
  color: #ffffff;
  flex: 1;
}

.dark .next-button {
  background-color: #4c63d2;
}

.prev-button {
  background-color: #ffffff;
  color: #666666;
  border: 1rpx solid #e2e8f0;
  margin-right: 20rpx;
  flex: 1;
}

.dark .prev-button {
  background-color: #343a40;
  color: #adb5bd;
  border: 1rpx solid #495057;
}

.preview-button {
  background-color: #5e72e4;
  color: #ffffff;
  flex: 1;
}

.dark .preview-button {
  background-color: #4c63d2;
}

/* 引入图标字体 */
@import "../../styles/iconfont.wxss";

/* 提示词卡片样式 */
.prompt-template-group {
  margin-bottom: 40rpx; /* 增加底部间距 */
}

.prompt-card {
  background-color: #ffffff;
  border-radius: 12rpx;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.05);
  padding: 24rpx;
  margin-top: 16rpx;
  margin-bottom: 16rpx;
  transition: all 0.3s ease;
}

.dark .prompt-card {
  background-color: #2c3034;
  box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.15);
}

.prompt-card:active {
  background-color: #f8f9fa;
  transform: scale(0.98);
}

.dark .prompt-card:active {
  background-color: #343a40;
}

.prompt-card-content {
  display: flex;
  align-items: center;
}

.prompt-card-icon {
  width: 80rpx;
  height: 80rpx;
  border-radius: 40rpx;
  background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
  display: flex;
  justify-content: center;
  align-items: center;
  margin-right: 20rpx;
}

.prompt-card-icon .iconfont {
  color: #ffffff;
  font-size: 40rpx;
}

.prompt-card-text {
  flex: 1;
}

.prompt-card-title {
  font-size: 32rpx;
  font-weight: 600;
  color: #333333;
  display: block;
  margin-bottom: 8rpx;
}

.dark .prompt-card-title {
  color: #e2e8f0;
}

.prompt-card-desc {
  font-size: 24rpx;
  color: #666666;
  display: block;
}

.dark .prompt-card-desc {
  color: #adb5bd;
}

.prompt-card-arrow {
  color: #999999;
  font-size: 32rpx;
}

.dark .prompt-card-arrow {
  color: #adb5bd;
}

.prompt-card-preview {
  margin-top: 16rpx;
  padding-top: 16rpx;
  border-top: 1rpx solid #f0f0f0;
  overflow: hidden; /* 防止内容溢出 */
}

.dark .prompt-card-preview {
  border-top: 1rpx solid #343a40;
}

.prompt-preview-snippet {
  font-size: 24rpx;
  color: #666666;
  line-height: 1.5;
  display: block;
  white-space: pre-wrap;
  word-break: break-all;
  overflow: hidden; /* 防止内容溢出 */
  text-overflow: ellipsis; /* 文本溢出时显示省略号 */
}

.dark .prompt-preview-snippet {
  color: #adb5bd;
}

/* 提示词预览弹窗样式 */
.prompt-preview-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.prompt-preview-content {
  width: 80%;
  max-width: 600rpx;
  background-color: #ffffff;
  border-radius: 16rpx;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  max-height: 80vh;
  align-items: center;
}

.dark .prompt-preview-content {
  background-color: #212529;
}

.prompt-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20rpx 30rpx;
  border-bottom: 1rpx solid #e2e8f0;
  width: 100%;
  box-sizing: border-box;
  position: relative;
}

.dark .prompt-preview-header {
  border-bottom: 1rpx solid #343a40;
}

.prompt-preview-title {
  font-size: 32rpx;
  font-weight: 600;
  color: #333333;
  flex: 1;
  text-align: center;
}

.dark .prompt-preview-title {
  color: #e2e8f0;
}

.prompt-preview-close {
  font-size: 40rpx;
  color: #999999;
  line-height: 1;
  position: absolute;
  right: 30rpx;
  top: 20rpx;
}

.dark .prompt-preview-close {
  color: #adb5bd;
}

.prompt-preview-body {
  padding: 30rpx 20rpx;
  max-height: 60vh;
  width: 100%;
  box-sizing: border-box;
}

.prompt-preview-text-container {
  width: 100%;
  padding: 0 10rpx;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

.prompt-preview-text {
  font-size: 28rpx;
  color: #333333;
  line-height: 1.6;
  white-space: pre-wrap;
  text-align: left;
  display: block;
  width: 100%;
  padding: 0 10rpx;
  box-sizing: border-box;
}

.dark .prompt-preview-text {
  color: #e2e8f0;
}

.prompt-preview-footer {
  display: flex;
  justify-content: space-between;
  padding: 24rpx 30rpx;
  border-top: 1rpx solid #e2e8f0;
  width: 100%;
  box-sizing: border-box;
}

.dark .prompt-preview-footer {
  border-top: 1rpx solid #343a40;
}

.prompt-preview-button {
  height: 80rpx;
  border-radius: 40rpx;
  font-size: 28rpx;
  padding: 0 30rpx;
  min-width: 160rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #f5f7fa;
  color: #666666;
  border: none;
  transition: all 0.3s ease;
}

.dark .prompt-preview-button {
  background-color: #343a40;
  color: #adb5bd;
}

.prompt-preview-button.primary {
  background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
  color: #ffffff;
  font-weight: 600;
  box-shadow: 0 4rpx 12rpx rgba(94, 114, 228, 0.3);
}

.dark .prompt-preview-button.primary {
  background: linear-gradient(135deg, #4c63d2 0%, #7050d2 100%);
  box-shadow: 0 4rpx 12rpx rgba(76, 99, 210, 0.3);
}

.prompt-preview-button.primary:active {
  transform: scale(0.98);
  box-shadow: 0 2rpx 8rpx rgba(94, 114, 228, 0.2);
}

*#*#*end*#*#*

*#*#*miniprogram\pages\role-select\role-select.js*#*#*begin*#*#*
// pages/role-select/role-select.js
const app = getApp();
const userService = require('../../services/userService');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

Page({
  /**
   * 页面的初始数据
   */
  data: {
    roles: [], // 角色列表
    systemRoles: [], // 系统角色列表
    userRoles: [], // 用户角色列表
    selectedRoleId: '', // 当前选中的角色ID
    loading: true, // 是否正在加载
    darkMode: false, // 暗夜模式
    categories: require('../../config/index').role.ROLE_CATEGORIES.concat([{ id: 'all', name: '全部' }]), // 角色分类
    activeCategory: 'all', // 当前选中的分类
    searchValue: '', // 搜索关键词
    filteredRoles: [], // 过滤后的角色列表
    recommendedRoles: [], // 推荐角色列表
    statusBarHeight: 0, // 状态栏高度
    navBarHeight: 0, // 导航栏高度
    showRoleDetail: false, // 是否显示角色详情
    currentRole: null, // 当前查看的角色
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 获取系统信息设置自定义导航栏高度
    const systemInfo = wx.getSystemInfoSync();
    const statusBarHeight = systemInfo.statusBarHeight;
    const navBarHeight = (systemInfo.platform === 'ios' ? 44 : 48);

    // 获取暗夜模式设置
    const darkMode = app.globalData.darkMode || false;

    this.setData({
      statusBarHeight: statusBarHeight,
      navBarHeight: navBarHeight,
      darkMode: darkMode
    });

    // 加载角色列表
    this.loadRoles();
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    // 检查主题变化
    if (this.data.darkMode !== app.globalData.darkMode) {
      this.setData({
        darkMode: app.globalData.darkMode
      });

      // 更新TabBar样式
      if (app.updateTheme) {
        app.updateTheme(app.globalData.darkMode);
      }
    }

    // 检查是否需要强制刷新角色列表
    // 如果是从角色编辑页面返回，则强制刷新
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    const prevPage = pages[pages.length - 2];

    // 判断是否从角色编辑页面返回
    const fromRoleEditor = prevPage &&
      (prevPage.route === 'pages/role-editor/index' ||
       prevPage.route === 'pages/user/role/edit/index');

    if (isDev) {
      console.log('当前页面:', currentPage.route);
      console.log('上一页面:', prevPage ? prevPage.route : '无');
      console.log('是否从角色编辑页面返回:', fromRoleEditor);
    }

    // 每次显示页面时加载角色列表，如果从角色编辑页面返回则强制刷新
    this.loadRoles(null, fromRoleEditor);
  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    // 下拉刷新时强制从服务器重新加载角色列表，忽略缓存
    this.loadRoles(() => {
      wx.stopPullDownRefresh();
    }, true);
  },

  /**
   * 加载角色列表
   * @param {Function} callback - 加载完成后的回调函数
   * @param {Boolean} forceRefresh - 是否强制刷新，忽略缓存
   */
  loadRoles: function (callback, forceRefresh = false) {
    this.setData({ loading: true });

    // 获取当前用户ID
    const userInfo = app.globalData.userInfo;
    if (!userInfo) {
      if (isDev) {
        console.log('用户未登录，无法加载角色列表');
      }
      this.setData({ loading: false });
      if (callback) callback();
      return;
    }

    // 使用userService获取用户ID和openid
    const { userId, openid } = userService.getUserIdentifiers(userInfo);
    if (isDev) {
      console.log('使用用户ID加载角色列表:', userId);
      if (openid) {
        console.log('用户openid:', openid);
      }
    }

    // 尝试从缓存中获取角色列表
    const cacheKey = `roles_cache_${userId}`;
    const cacheTimeKey = `roles_cache_time_${userId}`;
    const currentTime = new Date().getTime();
    const cacheTime = wx.getStorageSync(cacheTimeKey) || 0;
    const cacheExpireTime = 30 * 60 * 1000; // 30分钟缓存过期时间

    // 如果缓存存在且未过期，且不强制刷新，则使用缓存
    if (!forceRefresh && currentTime - cacheTime < cacheExpireTime) {
      const cachedRoles = wx.getStorageSync(cacheKey);
      if (cachedRoles && cachedRoles.length > 0) {
        if (isDev) {
          console.log('从缓存加载角色列表，角色数量:', cachedRoles.length);
        }

        // 分离系统角色和用户角色
        const systemRoles = cachedRoles.filter(role => role.creator === 'system' || role.isSystem);
        const userRoles = cachedRoles.filter(role => role.creator !== 'system' && !role.isSystem);

        // 获取聊天记录统计，用于推荐角色 - 考虑所有角色（系统角色和用户角色）
        this.getChatsStatistics(cachedRoles, openid || userId, (rolesWithStats) => {
          // 根据消息数量排序，选择前两个作为推荐角色
          const recommendedRoles = this.getRecommendedRolesByMessageCount(rolesWithStats);

          this.setData({
            roles: cachedRoles,
            systemRoles: systemRoles,
            userRoles: userRoles,
            filteredRoles: this.filterRoles(cachedRoles, this.data.activeCategory, this.data.searchValue),
            recommendedRoles: recommendedRoles,
            loading: false
          });

          if (callback) callback();
        });
        return;
      }
    }

    // 缓存不存在或已过期，从服务器获取角色列表
    if (isDev) {
      console.log('从服务器获取角色列表');
    }

    wx.cloud.callFunction({
      name: 'roles',
      data: {
        action: 'getRoles',
        userId: userId
      }
    })
    .then(res => {
      let roles = res.result.data || [];

      if (isDev) {
        console.log('角色总数:', roles.length);
      }

      // 分离系统角色和用户角色
      const systemRoles = roles.filter(role => role.creator === 'system' || role.isSystem);
      const userRoles = roles.filter(role => role.creator !== 'system' && !role.isSystem);

      if (isDev) {
        console.log('系统角色数量:', systemRoles.length);
        console.log('用户角色数量:', userRoles.length);
      }

      // 获取聊天记录统计，用于推荐角色 - 考虑所有角色（系统角色和用户角色）
      this.getChatsStatistics(roles, openid || userId, (rolesWithStats) => {
        // 根据消息数量排序，选择前两个作为推荐角色
        const recommendedRoles = this.getRecommendedRolesByMessageCount(rolesWithStats);

        // 将角色列表存入缓存
        wx.setStorageSync(cacheKey, roles);
        wx.setStorageSync(cacheTimeKey, currentTime);
        if (isDev) {
          console.log('角色列表已缓存，过期时间:', new Date(currentTime + cacheExpireTime));
        }

        this.setData({
          roles: roles,
          systemRoles: systemRoles,
          userRoles: userRoles,
          filteredRoles: this.filterRoles(roles, this.data.activeCategory, this.data.searchValue),
          recommendedRoles: recommendedRoles,
          loading: false
        });

        if (callback) callback();
      });
    })
    .catch(err => {
      console.error('获取角色列表失败:', err.message || err);
      wx.showToast({
        title: '获取角色列表失败',
        icon: 'none'
      });
      this.setData({ loading: false });
      if (callback) callback();
    });
  },

  /**
   * 获取聊天记录统计，用于推荐角色
   * @param {Array} roles - 角色列表
   * @param {String} userId - 用户ID或openid
   * @param {Function} callback - 回调函数，返回带有消息统计的角色列表
   */
  getChatsStatistics: function(roles, userId, callback) {
    if (!roles || roles.length === 0) {
      if (isDev) {
        console.log('角色列表为空，无法获取聊天统计');
      }
      callback(roles);
      return;
    }

    if (isDev) {
      console.log('开始获取聊天记录统计...');
    }
    const db = wx.cloud.database();

    // 查询所有聊天记录
    db.collection('chats')
      .where({
        openId: userId // 使用openId查询
      })
      .get()
      .then(res => {
        const chats = res.data || [];
        if (isDev) {
          console.log(`获取到 ${chats.length} 条聊天记录`);
        }

        // 创建角色消息数量映射
        const roleMessageCounts = {};

        // 统计每个角色的消息数量
        chats.forEach(chat => {
          if (chat.roleId && chat.messageCount) {
            if (!roleMessageCounts[chat.roleId]) {
              roleMessageCounts[chat.roleId] = 0;
            }
            roleMessageCounts[chat.roleId] += chat.messageCount;
          }
        });

        // 记录消息数量最多的前5个角色
        const topRoleIds = Object.entries(roleMessageCounts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5)
          .map(entry => entry[0]);

        if (isDev) {
          console.log('消息数量最多的前5个角色ID:', topRoleIds);
        }

        // 将消息数量添加到角色对象中
        const rolesWithStats = roles.map(role => {
          return {
            ...role,
            messageCount: roleMessageCounts[role._id] || 0
          };
        });

        // 检查是否有角色ID在统计中但不在角色列表中
        const missingRoleIds = Object.keys(roleMessageCounts).filter(
          roleId => !roles.some(role => role._id === roleId)
        );

        if (missingRoleIds.length > 0 && isDev) {
          console.warn('以下角色ID在聊天统计中存在，但不在角色列表中:', missingRoleIds);
        }

        callback(rolesWithStats);
      })
      .catch(err => {
        console.error('获取聊天记录统计失败:', err.message || err);
        // 出错时仍然返回原始角色列表
        callback(roles);
      });
  },

  /**
   * 根据消息数量获取推荐角色
   * @param {Array} roles - 带有消息统计的角色列表
   * @returns {Array} - 推荐角色列表（最多2个）
   */
  getRecommendedRolesByMessageCount: function(roles) {
    if (!roles || roles.length === 0) {
      return [];
    }

    // 按消息数量降序排序
    const sortedRoles = [...roles].sort((a, b) => {
      return (b.messageCount || 0) - (a.messageCount || 0);
    });

    if (isDev) {
      console.log('按消息数量排序后的前5个角色:', sortedRoles.slice(0, 5).map(role => ({
        id: role._id,
        name: role.name,
        messageCount: role.messageCount || 0
      })));
    }

    // 选择前两个有消息记录的角色作为推荐角色，不区分系统角色和用户角色
    const recommendedRoles = sortedRoles
      .filter(role => role.messageCount > 0)
      .slice(0, 2);

    console.log('根据消息数量推荐的角色:', recommendedRoles.map(role => ({
      id: role._id,
      name: role.name,
      messageCount: role.messageCount || 0
    })));

    // 如果没有足够的有消息记录的角色，则使用原来的isRecommended字段补充
    if (recommendedRoles.length < 2) {
      const defaultRecommended = roles
        .filter(role => role.isRecommended && !recommendedRoles.some(r => r._id === role._id))
        .slice(0, 2 - recommendedRoles.length);

      recommendedRoles.push(...defaultRecommended);
      console.log('补充默认推荐角色后:', recommendedRoles.map(role => ({
        id: role._id,
        name: role.name,
        messageCount: role.messageCount || 0,
        isRecommended: role.isRecommended
      })));
    }

    return recommendedRoles;
  },

  /**
   * 过滤角色列表
   * @param {Array} roles - 角色列表
   * @param {String} category - 分类
   * @param {String} searchValue - 搜索关键词
   * @returns {Array} - 过滤后的角色列表
   */
  filterRoles: function (roles, category, searchValue) {
    if (!roles || !Array.isArray(roles)) {
      console.log('角色列表为空或不是数组');
      return [];
    }

    return roles.filter(role => {
      if (!role) return false;

      // 分类过滤
      let categoryMatch = category === 'all';
      if (!categoryMatch) {
        // 检查多个可能的分类字段
        const roleCategory = role.category || role.role_type;
        if (roleCategory === category) {
          categoryMatch = true;
        }
        // 特殊处理：work和career视为相同
        else if ((category === 'career' && roleCategory === 'work') ||
                 (category === 'work' && roleCategory === 'career')) {
          categoryMatch = true;
        }
      }

      // 搜索过滤
      if (!searchValue) return categoryMatch;

      const name = role.name || role.role_name || '';
      const description = role.description || role.role_desc || role.background || '';
      const relationship = role.relationship || '';
      const occupation = role.occupation || '';

      const searchLower = searchValue.toLowerCase();
      const searchMatch = name.toLowerCase().includes(searchLower) ||
                         description.toLowerCase().includes(searchLower) ||
                         relationship.toLowerCase().includes(searchLower) ||
                         occupation.toLowerCase().includes(searchLower);

      return categoryMatch && searchMatch;
    });
  },

  /**
   * 切换分类
   * @param {Object} e - 事件对象
   */
  handleCategoryChange: function (e) {
    const category = e.currentTarget.dataset.category;
    this.setData({
      activeCategory: category,
      filteredRoles: this.filterRoles(this.data.roles, category, this.data.searchValue)
    });
  },

  /**
   * 搜索角色
   * @param {Object} e - 事件对象
   */
  handleSearchInput: function (e) {
    const searchValue = e.detail.value;
    this.setData({
      searchValue: searchValue,
      filteredRoles: this.filterRoles(this.data.roles, this.data.activeCategory, searchValue)
    });
  },

  /**
   * 清空搜索
   */
  handleClearSearch: function () {
    this.setData({
      searchValue: '',
      filteredRoles: this.filterRoles(this.data.roles, this.data.activeCategory, '')
    });
  },

  /**
   * 选择角色
   * @param {Object} e - 事件对象
   */
  handleSelectRole: function (e) {
    const role = e.detail.role;

    // 如果点击的是已选中的角色，则取消选中
    if (this.data.selectedRoleId === role._id) {
      this.setData({ selectedRoleId: '' });
    } else {
      this.setData({ selectedRoleId: role._id });
    }
  },

  /**
   * 开始对话
   * @param {Object} e - 事件对象，可选，如果提供则从中获取角色信息
   */
  handleStartChat: function (e) {
    let roleId = this.data.selectedRoleId;
    let role = null;

    // 如果提供了事件对象，从中获取角色信息
    if (e && e.currentTarget && e.currentTarget.dataset && e.currentTarget.dataset.role) {
      role = e.currentTarget.dataset.role;
      roleId = role._id;

      // 更新选中的角色ID
      this.setData({
        selectedRoleId: roleId,
        showRoleDetail: false
      });
    }

    // 如果没有选中角色，显示提示
    if (!roleId) {
      wx.showToast({
        title: '请先选择一个角色',
        icon: 'none'
      });
      return;
    }

    // 跳转到聊天页面
    wx.navigateTo({
      url: '/packageChat/pages/chat/chat?roleId=' + roleId,
      success: () => {
        console.log('跳转到聊天页面成功');
        // 将选中的角色ID存入全局变量
        app.globalData.chatParams = { roleId: roleId };
      }
    });
  },

  /**
   * 创建新角色
   */
  handleCreateRole: function () {
    wx.navigateTo({
      url: '/pages/role-editor/index'
    });
  },

  /**
   * 长按角色卡片显示操作菜单
   * @param {Object} e - 事件对象
   */
  handleLongPressRole: function (e) {
    const role = e.detail.role;
    this.setData({
      currentRole: role,
      showRoleDetail: true
    });
  },

  /**
   * 查看角色详情
   * @param {String} roleId - 角色ID
   */
  viewRoleDetail: function (roleId) {
    const role = this.data.roles.find(r => r._id === roleId);

    if (!role) return;

    wx.showModal({
      title: role.name,
      content: `${role.description || '暂无描述'}\n\n背景：${role.background || '暂无'}\n\n性格：${role.personality_traits ? role.personality_traits.join(', ') : '暂无'}\n\n使用次数：${role.usage ? role.usage.usageCount : 0}`,
      showCancel: false
    });
  },

  /**
   * 编辑角色
   * @param {Object} e - 事件对象
   */
  editRole: function (e) {
    const role = e.currentTarget.dataset.role;
    console.log('编辑角色，角色数据:', role);

    if (!role || !role._id) {
      console.error('无法编辑角色，角色数据不完整');
      wx.showToast({
        title: '角色数据不完整',
        icon: 'none'
      });
      return;
    }

    // 关闭详情弹窗
    this.setData({
      showRoleDetail: false
    });

    // 跳转到角色编辑页面
    console.log('准备跳转到角色编辑页面，角色ID:', role._id);
    wx.navigateTo({
      url: `/pages/role-editor/index?id=${role._id}`,
      success: (res) => {
        console.log('跳转到角色编辑页面成功');
      },
      fail: (err) => {
        console.error('跳转到角色编辑页面失败:', err);
        wx.showToast({
          title: '跳转失败',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 删除角色
   * @param {String|Object} roleIdOrEvent - 角色ID或事件对象
   */
  deleteRole: function (roleIdOrEvent) {
    let roleId;

    // 判断参数类型
    if (typeof roleIdOrEvent === 'string') {
      // 直接传入的角色ID
      roleId = roleIdOrEvent;
    } else if (roleIdOrEvent && roleIdOrEvent.currentTarget && roleIdOrEvent.currentTarget.dataset) {
      // 事件对象，从数据集中获取角色ID
      const role = roleIdOrEvent.currentTarget.dataset.role;
      if (role && role._id) {
        roleId = role._id;

        // 如果是从详情弹窗调用，关闭弹窗
        this.setData({
          showRoleDetail: false
        });
      }
    }

    if (!roleId) {
      console.error('无法删除角色，角色ID不存在');
      return;
    }

    wx.showModal({
      title: '确认删除',
      content: '确定要删除这个角色吗？删除后无法恢复。',
      success: (res) => {
        if (res.confirm) {
          // 调用云函数删除角色
          wx.cloud.callFunction({
            name: 'roles',
            data: {
              action: 'deleteRole',
              roleId: roleId
            }
          })
          .then(res => {
            console.log('删除角色成功:', res.result);
            wx.showToast({
              title: '删除成功',
              icon: 'success'
            });

            // 删除角色后清除缓存并强制刷新角色列表
            const userInfo = app.globalData.userInfo;
            const userId = userInfo.userId || userInfo.user_id || userInfo._id || userInfo.openid;
            const cacheKey = `roles_cache_${userId}`;
            const cacheTimeKey = `roles_cache_time_${userId}`;
            wx.removeStorageSync(cacheKey);
            wx.removeStorageSync(cacheTimeKey);

            // 重新加载角色列表，强制从服务器获取
            this.loadRoles(null, true);
          })
          .catch(err => {
            console.error('删除角色失败:', err);
            wx.showToast({
              title: '删除失败',
              icon: 'none'
            });
          });
        }
      }
    });
  },

  // 已删除未使用的 handleBackClick 函数

  /**
   * 关闭角色详情
   */
  closeRoleDetail: function () {
    this.setData({
      showRoleDetail: false
    });
  },

  // 已删除未使用的 formatEmotionalTendency 函数

  // handleSelectAndChat 函数已合并到 handleStartChat 函数中



  // 已删除未使用的 createTestRoles 函数
});

*#*#*end*#*#*

*#*#*miniprogram\pages\role-select\role-select.json*#*#*begin*#*#*
{
  "navigationStyle": "custom",
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark",
  "usingComponents": {
    "role-card": "/components/role-card/role-card"
  }
}

*#*#*end*#*#*

*#*#*miniprogram\pages\role-select\role-select.wxml*#*#*begin*#*#*
<!-- pages/role-select/role-select.wxml -->
<view class="role-select-container {{darkMode ? 'dark' : ''}}">
  <!-- 状态栏占位 -->
  <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

  <!-- 自定义导航栏 -->
  <view class="nav-bar" style="height: {{navBarHeight}}px;">
    <view class="nav-bar-left">
      <!-- 移除返回按钮，因为现在是tab页面 -->
    </view>
    <view class="nav-bar-title">选择对话角色</view>
    <view class="nav-bar-right"></view>
  </view>

  <!-- 搜索框 -->
  <view class="search-box">
    <image class="search-icon" src="/images/icons/search.png" mode="aspectFit"></image>
    <input class="search-input"
           type="text"
           placeholder="搜索角色..."
           value="{{searchValue}}"
           bindinput="handleSearchInput"></input>
    <view class="clear-button" bindtap="handleClearSearch" wx:if="{{searchValue}}">
      <image class="clear-icon" src="/images/icons/clear.png" mode="aspectFit"></image>
    </view>
  </view>

  <!-- 角色分类 -->
  <scroll-view class="category-scroll" scroll-x enable-flex>
    <view class="category-list">
      <view class="category-item {{activeCategory === category.id ? 'active' : ''}}"
            wx:for="{{categories}}"
            wx:key="id"
            wx:for-item="category"
            data-category="{{category.id}}"
            bindtap="handleCategoryChange">
        {{category.name}}
      </view>
    </view>
  </scroll-view>

  <!-- 角色列表容器 -->
  <view class="role-list-container">
    <!-- 加载中 -->
    <view class="loading-container" wx:if="{{loading}}">
      <view class="loading-spinner"></view>
      <text class="loading-text">加载中...</text>
    </view>

    <!-- 内容区域 -->
    <scroll-view class="role-list-scroll" scroll-y enable-back-to-top wx:if="{{!loading}}">
      <!-- 推荐角色 -->
      <block wx:if="{{activeCategory === 'all' && recommendedRoles.length > 0}}">
        <view class="section-title">推荐角色</view>
        <view class="role-grid">
          <role-card wx:for="{{recommendedRoles}}"
                    wx:key="_id"
                    role="{{item}}"
                    selected="{{selectedRoleId === item._id}}"
                    darkMode="{{darkMode}}"
                    bind:select="handleSelectRole"
                    bind:longpress="handleLongPressRole"></role-card>
        </view>
      </block>

      <!-- 系统角色 -->
      <view class="section-title">系统角色</view>
      <view class="role-grid">
        <block wx:if="{{systemRoles.length > 0}}">
          <role-card wx:for="{{systemRoles}}"
                    wx:key="_id"
                    wx:if="{{activeCategory === 'all' || item.category === activeCategory || item.role_type === activeCategory}}"
                    role="{{item}}"
                    selected="{{selectedRoleId === item._id}}"
                    darkMode="{{darkMode}}"
                    bind:select="handleSelectRole"
                    bind:longpress="handleLongPressRole"></role-card>
        </block>
        <view class="empty-tip" wx:else>
          <image class="empty-icon" src="/images/icons/empty.png" mode="aspectFit"></image>
          <text class="empty-text">{{activeCategory !== 'all' ? '该分类下暂无系统角色' : '暂无系统角色'}}</text>
        </view>
      </view>

      <!-- 我的角色 -->
      <view class="section-title">我的角色</view>
      <view class="role-grid">
        <block wx:if="{{userRoles.length > 0}}">
          <role-card wx:for="{{userRoles}}"
                    wx:key="_id"
                    wx:if="{{activeCategory === 'all' || item.category === activeCategory || item.role_type === activeCategory}}"
                    role="{{item}}"
                    selected="{{selectedRoleId === item._id}}"
                    darkMode="{{darkMode}}"
                    bind:select="handleSelectRole"
                    bind:longpress="handleLongPressRole"></role-card>
        </block>
        <view class="empty-tip" wx:else>
          <image class="empty-icon" src="/images/icons/empty.png" mode="aspectFit"></image>
          <text class="empty-text">{{activeCategory !== 'all' ? '该分类下暂无自定义角色' : '暂无自定义角色'}}</text>
        </view>
      </view>

      <!-- 已删除测试按钮和调试信息区域 -->
    </scroll-view>
  </view>

  <!-- 底部按钮 -->
  <view class="bottom-buttons">
    <button class="create-button" bindtap="handleCreateRole">创建新角色</button>
    <button class="start-button {{!selectedRoleId ? 'disabled' : ''}}" bindtap="handleStartChat">开始对话</button>
  </view>

  <!-- 角色详情弹窗 -->
  <view class="role-detail-modal {{showRoleDetail ? 'show' : ''}}">
    <view class="role-detail-content" wx:if="{{currentRole}}">
      <view class="role-detail-header">
        <view class="header-placeholder"></view>
        <text class="role-detail-title">{{currentRole.name || currentRole.role_name || '未命名角色'}}</text>
        <view class="close-button" bindtap="closeRoleDetail">
          <image class="close-icon" src="/images/icons/close.png" mode="aspectFit"></image>
        </view>
      </view>

      <scroll-view class="role-detail-body" scroll-y>
        <view class="role-avatar-container">
          <image class="role-avatar" src="{{currentRole.avatar || currentRole.avatar_url || '/images/avatars/default-avatar.png'}}" mode="aspectFill"></image>
        </view>

        <view class="role-info-section">
          <!-- 基本信息 -->
          <view class="role-info-group">
            <view class="role-info-row">
              <view class="role-info-item">
                <text class="role-info-label">分类：</text>
                <text class="role-info-value">{{(currentRole.category || currentRole.role_type) === 'emotion' ? '情感支持' :
                                          (currentRole.category || currentRole.role_type) === 'psychology' ? '心理咨询' :
                                          (currentRole.category || currentRole.role_type) === 'life' ? '生活伙伴' :
                                          (currentRole.category || currentRole.role_type) === 'career' || (currentRole.category || currentRole.role_type) === 'work' ? '职场导师' :
                                          (currentRole.category || currentRole.role_type) === 'other' ? '其他' : '未分类'}}</text>
              </view>
            </view>

            <view class="role-info-row">
              <view class="role-info-item">
                <text class="role-info-label">关系：</text>
                <text class="role-info-value">{{currentRole.relationship || '无'}}</text>
              </view>
            </view>

            <view class="role-info-row">
              <view class="role-info-item" wx:if="{{currentRole.age}}">
                <text class="role-info-label">年龄：</text>
                <text class="role-info-value">{{currentRole.age}}岁</text>
              </view>

              <view class="role-info-item" wx:if="{{currentRole.gender}}">
                <text class="role-info-label">性别：</text>
                <text class="role-info-value">{{currentRole.gender}}</text>
              </view>
            </view>
          </view>

          <!-- 描述信息 -->
          <view class="role-info-group">
            <view class="role-info-row">
              <view class="role-info-item description-item">
                <text class="role-info-label">描述：</text>
                <text class="role-info-value">{{currentRole.description || currentRole.role_desc || '暂无描述'}}</text>
              </view>
            </view>
          </view>

          <!-- 职业和教育背景 -->
          <view class="role-info-group">
            <view class="role-info-row" wx:if="{{currentRole.occupation}}">
              <view class="role-info-item">
                <text class="role-info-label">职业：</text>
                <text class="role-info-value">{{currentRole.occupation}}</text>
              </view>
            </view>

            <view class="role-info-row" wx:if="{{currentRole.education}}">
              <view class="role-info-item">
                <text class="role-info-label">教育背景：</text>
                <text class="role-info-value">{{currentRole.education}}</text>
              </view>
            </view>
          </view>

          <!-- 个性特征 -->
          <view class="role-info-group">
            <view class="role-info-row" wx:if="{{currentRole.hobbies && currentRole.hobbies.length > 0}}">
              <view class="role-info-item">
                <text class="role-info-label">爱好：</text>
                <text class="role-info-value">{{Array.isArray(currentRole.hobbies) ? currentRole.hobbies.join(', ') : currentRole.hobbies}}</text>
              </view>
            </view>

            <view class="role-info-row" wx:if="{{currentRole.personality_traits && currentRole.personality_traits.length > 0}}">
              <view class="role-info-item">
                <text class="role-info-label">性格特点：</text>
                <text class="role-info-value">{{Array.isArray(currentRole.personality_traits) ? currentRole.personality_traits.join(', ') : currentRole.personality_traits}}</text>
              </view>
            </view>

            <view class="role-info-row" wx:if="{{currentRole.emotional_tendency}}">
              <view class="role-info-item">
                <text class="role-info-label">情感倾向：</text>
                <text class="role-info-value short-text">{{currentRole.emotional_tendency}}</text>
              </view>
            </view>

            <view class="role-info-row" wx:if="{{currentRole.communication_style}}">
              <view class="role-info-item background-item">
                <text class="role-info-label">说话风格：</text>
                <text class="role-info-value">{{currentRole.communication_style}}</text>
              </view>
            </view>
          </view>

          <!-- 背景故事 -->
          <view class="role-info-group" wx:if="{{currentRole.background}}">
            <view class="role-info-row">
              <view class="role-info-item background-item">
                <text class="role-info-label">背景故事：</text>
                <text class="role-info-value">{{currentRole.background}}</text>
              </view>
            </view>
          </view>

          <!-- 使用统计 -->
          <view class="role-info-group">
            <view class="role-info-row">
              <view class="role-info-item">
                <text class="role-info-label">使用次数：</text>
                <text class="role-info-value">{{currentRole.usage && currentRole.usage.usageCount ? currentRole.usage.usageCount : 0}}次</text>
              </view>
            </view>
          </view>
        </view>
      </scroll-view>

      <view class="role-detail-footer">
        <view class="system-role-tag" wx:if="{{currentRole.isSystem || currentRole.creator === 'system'}}">
          <text class="system-role-text">系统预设角色</text>
        </view>

        <view class="footer-buttons">
          <view class="button-row">
            <button class="detail-button edit" bindtap="editRole" data-role="{{currentRole}}" wx:if="{{!currentRole.isSystem && currentRole.creator !== 'system'}}">编辑角色</button>
            <button class="detail-button delete" bindtap="deleteRole" data-role="{{currentRole}}" wx:if="{{!currentRole.isSystem && currentRole.creator !== 'system'}}">删除角色</button>
            <button class="detail-button edit chat-btn" bindtap="handleStartChat" data-role="{{currentRole}}">开始对话</button>
          </view>
        </view>
      </view>
    </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\role-select\role-select.wxss*#*#*begin*#*#*
/* pages/role-select/role-select.wxss */
.role-select-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f8f9fa;
  box-sizing: border-box;
}

/* 暗夜模式 */
.dark {
  background-color: #1a1d20;
  color: #f8f9fa;
}

/* 状态栏样式 */
.status-bar {
  width: 100%;
  background-color: #ffffff;
}

.dark .status-bar {
  background-color: #212529;
}

/* 导航栏样式 */
.nav-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 16px;
  background-color: #ffffff;
  border-bottom: 1rpx solid #e2e8f0;
  position: relative;
  z-index: 100;
  box-sizing: border-box;
}

.dark .nav-bar {
  background-color: #212529;
  border-bottom: 1rpx solid #343a40;
}

.nav-bar-left, .nav-bar-right {
  min-width: 60px;
  display: flex;
  align-items: center;
}

.nav-bar-left {
  padding: 10px 0;
  position: relative;
  z-index: 101; /* 确保在其他元素之上 */
}

.nav-bar-title {
  font-size: 17px;
  font-weight: 600;
  color: #000000;
  text-align: center;
  flex: 1;
}

.dark .nav-bar-title {
  color: #ffffff;
}

/* 已删除未使用的返回按钮和页面标题样式 */

/* 搜索框 */
.search-box {
  position: relative;
  margin: 20rpx 30rpx;
}

.search-icon {
  position: absolute;
  left: 24rpx;
  top: 50%;
  transform: translateY(-50%);
  width: 32rpx;
  height: 32rpx;
  z-index: 1;
}

.search-input {
  height: 80rpx;
  background-color: #ffffff;
  border-radius: 40rpx;
  padding: 0 80rpx;
  font-size: 28rpx;
  color: #333333;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.05);
}

.dark .search-input {
  background-color: #2c3034;
  color: #f8f9fa;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.2);
}

.clear-button {
  position: absolute;
  right: 24rpx;
  top: 50%;
  transform: translateY(-50%);
  width: 40rpx;
  height: 40rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1;
}

.clear-icon {
  width: 32rpx;
  height: 32rpx;
}

/* 角色分类 */
.category-scroll {
  margin: 20rpx 30rpx;
  white-space: nowrap;
}

.category-list {
  display: flex;
  padding: 10rpx 0;
}

.category-item {
  display: inline-block;
  padding: 12rpx 30rpx;
  margin-right: 20rpx;
  background-color: #f0f0f0;
  border-radius: 30rpx;
  font-size: 28rpx;
  color: #666666;
  transition: all 0.3s ease;
}

.dark .category-item {
  background-color: #343a40;
  color: #adb5bd;
}

.category-item.active {
  background-color: #5e72e4;
  color: #ffffff;
}

/* 角色列表容器 */
.role-list-container {
  flex: 1;
  position: relative;
  margin: 0 30rpx 20rpx;
  overflow: hidden;
}

.dark .role-list-container {
  background-color: #1a1d20;
}

/* 角色列表滚动区 */
.role-list-scroll {
  height: 100%;
  width: 100%;
}

/* 已删除调试信息相关样式 */

.section-title {
  font-size: 32rpx;
  font-weight: 600;
  color: #333333;
  margin: 30rpx 0 20rpx;
  padding: 0 10rpx;
}

.dark .section-title {
  color: #f8f9fa;
}

.role-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20rpx;
  margin-bottom: 30rpx;
}

/* 加载中 */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60rpx 0;
}

.loading-spinner {
  width: 60rpx;
  height: 60rpx;
  border: 6rpx solid #f3f3f3;
  border-top: 6rpx solid #5e72e4;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  font-size: 28rpx;
  color: #999999;
  margin-top: 20rpx;
}

.dark .loading-text {
  color: #adb5bd;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* 空状态 */
.empty-tip {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60rpx 0;
  grid-column: span 2;
}

.empty-icon {
  width: 120rpx;
  height: 120rpx;
  margin-bottom: 20rpx;
}

.empty-text {
  font-size: 28rpx;
  color: #999999;
}

.dark .empty-text {
  color: #adb5bd;
}

/* 底部按钮 */
.bottom-buttons {
  display: flex;
  justify-content: space-between;
  padding: 20rpx 30rpx 40rpx;
}

.create-button, .start-button {
  width: 48%;
  height: 88rpx;
  border-radius: 44rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 30rpx;
  font-weight: 500;
}

.create-button {
  background-color: #ffffff;
  color: #5e72e4;
  border: 2rpx solid #5e72e4;
}

.dark .create-button {
  background-color: #343a40;
  color: #5e72e4;
  border: 2rpx solid #5e72e4;
}

.start-button {
  background-color: #5e72e4;
  color: #ffffff;
}

.start-button.disabled {
  background-color: #cccccc;
  color: #ffffff;
}

/* 角色详情弹窗 */
.role-detail-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.role-detail-modal.show {
  opacity: 1;
  visibility: visible;
}

.role-detail-content {
  width: 80%;
  max-width: 540rpx;
  max-height: 80%;
  background-color: #ffffff;
  border-radius: 24rpx;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 12rpx 30rpx rgba(0, 0, 0, 0.12);
  transform: translateY(20rpx) scale(0.98);
  transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
}

.dark .role-detail-content {
  background-color: #212529;
  box-shadow: 0 12rpx 30rpx rgba(0, 0, 0, 0.3);
}

.role-detail-modal.show .role-detail-content {
  transform: translateY(0) scale(1);
}

.role-detail-header {
  padding: 24rpx 28rpx;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1rpx solid rgba(0, 0, 0, 0.05);
  background-color: #ffffff;
}

.dark .role-detail-header {
  background-color: #212529;
  border-bottom: 1rpx solid rgba(255, 255, 255, 0.05);
}

.header-placeholder {
  width: 56rpx;
  height: 56rpx;
}

.role-detail-title {
  font-size: 34rpx;
  font-weight: 600;
  color: #333333;
  text-align: center;
  flex: 1;
}

.dark .role-detail-title {
  color: #f8f9fa;
}

.role-detail-header .close-button {
  width: 56rpx;
  height: 56rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 28rpx;
  background-color: rgba(0, 0, 0, 0.03);
}

.dark .role-detail-header .close-button {
  background-color: rgba(255, 255, 255, 0.1);
}

.role-detail-header .close-icon {
  width: 32rpx;
  height: 32rpx;
}

.dark .role-detail-header .close-icon {
  filter: invert(1);
}

.role-detail-body {
  flex: 1;
  padding: 16rpx 16rpx 20rpx;
  max-height: 60vh;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.role-avatar-container {
  display: flex;
  justify-content: center;
  margin-bottom: 24rpx;
}

.role-avatar {
  width: 140rpx;
  height: 140rpx;
  border-radius: 70rpx;
  background-color: #f0f0f0;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.08);
  border: 4rpx solid #ffffff;
}

.role-info-section {
  display: flex;
  flex-direction: column;
  gap: 12rpx;
  width: 100%;
  max-width: 480rpx;
}

.role-info-group {
  background-color: #f9f9f9;
  border-radius: 12rpx;
  padding: 10rpx 16rpx;
  display: flex;
  flex-direction: column;
  gap: 6rpx;
  width: 100%;
}

.dark .role-info-group {
  background-color: #343a40;
}

.role-info-row {
  display: flex;
  width: 100%;
  flex-wrap: wrap;
}

.role-info-item {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  width: 100%;
  padding: 4rpx 0;
}

.role-info-row:nth-child(3) .role-info-item {
  width: 50%;
  box-sizing: border-box;
  padding-right: 10rpx;
}

.role-info-label {
  font-size: 26rpx;
  font-weight: 600;
  color: #333333;
  min-width: 90rpx;
  flex-shrink: 0;
}

.dark .role-info-label {
  color: #f8f9fa;
}

.role-info-value {
  font-size: 26rpx;
  color: #666666;
  word-break: break-all;
  line-height: 1.5;
  flex: 1;
}

.dark .role-info-value {
  color: #adb5bd;
}

/* 短文本特殊处理 */
.short-text {
  white-space: nowrap;
  overflow: visible;
  text-overflow: clip;
  display: inline;
}

.description-item,
.background-item,
.communication-style-item {
  flex-direction: column;
  width: 100%;
}

.description-item .role-info-label,
.background-item .role-info-label,
.communication-style-item .role-info-label {
  margin-bottom: 8rpx;
}

.description-item .role-info-value,
.background-item .role-info-value,
.communication-style-item .role-info-value {
  white-space: pre-wrap;
  padding: 8rpx 0;
  line-height: 1.6;
  width: 100%;
  box-sizing: border-box;
}

.role-detail-footer {
  padding: 16rpx 20rpx 24rpx;
  display: flex;
  flex-direction: column;
  border-top: 1rpx solid #f0f0f0;
  gap: 12rpx;
  align-items: center;
}

.footer-buttons {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 12rpx;
  align-items: center;
}

.system-role-tag {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 6rpx 0;
  margin-bottom: 10rpx;
}

.system-role-text {
  font-size: 24rpx;
  color: #5e72e4;
  font-weight: 500;
  background-color: rgba(94, 114, 228, 0.1);
  padding: 6rpx 16rpx;
  border-radius: 24rpx;
}

.dark .system-role-text {
  color: #4dabf7;
  background-color: rgba(77, 171, 247, 0.15);
}

.button-row {
  display: flex;
  justify-content: space-between;
  gap: 16rpx;
  width: 90%;
  max-width: 600rpx;
}

.detail-button {
  flex: 1;
  height: 76rpx;
  border-radius: 38rpx;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28rpx;
  font-weight: 500;
}

.detail-button.edit {
  background-color: #ffffff;
  color: #5e72e4;
  border: 2rpx solid #5e72e4;
  font-size: 26rpx;
}

.dark .detail-button.edit {
  background-color: #343a40;
  color: #4dabf7;
  border: 2rpx solid #4dabf7;
}

.detail-button.delete {
  background-color: #ffffff;
  color: #ff4d4f;
  border: 2rpx solid #ff4d4f;
  font-size: 26rpx;
}

.dark .detail-button.delete {
  background-color: #343a40;
  color: #ff6b6b;
  border: 2rpx solid #ff6b6b;
}

.chat-btn {
  background-color: #5e72e4 !important;
  color: #ffffff !important;
  border: 2rpx solid #5e72e4 !important;
}

.dark .chat-btn {
  background-color: #4c63d2 !important;
  border: 2rpx solid #4c63d2 !important;
}

/* 已删除未使用的样式 */

*#*#*end*#*#*

*#*#*miniprogram\pages\test-gemini\test-gemini.js*#*#*begin*#*#*
// pages/test-gemini/test-gemini.js
/**
 * Gemini API测试页面
 * 用于测试Gemini API的连接和功能
 */

// 获取应用实例
const app = getApp();

Page({
  /**
   * 页面的初始数据
   */
  data: {
    darkMode: false,
    testing: false,
    testResult: null,
    errorMessage: '',
    modelType: 'gemini', // 默认使用Gemini模型
    modelTypes: ['gemini', 'zhipu'],
    testMessage: '你好，这是一个测试消息。',
    cloudInit: false
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 从全局获取暗黑模式设置
    this.setData({
      darkMode: app.globalData.darkMode,
      cloudInit: app.globalData.cloudInit
    });

    // 如果云环境未初始化，尝试初始化
    if (!this.data.cloudInit) {
      this.initCloud();
    }
  },

  /**
   * 初始化云环境
   */
  initCloud() {
    try {
      // 检查是否已经初始化
      if (!wx.cloud) {
        console.error('请使用 2.2.3 或以上的基础库以使用云能力');
        this.setData({
          errorMessage: '请使用 2.2.3 或以上的基础库以使用云能力'
        });
        return;
      }

      if (!wx.cloud.inited) {
        wx.cloud.init({
          env: app.globalData.cloudEnv || wx.cloud.DYNAMIC_CURRENT_ENV,
          traceUser: true,
        });
      }

      this.setData({
        cloudInit: true,
        errorMessage: ''
      });

      console.log('云环境初始化成功');
    } catch (error) {
      console.error('云环境初始化失败:', error);
      this.setData({
        errorMessage: '云环境初始化失败: ' + (error.message || error)
      });
    }
  },

  /**
   * 选择模型类型
   */
  onModelTypeChange(e) {
    this.setData({
      modelType: e.detail.value
    });
  },

  /**
   * 输入测试消息
   */
  onTestMessageInput(e) {
    this.setData({
      testMessage: e.detail.value
    });
  },

  /**
   * 测试Gemini API连接
   */
  testConnection() {
    // 检查云环境是否初始化
    if (!this.data.cloudInit) {
      this.initCloud();
      if (!this.data.cloudInit) {
        wx.showToast({
          title: '云环境未初始化',
          icon: 'none'
        });
        return;
      }
    }

    this.setData({
      testing: true,
      testResult: null,
      errorMessage: ''
    });

    // 调用云函数测试连接
    wx.cloud.callFunction({
      name: 'chat',
      data: {
        action: 'testConnection',
        modelType: this.data.modelType
      }
    })
    .then(res => {
      console.log('测试结果:', res);

      if (res.result && res.result.success) {
        this.setData({
          testResult: {
            success: true,
            message: res.result.message || `${this.data.modelType}模型连接测试成功`,
            reply: res.result.reply || '测试成功'
          }
        });
      } else {
        // 显示详细的错误信息
        let errorMessage = '测试失败';
        if (res.result && res.result.error) {
          errorMessage = res.result.error;
          // 如果错误信息是对象，转换为字符串
          if (typeof errorMessage === 'object') {
            try {
              errorMessage = JSON.stringify(errorMessage);
            } catch (e) {
              errorMessage = '无法解析的错误对象';
            }
          }
        }

        this.setData({
          testResult: {
            success: false,
            message: errorMessage
          }
        });
      }
    })
    .catch(err => {
      console.error('测试连接失败:', err);
      this.setData({
        testResult: {
          success: false,
          message: err.message || '测试连接失败'
        }
      });
    })
    .finally(() => {
      this.setData({
        testing: false
      });
    });
  },

  /**
   * 测试发送消息
   */
  testSendMessage() {
    // 检查云环境是否初始化
    if (!this.data.cloudInit) {
      this.initCloud();
      if (!this.data.cloudInit) {
        wx.showToast({
          title: '云环境未初始化',
          icon: 'none'
        });
        return;
      }
    }

    // 检查测试消息是否为空
    if (!this.data.testMessage.trim()) {
      wx.showToast({
        title: '请输入测试消息',
        icon: 'none'
      });
      return;
    }

    this.setData({
      testing: true,
      testResult: null,
      errorMessage: ''
    });

    // 调用云函数发送消息
    wx.cloud.callFunction({
      name: 'chat',
      data: {
        action: 'reply', // 使用reply操作，而不是generateAIReply
        message: this.data.testMessage,
        history: [],
        roleInfo: {
          prompt: '你是一个友好的AI助手，能够提供有用的信息和支持。'
        },
        includeEmotionAnalysis: false,
        modelType: this.data.modelType
      }
    })
    .then(res => {
      console.log('发送消息结果:', res);

      if (res.result && res.result.success) {
        this.setData({
          testResult: {
            success: true,
            message: '消息发送成功',
            reply: res.result.content || '测试成功'
          }
        });
      } else {
        // 显示详细的错误信息
        let errorMessage = '消息发送失败';
        if (res.result && res.result.error) {
          errorMessage = res.result.error;
          // 如果错误信息是对象，转换为字符串
          if (typeof errorMessage === 'object') {
            try {
              errorMessage = JSON.stringify(errorMessage);
            } catch (e) {
              errorMessage = '无法解析的错误对象';
            }
          }
        }

        this.setData({
          testResult: {
            success: false,
            message: errorMessage
          }
        });
      }
    })
    .catch(err => {
      console.error('发送消息失败:', err);
      this.setData({
        testResult: {
          success: false,
          message: err.message || '发送消息失败'
        }
      });
    })
    .finally(() => {
      this.setData({
        testing: false
      });
    });
  },

  /**
   * 返回上一页
   */
  goBack() {
    wx.navigateBack();
  }
});

*#*#*end*#*#*

*#*#*miniprogram\pages\test-gemini\test-gemini.json*#*#*begin*#*#*
{
  "usingComponents": {},
  "navigationBarTitleText": "Gemini API 测试",
  "navigationBarBackgroundColor": "#007bff",
  "navigationBarTextStyle": "white",
  "backgroundColor": "#f8f9fa",
  "backgroundTextStyle": "light"
}

*#*#*end*#*#*

*#*#*miniprogram\pages\test-gemini\test-gemini.wxml*#*#*begin*#*#*
<!--pages/test-gemini/test-gemini.wxml-->
<view class="container {{darkMode ? 'dark-mode' : ''}}">
  <view class="header">
    <view class="title">Gemini API 测试</view>
    <view class="subtitle">测试Gemini API的连接和功能</view>
  </view>

  <view class="content">
    <!-- 云环境初始化状态 -->
    <view class="section">
      <view class="section-title">云环境状态</view>
      <view class="cloud-status {{cloudInit ? 'success' : 'error'}}">
        <text>{{cloudInit ? '已初始化' : '未初始化'}}</text>
        <button wx:if="{{!cloudInit}}" class="btn" bindtap="initCloud">初始化云环境</button>
      </view>
      <view wx:if="{{errorMessage}}" class="error-message">{{errorMessage}}</view>
    </view>

    <!-- 模型选择 -->
    <view class="section">
      <view class="section-title">模型选择</view>
      <radio-group class="model-select" bindchange="onModelTypeChange">
        <label wx:for="{{modelTypes}}" wx:key="*this" class="model-option">
          <radio value="{{item}}" checked="{{modelType === item}}" color="{{darkMode ? '#4dabf7' : '#007bff'}}" />
          <text>{{item === 'gemini' ? 'Google Gemini' : '智谱AI'}}</text>
        </label>
      </radio-group>
    </view>

    <!-- 测试消息输入 -->
    <view class="section">
      <view class="section-title">测试消息</view>
      <textarea class="test-message" value="{{testMessage}}" bindinput="onTestMessageInput" placeholder="输入测试消息" maxlength="500"></textarea>
    </view>

    <!-- 测试按钮 -->
    <view class="section">
      <view class="buttons">
        <button class="btn" bindtap="testConnection" loading="{{testing}}">测试连接</button>
        <button class="btn" bindtap="testSendMessage" loading="{{testing}}">发送消息</button>
      </view>
    </view>

    <!-- 测试结果 -->
    <view class="section" wx:if="{{testResult}}">
      <view class="section-title">测试结果</view>
      <view class="test-result {{testResult.success ? 'success' : 'error'}}">
        <view class="result-status">
          <text class="status-icon">{{testResult.success ? '✓' : '✗'}}</text>
          <text class="status-text">{{testResult.message}}</text>
        </view>
        <view class="result-content" wx:if="{{testResult.reply}}">
          <view class="reply-title">回复内容：</view>
          <view class="reply-text">{{testResult.reply}}</view>
        </view>
      </view>
    </view>
  </view>

  <!-- 返回按钮 -->
  <view class="footer">
    <button class="btn back-btn" bindtap="goBack">返回</button>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\test-gemini\test-gemini.wxss*#*#*begin*#*#*
/* pages/test-gemini/test-gemini.wxss */
.container {
  padding: 30rpx;
  min-height: 100vh;
  background-color: #f8f9fa;
  color: #343a40;
  transition: all 0.3s ease;
}

.dark-mode {
  background-color: #1a1d20;
  color: #e9ecef;
}

.header {
  margin-bottom: 40rpx;
  text-align: center;
}

.title {
  font-size: 40rpx;
  font-weight: bold;
  margin-bottom: 10rpx;
}

.subtitle {
  font-size: 28rpx;
  color: #6c757d;
}

.dark-mode .subtitle {
  color: #adb5bd;
}

.content {
  width: 100%;
}

.section {
  margin-bottom: 40rpx;
  background-color: #ffffff;
  border-radius: 16rpx;
  padding: 30rpx;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.05);
}

.dark-mode .section {
  background-color: #2a2d31;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.2);
}

.section-title {
  font-size: 32rpx;
  font-weight: bold;
  margin-bottom: 20rpx;
  color: #495057;
}

.dark-mode .section-title {
  color: #ced4da;
}

.cloud-status {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20rpx;
  border-radius: 8rpx;
  margin-bottom: 20rpx;
}

.cloud-status.success {
  background-color: #d4edda;
  color: #155724;
}

.dark-mode .cloud-status.success {
  background-color: #1e4620;
  color: #8fd19e;
}

.cloud-status.error {
  background-color: #f8d7da;
  color: #721c24;
}

.dark-mode .cloud-status.error {
  background-color: #4c1c1f;
  color: #ea868f;
}

.error-message {
  color: #dc3545;
  font-size: 28rpx;
  margin-top: 10rpx;
}

.dark-mode .error-message {
  color: #f77;
}

.model-select {
  display: flex;
  flex-direction: column;
}

.model-option {
  display: flex;
  align-items: center;
  margin-bottom: 20rpx;
}

.model-option text {
  margin-left: 20rpx;
}

.test-message {
  width: 100%;
  height: 200rpx;
  border: 2rpx solid #ced4da;
  border-radius: 8rpx;
  padding: 20rpx;
  box-sizing: border-box;
  font-size: 28rpx;
  background-color: #fff;
  color: #212529;
}

.dark-mode .test-message {
  border-color: #495057;
  background-color: #343a40;
  color: #e9ecef;
}

.buttons {
  display: flex;
  justify-content: space-between;
}

.btn {
  flex: 1;
  margin: 0 10rpx;
  background-color: #007bff;
  color: #fff;
  border: none;
  border-radius: 8rpx;
  padding: 20rpx 0;
  font-size: 28rpx;
}

.dark-mode .btn {
  background-color: #4dabf7;
  color: #212529;
}

.back-btn {
  background-color: #6c757d;
  margin-top: 40rpx;
}

.dark-mode .back-btn {
  background-color: #adb5bd;
}

.test-result {
  padding: 20rpx;
  border-radius: 8rpx;
}

.test-result.success {
  background-color: #d4edda;
  color: #155724;
}

.dark-mode .test-result.success {
  background-color: #1e4620;
  color: #8fd19e;
}

.test-result.error {
  background-color: #f8d7da;
  color: #721c24;
}

.dark-mode .test-result.error {
  background-color: #4c1c1f;
  color: #ea868f;
}

.result-status {
  display: flex;
  align-items: center;
  margin-bottom: 20rpx;
}

.status-icon {
  font-size: 40rpx;
  margin-right: 20rpx;
}

.status-text {
  font-size: 28rpx;
}

.result-content {
  margin-top: 20rpx;
  padding-top: 20rpx;
  border-top: 2rpx solid rgba(0, 0, 0, 0.1);
}

.dark-mode .result-content {
  border-top-color: rgba(255, 255, 255, 0.1);
}

.reply-title {
  font-size: 28rpx;
  font-weight: bold;
  margin-bottom: 10rpx;
}

.reply-text {
  font-size: 28rpx;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-all;
}

*#*#*end*#*#*

*#*#*miniprogram\pages\user\profile\profile.js*#*#*begin*#*#*
// 个人资料页面
const app = getApp();
const userService = require('../../../services/userService');

Page({
  data: {
    statusBarHeight: 20, // 默认状态栏高度
    navBarHeight: 44, // 默认导航栏高度
    navTotalHeight: 64, // 状态栏+导航栏总高度
    loading: true, // 加载状态
    darkMode: false, // 暗黑模式状态

    // 用户信息
    userId: '',
    userInfo: {
      nickName: '',
      avatarUrl: '',
      gender: '',
      age: '',
      bio: ''
    },

    // 选择器数据
    genderOptions: ['男', '女', '其他'],
    genderIndex: 0,
    ageOptions: Array.from({length: 100}, (_, i) => i + 1),
    ageIndex: 17, // 默认18岁

    // 文本长度计数
    bioLength: 0,

    // 性格分析数据
    personalityTraits: [
      { name: '开朗', score: 85 },
      { name: '理性', score: 70 },
      { name: '创造力', score: 65 },
      { name: '耐心', score: 75 },
      { name: '好奇心', score: 90 }
    ],
    personalitySummary: '',

    // 兴趣标签
    interestTags: []
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    this.initSystemInfo();
    this.loadUserData();
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    // 检查暗黑模式变化
    if (app.globalData && this.data.darkMode !== app.globalData.darkMode) {
      this.setData({
        darkMode: app.globalData.darkMode
      });
    }
  },

  /**
   * 初始化系统信息
   */
  initSystemInfo: function () {
    try {
      const systemInfo = wx.getSystemInfoSync();
      const app = getApp();

      // 检测暗黑模式
      let darkMode = false;
      if (app.globalData && app.globalData.darkMode !== undefined) {
        darkMode = app.globalData.darkMode;
      } else {
        darkMode = systemInfo.theme === 'dark';
        // 更新全局数据
        if (app.globalData) {
          app.globalData.darkMode = darkMode;
        }
      }

      // 计算导航栏高度
      const navBarHeight = 44; // 固定导航栏高度
      const navTotalHeight = systemInfo.statusBarHeight + navBarHeight;

      this.setData({
        statusBarHeight: systemInfo.statusBarHeight,
        navBarHeight: navBarHeight,
        navTotalHeight: navTotalHeight,
        darkMode: darkMode
      });

      // 监听系统主题变化
      wx.onThemeChange && wx.onThemeChange((result) => {
        const isDark = result.theme === 'dark';
        this.setData({ darkMode: isDark });
        // 更新全局数据
        if (app.globalData) {
          app.globalData.darkMode = isDark;
        }
      });
    } catch (e) {
      console.error('获取系统信息失败:', e);
    }
  },

  /**
   * 加载用户数据
   */
  loadUserData: function () {
    try {
      // 直接从本地缓存获取用户信息
      const loginInfo = wx.getStorageSync('loginInfo') || {};
      let userInfo = loginInfo.userInfo || {};

      // 如果没有loginInfo，尝试使用userInfo
      if (!userInfo || Object.keys(userInfo).length === 0) {
        userInfo = wx.getStorageSync('userInfo') || {};
      }

      console.log('从本地缓存获取的用户信息:', userInfo);

      // 确保有用户ID
      const userId = userInfo.userId || '6457751';

      if (!userId) {
        console.error('无法获取用户ID');
        wx.showToast({
          title: '获取用户信息失败',
          icon: 'none'
        });
        this.setData({ loading: false });
        return;
      }

      // 处理昵称和username，确保两者一致
      if (!userInfo.nickName && userInfo.username) {
        userInfo.nickName = userInfo.username;
      } else if (!userInfo.username && userInfo.nickName) {
        userInfo.username = userInfo.nickName;
      } else if (!userInfo.nickName && !userInfo.username) {
        userInfo.nickName = '微信用户';
        userInfo.username = '微信用户';
      }

      // 先保存原始的userId和其他必要字段
      const originalUserId = userInfo.userId;
      const otherFields = {};
      Object.keys(userInfo).forEach(key => {
        if (!['nickName', 'username', 'avatarUrl', 'gender', 'age', 'bio'].includes(key)) {
          otherFields[key] = userInfo[key];
        }
      });

      // 确保昵称和用户名一致
      const finalNickName = userInfo.nickName || userInfo.username || '微信用户';
      const finalUsername = userInfo.username || userInfo.nickName || '微信用户';

      // 重新构建userInfo对象，确保昵称和用户名一致
      userInfo = {
        ...otherFields,
        userId: originalUserId || userId,
        nickName: finalNickName,
        username: finalUsername,
        avatarUrl: userInfo.avatarUrl || '',
        gender: userInfo.gender || 1,
        age: userInfo.age || 25,
        bio: userInfo.bio || ''
      };

      // 打印日志，检查昵称和用户名是否一致
      console.log('重新构建userInfo对象后，nickName:', userInfo.nickName, 'username:', userInfo.username);

      // 获取兴趣标签
      this.fetchInterestTags(userId);

      // 获取性格分析
      this.fetchPersonalityAnalysis(userId);

      // 设置性别索引
      let genderIndex = 0;
      if (userInfo.gender) {
        genderIndex = this.data.genderOptions.findIndex(item => item === userInfo.gender);
        genderIndex = genderIndex >= 0 ? genderIndex : 0;
      }

      // 设置年龄索引
      let ageIndex = 17;
      if (userInfo.age) {
        ageIndex = this.data.ageOptions.findIndex(item => item === parseInt(userInfo.age));
        ageIndex = ageIndex >= 0 ? ageIndex : 17;
      }

      this.setData({
        loading: false,
        userId: userId,
        userInfo: userInfo,
        genderIndex: genderIndex,
        ageIndex: ageIndex,
        bioLength: userInfo.bio ? userInfo.bio.length : 0
      });

      // 更新本地缓存
      wx.setStorageSync('userInfo', userInfo);

      console.log('用户数据加载完成:', userInfo);
    } catch (error) {
      console.error('加载用户数据失败:', error);
      wx.showToast({
        title: '加载用户数据失败',
        icon: 'none'
      });
      this.setData({ loading: false });
    }
  },

  /**
   * 通用的用户数据获取函数
   * @param {string} userId - 用户ID
   * @param {string} action - 云函数action名称
   * @param {Object} defaultData - 默认数据
   * @param {Function} processResult - 处理结果的函数
   * @param {string} errorMessage - 错误日志前缀
   * @returns {Promise<Object>} 处理后的数据
   */
  fetchUserData: async function (userId, action, defaultData, processResult, errorMessage) {
    if (!userId) return defaultData;

    // 确保使用正确的用户ID
    userId = userId || '6457751'; // 使用固定的userId

    try {
      // 调用云函数获取用户数据
      const result = await wx.cloud.callFunction({
        name: 'user',
        data: {
          action,
          userId
        }
      });

      // 处理结果
      if (result.result && result.result.success) {
        return processResult(result.result);
      } else {
        console.warn(`${errorMessage} - 云函数返回失败:`, result.result);
        return defaultData;
      }
    } catch (error) {
      console.error(`${errorMessage}:`, error);
      return defaultData;
    }
  },

  /**
   * 获取兴趣标签
   */
  fetchInterestTags: async function (userId) {
    if (!userId) return;

    // 默认标签
    const defaultTags = ['旅行', '摄影', '美食', '电影', '音乐', '阅读', '科技'];

    // 处理结果的函数
    const processResult = (result) => {
      if (result.keywords) {
        // 从关键词中提取标签
        return result.keywords.map(item => item.word || item);
      }
      return defaultTags;
    };

    // 获取数据
    const tags = await this.fetchUserData(
      userId,
      'getUserInterests',
      defaultTags,
      processResult,
      '获取用户兴趣标签失败'
    );

    // 更新状态
    this.setData({ interestTags: tags });
  },

  /**
   * 获取性格分析
   */
  fetchPersonalityAnalysis: async function (userId) {
    if (!userId) return;

    // 默认摘要
    const defaultSummary = '您的性格特点是开朗、乐观，善于与人沟通。在面对挑战时，您表现出较强的适应能力和解决问题的能力。您对新事物充满好奇心，喜欢探索和学习。';

    // 处理结果的函数
    const processResult = (result) => {
      const data = result.data;
      const updates = {};

      // 更新性格特质
      if (data && data.personalityTraits && data.personalityTraits.length > 0) {
        updates.personalityTraits = data.personalityTraits;
      }

      // 更新性格摘要
      updates.personalitySummary = (data && data.summary) ? data.summary : defaultSummary;

      return updates;
    };

    // 获取数据
    const updates = await this.fetchUserData(
      userId,
      'getUserPerception',
      { personalitySummary: defaultSummary },
      processResult,
      '获取用户性格分析失败'
    );

    // 更新状态
    this.setData(updates);
  },

  /**
   * 选择头像
   */
  chooseAvatar: function () {
    wx.chooseImage({
      count: 1,
      sizeType: ['compressed'],
      sourceType: ['album', 'camera'],
      success: (res) => {
        const tempFilePath = res.tempFilePaths[0];

        // 显示上传中提示
        wx.showLoading({
          title: '上传中...',
          mask: true
        });

        // 获取用户ID
        const loginInfo = wx.getStorageSync('loginInfo') || {};
        const userId = (loginInfo.userInfo && loginInfo.userInfo.userId) || '6457751'; // 使用固定的userId
        if (!userId) {
          wx.hideLoading();
          wx.showToast({
            title: '无法获取用户ID',
            icon: 'none'
          });
          return;
        }

        // 生成云存储路径
        const cloudPath = `users/${userId}/avatar_${Date.now()}.jpg`;

        // 上传到云存储
        wx.cloud.uploadFile({
          cloudPath: cloudPath,
          filePath: tempFilePath,
          success: res => {
            console.log('头像上传成功:', res);
            const fileID = res.fileID;

            // 获取可访问的URL
            wx.cloud.getTempFileURL({
              fileList: [fileID],
              success: res => {
                const avatarUrl = res.fileList[0].tempFileURL;
                console.log('头像临时URL:', avatarUrl);

                // 更新头像
                const userInfo = this.data.userInfo;
                userInfo.avatarUrl = fileID; // 存储fileID而非临时URL

                this.setData({
                  userInfo: userInfo
                });

                wx.hideLoading();
                wx.showToast({
                  title: '头像上传成功',
                  icon: 'success'
                });
              },
              fail: err => {
                console.error('获取头像临时URL失败:', err);
                // 即使获取临时URL失败，仍然更新头像
                const userInfo = this.data.userInfo;
                userInfo.avatarUrl = fileID;

                this.setData({
                  userInfo: userInfo
                });

                wx.hideLoading();
                wx.showToast({
                  title: '头像已更新',
                  icon: 'success'
                });
              }
            });
          },
          fail: err => {
            console.error('头像上传失败:', err);
            wx.hideLoading();
            wx.showToast({
              title: '头像上传失败',
              icon: 'none'
            });
          }
        });
      },
      fail: err => {
        console.error('选择头像失败:', err);
        wx.showToast({
          title: '选择头像失败',
          icon: 'none'
        });
      }
    });
  },

  /**
   * 处理昵称输入
   */
  handleNicknameInput: function (e) {
    const userInfo = this.data.userInfo;
    userInfo.nickName = e.detail.value;
    userInfo.username = e.detail.value; // 同时更新username字段

    this.setData({
      userInfo: userInfo
    });
  },

  /**
   * 处理性别选择
   */
  handleGenderChange: function (e) {
    const index = e.detail.value;
    const gender = this.data.genderOptions[index];

    const userInfo = this.data.userInfo;
    userInfo.gender = gender;

    this.setData({
      userInfo: userInfo,
      genderIndex: index
    });
  },

  /**
   * 处理年龄选择
   */
  handleAgeChange: function (e) {
    const index = e.detail.value;
    const age = this.data.ageOptions[index];

    const userInfo = this.data.userInfo;
    userInfo.age = age;

    this.setData({
      userInfo: userInfo,
      ageIndex: index
    });
  },

  /**
   * 处理个人简介输入
   */
  handleBioInput: function (e) {
    const bio = e.detail.value;
    const userInfo = this.data.userInfo;
    userInfo.bio = bio;

    this.setData({
      userInfo: userInfo,
      bioLength: bio.length
    });
  },

  /**
   * 切换暗黑模式
   */
  toggleDarkMode: function () {
    // 确保当前值是布尔值
    const currentDarkMode = typeof this.data.darkMode === 'boolean' ? this.data.darkMode : this.data.darkMode === 'true';
    const newDarkMode = !currentDarkMode;

    console.log('切换暗黑模式，当前值:', currentDarkMode, '新值:', newDarkMode);

    this.setData({
      darkMode: newDarkMode
    });

    // 更新全局数据
    if (app.globalData) {
      app.globalData.darkMode = newDarkMode;
      console.log('已更新全局数据 darkMode:', app.globalData.darkMode);
    }

    // 保存到本地存储
    wx.setStorageSync('darkMode', newDarkMode);
    console.log('已保存到本地存储 darkMode:', newDarkMode);

    // 更新TabBar样式
    if (app.updateTheme) {
      app.updateTheme(newDarkMode);
    }

    // 刷新当前页面样式
    this.updatePageStyle(newDarkMode);
  },

  /**
   * 更新页面样式
   */
  updatePageStyle: function(isDarkMode) {
    // 刷新页面元素样式
    console.log('页面样式已更新为:', isDarkMode ? '暗色模式' : '亮色模式');
  },

  /**
   * 清除聊天记录
   */
  clearChatHistory: function () {
    wx.showModal({
      title: '确认清除',
      content: '确定要清除所有聊天记录吗？此操作不可恢复。',
      confirmColor: '#ff4d4f',
      success: (res) => {
        if (res.confirm) {
          // 这里应该调用云函数或API清除聊天记录
          wx.showToast({
            title: '聊天记录已清除',
            icon: 'success'
          });
        }
      }
    });
  },

  /**
   * 显示关于我们
   */
  showAbout: function () {
    wx.navigateTo({
      url: '/pages/about/index'
    });
  },

  /**
   * 保存个人资料
   */
  saveProfile: async function () {
    // 复制一份用户信息，避免直接修改this.data
    const userInfo = JSON.parse(JSON.stringify(this.data.userInfo));

    // 验证昵称
    if (!userInfo.nickName || userInfo.nickName.trim() === '') {
      wx.showToast({
        title: '请输入昵称',
        icon: 'none'
      });
      return;
    }

    // 再次确保 username 和 nickName 一致
    userInfo.username = userInfo.nickName;

    console.log('保存前的用户信息:', userInfo);

    // 显示加载中
    wx.showLoading({
      title: '保存中...',
      mask: true
    });

    try {
      // 获取用户ID
      const loginInfo = wx.getStorageSync('loginInfo') || {};
      const userId = (loginInfo.userInfo && loginInfo.userInfo.userId) || '6457751'; // 使用固定的userId
      if (!userId) {
        throw new Error('无法获取用户ID');
      }

      // 保存到数据库
      const saveResult = await userService.saveUserProfile(userId, userInfo);

      if (!saveResult) {
        throw new Error('保存用户资料失败');
      }

      // 保存到本地缓存
      wx.setStorageSync('userInfo', userInfo);

      // 更新全局状态
      if (app.globalData) {
        app.globalData.userInfo = {
          ...app.globalData.userInfo,
          ...userInfo
        };
      }

      wx.hideLoading();
      wx.showToast({
        title: '保存成功',
        icon: 'success',
        success: () => {
          // 延迟返回，等待 Toast 显示完成
          setTimeout(() => {
            wx.navigateBack();
          }, 1000);
        }
      });
    } catch (error) {
      console.error('保存用户资料失败:', error);
      wx.hideLoading();
      wx.showToast({
        title: error.message || '保存失败，请重试',
        icon: 'none'
      });
    }
  },

  /**
   * 返回上一页
   */
  handleBack: function () {
    wx.navigateBack();
  }
});

*#*#*end*#*#*

*#*#*miniprogram\pages\user\profile\profile.json*#*#*begin*#*#*
{
  "navigationStyle": "custom",
  "usingComponents": {},
  "navigationBarTextStyle": "black",
  "backgroundColor": "#f8f9fa"
}

*#*#*end*#*#*

*#*#*miniprogram\pages\user\profile\profile.wxml*#*#*begin*#*#*
<view class="profile-container {{darkMode ? 'dark' : ''}}">
  <!-- 自定义导航栏 -->
  <view class="nav-container">
    <!-- 状态栏占位 -->
    <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

    <!-- 导航栏内容 -->
    <view class="nav-bar" style="height: {{navBarHeight}}px;">
      <view class="nav-bar-content">
        <view class="nav-back" bindtap="handleBack">
          <text class="nav-icon">←</text>
        </view>
        <view class="nav-title">个人资料</view>
        <view class="nav-placeholder"></view>
      </view>
    </view>
  </view>

  <!-- 加载状态 -->
  <view class="loading-container" wx:if="{{loading}}">
    <view class="loading-spinner"></view>
    <text class="loading-text">加载中...</text>
  </view>

  <!-- 内容区域 -->
  <view class="profile-content" wx:else>
    <!-- 头像区域 -->
    <view class="avatar-section">
      <view class="avatar-container" bindtap="chooseAvatar">
        <image class="avatar" src="{{userInfo.avatarUrl || '/images/avatars/default-avatar.png'}}"></image>
        <view class="avatar-edit">
          <text class="avatar-edit-icon">✎</text> 更换头像
        </view>
      </view>
      <view class="user-name">{{userInfo.nickName || '未设置昵称'}}</view>
      <view class="user-id">ID: {{userId || '未登录'}}</view>
    </view>

    <!-- 基本信息卡片 -->
    <view class="card">
      <view class="card-header">
        <image class="card-icon" src="/images/icons/user-info.png"></image>
        <text class="card-title">基本信息</text>
      </view>
      <view class="card-content">
        <view class="form-item">
          <text class="form-label required">昵称</text>
          <input class="form-input {{userInfo.nickName ? 'filled' : ''}}"
                 value="{{userInfo.nickName}}"
                 placeholder="请输入昵称"
                 bindinput="handleNicknameInput" />
        </view>

        <view class="form-item">
          <text class="form-label">性别</text>
          <picker class="form-picker {{userInfo.gender ? 'filled' : ''}}"
                  range="{{genderOptions}}"
                  value="{{genderIndex}}"
                  bindchange="handleGenderChange">
            <view style="padding-right: 40rpx;">{{genderOptions[genderIndex] || '请选择性别'}}</view>
            <text class="picker-arrow">▼</text>
          </picker>
        </view>

        <view class="form-item">
          <text class="form-label">年龄</text>
          <picker class="form-picker {{userInfo.age ? 'filled' : ''}}"
                  mode="selector"
                  range="{{ageOptions}}"
                  value="{{ageIndex}}"
                  bindchange="handleAgeChange">
            <view style="padding-right: 40rpx;">{{userInfo.age ? userInfo.age + '岁' : '请选择年龄'}}</view>
            <text class="picker-arrow">▼</text>
          </picker>
        </view>

        <view class="form-item">
          <text class="form-label">个人简介</text>
          <textarea class="form-textarea {{userInfo.bio ? 'filled' : ''}}"
                    value="{{userInfo.bio}}"
                    placeholder="介绍一下自己吧..."
                    maxlength="200"
                    bindinput="handleBioInput"></textarea>
          <view class="textarea-counter">{{bioLength}}/200</view>
        </view>
      </view>
    </view>

    <!-- 性格分析卡片 -->
    <view class="card">
      <view class="card-header">
        <image class="card-icon" src="/images/icons/personality.png"></image>
        <text class="card-title">性格分析</text>
        <text class="card-subtitle">基于您的聊天内容分析</text>
      </view>
      <view class="card-content">
        <view wx:if="{{personalityTraits && personalityTraits.length > 0}}">
          <view class="personality-traits">
            <view class="trait-item" wx:for="{{personalityTraits}}" wx:key="name">
              <text class="trait-name">{{item.name}}</text>
              <view class="trait-bar-container">
                <view class="trait-bar" style="width: {{item.score}}%;"></view>
              </view>
              <text class="trait-score">{{item.score}}%</text>
            </view>
          </view>

          <view class="divider"></view>

          <view class="personality-summary">
            {{personalitySummary || '您的性格特点是开朗、乐观，善于与人沟通。在面对挑战时，您表现出较强的适应能力和解决问题的能力。'}}
          </view>
        </view>
        <view class="empty-data" wx:else>
          <view class="empty-data-icon">📊</view>
          <view>暂无性格分析数据，多与AI对话可以获得更准确的分析</view>
        </view>
      </view>
    </view>

    <!-- 兴趣标签卡片 -->
    <view class="card">
      <view class="card-header">
        <image class="card-icon" src="/images/icons/interests.png"></image>
        <text class="card-title">兴趣标签</text>
      </view>
      <view class="card-content">
        <view class="interest-tags" wx:if="{{interestTags && interestTags.length > 0}}">
          <view class="interest-tag" wx:for="{{interestTags}}" wx:key="*this">{{item}}</view>
        </view>
        <view class="empty-data" wx:else>
          <view class="empty-data-icon">🏷️</view>
          <view>暂无兴趣标签，多与AI对话可以发现您的兴趣爱好</view>
        </view>
      </view>
    </view>

    <!-- 设置卡片 -->
    <view class="card">
      <view class="card-header">
        <image class="card-icon" src="/images/icons/settings.png"></image>
        <text class="card-title">设置</text>
      </view>
      <view class="card-content" style="padding: 0;">
        <view class="setting-item" bindtap="toggleDarkMode">
          <image class="setting-icon" src="/images/icons/dark-mode.png"></image>
          <view class="setting-content">
            <view class="setting-label">暗黑模式</view>
            <view class="setting-desc">切换应用的显示主题</view>
          </view>
          <view class="setting-action">
            <switch checked="{{darkMode}}" color="#4a6cf7" bindchange="toggleDarkMode"></switch>
          </view>
        </view>

        <view class="setting-item" bindtap="clearChatHistory">
          <image class="setting-icon" src="/images/icons/clear-history.png"></image>
          <view class="setting-content">
            <view class="setting-label">清除聊天记录</view>
            <view class="setting-desc">删除所有的聊天历史</view>
          </view>
          <view class="setting-action">
            <image class="setting-arrow" src="/images/icons/arrow-right.png"></image>
          </view>
        </view>

        <view class="setting-item" bindtap="showAbout">
          <image class="setting-icon" src="/images/icons/about.png"></image>
          <view class="setting-content">
            <view class="setting-label">关于我们</view>
            <view class="setting-desc">了解更多信息</view>
          </view>
          <view class="setting-action">
            <image class="setting-arrow" src="/images/icons/arrow-right.png"></image>
          </view>
        </view>
      </view>
    </view>

    <!-- 提交按钮 -->
    <view class="submit-button-container">
      <button class="submit-button" bindtap="saveProfile">保存资料</button>
    </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\user\profile\profile.wxss*#*#*begin*#*#*
/* 个人资料页面 - 现代简约风格 */

/* 全局变量 */
page {
  /* 主色调 */
  --primary-color: #4a6cf7;
  --primary-light: #eef1fe;
  --primary-dark: #3a56d4;

  /* 文本颜色 */
  --text-primary: #333333;
  --text-secondary: #666666;
  --text-hint: #999999;

  /* 背景颜色 */
  --bg-color: #f8f9fa;
  --card-bg: #ffffff;

  /* 边框颜色 */
  --border-color: #eeeeee;
  --divider-color: #f0f0f0;

  /* 功能色 */
  --success-color: #52c41a;
  --warning-color: #faad14;
  --error-color: #ff4d4f;

  /* 阴影 */
  --shadow-sm: 0 2rpx 8rpx rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4rpx 16rpx rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 8rpx 24rpx rgba(0, 0, 0, 0.12);

  /* 圆角 */
  --radius-sm: 8rpx;
  --radius-md: 16rpx;
  --radius-lg: 24rpx;
  --radius-xl: 32rpx;
  --radius-circle: 50%;

  background-color: var(--bg-color);
  color: var(--text-primary);
  font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

/* 页面容器 */
.profile-container {
  min-height: 100vh;
  background-color: var(--bg-color);
  padding-bottom: calc(120rpx + env(safe-area-inset-bottom));
}

/* 导航栏容器 */
.nav-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background-color: var(--card-bg);
  box-shadow: var(--shadow-sm);
}

/* 状态栏 */
.status-bar {
  width: 100%;
  background-color: var(--card-bg);
}

/* 导航栏 */
.nav-bar {
  width: 100%;
  background-color: var(--card-bg);
}

.nav-bar-content {
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
}

.nav-back {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: flex-start;
}

.nav-icon {
  font-size: 24px;
  color: var(--primary-color);
}

.nav-title {
  font-size: 17px;
  font-weight: 600;
  color: var(--text-primary);
  flex: 1;
  text-align: center;
}

.nav-placeholder {
  width: 40px;
}

/* 加载状态 */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.loading-spinner {
  width: 64rpx;
  height: 64rpx;
  border: 6rpx solid rgba(74, 108, 247, 0.2);
  border-top: 6rpx solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 24rpx;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-text {
  font-size: 28rpx;
  color: var(--text-secondary);
}

/* 内容区域 */
.profile-content {
  padding: 24rpx;
  padding-top: calc(var(--nav-total-height, 88px) + 24rpx);
}

/* 头像区域 */
.avatar-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 120rpx 0 60rpx; /* 增加上边距，避免被导航栏遮挡 */
}

.avatar-container {
  position: relative;
  width: 180rpx;
  height: 180rpx;
  border-radius: var(--radius-circle);
  overflow: hidden;
  box-shadow: var(--shadow-md);
  border: 4rpx solid var(--card-bg);
}

.avatar {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.avatar-edit {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  padding: 8rpx 0;
  text-align: center;
  font-size: 24rpx;
  transform: translateY(100%);
  transition: transform 0.3s ease;
}

.avatar-container:active .avatar-edit {
  transform: translateY(0);
}

.avatar-edit-icon {
  font-size: 32rpx;
}

.avatar-hint {
  font-size: 24rpx;
  color: var(--text-hint);
  margin-top: 16rpx;
}

.user-name {
  font-size: 36rpx;
  font-weight: 600;
  color: var(--text-primary);
  margin-top: 24rpx;
}

.user-id {
  font-size: 24rpx;
  color: var(--text-hint);
  margin-top: 8rpx;
}

/* 卡片样式 */
.card {
  background: var(--card-bg);
  border-radius: var(--radius-lg);
  margin-bottom: 32rpx;
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  border: 1rpx solid var(--border-color);
}

.card-header {
  padding: 24rpx 32rpx;
  border-bottom: 1px solid var(--divider-color);
  display: flex;
  align-items: center;
}

.card-icon {
  width: 40rpx;
  height: 40rpx;
  margin-right: 16rpx;
}

.card-title {
  font-size: 32rpx;
  font-weight: 600;
  color: var(--text-primary);
  flex: 1;
}

.card-subtitle {
  font-size: 24rpx;
  color: var(--text-hint);
  margin-top: 4rpx;
}

.card-content {
  padding: 32rpx;
}

/* 表单样式 */
.form-item {
  margin-bottom: 32rpx;
}

.form-item:last-child {
  margin-bottom: 0;
}

.form-label {
  display: block;
  font-size: 28rpx;
  color: var(--text-secondary);
  margin-bottom: 16rpx;
  font-weight: 500;
}

.dark .form-label {
  color: #aaaaaa;
}

.required::after {
  content: '*';
  color: var(--error-color);
  margin-left: 4rpx;
}

.form-input, .form-picker, .form-textarea {
  width: 100%;
  height: 88rpx;
  padding: 0 28rpx;
  border-radius: var(--radius-md);
  background-color: #f5f7fa;
  color: var(--text-primary);
  font-size: 28rpx;
  box-sizing: border-box;
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
}

.form-input.filled, .form-picker.filled, .form-textarea.filled {
  background-color: var(--primary-light);
  border-color: var(--primary-color);
}

.form-input:focus, .form-textarea:focus {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 2px rgba(74, 108, 247, 0.1);
}

.form-picker {
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.picker-arrow {
  font-size: 20rpx;
  color: var(--text-hint);
  position: absolute;
  right: 28rpx;
  top: 50%;
  transform: translateY(-50%);
  opacity: 0.7;
}

.form-textarea {
  height: 180rpx;
  padding: 20rpx 28rpx;
  line-height: 1.5;
}

.textarea-counter {
  text-align: right;
  font-size: 24rpx;
  color: var(--text-hint);
  margin-top: 8rpx;
}

/* 开关项 */
.switch-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* 性格分析区域 */
.personality-traits {
  margin-bottom: 32rpx;
}

.trait-item {
  display: flex;
  align-items: center;
  margin-bottom: 24rpx;
}

.trait-name {
  width: 160rpx;
  font-size: 28rpx;
  color: var(--text-primary);
  font-weight: 500;
}

.trait-bar-container {
  flex: 1;
  height: 16rpx;
  background-color: #f0f0f0;
  border-radius: 8rpx;
  overflow: hidden;
  margin: 0 16rpx;
}

.trait-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--primary-color), var(--primary-dark));
  border-radius: 8rpx;
}

.trait-score {
  width: 80rpx;
  font-size: 24rpx;
  color: var(--text-secondary);
  text-align: right;
  font-weight: 500;
}

.personality-summary {
  font-size: 28rpx;
  color: var(--text-primary);
  line-height: 1.6;
  padding: 24rpx;
  background-color: var(--primary-light);
  border-radius: var(--radius-md);
  border-left: 4rpx solid var(--primary-color);
}

/* 兴趣标签 */
.interest-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 16rpx;
}

.interest-tag {
  padding: 12rpx 24rpx;
  background-color: var(--primary-light);
  color: var(--primary-color);
  border-radius: 32rpx;
  font-size: 28rpx;
  font-weight: 500;
  box-shadow: var(--shadow-sm);
  border: 1rpx solid rgba(74, 108, 247, 0.2);
}

/* 空数据提示 */
.empty-data {
  padding: 40rpx 24rpx;
  text-align: center;
  color: var(--text-hint);
  font-size: 28rpx;
  background-color: #f9f9f9;
  border-radius: var(--radius-md);
  margin-bottom: 32rpx;
  border: 1rpx dashed var(--border-color);
}

.empty-data-icon {
  font-size: 64rpx;
  margin-bottom: 16rpx;
  color: var(--text-hint);
}

/* 提交按钮 */
.submit-button-container {
  padding: 32rpx 0 calc(32rpx + env(safe-area-inset-bottom));
  margin-top: 32rpx;
}

.submit-button {
  width: 100%;
  height: 96rpx;
  background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
  color: white;
  border-radius: 48rpx;
  font-size: 32rpx;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  border: none;
  box-shadow: 0 8rpx 16rpx rgba(74, 108, 247, 0.2);
  transition: all 0.3s ease;
}

.submit-button:active {
  opacity: 0.9;
  transform: translateY(2rpx);
  box-shadow: 0 4rpx 8rpx rgba(74, 108, 247, 0.2);
}

/* 分割线 */
.divider {
  height: 1rpx;
  background-color: var(--divider-color);
  margin: 24rpx 0;
}

/* 设置项 */
.setting-item {
  display: flex;
  align-items: center;
  padding: 28rpx 32rpx;
  border-bottom: 1rpx solid var(--divider-color);
}

.setting-item:last-child {
  border-bottom: none;
}

.setting-icon {
  width: 40rpx;
  height: 40rpx;
  margin-right: 24rpx;
}

.setting-content {
  flex: 1;
}

.setting-label {
  font-size: 30rpx;
  color: var(--text-primary);
  margin-bottom: 4rpx;
}

.setting-desc {
  font-size: 24rpx;
  color: var(--text-hint);
}

.setting-action {
  display: flex;
  align-items: center;
}

.setting-value {
  font-size: 28rpx;
  color: var(--text-secondary);
  margin-right: 16rpx;
}

.setting-arrow {
  width: 32rpx;
  height: 32rpx;
  opacity: 0.5;
}

/* 暗黑模式适配 */
.dark {
  --primary-color: #6d8cff;
  --primary-light: #2a3352;
  --primary-dark: #4a6cf7;

  --text-primary: #f0f0f0;
  --text-secondary: #cccccc;
  --text-hint: #999999;

  --bg-color: #121212;
  --card-bg: #1e1e1e;

  --border-color: #333333;
  --divider-color: #2c2c2c;

  background-color: var(--bg-color);
  color: var(--text-primary);
}

.dark .card {
  background-color: var(--card-bg);
  border-color: #333333;
}

.dark .nav-bar {
  background-color: var(--card-bg);
  border-bottom: 1rpx solid var(--border-color);
}

.dark .form-input,
.dark .form-picker,
.dark .form-textarea {
  background-color: #2c2c2c;
  border-color: #444444;
  color: var(--text-primary);
}

.dark .form-picker {
  background-color: #222222;
  border-color: #333333;
}

.dark .picker-arrow {
  color: #666666;
}

.dark .trait-bar-container {
  background-color: #333333;
}

.dark .empty-data {
  background-color: #2a2a2a;
  border-color: #444444;
}

.dark .setting-item {
  border-color: var(--divider-color);
}

*#*#*end*#*#*

*#*#*miniprogram\pages\user\user.js*#*#*begin*#*#*
// 获取应用实例
const app = getApp()
import { getLoginInfo, checkLogin } from '../../utils/auth'
import { updateActiveDay } from '../../utils/stats'
// 引入 echarts
const echarts = require('../../components/ec-canvas/echarts')
// 引入用户服务
const userService = require('../../services/userService')

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

Page({
  // 页面的初始数据
  data: {
    loading: true,      // 加载状态
    userInfo: null,     // 用户信息
    showLogin: false,   // 是否显示登录弹窗
    needRefresh: false, // 是否需要刷新
    openId: '',         // 用户openId
    darkMode: false,    // 暗夜模式
    statusBarHeight: 20, // 状态栏高度
    navBarHeight: 44,    // 导航栏高度
    navTotalHeight: 64,  // 导航栏总高度

    // 用户统计数据
    stats: {
      chatCount: 0,     // 对话次数
      activeDay: 0,     // 活跃天数
      reportCount: 0,   // 心情报告数
    },

    // 情绪概览数据
    emotionData: require('../../config/index').user.DEFAULT_EMOTION_DATA,

    // 个性分析数据
    personalityData: require('../../config/index').user.DEFAULT_PERSONALITY_DATA,

    // 情绪饼图配置
    emotionPieEc: {
      lazyLoad: true
    },

    // 个性雷达图配置
    personalityRadarEc: {
      lazyLoad: true
    }
  },

  // 生命周期函数--监听页面加载
  onLoad() {
    // 获取系统信息，检测暗黑模式
    const systemInfo = wx.getSystemInfoSync();

    // 优先使用本地缓存中的 darkMode 设置
    const localDarkMode = wx.getStorageSync('darkMode');
    let darkMode;

    if (localDarkMode !== undefined && localDarkMode !== null) {
      // 确保 darkMode 是布尔值
      darkMode = typeof localDarkMode === 'boolean' ? localDarkMode : localDarkMode === 'true';
      if (isDev) {
        console.log('用户页面从本地缓存读取暗黑模式设置:', darkMode);
      }

      // 将布尔值存回缓存，确保类型一致
      wx.setStorageSync('darkMode', darkMode);
    } else {
      darkMode = systemInfo.theme === 'dark';
      if (isDev) {
        console.log('用户页面使用系统主题设置暗黑模式:', darkMode);
      }

      // 将系统主题设置存入缓存
      wx.setStorageSync('darkMode', darkMode);
    }

    // 获取胶囊按钮位置信息
    const menuButtonInfo = wx.getMenuButtonBoundingClientRect();

    // 计算导航栏高度，增加一点高度使其更美观
    const navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + 10;

    // 计算导航栏总高度（状态栏 + 导航栏）
    const navTotalHeight = systemInfo.statusBarHeight + navBarHeight;

    // 将导航栏高度信息存入全局数据
    app.globalData.navHeight = navBarHeight;
    app.globalData.statusBarHeight = systemInfo.statusBarHeight;
    app.globalData.navTotalHeight = navTotalHeight;

    // 确保使用布尔值
    const finalDarkMode = typeof darkMode === 'boolean' ? darkMode : darkMode === 'true';

    this.setData({
      darkMode: finalDarkMode,
      statusBarHeight: systemInfo.statusBarHeight,
      navBarHeight: navBarHeight,
      navTotalHeight: navTotalHeight
    });

    this.checkLoginStatus()
  },

  // 生命周期函数--监听页面初次渲染完成
  onReady() {
    // 初始化图表
    setTimeout(() => {
      this.initEmotionPieChart()
      this.initPersonalityRadarChart()
    }, 300) // 稍微延迟初始化，确保组件已经渲染完成
  },

  // 生命周期函数--监听页面显示
  onShow() {
    if (isDev) {
      console.log('页面显示, needRefresh:', this.data.needRefresh);
    }

    // 检查暗夜模式变化
    const localDarkMode = wx.getStorageSync('darkMode');
    let shouldUpdateDarkMode = false;
    let newDarkMode = this.data.darkMode;

    if (localDarkMode !== undefined && localDarkMode !== null) {
      // 确保 localDarkMode 是布尔值
      const darkModeValue = typeof localDarkMode === 'boolean' ? localDarkMode : localDarkMode === 'true';

      // 如果有本地缓存设置，使用本地缓存设置
      shouldUpdateDarkMode = this.data.darkMode !== darkModeValue;
      if (shouldUpdateDarkMode) {
        if (isDev) {
          console.log('从本地缓存更新暗黑模式为:', darkModeValue);
        }
        newDarkMode = darkModeValue;

        // 将布尔值存回缓存，确保类型一致
        wx.setStorageSync('darkMode', darkModeValue);
      }
    } else if (this.data.darkMode !== app.globalData.darkMode) {
      // 如果没有本地缓存设置，使用全局状态
      shouldUpdateDarkMode = true;
      newDarkMode = app.globalData.darkMode;
      if (isDev) {
        console.log('从全局状态更新暗黑模式为:', newDarkMode);
      }
    }

    if (shouldUpdateDarkMode) {
      this.setData({
        darkMode: newDarkMode
      });

      // 更新TabBar样式
      if (app.updateTheme) {
        app.updateTheme(newDarkMode);
      }
    }

    // 检查是否需要刷新
    if (this.data.needRefresh) {
      if (isDev) {
        console.log('检测到需要刷新用户信息');
      }
      // 强制从服务器获取最新数据
      this.refreshUserInfo(true);
      this.setData({ needRefresh: false });
    } else {
      // 从内存刷新用户信息，确保显示最新数据
      this.refreshUserInfo(false);
    }

    // 更新用户活跃天数
    if (checkLogin()) {
      updateActiveDay().then(result => {
        if (result.success && result.data && result.data.stats) {
          // 更新统计数据
          const { userInfo } = this.data
          if (userInfo) {
            userInfo.stats = result.data.stats
            this.setData({
              userInfo,
              stats: {
                chatCount: result.data.stats.chat_count || 0,
                activeDay: result.data.stats.active_days || 0,
                reportCount: result.data.stats.daily_report_count || 0
              }
            })
          }
        }
      })

      // 获取用户总消息数
      this.getTotalMessageCount()

      // 获取用户心情报告数量
      this.getReportCount()

      // 获取用户情绪数据
      this.loadEmotionData()

      // 获取用户个性分析数据
      this.loadPersonalityData()

      // 获取用户兴趣标签
      this.loadInterestTags()
    }
  },

  /**
   * 获取用户总消息数
   */
  async getTotalMessageCount() {
    try {
      if (isDev) {
        console.log('开始获取用户总消息数...');
      }

      // 获取用户ID
      const userInfo = this.data.userInfo;
      if (!userInfo) {
        console.error('未获取到用户信息，无法获取总消息数');
        return;
      }

      // 使用userService获取用户ID和openId
      const { userId, openid: openId } = userService.getUserIdentifiers(userInfo);

      // 获取用户ID信息已足够，不需要额外的statsId

      // 直接从本地获取聊天记录数量
      await this.getLocalChatCount();

      // 调用云函数获取总消息数并更新数据库
      const result = await wx.cloud.callFunction({
        name: 'user',
        data: {
          action: 'getTotalMessageCount',
          userId: openId || userId // 优先使用openId
        }
      });

      if (result.result && result.result.success) {
        const totalMessageCount = result.result.totalMessageCount || 0;

        // 如果云函数返回的总消息数大于0，更新页面数据
        if (totalMessageCount > 0) {
          // 更新页面数据
          this.setData({
            'stats.chatCount': totalMessageCount
          });

          // 更新用户信息中的统计数据
          if (userInfo.stats) {
            userInfo.stats.chat_count = totalMessageCount;
            this.setData({ userInfo });
          }
        }
      }
    } catch (error) {
      console.error('获取用户总消息数失败:', error);
    }
  },

  /**
   * 获取用户心情报告数量
   */
  async getReportCount() {
    try {
      if (isDev) {
        console.log('开始获取用户心情报告数量...');
      }

      // 获取用户ID
      const userInfo = this.data.userInfo;
      if (!userInfo) {
        console.error('未获取到用户信息，无法获取心情报告数量');
        return;
      }

      // 使用userService获取用户ID和openId
      const { userId, openid: openId } = userService.getUserIdentifiers(userInfo);

      // 调用云函数获取心情报告数量
      const result = await wx.cloud.callFunction({
        name: 'user',
        data: {
          action: 'getReportCount',
          userId: openId || userId // 优先使用openId
        }
      });

      if (result.result && result.result.success) {
        const reportCount = result.result.reportCount || 0;

        // 更新页面数据
        this.setData({
          'stats.reportCount': reportCount
        });

        // 更新用户信息中的统计数据
        if (userInfo.stats) {
          userInfo.stats.daily_report_count = reportCount;
          this.setData({ userInfo });
        }
      }
    } catch (error) {
      console.error('获取用户心情报告数量失败:', error);
    }
  },

  /**
   * 从本地获取聊天记录数量
   */
  async getLocalChatCount() {
    try {
      if (isDev) {
        console.log('开始从本地获取聊天记录数量...');
      }

      // 获取用户ID
      const userInfo = this.data.userInfo;
      if (!userInfo) {
        console.error('未获取到用户信息，无法获取本地聊天记录');
        return;
      }

      // 使用userService获取openId
      const { openid: openId } = userService.getUserIdentifiers(userInfo);

      if (!openId) {
        console.error('未获取到用户openId，无法获取本地聊天记录');
        return;
      }

      // 直接从数据库获取聊天记录
      const db = wx.cloud.database();
      const _ = db.command;

      // 构建查询条件，考虑多种可能的字段名
      const query = _.or([
        { openId: openId },
        { openid: openId },
        { userId: openId },
        { userid: openId },
        { user_id: openId }
      ]);

      // 查询该用户的所有聊天记录
      const chatsResult = await db.collection('chats')
        .where(query)
        .get();

      if (chatsResult.data && chatsResult.data.length > 0) {
        // 计算总消息数
        let totalMessageCount = 0;
        chatsResult.data.forEach(chat => {
          if (chat.messageCount && typeof chat.messageCount === 'number') {
            totalMessageCount += chat.messageCount;
          } else if (chat.messages && Array.isArray(chat.messages)) {
            // 如果没有messageCount字段，但有messages数组，使用数组长度
            totalMessageCount += chat.messages.length;
          }
        });

        // 更新页面数据
        this.setData({
          'stats.chatCount': totalMessageCount
        });

        // 更新用户信息中的统计数据
        if (userInfo.stats) {
          userInfo.stats.chat_count = totalMessageCount;
          this.setData({ userInfo });

          // 尝试直接更新数据库中的user_stats表
          try {
            if (userInfo.stats._id) {
              await db.collection('user_stats').doc(userInfo.stats._id).update({
                data: {
                  chat_count: totalMessageCount,
                  updated_at: db.serverDate()
                }
              });
            }
          } catch (updateErr) {
            console.error('直接更新user_stats表失败:', updateErr);
          }
        }

        // 如果找到了聊天记录，但总消息数为0，可能是messageCount字段不存在
        if (totalMessageCount === 0) {
          // 使用聊天记录的数量作为总消息数
          const chatCount = chatsResult.data.length;

          // 更新页面数据
          this.setData({
            'stats.chatCount': chatCount
          });

          // 更新用户信息中的统计数据
          if (userInfo.stats) {
            userInfo.stats.chat_count = chatCount;
            this.setData({ userInfo });
          }
        }
      } else {
        // 如果没有找到聊天记录，但用户信息中有chat_count，使用它
        if (userInfo.stats && userInfo.stats.chat_count) {
          const chatCount = userInfo.stats.chat_count;

          // 更新页面数据
          this.setData({
            'stats.chatCount': chatCount
          });
        } else {
          // 如果什么都没有，设置为0
          this.setData({
            'stats.chatCount': 0
          });
        }
      }
    } catch (error) {
      console.error('获取本地聊天记录失败:', error);
    }
  },

  // 加载情绪数据
  async loadEmotionData() {
    try {
      if (isDev) {
        console.log('开始加载情绪概览数据...');
      }

      // 获取用户ID
      const userInfo = wx.getStorageSync('userInfo');
      const { userId, openid: openId } = userService.getUserIdentifiers(userInfo, true);

      if (!openId && !userId) {
        console.error('未获取到用户ID，无法获取情绪数据');
        return null;
      }

      // 使用openId作为userId
      const userIdentifier = openId || userId;

      // 使用emotionService获取一周内的情绪记录
      const emotionService = require('../../services/emotionService');
      const records = await emotionService.getEmotionHistory(userIdentifier, null, 20);

      if (!records || records.length === 0) {
        console.warn('未找到情绪记录，无法生成情绪概览数据');
        return null;
      }

      // 统计不同情绪类型的数量
      const emotionCounts = {};

      records.forEach(record => {
        // 获取情绪类型
        let emotionType = record.analysis?.primary_emotion || record.analysis?.type || 'neutral';
        let emotionLabel = '';

        // 尝试获取中文情绪类型
        if (record.analysis?.primary_emotion_cn) {
          emotionLabel = record.analysis.primary_emotion_cn;
        } else if (record.analysis?.type && typeof record.analysis.type === 'string' && /[\u4e00-\u9fa5]/.test(record.analysis.type)) {
          emotionLabel = record.analysis.type;
        } else {
          emotionLabel = emotionService.EmotionTypeLabels[emotionType] || '未知情绪';
        }

        // 统计数量
        emotionCounts[emotionLabel] = (emotionCounts[emotionLabel] || 0) + 1;
      });

      // 将统计结果转换为饼图数据格式
      const labels = [];
      const values = [];
      const colors = [];
      const emotionColors = emotionService.EmotionTypeColors;

      for (const [emotion, count] of Object.entries(emotionCounts)) {
        labels.push(emotion);
        values.push(count);
        colors.push(emotionColors[emotion] || '#95A5A6'); // 默认使用灰色
      }

      const emotionData = {
        labels,
        values,
        colors
      };

      // 更新数据
      this.setData({ emotionData });

      // 在非下拉刷新时更新情绪饼图
      if (!this._isRefreshing && this.emotionPieChart) {
        try {
          const option = this.getEmotionPieOption(emotionData);
          this.emotionPieChart.setOption(option);
        } catch (chartError) {
          console.error('更新情绪饼图失败:', chartError);
          // 如果更新失败，尝试重新初始化
          this.emotionPieChart = null;
          setTimeout(() => this.initEmotionPieChart(), 300);
        }
      }

      return emotionData;
    } catch (error) {
      console.error('获取情绪数据失败:', error);
      throw error;
    }
  },

  // 加载个性分析数据
  async loadPersonalityData() {
    try {
      if (isDev) {
        console.log('开始加载个性分析数据...');
      }

      // 默认个性数据，当云函数调用失败时使用
      const defaultPersonalityData = {
        labels: ['创造力', '责任感', '同理心', '社交性', '耐心'],
        values: [65, 80, 70, 50, 60],
        summary: '你是一个具有较强责任感和同理心的人，在创造力和耐心方面也有不错的表现。你善于理解他人的情感，并且能够认真完成自己的任务。'
      };

      // 获取用户ID
      const userInfo = wx.getStorageSync('userInfo');
      const { userId, openid: openId } = userService.getUserIdentifiers(userInfo, true);

      if (!openId && !userId) {
        console.error('未获取到用户ID，无法获取个性分析数据');
        // 使用默认数据
        this.setData({ personalityData: defaultPersonalityData });
        return defaultPersonalityData;
      }

      // 使用openId作为userId
      const userIdentifier = openId || userId;

      // 调用云函数获取个性分析数据
      try {
        const result = await wx.cloud.callFunction({
          name: 'user',
          data: {
            action: 'getUserPerception',
            userId: userIdentifier
          }
        });

        if (result.result && result.result.success && result.result.data) {
          const perceptionData = result.result.data;

          // 处理数据用于雷达图显示
          if (perceptionData.personalityTraits && perceptionData.personalityTraits.length > 0) {
            const personalityData = {
              labels: perceptionData.personalityTraits.map(item => item.trait),
              values: perceptionData.personalityTraits.map(item => Math.round(item.score * 100)),
              summary: perceptionData.personalitySummary || ''
            };

            // 更新数据
            this.setData({ personalityData });

            // 在非下拉刷新时更新个性雷达图
            if (!this._isRefreshing && this.personalityRadarChart) {
              try {
                const option = this.getPersonalityRadarOption(personalityData);
                this.personalityRadarChart.setOption(option);
              } catch (chartError) {
                console.error('更新个性雷达图失败:', chartError);
                // 如果更新失败，尝试重新初始化
                this.personalityRadarChart = null;
                setTimeout(() => this.initPersonalityRadarChart(), 300);
              }
            }

            return personalityData;
          } else {
            if (isDev) {
              console.warn('个性特征数据为空，使用默认数据');
            }
            this.setData({ personalityData: defaultPersonalityData });
            return defaultPersonalityData;
          }
        } else {
          if (isDev) {
            console.warn('云函数返回的个性分析数据无效');
          }
          this.setData({ personalityData: defaultPersonalityData });
          return defaultPersonalityData;
        }
      } catch (cloudError) {
        console.error('调用云函数失败:', cloudError);
        this.setData({ personalityData: defaultPersonalityData });
        return defaultPersonalityData;
      }
    } catch (error) {
      console.error('获取个性分析数据失败:', error);
      // 使用默认数据
      const defaultPersonalityData = {
        labels: ['创造力', '责任感', '同理心', '社交性', '耐心'],
        values: [65, 80, 70, 50, 60],
        summary: '你是一个具有较强责任感和同理心的人，在创造力和耐心方面也有不错的表现。你善于理解他人的情感，并且能够认真完成自己的任务。'
      };
      this.setData({ personalityData: defaultPersonalityData });
      return defaultPersonalityData;
    }
  },

  // 刷新用户信息
  async refreshUserInfo(forceRefresh = false) {
    try {
      if (isDev) {
        console.log('开始刷新用户信息, 强制刷新:', forceRefresh);
      }

      // 首先从全局状态获取用户信息
      const globalUserInfo = app.globalData.userInfo;

      // 从本地存储获取用户信息
      const { userInfo: localUserInfo } = getLoginInfo();

      // 如果是强制刷新，则从服务器获取最新数据
      if (forceRefresh) {
        this.setData({ loading: true });

        // 获取当前登录信息
        const loginInfo = getLoginInfo();
        if (!loginInfo || !loginInfo.userInfo || !loginInfo.userInfo.userId) {
          throw new Error('用户未登录或登录信息不完整');
        }

        try {
          // 使用云函数获取最新用户信息
          const result = await wx.cloud.callFunction({
            name: 'user',
            data: {
              action: 'getInfo',
              userId: loginInfo.userInfo.userId
            }
          });

          if (result.result && result.result.success) {
            // 更新用户信息
            const updatedUserInfo = {
              ...loginInfo.userInfo,
              ...result.result.data.user
            };

            // 更新全局状态
            app.globalData.userInfo = updatedUserInfo;

            // 更新本地存储
            wx.setStorageSync('loginInfo', {
              ...loginInfo,
              userInfo: updatedUserInfo
            });

            // 更新页面数据
            this.setData({
              userInfo: updatedUserInfo,
              loading: false,
              stats: {
                chatCount: updatedUserInfo.stats?.chat_count || 0,
                activeDay: updatedUserInfo.stats?.active_days || 0,
                reportCount: updatedUserInfo.stats?.daily_report_count || 0
              }
            });

            // 获取用户总消息数
            setTimeout(() => {
              this.getTotalMessageCount();
            }, 500);

            return;
          }
        } catch (cloudError) {
          console.error('云函数获取用户信息失败:', cloudError);
          // 如果云函数失败，则回退到使用数据库直接查询
        }

        // 如果云函数失败，则使用数据库直接查询
        const db = wx.cloud.database();
        const userBaseResult = await db.collection('user_base')
          .where({ user_id: loginInfo.userInfo.userId })
          .get();

        if (userBaseResult.data && userBaseResult.data.length > 0) {
          // 获取用户统计信息
          const userStatsResult = await db.collection('user_stats')
            .where({ user_id: loginInfo.userInfo.userId })
            .get();

          // 更新用户信息
          const updatedUserInfo = {
            ...loginInfo.userInfo,
            username: userBaseResult.data[0].username,
            avatarUrl: userBaseResult.data[0].avatar_url,
            stats: userStatsResult.data[0] || loginInfo.userInfo.stats
          };

          // 更新全局状态
          app.globalData.userInfo = updatedUserInfo;

          // 更新本地存储
          wx.setStorageSync('loginInfo', {
            ...loginInfo,
            userInfo: updatedUserInfo
          });

          // 更新页面数据
          this.setData({
            userInfo: updatedUserInfo,
            loading: false,
            stats: {
              chatCount: updatedUserInfo.stats?.chat_count || 0,
              activeDay: updatedUserInfo.stats?.active_days || 0,
              reportCount: updatedUserInfo.stats?.daily_report_count || 0
            }
          });

          // 获取用户总消息数和心情报告数量
          setTimeout(() => {
            this.getTotalMessageCount();
            this.getReportCount();
          }, 500);

          return;
        }
      }

      // 如果不是强制刷新或强制刷新失败，则使用全局状态或本地存储
      // 优先使用全局状态，因为它可能是最新的
      const userInfo = globalUserInfo || localUserInfo;

      if (userInfo) {
        this.setData({
          userInfo,
          loading: false,
          stats: {
            chatCount: userInfo.stats?.chat_count || 0,
            activeDay: userInfo.stats?.active_days || 0,
            reportCount: userInfo.stats?.daily_report_count || 0
          }
        });

        // 获取用户总消息数和心情报告数量
        setTimeout(() => {
          this.getTotalMessageCount();
          this.getReportCount();
        }, 500);
      } else {
        throw new Error('无法获取用户信息');
      }
    } catch (error) {
      console.error('刷新用户信息失败:', error);
      this.setData({ loading: false });

      // 显示错误提示
      wx.showToast({
        title: '刷新失败',
        icon: 'error'
      });
    }
  },

  // 检查登录状态
  async checkLoginStatus() {
    try {
      const { userInfo } = getLoginInfo()

      if (checkLogin()) {
        // 获取用户openId
        const openId = wx.getStorageSync('openId') || (userInfo && userInfo.stats && userInfo.stats.openid);

        this.setData({
          userInfo,
          openId,
          loading: false,
          stats: {
            chatCount: userInfo.stats?.chat_count || 0,
            activeDay: userInfo.stats?.active_days || 0,
            reportCount: userInfo.stats?.daily_report_count || 0
          }
        })

        // 获取用户总消息数和心情报告数量
        setTimeout(() => {
          this.getTotalMessageCount();
          this.getReportCount();
        }, 500);
      } else {
        this.setData({
          loading: false,
          showLogin: true
        })
      }
    } catch (error) {
      console.error('检查登录状态失败:', error)
      this.setData({ loading: false })
      wx.showToast({
        title: '系统错误',
        icon: 'error'
      })
    }
  },

  // 处理登录弹窗关闭
  handleLoginClose() {
    // 如果已经登录成功，则隐藏登录弹窗
    if (app.globalData.isLoggedIn && app.globalData.userInfo) {
      this.setData({
        showLogin: false,
        userInfo: app.globalData.userInfo
      });
    } else {
      // 如果未登录，也隐藏登录弹窗
      this.setData({
        showLogin: false
      });
    }
  },

  // 处理退出登录
  handleLogout() {
    wx.showModal({
      title: '提示',
      content: '确定要退出登录吗？',
      success: (res) => {
        if (res.confirm) {
          // 使用全局的logout方法
          if (app.logout()) {
            this.setData({
              userInfo: null
            })
            wx.showToast({
              title: '已退出登录',
              icon: 'success'
            })
          } else {
            wx.showToast({
              title: '退出失败',
              icon: 'error'
            })
          }
        }
      }
    })
  },

  // 页面相关事件处理函数--监听用户下拉动作
  async onPullDownRefresh() {
    console.log('用户下拉刷新')

    // 设置刷新标志，避免重复初始化图表
    this._isRefreshing = true

    // 显示刷新提示
    wx.showLoading({
      title: '正在刷新...',
      mask: true
    })

    try {
      // 强制刷新用户信息
      await this.refreshUserInfo(true)

      // 重置图表实例
      this.emotionPieChart = null
      this.personalityRadarChart = null

      // 刷新情绪概览、个性分析、兴趣标签数据、总消息数和心情报告数量
      // 使用Promise.allSettled而不是Promise.all，确保即使一个请求失败也不会影响其他请求
      const results = await Promise.allSettled([
        this.loadEmotionData(),
        this.loadPersonalityData(),
        this.loadInterestTags(true),
        this.getTotalMessageCount(),
        this.getReportCount()
      ])

      // 检查结果
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          const dataTypes = ['情绪数据', '个性数据', '兴趣标签', '总消息数', '心情报告数量'];
          console.error(`数据加载失败 (${dataTypes[index]})`, result.reason)
        }
      })

      console.log('所有数据刷新完成')

      // 延迟重新初始化图表，确保数据已经准备好
      setTimeout(() => {
        try {
          // 重新初始化图表
          this.initEmotionPieChart()
          this.initPersonalityRadarChart()

          console.log('图表重新初始化完成')
        } catch (chartError) {
          console.error('图表初始化失败:', chartError)
        } finally {
          // 重置刷新标志
          this._isRefreshing = false
        }
      }, 800) // 增加延迟时间，确保数据已经完全准备好

      // 显示成功提示
      wx.showToast({
        title: '刷新成功',
        icon: 'success',
        duration: 1500
      })
    } catch (error) {
      console.error('刷新数据失败:', error)
      wx.showToast({
        title: '刷新失败',
        icon: 'error',
        duration: 1500
      })
    } finally {
      // 隐藏加载提示
      wx.hideLoading()

      // 停止下拉刷新动画
      wx.stopPullDownRefresh()
    }
  },

  // 处理登录成功
  handleLoginSuccess(e) {
    // 直接使用全局用户信息更新页面
    const userInfo = app.globalData.userInfo;

    if (userInfo) {
      // 获取用户openId
      const openId = wx.getStorageSync('openId') || (userInfo && userInfo.stats && userInfo.stats.openid);

      this.setData({
        userInfo,
        openId,
        loading: false,
        showLogin: false,
        stats: {
          chatCount: userInfo.stats?.chat_count || 0,
          activeDay: userInfo.stats?.active_days || 0,
          reportCount: userInfo.stats?.daily_report_count || 0
        }
      });

      // 获取用户总消息数和心情报告数量
      setTimeout(() => {
        this.getTotalMessageCount();
        this.getReportCount();
        // 加载用户兴趣标签
        this.loadInterestTags();
      }, 500);
    } else {
      // 如果全局用户信息不可用，则使用事件中的用户信息
      const { userInfo } = e.detail;
      if (userInfo) {
        // 获取用户openId
        const openId = wx.getStorageSync('openId') || (userInfo && userInfo.stats && userInfo.stats.openid);

        this.setData({
          userInfo,
          openId,
          loading: false,
          showLogin: false,
          stats: {
            chatCount: userInfo.stats?.chat_count || 0,
            activeDay: userInfo.stats?.active_days || 0,
            reportCount: userInfo.stats?.daily_report_count || 0
          }
        });

        // 获取用户总消息数和心情报告数量
        setTimeout(() => {
          this.getTotalMessageCount();
          this.getReportCount();
          // 加载用户兴趣标签
          this.loadInterestTags();
        }, 500);
      }
    }
  },

  // 导航到个人信息页面
  navigateToProfile() {
    wx.navigateTo({
      url: '/pages/user/profile/profile'
    })
  },

  // 导航到情绪历史页面
  navigateToEmotionHistory() {
    wx.navigateTo({
      url: '/packageEmotion/pages/emotion-history/emotion-history'
    })
  },

  // 导航到角色管理页面
  navigateToRoleManagement() {
    wx.navigateTo({
      url: '/pages/role-select/role-select'
    })
  },

  // 导航到设置页面
  navigateToSettings() {
    // 由于设置页面还没有实现，暂时导航到个人资料页面
    wx.navigateTo({
      url: '/pages/user/profile/profile'
    })
  },

  // 初始化情绪饼图
  initEmotionPieChart() {
    try {
      this.ecComponent = this.selectComponent('#emotionPieChart')
      if (!this.ecComponent) {
        console.error('无法获取情绪饼图组件实例')
        // 延迟重试
        setTimeout(() => this.initEmotionPieChart(), 300)
        return
      }

      this.ecComponent.init((canvas, width, height, dpr) => {
        try {
          // 初始化 echarts 实例
          const chart = echarts.init(canvas, null, {
            width: width,
            height: height,
            devicePixelRatio: dpr
          })

          // 获取饼图配置
          const option = this.getEmotionPieOption(this.data.emotionData)

          // 使用配置项设置图表
          chart.setOption(option)

          // 保存图表实例
          this.emotionPieChart = chart

          // 添加图表点击事件
          chart.on('click', (params) => {
            console.log('情绪饼图点击事件:', params)
          })

          // 返回图表实例
          return chart
        } catch (error) {
          console.error('初始化情绪饼图失败:', error)
          return null
        }
      })
    } catch (error) {
      console.error('初始化情绪饼图组件失败:', error)
    }
  },

  // 初始化个性雷达图
  initPersonalityRadarChart() {
    try {
      this.radarComponent = this.selectComponent('#personalityRadarChart')
      if (!this.radarComponent) {
        console.error('无法获取个性雷达图组件实例')
        // 延迟重试
        setTimeout(() => this.initPersonalityRadarChart(), 300)
        return
      }

      this.radarComponent.init((canvas, width, height, dpr) => {
        try {
          // 初始化 echarts 实例
          const chart = echarts.init(canvas, null, {
            width: width,
            height: height,
            devicePixelRatio: dpr
          })

          // 获取雷达图配置
          const option = this.getPersonalityRadarOption(this.data.personalityData)

          // 使用配置项设置图表
          chart.setOption(option)

          // 保存图表实例
          this.personalityRadarChart = chart

          // 添加图表点击事件
          chart.on('click', (params) => {
            console.log('个性雷达图点击事件:', params)
          })

          // 返回图表实例
          return chart
        } catch (error) {
          console.error('初始化个性雷达图失败:', error)
          return null
        }
      })
    } catch (error) {
      console.error('初始化个性雷达图组件失败:', error)
    }
  },

  // 获取情绪饼图配置
  getEmotionPieOption(emotionData) {
    // 防止空数据或异常数据
    if (!emotionData || !emotionData.labels || !emotionData.values || !emotionData.colors) {
      console.warn('情绪数据不完整，使用默认数据')
      emotionData = {
        labels: ['未知情绪'],
        values: [1],
        colors: ['#95A5A6']
      }
    }

    // 根据暗夜模式调整文字颜色
    const textColor = this.data.darkMode ? '#e2e8f0' : '#333333';

    // 准备饼图数据
    const pieData = emotionData.labels.map((label, index) => ({
      name: label,
      value: emotionData.values[index] || 0, // 防止值为空
      itemStyle: {
        color: emotionData.colors[index] || '#95A5A6' // 默认使用灰色
      }
    }))

    return {
      tooltip: {
        trigger: 'item',
        formatter: '{b}: {c} ({d}%)',
        textStyle: {
          color: textColor
        }
      },
      series: [{
        name: '情绪分布',
        type: 'pie',
        radius: ['40%', '70%'],
        center: ['50%', '50%'],
        avoidLabelOverlap: false,
        itemStyle: {
          borderRadius: 6,
          borderColor: this.data.darkMode ? '#2d3748' : '#fff',
          borderWidth: 2
        },
        label: {
          show: false,
          position: 'center',
          color: textColor
        },
        emphasis: {
          label: {
            show: true,
            fontSize: '14',
            fontWeight: 'bold',
            color: textColor
          }
        },
        labelLine: {
          show: false
        },
        data: pieData
      }]
    }
  },

  // 获取个性雷达图配置
  getPersonalityRadarOption(personalityData) {
    // 防止空数据或异常数据
    if (!personalityData || !personalityData.labels || !personalityData.values) {
      console.warn('个性数据不完整，使用默认数据')
      personalityData = {
        labels: ['创造力', '责任感', '同理心', '社交性', '耐心'],
        values: [50, 50, 50, 50, 50],
        summary: '暂无个性分析数据'
      }
    }

    // 根据暗夜模式调整颜色
    const textColor = this.data.darkMode ? '#e2e8f0' : '#333333';
    const axisLineColor = this.data.darkMode ? '#4a5568' : '#ddd';
    const splitLineColors = this.data.darkMode ?
      ['#4a5568', '#3d4654', '#343a40', '#2d3748'] :
      ['#ddd', '#ccc', '#bbb', '#aaa'];

    // 准备雷达图指示器
    const indicators = personalityData.labels.map(label => ({
      name: label,
      max: 100
    }))

    return {
      tooltip: {
        trigger: 'item',
        textStyle: {
          color: textColor
        }
      },
      radar: {
        indicator: indicators,
        radius: '65%',
        splitNumber: 4,
        axisName: {
          color: this.data.darkMode ? '#a0aec0' : '#999',
          fontSize: 10
        },
        splitLine: {
          lineStyle: {
            color: splitLineColors
          }
        },
        splitArea: {
          show: false
        },
        axisLine: {
          lineStyle: {
            color: axisLineColor
          }
        }
      },
      series: [{
        name: '个性特质',
        type: 'radar',
        data: [{
          value: personalityData.values,
          name: '个性特质',
          areaStyle: {
            color: this.data.darkMode ? 'rgba(77, 171, 247, 0.2)' : 'rgba(94, 114, 228, 0.3)'
          },
          lineStyle: {
            color: this.data.darkMode ? '#4dabf7' : '#5e72e4'
          },
          itemStyle: {
            color: this.data.darkMode ? '#4dabf7' : '#5e72e4'
          }
        }]
      }]
    }
  },

  /**
   * 加载用户兴趣标签
   * @param {boolean} forceRefresh 是否强制刷新
   */
  async loadInterestTags(forceRefresh = false) {
    try {
      if (isDev) {
        console.log('开始加载用户兴趣标签...');
      }

      // 获取用户ID
      const openId = wx.getStorageSync('openId') || (this.data.userInfo && this.data.userInfo.stats && this.data.userInfo.stats.openid);

      if (!openId) {
        console.error('未获取到用户ID，无法加载兴趣标签');
        return;
      }

      // 更新openId到页面数据
      this.setData({ openId });

      // 获取兴趣标签云组件
      const tagCloud = this.selectComponent('#interestTagCloud');
      if (!tagCloud) {
        console.error('无法获取兴趣标签云组件实例');
        return;
      }

      // 加载标签
      tagCloud.loadTags(forceRefresh);

      return true;
    } catch (error) {
      console.error('加载用户兴趣标签失败:', error);
      return false;
    }
  },

  /**
   * 刷新兴趣标签
   */
  refreshInterestTags() {
    this.loadInterestTags(true);

    wx.showToast({
      title: '正在刷新标签',
      icon: 'loading',
      duration: 1000
    });
  },

  /**
   * 处理标签点击事件
   * @param {Object} e 事件对象
   */
  handleTagClick(e) {
    const { tag } = e.detail;
    if (isDev) {
      console.log('点击了标签:', tag);
    }

    // 显示标签详情
    wx.showModal({
      title: '兴趣标签',
      content: `标签: ${tag.name}\n分类: ${tag.category || '未分类'}\n权重: ${tag.value}%`,
      showCancel: false
    });
  },

  /**
   * 处理标签加载完成事件
   * @param {Object} e 事件对象
   */
  handleTagsLoaded(e) {
    const { tags } = e.detail;
    if (isDev) {
      console.log('兴趣标签加载完成, 数量:', tags.length);
    }
  },

  /**
   * 处理标签加载错误事件
   * @param {Object} e 事件对象
   */
  handleTagsError(e) {
    const { error } = e.detail;
    console.error('兴趣标签加载错误:', error);

    wx.showToast({
      title: '标签加载失败',
      icon: 'error',
      duration: 1500
    });
  }
})


*#*#*end*#*#*

*#*#*miniprogram\pages\user\user.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "个人中心",
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark",
  "navigationStyle": "custom",
  "usingComponents": {
    "login": "../../components/login/index",
    "ec-canvas": "../../components/ec-canvas/ec-canvas",
    "interest-tag-cloud": "../../components/interest-tag-cloud/interest-tag-cloud"
  }
}

*#*#*end*#*#*

*#*#*miniprogram\pages\user\user.wxml*#*#*begin*#*#*
<view class="user-page {{darkMode ? 'dark' : ''}}">
  <!-- 导航栏容器 -->
  <view class="nav-container">
    <!-- 状态栏占位 -->
    <view class="status-bar" style="height: {{statusBarHeight}}px"></view>

    <!-- 自定义导航栏 -->
    <view class="nav-bar" style="height: {{navBarHeight}}px;">
      <view class="nav-bar-left"></view>
      <view class="nav-bar-title">个人中心</view>
      <view class="nav-bar-right"></view>
    </view>
  </view>
  <!-- 内容区域 -->
  <view class="content-area" style="margin-top: {{navTotalHeight + 10}}px;">

  <!-- 加载状态 -->
  <view wx:if="{{loading}}" class="loading-container">
    <view class="loading-spinner"></view>
    <text>加载中...</text>
  </view>

  <!-- 用户信息 -->
  <view wx:elif="{{userInfo}}" class="user-content">
    <!-- 个人资料头部 -->
    <view class="profile-header" bindtap="navigateToProfile">
      <image class="profile-avatar" src="{{userInfo.avatarUrl || '/images/system/default-avatar.png'}}" mode="aspectFill"></image>
      <view class="profile-name">{{userInfo.username || '微信用户'}}</view>
      <view class="profile-bio">探索自我，提升情商</view>
    </view>

    <!-- 统计数据 -->
    <view class="profile-stats">
      <view class="stat-item">
        <view class="stat-value">{{stats.chatCount}}</view>
        <view class="stat-label">对话次数</view>
      </view>
      <view class="stat-item">
        <view class="stat-value">{{stats.activeDay}}</view>
        <view class="stat-label">活跃天数</view>
      </view>
      <view class="stat-item">
        <view class="stat-value">{{stats.reportCount}}</view>
        <view class="stat-label">心情报告</view>
      </view>
    </view>

    <!-- 情绪概览 -->
    <view class="emotion-card">
      <view class="emotion-title">
        <text>情绪概览</text>
        <text class="emotion-more" bindtap="navigateToEmotionHistory">查看详情</text>
      </view>
      <view class="emotion-chart">
        <view class="chart-container">
          <ec-canvas id="emotionPieChart" canvas-id="emotionPieChart" ec="{{ emotionPieEc }}"></ec-canvas>
        </view>
      </view>

      <view class="emotion-summary">
        <text>过去一周，你的主要情绪是<text class="emotion-highlight">{{emotionData.mainEmotion}}</text>和<text class="emotion-highlight-secondary">{{emotionData.secondEmotion}}</text>，这可能与你的工作状态有关。</text>
      </view>
    </view>

    <!-- 个性分析 -->
    <view class="emotion-card">
      <view class="emotion-title">个性分析</view>
      <view class="emotion-chart">
        <view class="chart-container">
          <ec-canvas id="personalityRadarChart" canvas-id="personalityRadarChart" ec="{{ personalityRadarEc }}"></ec-canvas>
        </view>
      </view>

      <view class="emotion-summary">
        <text>{{personalityData.summary}}</text>
      </view>
    </view>

    <!-- 兴趣标签 -->
    <view class="emotion-card">
      <view class="emotion-title">
        <text>兴趣标签</text>
        <text class="emotion-more" bindtap="refreshInterestTags">刷新</text>
      </view>
      <view class="interest-tag-container">
        <interest-tag-cloud
          id="interestTagCloud"
          userId="{{openId}}"
          maxTags="30"
          minFontSize="12"
          maxFontSize="20"
          showCategory="{{true}}"
          darkMode="{{darkMode}}"
          showTitle="{{false}}"
          showRefreshButton="{{false}}"
          bind:tagclick="handleTagClick"
          bind:loaded="handleTagsLoaded"
          bind:error="handleTagsError"
        ></interest-tag-cloud>
      </view>
    </view>

    <!-- 功能列表 -->
    <view class="feature-list">
      <view class="feature-item" bindtap="navigateToRoleManagement">
        <view class="feature-icon role-icon">👤</view>
        <view class="feature-info">
          <text class="feature-title">角色管理</text>
          <text class="feature-desc">管理您的AI角色</text>
        </view>
        <view class="feature-arrow"></view>
      </view>

      <view class="feature-item" bindtap="navigateToEmotionHistory">
        <view class="feature-icon emotion-icon">📊</view>
        <view class="feature-info">
          <text class="feature-title">情绪历史</text>
          <text class="feature-desc">查看情绪变化趋势</text>
        </view>
        <view class="feature-arrow"></view>
      </view>

      <view class="feature-item" bindtap="navigateToSettings">
        <view class="feature-icon settings-icon">⚙️</view>
        <view class="feature-info">
          <text class="feature-title">系统设置</text>
          <text class="feature-desc">偏好和通知设置</text>
        </view>
        <view class="feature-arrow"></view>
      </view>

      <!-- 退出登录按钮 -->
      <view class="feature-item logout-item" bindtap="handleLogout">
        <view class="feature-icon logout-icon">🚪</view>
        <view class="feature-info">
          <text class="feature-title logout-title">退出登录</text>
          <text class="feature-desc">切换到其他账号</text>
        </view>
      </view>
    </view>
  </view>

  <!-- 未登录状态 -->
  <view wx:else class="not-login">
    <image class="login-image" src="/images/system/error.png" mode="aspectFit"></image>
    <text class="login-tip">登录后即可开始聊天</text>
  </view>

  <!-- 登录组件 -->
  <login show="{{showLogin}}" auto-login="{{true}}" bind:success="handleLoginSuccess" bind:close="handleLoginClose" />

  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\user\user.wxss*#*#*begin*#*#*
/* pages/user/user.wxss */

/* 页面容器 */
page {
  --primary-color: #5e72e4;
  --secondary-color: #f7fafc;
  --accent-color: #ff6b6b;
  --text-color: #2d3748;
  --light-text: #a0aec0;
  --border-color: #e2e8f0;
  --success-color: #48bb78;
  --warning-color: #ecc94b;
  --danger-color: #f56565;
  --background-color: #f8f9fa;

  background-color: var(--background-color);
  color: var(--text-color);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

.user-page {
  min-height: 100vh;
  padding-bottom: 100rpx;
}

/* 导航栏容器 */
.nav-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background-color: #f8f9fa;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.08);
  border-bottom-left-radius: 24rpx;
  border-bottom-right-radius: 24rpx;
  padding-bottom: 10rpx; /* 底部增加一点空间 */
  transition: all 0.3s ease;
}

.light .nav-container {
  background-color: #f8f9fa;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.08);
}

.dark .nav-container {
  background-color: #1a202c;
  box-shadow: 0 4rpx 16rpx rgba(0, 0, 0, 0.15);
}

/* 状态栏和导航栏 */
.status-bar, .nav-bar {
  width: 100%;
}

/* 状态栏 */
.status-bar {
  background-color: #f8f9fa;
}

.light .status-bar {
  background-color: #f8f9fa;
}

.dark .status-bar {
  background-color: #1a202c;
}

/* 自定义导航栏 */
.nav-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f8f9fa;
  box-sizing: border-box;
  padding: 10rpx 30rpx; /* 增加上下内边距 */
  min-height: 100rpx; /* 确保最小高度 */
}

.light .nav-bar {
  background-color: #f8f9fa;
}

.dark .nav-bar {
  background-color: #1a202c;
}

.nav-bar-left {
  display: flex;
  align-items: center;
  min-width: 80rpx;
  padding: 6rpx 0;
}

.nav-bar-title {
  flex: 1;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 10rpx;
  font-size: 36rpx;
  font-weight: bold;
  color: #333333;
}

.light .nav-bar-title {
  color: #333333;
}

.dark .nav-bar-title {
  color: #f8f9fa;
}

.nav-bar-right {
  min-width: 80rpx;
}

/* 加载状态 */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 70vh;
  margin-top: 20rpx;
}

.loading-spinner {
  width: 64rpx;
  height: 64rpx;
  border: 6rpx solid rgba(94, 114, 228, 0.1);
  border-top: 6rpx solid var(--primary-color);
  border-radius: 50%;
  margin-bottom: 24rpx;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* 内容区域 */
.content-area {
  padding: 30rpx;
  box-sizing: border-box;
}

/* 用户内容区 */
.user-content {
  padding: 0;
  animation: fade-in 0.3s ease;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* 个人资料头部 */
.profile-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 40rpx;
}

.profile-avatar {
  width: 160rpx;
  height: 160rpx;
  border-radius: 80rpx;
  margin-bottom: 24rpx;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
  border: 4rpx solid white;
}

.profile-name {
  font-size: 36rpx;
  font-weight: 600;
  margin-bottom: 8rpx;
  color: var(--text-color);
}

.profile-bio {
  font-size: 28rpx;
  color: var(--light-text);
}

/* 统计数据 */
.profile-stats {
  display: flex;
  justify-content: space-between;
  background-color: white;
  border-radius: 24rpx;
  padding: 32rpx;
  margin-bottom: 32rpx;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.stat-value {
  font-size: 40rpx;
  font-weight: 600;
  color: var(--primary-color);
  margin-bottom: 8rpx;
}

.stat-label {
  font-size: 24rpx;
  color: var(--light-text);
}

/* 情绪卡片 */
.emotion-card {
  background-color: white;
  border-radius: 24rpx;
  padding: 32rpx;
  margin-bottom: 32rpx;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.emotion-title {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 32rpx;
  font-weight: 600;
  margin-bottom: 24rpx;
  color: var(--text-color);
}

.emotion-more {
  font-size: 24rpx;
  color: var(--primary-color);
  font-weight: normal;
}

.emotion-chart {
  width: 100%;
  height: 400rpx;
  background-color: var(--secondary-color);
  border-radius: 16rpx;
  margin-bottom: 24rpx;
  overflow: hidden;
}

.chart-placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--light-text);
  font-size: 28rpx;
}

.chart-container {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

ec-canvas {
  width: 100% !important;
  height: 100% !important;
  display: block !important;
}

.emotion-summary {
  font-size: 28rpx;
  line-height: 1.5;
  color: var(--text-color);
}

.emotion-highlight {
  color: #ffc107;
  font-weight: 600;
}

.emotion-highlight-secondary {
  color: #f56565;
  font-weight: 600;
}

/* 兴趣标签容器 */
.interest-tag-container {
  width: 100%;
  min-height: 200rpx;
  padding: 16rpx 0;
  background-color: var(--secondary-color);
  border-radius: 16rpx;
  overflow: hidden;
}

/* 功能列表 */
.feature-list {
  background-color: white;
  border-radius: 24rpx;
  overflow: hidden;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.05);
}

.feature-item {
  display: flex;
  align-items: center;
  padding: 32rpx;
  border-bottom: 1rpx solid var(--border-color);
  position: relative;
}

.feature-item:last-child {
  border-bottom: none;
}

.feature-icon {
  width: 80rpx;
  height: 80rpx;
  background-color: var(--secondary-color);
  border-radius: 16rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-right: 24rpx;
  font-size: 40rpx;
}

.role-icon {
  background-color: rgba(94, 114, 228, 0.1);
  color: var(--primary-color);
}

.emotion-icon {
  background-color: rgba(236, 201, 75, 0.1);
  color: var(--warning-color);
}

.settings-icon {
  background-color: rgba(160, 174, 192, 0.1);
  color: var(--light-text);
}

.logout-icon {
  background-color: rgba(245, 101, 101, 0.1);
  color: var(--danger-color);
}

.feature-info {
  flex: 1;
}

.feature-title {
  font-size: 32rpx;
  font-weight: 500;
  margin-bottom: 8rpx;
  color: var(--text-color);
}

.feature-desc {
  font-size: 24rpx;
  color: var(--light-text);
}

.feature-arrow {
  width: 16rpx;
  height: 16rpx;
  border-top: 3rpx solid var(--light-text);
  border-right: 3rpx solid var(--light-text);
  transform: rotate(45deg);
}

.logout-title {
  color: var(--danger-color);
}

/* 未登录状态 */
.not-login {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 70vh;
  padding: 0 64rpx;
  margin-top: 20rpx;
}

.login-image {
  width: 240rpx;
  height: 240rpx;
  margin-bottom: 40rpx;
}

.login-tip {
  font-size: 32rpx;
  color: var(--light-text);
  text-align: center;
  margin-bottom: 64rpx;
}

/* 暗黑模式适配 */
@media (prefers-color-scheme: dark) {
  page {
    --primary-color: #9ecaff;
    --secondary-color: #2d3748;
    --text-color: #e2e8f0;
    --light-text: #a0aec0;
    --border-color: #4a5568;
    --background-color: #1a202c;
    --success-color: #68d391;
    --warning-color: #f6e05e;
    --danger-color: #fc8181;
  }
}

/* 暗黑模式类适配 */
.dark {
  --primary-color: #9ecaff;
  --secondary-color: #2d3748;
  --text-color: #e2e8f0;
  --light-text: #a0aec0;
  --border-color: #4a5568;
  --background-color: #1a202c;
  --success-color: #68d391;
  --warning-color: #f6e05e;
  --danger-color: #fc8181;
  background-color: var(--background-color);
  color: var(--text-color);
}

.dark .profile-stats,
.dark .emotion-card,
.dark .feature-list {
  background-color: #2d3748;
}

.dark .feature-icon {
  background-color: #4a5568;
}

.dark .chart-placeholder {
  background-color: #4a5568;
}

.dark .profile-avatar {
  border-color: #2d3748;
  box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.3);
}

.dark .feature-arrow {
  border-color: #a0aec0;
}

.dark .loading-spinner {
  border-color: rgba(158, 202, 255, 0.1);
  border-top-color: var(--primary-color);
}

*#*#*end*#*#*

*#*#*miniprogram\pages\welcome\welcome.js*#*#*begin*#*#*
// pages/welcome/welcome.js
const app = getApp();
import { saveLoginInfo } from '../../utils/auth';

Page({
  /**
   * 页面的初始数据
   */
  data: {
    agreed: false,
    loading: false
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    // 检查用户是否已登录
    this.checkLoginStatus();
  },

  /**
   * 检查登录状态
   */
  checkLoginStatus: function () {
    // 从全局获取登录状态
    const isLoggedIn = app.globalData.isLoggedIn;

    if (isLoggedIn) {
      // 已登录，跳转到首页
      this.navigateToHome();
    }
  },

  /**
   * 处理协议勾选状态变化
   */
  handleAgreementChange: function(e) {
    this.setData({
      agreed: e.detail.value.length > 0
    });
  },

  /**
   * 处理获取用户信息
   */
  handleGetUserInfo: function(e) {
    if (e.detail.userInfo) {
      this.handleLogin(e.detail.userInfo);
    } else {
      wx.showToast({
        title: '需要您的授权才能继续使用',
        icon: 'none'
      });
    }
  },

  /**
   * 处理登录
   */
  handleLogin: async function(userInfo) {
    // 检查是否同意协议
    if (!this.data.agreed) {
      wx.showToast({
        title: '请先同意服务协议',
        icon: 'none'
      });
      return;
    }

    // 防止重复点击
    if (this.data.loading) return;

    this.setData({ loading: true });

    try {
      // 获取用户信息
      if (!userInfo) {
        const userProfile = await wx.getUserProfile({
          desc: '用于完善用户资料'
        });
        userInfo = userProfile.userInfo;
      }

      // 获取登录凭证
      const { code } = await wx.login();

      // 调用登录云函数
      const { result } = await wx.cloud.callFunction({
        name: 'login',
        data: {
          code,
          userInfo
        }
      });

      if (!result.success) {
        throw new Error(result.error || '登录失败');
      }

      // 保存登录信息并更新全局状态
      const loginData = {
        token: result.data.token,
        userInfo: result.data.userInfo
      };

      if(!saveLoginInfo(loginData)) {
        throw new Error('保存登录信息失败');
      }

      // 更新全局状态
      app.globalData.isLoggedIn = true;
      app.globalData.userInfo = result.data.userInfo;

      // 显示成功提示
      wx.showToast({
        title: '登录成功',
        icon: 'success',
        duration: 1500
      });

      // 延迟跳转，等待提示显示
      setTimeout(() => {
        this.navigateToHome();
      }, 1500);

    } catch (error) {
      console.error('Login failed:', error);
      let errorMsg = '登录失败，请重试';

      if (error.errMsg?.includes('getUserProfile:fail')) {
        errorMsg = '需要您的授权才能继续使用';
      }

      wx.showToast({
        title: errorMsg,
        icon: 'none'
      });
    } finally {
      this.setData({ loading: false });
    }
  },

  /**
   * 跳转到首页
   */
  navigateToHome: function () {
    wx.switchTab({
      url: '/pages/home/home'
    });
  }
})

*#*#*end*#*#*

*#*#*miniprogram\pages\welcome\welcome.json*#*#*begin*#*#*
{
  "navigationBarTitleText": "HeartChat",
  "navigationStyle": "custom",
  "usingComponents": {}
}

*#*#*end*#*#*

*#*#*miniprogram\pages\welcome\welcome.wxml*#*#*begin*#*#*
<view class="welcome-container">
  <!-- 顶部状态栏占位 -->
  <view class="status-bar"></view>

  <!-- 头部区域 -->
  <view class="welcome-header">
    <view class="app-logo">
      <view class="heart-icon">❤️</view>
    </view>
    <view class="app-name">HeartChat</view>
    <view class="app-slogan">情感陪伴与情商提升的智能伙伴</view>
  </view>

  <!-- 内容区域 -->
  <view class="welcome-content">
    <view class="welcome-features">
      <view class="feature-item">
        <view class="feature-icon">💬</view>
        <view class="feature-text">
          <view class="feature-title">情感倾诉</view>
          <view class="feature-description">在安全的环境中表达情感，获得理解和支持</view>
        </view>
      </view>
      <view class="feature-item">
        <view class="feature-icon">👥</view>
        <view class="feature-text">
          <view class="feature-title">角色互动</view>
          <view class="feature-description">与多样化的AI角色对话，满足不同情感需求</view>
        </view>
      </view>
      <view class="feature-item">
        <view class="feature-icon">📊</view>
        <view class="feature-text">
          <view class="feature-title">情绪跟踪</view>
          <view class="feature-description">记录和分析情绪变化，了解自己的情感模式</view>
        </view>
      </view>
      <view class="feature-item">
        <view class="feature-icon">💡</view>
        <view class="feature-text">
          <view class="feature-title">每日心情报告</view>
          <view class="feature-description">获取个性化的心情总结和建议</view>
        </view>
      </view>
    </view>
  </view>

  <!-- 底部区域 -->
  <view class="welcome-footer">
    <!-- 登录按钮 -->
    <button class="login-button" open-type="getUserInfo" bindgetuserinfo="handleGetUserInfo" loading="{{loading}}" disabled="{{loading || !agreed}}">一键微信登录</button>

    <!-- 协议区域 -->
    <view class="agreement-box">
      <checkbox-group bindchange="handleAgreementChange">
        <label class="agreement-label">
          <checkbox value="agreed" checked="{{agreed}}" />
          <text class="agreement-text">我已阅读并同意</text>
          <navigator url="/pages/agreement/service" class="link">《服务协议》</navigator>
          <text class="agreement-text">和</text>
          <navigator url="/pages/agreement/privacy" class="link">《隐私协议》</navigator>
        </label>
      </checkbox-group>
    </view>
  </view>
</view>

*#*#*end*#*#*

*#*#*miniprogram\pages\welcome\welcome.wxss*#*#*begin*#*#*
/* 欢迎页面样式 */
page {
  height: 100%;
  overflow: hidden;
}

/* 状态栏占位 */
.status-bar {
  height: 44px;
  width: 100%;
}

/* 主容器 */
.welcome-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  background-image: linear-gradient(to bottom, #5e72e4, #825ee4);
  color: white;
  box-sizing: border-box;
  padding-bottom: env(safe-area-inset-bottom);
}

/* 头部区域 */
.welcome-header {
  padding: 60rpx 48rpx 0;
  text-align: center;
}

.app-logo {
  width: 240rpx;
  height: 240rpx;
  margin: 0 auto 48rpx;
  background-color: white;
  border-radius: 60rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  box-shadow: 0 8rpx 24rpx rgba(0, 0, 0, 0.15);
}

.heart-icon {
  font-size: 120rpx;
  line-height: 1;
}

.app-name {
  font-size: 64rpx;
  font-weight: 700;
  margin-bottom: 16rpx;
  text-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.1);
}

.app-slogan {
  font-size: 32rpx;
  opacity: 0.9;
  padding: 0 40rpx;
  line-height: 1.5;
}

/* 内容区域 */
.welcome-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 40rpx 48rpx;
}

.welcome-features {
  margin-bottom: 32rpx;
}

.feature-item {
  display: flex;
  align-items: center;
  margin-bottom: 40rpx;
}

.feature-icon {
  width: 80rpx;
  height: 80rpx;
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 24rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-right: 32rpx;
  font-size: 40rpx;
}

.feature-text {
  flex: 1;
}

.feature-title {
  font-weight: 600;
  font-size: 32rpx;
  margin-bottom: 8rpx;
}

.feature-description {
  font-size: 28rpx;
  opacity: 0.8;
  line-height: 1.4;
}

/* 底部区域 */
.welcome-footer {
  padding: 48rpx;
}

.login-button {
  background-color: white;
  color: #5e72e4;
  border-radius: 24rpx;
  padding: 32rpx;
  font-weight: 600;
  font-size: 32rpx;
  text-align: center;
  margin-bottom: 32rpx;
  box-shadow: 0 8rpx 16rpx rgba(0, 0, 0, 0.1);
  border: none;
  transition: all 0.3s;
}

.login-button[disabled] {
  background-color: rgba(255, 255, 255, 0.6);
  color: rgba(94, 114, 228, 0.6);
}

.login-button:active {
  transform: scale(0.98);
  box-shadow: 0 4rpx 8rpx rgba(0, 0, 0, 0.1);
}

/* 协议区域 */
.agreement-box {
  margin-bottom: 40rpx;
  text-align: center;
}

.agreement-label {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24rpx;
  color: rgba(255, 255, 255, 0.8);
  flex-wrap: wrap;
}

.agreement-text {
  margin: 0 4rpx;
}

.link {
  color: white;
  text-decoration: underline;
  display: inline;
}

/* 动画效果 */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

/* 安全区适配 */
@supports (padding-bottom: constant(safe-area-inset-bottom)) {
  .welcome-footer {
    padding-bottom: constant(safe-area-inset-bottom);
  }
}

@supports (padding-bottom: env(safe-area-inset-bottom)) {
  .welcome-footer {
    padding-bottom: env(safe-area-inset-bottom);
  }
}

*#*#*end*#*#*

*#*#*miniprogram\services\chatCacheService.js*#*#*begin*#*#*
/**
 * 聊天缓存服务
 * 提供聊天记录的本地缓存管理功能
 */

// 缓存前缀
const CACHE_PREFIX = 'chat_';
// 每页消息数量
const PAGE_SIZE = 20;
// 最大缓存聊天数
const MAX_CACHED_CHATS = 10;

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

/**
 * 保存消息到本地缓存
 * @param {string} chatId 聊天ID
 * @param {Array} messages 消息数组
 * @param {boolean} isLatest 是否为最新消息
 * @param {number} pageNum 页码(可选)
 * @param {Object} roleInfo 角色信息(可选)
 */
function saveMessagesToCache(chatId, messages, isLatest, pageNum, roleInfo) {
  if (!chatId || !messages || messages.length === 0) {
    if (isDev) {
      console.log('保存缓存参数无效');
    }
    return;
  }

  const cacheKey = `${CACHE_PREFIX}${chatId}`;
  let chatCache = wx.getStorageSync(cacheKey) || {
    basic: {
      roleId: roleInfo?.roleId || '',
      roleName: roleInfo?.name || '',
      lastUpdateTime: Date.now(),
      messageCount: 0
    },
    messages: {
      latest: [],
      pages: {}
    }
  };

  // 更新基本信息
  if (roleInfo) {
    chatCache.basic.roleId = roleInfo.roleId || chatCache.basic.roleId;
    chatCache.basic.roleName = roleInfo.name || chatCache.basic.roleName;
  }

  if (isLatest) {
    chatCache.basic.lastUpdateTime = Date.now();
    // 只在新增消息时更新计数
    const existingIds = new Set(chatCache.messages.latest.map(msg => msg._id));
    const newCount = messages.filter(msg => !existingIds.has(msg._id)).length;
    chatCache.basic.messageCount += newCount;
  }

  // 保存消息
  if (isLatest) {
    // 合并最新消息，避免重复
    const existingIds = new Set(chatCache.messages.latest.map(msg => msg._id));
    const newMessages = messages.filter(msg => !existingIds.has(msg._id));

    // 处理分段消息的关联
    const messageMap = {};
    [...chatCache.messages.latest, ...newMessages].forEach(msg => {
      messageMap[msg._id] = msg;
    });

    // 将分段消息按照索引排序
    const sortedMessages = [...chatCache.messages.latest, ...newMessages].sort((a, b) => {
      // 如果都是分段消息且来自同一原始消息
      if (a.isSegment && b.isSegment && a.originalMessageId === b.originalMessageId) {
        return a.segmentIndex - b.segmentIndex;
      }
      // 否则按时间戳排序
      return a.timestamp - b.timestamp;
    }).slice(-PAGE_SIZE * 2); // 由于分段消息可能会增加消息数量，所以增加缓存容量

    chatCache.messages.latest = sortedMessages;
  } else if (pageNum) {
    // 保存历史页面
    chatCache.messages.pages[`page_${pageNum}`] = messages;
  }

  // 保存到缓存
  try {
    wx.setStorageSync(cacheKey, chatCache);
    if (isDev) {
      console.log(`成功保存聊天记录到缓存: ${chatId}, 消息数: ${messages.length}`);
    }
  } catch (error) {
    console.error('保存聊天记录到缓存失败:', error.message || error);
    // 如果存储失败，可能是缓存已满，尝试清理旧数据
    cleanupOldCache();
    // 再次尝试保存
    try {
      wx.setStorageSync(cacheKey, chatCache);
      if (isDev) {
        console.log('清理缓存后成功保存');
      }
    } catch (e) {
      console.error('二次尝试保存缓存失败:', e.message || e);
    }
  }
}

/**
 * 从本地缓存加载消息
 * @param {string} chatId 聊天ID
 * @param {number} pageNum 页码(可选)
 * @returns {Array|null} 消息数组或null
 */
function loadMessagesFromCache(chatId, pageNum) {
  if (!chatId) return null;

  const cacheKey = `${CACHE_PREFIX}${chatId}`;
  const chatCache = wx.getStorageSync(cacheKey);

  if (!chatCache || !chatCache.messages) {
    if (isDev) {
      console.log(`缓存中没有找到聊天记录: ${chatId}`);
    }
    return null;
  }

  if (pageNum) {
    // 加载特定页面
    return chatCache.messages.pages[`page_${pageNum}`] || null;
  } else {
    // 加载最新消息
    return chatCache.messages.latest || [];
  }
}

/**
 * 获取聊天基本信息
 * @param {string} chatId 聊天ID
 * @returns {Object|null} 聊天基本信息
 */
function getChatBasicInfo(chatId) {
  if (!chatId) return null;

  const cacheKey = `${CACHE_PREFIX}${chatId}`;
  const chatCache = wx.getStorageSync(cacheKey);

  return chatCache?.basic || null;
}

/**
 * 更新单条消息
 * @param {string} chatId 聊天ID
 * @param {string} messageId 消息ID
 * @param {Object} updates 更新内容
 * @returns {boolean} 是否成功
 */
function updateMessageInCache(chatId, messageId, updates) {
  if (!chatId || !messageId || !updates) return false;

  const cacheKey = `${CACHE_PREFIX}${chatId}`;
  const chatCache = wx.getStorageSync(cacheKey);

  if (!chatCache || !chatCache.messages) return false;

  let updated = false;

  // 更新最新消息
  if (chatCache.messages.latest && chatCache.messages.latest.length > 0) {
    const index = chatCache.messages.latest.findIndex(msg => msg._id === messageId);
    if (index !== -1) {
      chatCache.messages.latest[index] = {
        ...chatCache.messages.latest[index],
        ...updates
      };
      updated = true;
    }
  }

  // 更新分页消息
  if (chatCache.messages.pages) {
    for (const pageKey in chatCache.messages.pages) {
      const page = chatCache.messages.pages[pageKey];
      if (page && page.length > 0) {
        const index = page.findIndex(msg => msg._id === messageId);
        if (index !== -1) {
          page[index] = {
            ...page[index],
            ...updates
          };
          updated = true;
        }
      }
    }
  }

  if (updated) {
    try {
      wx.setStorageSync(cacheKey, chatCache);
      if (isDev) {
        console.log(`成功更新缓存中的消息: ${messageId}`);
      }
      return true;
    } catch (error) {
      console.error('更新缓存消息失败:', error.message || error);
      return false;
    }
  }

  return false;
}

/**
 * 清理旧缓存
 */
function cleanupOldCache() {
  try {
    // 获取所有缓存键
    const keys = wx.getStorageInfoSync().keys;
    const chatKeys = keys.filter(key => key.startsWith(CACHE_PREFIX));

    if (chatKeys.length <= MAX_CACHED_CHATS) return; // 如果聊天记录少于限制，不清理

    // 按最后更新时间排序
    const sortedChats = chatKeys.map(key => {
      const cache = wx.getStorageSync(key);
      return {
        key,
        lastUpdateTime: cache?.basic?.lastUpdateTime || 0
      };
    }).sort((a, b) => a.lastUpdateTime - b.lastUpdateTime);

    // 删除最旧的聊天记录，直到数量符合限制
    const deleteCount = chatKeys.length - MAX_CACHED_CHATS;
    for (let i = 0; i < deleteCount; i++) {
      wx.removeStorageSync(sortedChats[i].key);
      if (isDev) {
        console.log(`已清理旧聊天记录缓存: ${sortedChats[i].key}`);
      }
    }
  } catch (error) {
    console.error('清理缓存失败:', error.message || error);
  }
}

/**
 * 清除指定聊天的缓存
 * @param {string} chatId 聊天ID
 */
function clearChatCache(chatId) {
  if (!chatId) return;

  const cacheKey = `${CACHE_PREFIX}${chatId}`;
  try {
    wx.removeStorageSync(cacheKey);
    if (isDev) {
      console.log(`已清除聊天缓存: ${chatId}`);
    }
  } catch (error) {
    console.error(`清除聊天缓存失败: ${chatId}`, error.message || error);
  }
}

/**
 * 获取所有缓存的聊天
 * @returns {Array} 聊天基本信息数组
 */
function getAllCachedChats() {
  try {
    const keys = wx.getStorageInfoSync().keys;
    const chatKeys = keys.filter(key => key.startsWith(CACHE_PREFIX));

    return chatKeys.map(key => {
      const cache = wx.getStorageSync(key);
      const chatId = key.replace(CACHE_PREFIX, '');
      return {
        chatId,
        ...cache.basic
      };
    }).sort((a, b) => b.lastUpdateTime - a.lastUpdateTime); // 按最后更新时间倒序
  } catch (error) {
    console.error('获取所有缓存聊天失败:', error.message || error);
    return [];
  }
}

// 导出服务
module.exports = {
  saveMessagesToCache,
  loadMessagesFromCache,
  getChatBasicInfo,
  updateMessageInCache,
  cleanupOldCache,
  clearChatCache,
  getAllCachedChats,
  PAGE_SIZE
};

*#*#*end*#*#*

*#*#*miniprogram\services\cloudFuncCaller.js*#*#*begin*#*#*
/**
 * 云函数调用工具
 * 提供统一的云函数调用接口，包含错误处理和日志记录
 */

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

/**
 * 调用云函数
 * @param {string} name 云函数名称
 * @param {Object} data 云函数参数
 * @param {Object} options 调用选项
 * @param {boolean} options.showLoading 是否显示加载提示
 * @param {string} options.loadingText 加载提示文本
 * @param {boolean} options.showError 是否显示错误提示
 * @returns {Promise<Object>} 云函数返回结果
 */
async function callCloudFunc(name, data = {}, options = {}) {
  // 默认选项
  const defaultOptions = {
    showLoading: false,
    loadingText: '处理中...',
    showError: true
  };

  // 合并选项
  const mergedOptions = { ...defaultOptions, ...options };

  // 显示加载提示
  if (mergedOptions.showLoading) {
    wx.showLoading({
      title: mergedOptions.loadingText,
      mask: true
    });
  }

  try {
    if (isDev) {
      console.log(`调用云函数 ${name}:`, data);
    }

    // 调用云函数
    const result = await wx.cloud.callFunction({
      name,
      data
    });

    // 处理结果
    if (result && result.result) {
      if (isDev) {
        console.log(`云函数 ${name} 返回:`, result.result);
      }

      // 如果云函数返回错误
      if (result.result.error && mergedOptions.showError) {
        wx.showToast({
          title: result.result.error,
          icon: 'none',
          duration: 2000
        });
      }

      return result.result;
    } else {
      console.error(`云函数 ${name} 返回无效结果`);

      if (mergedOptions.showError) {
        wx.showToast({
          title: '服务调用失败',
          icon: 'none',
          duration: 2000
        });
      }

      return { success: false, error: '无效的云函数返回结果' };
    }
  } catch (error) {
    console.error(`云函数 ${name} 调用异常:`, error.message || error);

    if (mergedOptions.showError) {
      wx.showToast({
        title: error.message || '服务调用异常',
        icon: 'none',
        duration: 2000
      });
    }

    return { success: false, error: error.message || '云函数调用异常' };
  } finally {
    // 隐藏加载提示
    if (mergedOptions.showLoading) {
      wx.hideLoading();
    }
  }
}

/**
 * 批量调用云函数
 * @param {Array} calls 云函数调用数组，每个元素包含name和data字段
 * @param {Object} options 调用选项
 * @returns {Promise<Array>} 云函数返回结果数组
 */
async function batchCallCloudFunc(calls, options = {}) {
  if (!Array.isArray(calls) || calls.length === 0) {
    return [];
  }

  // 默认选项
  const defaultOptions = {
    showLoading: false,
    loadingText: '批量处理中...',
    showError: true,
    parallel: true // 是否并行调用
  };

  // 合并选项
  const mergedOptions = { ...defaultOptions, ...options };

  // 显示加载提示
  if (mergedOptions.showLoading) {
    wx.showLoading({
      title: mergedOptions.loadingText,
      mask: true
    });
  }

  try {
    if (isDev) {
      console.log(`批量调用云函数:`, calls);
    }

    let results;

    // 并行或串行调用
    if (mergedOptions.parallel) {
      // 并行调用
      const promises = calls.map(call =>
        callCloudFunc(call.name, call.data, { ...mergedOptions, showLoading: false, showError: false })
      );
      results = await Promise.all(promises);
    } else {
      // 串行调用
      results = [];
      for (const call of calls) {
        const result = await callCloudFunc(call.name, call.data, { ...mergedOptions, showLoading: false, showError: false });
        results.push(result);
      }
    }

    if (isDev) {
      console.log(`批量云函数调用完成:`, results);
    }
    return results;
  } catch (error) {
    console.error(`批量云函数调用异常:`, error.message || error);

    if (mergedOptions.showError) {
      wx.showToast({
        title: error.message || '批量服务调用异常',
        icon: 'none',
        duration: 2000
      });
    }

    return [];
  } finally {
    // 隐藏加载提示
    if (mergedOptions.showLoading) {
      wx.hideLoading();
    }
  }
}

// 导出模块
module.exports = {
  callCloudFunc,
  batchCallCloudFunc
};

*#*#*end*#*#*

*#*#*miniprogram\services\emotionService.js*#*#*begin*#*#*
/**
 * 情感分析服务
 * 提供情感分析相关功能
 */

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 情感类型枚举
const EmotionTypes = {
  JOY: '喜悦',
  SADNESS: '伤感',
  ANGER: '愤怒',
  ANXIETY: '焦虑',
  NEUTRAL: '平静'
};

// 情感类型中文标签
const EmotionTypeLabels = {
  // 中文情感类型直接使用
  '喜悦': '喜悦',
  '伤感': '伤感',
  '愤怒': '愤怒',
  '焦虑': '焦虑',
  '平静': '平静',
  '惊讶': '惊讶',
  '厌恶': '厌恶',
  '期待': '期待',
  '紧迫': '紧迫',
  '失望': '失望',
  '疲惫': '疲惫',

  // 兼容英文情感类型
  joy: '喜悦',
  sadness: '伤感',
  anger: '愤怒',
  anxiety: '焦虑',
  neutral: '平静',
  calm: '平静',
  surprise: '惊讶',
  disgust: '厌恶',
  anticipation: '期待',
  urgency: '紧迫',
  disappointment: '失望',
  fatigue: '疲惫'
};

// 情感类型颜色
const EmotionTypeColors = {
  // 中文情感类型颜色映射 - 使用更丰富的色彩
  '喜悦': '#10B981',    // 绿色
  '开心': '#10B981',    // 绿色
  '快乐': '#34D399',    // 浅绿色
  '兴奋': '#059669',    // 深绿色
  '满足': '#8B5CF6',    // 紫色
  '幸福': '#047857',    // 深绿色
  '伤感': '#60A5FA',    // 蓝色
  '悲伤': '#3B82F6',    // 深蓝色
  '难过': '#6366F1',    // 靛蓝色
  '忧伤': '#818CF8',    // 浅紫色
  '愤怒': '#EF4444',    // 红色
  '生气': '#F87171',    // 浅红色
  '愤怨': '#DC2626',    // 深红色
  '愤愤': '#B91C1C',    // 更深红色
  '焦虑': '#F59E0B',    // 黄色
  '担忧': '#FBBF24',    // 浅黄色
  '紧张': '#D97706',    // 深黄色
  '恐惧': '#92400E',    // 棕色
  '平静': '#64748B',    // 蓝灰色
  '平稳': '#94A3B8',    // 浅蓝灰色
  '平和': '#475569',    // 深蓝灰色
  '安宁': '#334155',    // 更深蓝灰色
  '惊讶': '#EC4899',    // 粉色
  '惊奇': '#DB2777',    // 深粉色
  '惊喜': '#F472B6',    // 浅粉色
  '惊恐': '#9D174D',    // 更深粉色
  '厌恶': '#F97316',    // 橙色
  '厌倦': '#FB923C',    // 浅橙色
  '厌怕': '#C2410C',    // 深橙色
  '厌烦': '#9A3412',    // 更深橙色
  '期待': '#14B8A6',    // 青绿色
  '盼望': '#0D9488',    // 深青绿色
  '向往': '#2DD4BF',    // 浅青绿色
  '憧憬': '#0F766E',    // 更深青绿色
  '紧迫': '#BE123C',    // 深红色
  '紧急': '#E11D48',    // 中红色
  '紧张': '#F43F5E',    // 浅红色
  '紧张不安': '#9F1239', // 更深红色
  '失望': '#6B7280',    // 灰色
  '失落': '#9CA3AF',    // 浅灰色
  '失望透顶': '#4B5563', // 深灰色
  '失落感': '#374151',    // 更深灰色
  '疲惫': '#8B5CF6',    // 紫色
  '疲惫不堂': '#7C3AED', // 深紫色
  '疲乏': '#A78BFA', // 浅紫色
  '疲惫不堪': '#4C1D95', // 更深紫色
  '中性': '#9CA3AF',    // 灰色
  '未知': '#6B7280',    // 灰色
  '好奇': '#06B6D4',    // 浅青色
  '好奇心': '#0891B2', // 青色
  '好奇心切': '#0E7490', // 深青色
  '关心': '#8B5CF6',    // 紫色
  '关切': '#7C3AED',    // 深紫色
  '关怀': '#6D28D9',    // 更深紫色
  '感激': '#F59E0B',    // 黄色
  '感恩': '#D97706',    // 深黄色
  '感激不尽': '#B45309', // 更深黄色

  // 兼容英文情感类型颜色映射
  joy: '#10B981',         // 绿色
  happiness: '#34D399',   // 浅绿色
  excited: '#059669',     // 深绿色
  content: '#047857',     // 更深绿色
  sadness: '#60A5FA',     // 蓝色
  grief: '#3B82F6',       // 深蓝色
  melancholy: '#6366F1',  // 靛蓝色
  sorrow: '#818CF8',      // 浅紫色
  anger: '#EF4444',       // 红色
  rage: '#DC2626',        // 深红色
  fury: '#B91C1C',        // 更深红色
  irritation: '#F87171',  // 浅红色
  anxiety: '#F59E0B',     // 黄色
  worry: '#FBBF24',       // 浅黄色
  tension: '#D97706',     // 深黄色
  fear: '#92400E',        // 棕色
  neutral: '#64748B',     // 蓝灰色
  calm: '#94A3B8',        // 浅蓝灰色
  peaceful: '#475569',    // 深蓝灰色
  serene: '#334155',      // 更深蓝灰色
  surprise: '#EC4899',    // 粉色
  amazement: '#DB2777',   // 深粉色
  astonishment: '#F472B6',// 浅粉色
  shock: '#9D174D',       // 更深粉色
  disgust: '#F97316',     // 橙色
  dislike: '#FB923C',     // 浅橙色
  aversion: '#C2410C',    // 深橙色
  revulsion: '#9A3412',   // 更深橙色
  anticipation: '#14B8A6',// 青绿色
  expectation: '#0D9488', // 深青绿色
  hope: '#2DD4BF',        // 浅青绿色
  longing: '#0F766E',     // 更深青绿色
  urgency: '#BE123C',     // 深红色
  pressing: '#E11D48',    // 中红色
  urgent: '#F43F5E',      // 浅红色
  critical: '#9F1239',    // 更深红色
  disappointment: '#6B7280', // 灰色
  letdown: '#9CA3AF',     // 浅灰色
  disillusionment: '#4B5563', // 深灰色
  regret: '#374151',      // 更深灰色
  fatigue: '#8B5CF6',     // 紫色
  exhaustion: '#7C3AED',  // 深紫色
  tiredness: '#A78BFA',   // 浅紫色
  weariness: '#4C1D95',   // 更深紫色
  trust: '#0EA5E9',       // 浅蓝色
  confidence: '#0284C7',  // 中蓝色
  faith: '#0369A1',       // 深蓝色
  admiration: '#0C4A6E',  // 更深蓝色
  curious: '#06B6D4',     // 浅青色
  inquisitive: '#0891B2', // 青色
  wonder: '#0E7490',      // 深青色
  caring: '#8B5CF6',      // 紫色
  concerned: '#7C3AED',   // 深紫色
  compassionate: '#6D28D9', // 更深紫色
  grateful: '#F59E0B',    // 黄色
  thankful: '#D97706',    // 深黄色
  appreciative: '#B45309' // 更深黄色
};

/**
 * 分析文本情感
 * @param {string} text 待分析文本
 * @param {Object} options 附加选项
 * @param {boolean} options.saveRecord 是否保存记录
 * @param {string} options.roleId 角色ID
 * @param {string} options.chatId 对话ID
 * @param {Array} options.history 历史消息记录
 * @param {boolean} options.extractKeywords 是否提取关键词
 * @param {boolean} options.linkKeywords 是否关联关键词与情感
 * @returns {Promise<object>} 情感分析结果
 */
async function analyzeEmotion(text, options = {}) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      if (isDev) {
        console.warn('情感分析文本为空');
      }
      return createDefaultResult();
    }

    // 构建调用参数
    const callParams = {
      text: text, // 确保文本参数正确传递
      saveRecord: options.saveRecord || false,
      extractKeywords: options.extractKeywords !== false, // 默认为true
      linkKeywords: options.linkKeywords !== false // 默认为true
    };

    // 添加可选参数
    if (options.roleId) callParams.roleId = options.roleId;
    if (options.chatId) callParams.chatId = options.chatId;

    // 添加历史消息记录
    if (Array.isArray(options.history) && options.history.length > 0) {
      callParams.history = options.history;
    }

    if (isDev) {
      console.log('发送到云函数的参数:', callParams);
    }

    // 调用 analysis 云函数
    const result = await wx.cloud.callFunction({
      name: 'analysis',
      data: {
        type: 'emotion',
        ...callParams
      }
    });

    // 验证结果
    if (!result || !result.result) {
      console.error('情感分析云函数返回错误: 无效的响应');
      return createDefaultResult();
    }

    // 即使云函数返回错误，也尝试提取有用的数据
    if (!result.result.success) {
      console.error('情感分析云函数返回错误:', result.result.error || '未知错误');

      // 如果有数据，就使用这些数据
      if (result.result.data) {
        if (isDev) {
          console.log('尝试使用云函数返回的部分数据');
        }
        return {
          success: true,
          data: result.result.data
        };
      }

      // 如果没有数据，就使用默认数据
      return createDefaultResult();
    }

    if (isDev) {
      console.log('使用 analysis 云函数分析成功');
    }

    // 返回分析结果和记录ID（如果有）
    const analysisResult = result.result.result || result.result.data || {};

    // 如果有关键词，将关键词添加到结果中
    const keywords = result.result.keywords || [];

    // 构建完整的结果对象
    const finalResult = {
      success: true,
      data: {
        ...analysisResult,
        recordId: result.result.recordId || null,
        keywords: keywords,
        timestamp: new Date().getTime() // 添加时间戳
      }
    };

    // 保存最新的情绪分析结果到本地缓存
    try {
      wx.setStorageSync('latestEmotionAnalysis', finalResult);
      if (isDev) {
        console.log('已将最新情绪分析结果保存到本地缓存');
      }
    } catch (e) {
      console.error('保存情绪分析结果到本地缓存失败:', e.message || e);
    }

    return finalResult;
  } catch (error) {
    console.error('情感分析调用失败:', error.message || error);
    return createDefaultResult();
  }
}

/**
 * 创建默认的情感分析结果
 * @returns {object} 默认情感分析结果
 */
function createDefaultResult() {
  const defaultData = {
    type: EmotionTypes.NEUTRAL,
    intensity: 0.5,
    valence: 0.0,
    arousal: 0.5,
    trend: 'unknown',
    attention_level: 'medium',
    radar_dimensions: {
      trust: 0.5,
      openness: 0.5,
      resistance: 0.5,
      stress: 0.5,
      control: 0.5
    },
    topic_keywords: [],
    emotion_triggers: [],
    suggestions: ['继续保持对话'],
    summary: '无法分析您当前的情绪状态，您的情绪似乎比较平稳。',
    recordId: null,
    // 兼容旧版字段
    primary_emotion: EmotionTypes.NEUTRAL,
    secondary_emotions: [],
    keywords: [],
    report: '无法分析您当前的情绪状态，您的情绪似乎比较平稳。'
  };

  return {
    success: false,
    error: '情绪分析失败',
    data: defaultData
  };
}

/**
 * 保存情感分析记录到数据库
 * @param {object} emotionData 情感数据
 * @returns {Promise<string>} 记录ID
 */
async function saveEmotionRecord(emotionData) {
  try {
    const db = wx.cloud.database();
    const result = await db.collection('emotionRecords').add({
      data: {
        userId: emotionData.userId,
        roleId: emotionData.roleId,
        roleName: emotionData.roleName,
        chatId: emotionData.chatId,
        messageId: emotionData.messageId,
        analysis: emotionData.analysis,
        createTime: db.serverDate()
      }
    });
    return result._id;
  } catch (error) {
    console.error('保存情感记录失败:', error.message || error);
    throw error;
  }
}

/**
 * 获取情感历史记录
 * @param {string} userId 用户ID
 * @param {string} roleId 角色ID (可选)
 * @param {number} limit 限制数量
 * @returns {Promise<Array>} 情感历史记录
 */
async function getEmotionHistory(userId, roleId = null, limit = 10) {
  if (isDev) {
    console.log('开始获取情感历史记录, 参数:', { userId, roleId, limit });
  }

  if (!userId) {
    console.error('获取情感历史记录失败: 用户ID不能为空');
    return [];
  }

  try {
    // 检查云环境初始化
    if (!wx.cloud) {
      console.error('获取情感历史记录失败: 云环境未初始化');
      return [];
    }

    // 尝试使用云函数查询
    if (isDev) {
      console.log('尝试使用云函数查询情绪历史记录');
    }

    // 初始化云环境（如果需要）
    if (!wx.cloud.inited) {
      try {
        wx.cloud.init({
          env: 'cloud1-9gpfk3ie94d8630a', // 使用您的实际环境ID
          traceUser: true
        });
        if (isDev) {
          console.log('云环境初始化成功');
        }
      } catch (initError) {
        console.error('云环境初始化失败:', initError.message || initError);
      }
    }

    let result;
    try {
      result = await wx.cloud.callFunction({
        name: 'getEmotionRecords',
        data: {
          userId: userId,
          roleId: roleId,
          limit: limit
        }
      });

      if (isDev) {
        console.log('云函数返回结果成功');
      }
    } catch (cloudError) {
      console.error('调用云函数失败:', cloudError.message || cloudError);
      // 不抛出错误，而是让代码继续执行到备用方案
      result = { result: { success: false, error: cloudError } };
    }

    if (result && result.result && result.result.success) {
      const records = result.result.data || [];
      if (isDev) {
        console.log('云函数获取情绪历史记录成功, 数量:', records.length);
      }

      // 处理返回的数据，确保字段格式一致
      const processedData = records.map(record => {
        // 处理 analysis 字段
        if (record.analysis) {
          // 确保有 primary_emotion 字段
          if (!record.analysis.primary_emotion && record.analysis.type) {
            record.analysis.primary_emotion = record.analysis.type;
          }

          // 确保有 topic_keywords 字段
          if (!record.analysis.topic_keywords && record.analysis.keywords) {
            record.analysis.topic_keywords = record.analysis.keywords;
          }
        }

        return record;
      });

      return processedData;
    } else {
      if (isDev) {
        console.error('云函数返回错误:', result && result.result ? result.result.error : '未知错误');
        console.log('尝试直接使用数据库查询作为备用方案');
      }

      const db = wx.cloud.database();

      // 尝试使用字符串查询
      let dbResult;
      try {
        // 构建字符串查询条件
        let whereStr = `userId=="${userId}"`;
        if (roleId) {
          whereStr += ` && roleId=="${roleId}"`;
        }

        if (isDev) {
          console.log('字符串查询条件:', whereStr);
        }

        // 查询记录
        dbResult = await db.collection('emotionRecords')
          .where(whereStr)
          .orderBy('createTime', 'desc')
          .limit(limit)
          .get();

        if (isDev && dbResult && dbResult.data) {
          console.log('字符串查询结果数量:', dbResult.data.length);
        }
      } catch (stringQueryError) {
        console.error('字符串查询失败:', stringQueryError.message || stringQueryError);

        // 如果字符串查询失败，尝试使用对象查询
        try {
          const query = { userId: userId };
          if (roleId) {
            query.roleId = roleId;
          }

          if (isDev) {
            console.log('对象查询条件:', query);
          }

          dbResult = await db.collection('emotionRecords')
            .where(query)
            .orderBy('createTime', 'desc')
            .limit(limit)
            .get();

          if (isDev && dbResult && dbResult.data) {
            console.log('对象查询结果数量:', dbResult.data.length);
          }
        } catch (objectQueryError) {
          console.error('对象查询失败:', objectQueryError.message || objectQueryError);

          // 如果两种查询都失败，返回空数组
          return [];
        }
      }

      // 检查dbResult是否定义
      if (!dbResult || !dbResult.data) {
        console.error('查询结果为空');
        return [];
      }

      if (isDev) {
        console.log('备用查询获取情感历史记录成功, 数量:', dbResult.data.length);
      }

      // 处理返回的数据，确保字段格式一致
      const processedData = dbResult.data.map(record => {
        // 处理 analysis 字段
        if (record.analysis) {
          // 确保有 primary_emotion 字段
          if (!record.analysis.primary_emotion && record.analysis.type) {
            record.analysis.primary_emotion = record.analysis.type;
          }

          // 确保有 topic_keywords 字段
          if (!record.analysis.topic_keywords && record.analysis.keywords) {
            record.analysis.topic_keywords = record.analysis.keywords;
          }
        }

        return record;
      });

      return processedData;
    }
  } catch (error) {
    console.error('获取情感历史记录失败:', error.message || error);

    // 返回空数组
    if (isDev) {
      console.log('没有找到情绪历史记录');
    }
    return [];
  }
}



/**
 * 根据情感类型匹配推荐角色
 * @param {object} emotion 情感分析结果
 * @param {Array} roleList 角色列表
 * @returns {object|null} 推荐角色
 */
function matchRoleByEmotion(emotion, roleList) {
  if (!emotion || !roleList || roleList.length === 0) {
    return null;
  }

  // 情感类型与角色特性的匹配规则
  const matchRules = {
    joy: ['开朗', '活泼', '幽默', '乐观'],
    sadness: ['温柔', '体贴', '同理心', '安慰'],
    anger: ['冷静', '理性', '平和', '客观'],
    anxiety: ['稳重', '可靠', '安抚', '支持'],
    neutral: ['平衡', '中立', '客观', '全面'],
    // 添加新的情感类型映射
    calm: ['平静', '安宁', '平和', '舒适'],
    surprise: ['好奇', '活力', '创新', '灵活'],
    disgust: ['直接', '坦率', '批判性', '分析'],
    anticipation: ['积极', '前瞻', '规划', '鼓励'],
    urgency: ['高效', '果断', '行动导向', '解决问题'],
    disappointment: ['理解', '支持', '鼓励', '积极'],
    fatigue: ['放松', '舒缓', '耐心', '关怀'],
    // 添加新增的情绪类型映射
    curious: ['好奇', '探索', '创新', '学习'],
    caring: ['关心', '体贴', '理解', '关怀'],
    grateful: ['感恩', '感谢', '欢喜', '欣赏']
  };

  // 获取当前情感类型的匹配特性
  // 适配新的情感分析结果格式，优先使用primary_emotion字段
  const emotionType = emotion.primary_emotion || emotion.type || 'neutral';
  const matchTraits = matchRules[emotionType] || matchRules.neutral;

  // 为每个角色计算匹配分数
  const scoredRoles = roleList.map(role => {
    // 提取角色特性关键词
    const roleTraits = [
      role.role_name || '',
      role.role_desc || '',
      role.speaking_style || '',
      role.style || ''
    ].join(' ').toLowerCase();

    // 计算匹配分数
    let score = 0;
    matchTraits.forEach(trait => {
      if (roleTraits.includes(trait.toLowerCase())) {
        score += 1;
      }
    });

    // 根据情感强度调整分数
    const intensity = emotion.intensity || 0.5;
    if (intensity > 0.7) {
      score *= 1.5; // 情感强烈时，更倾向于匹配
    }

    return {
      role,
      score
    };
  });

  // 按分数排序
  scoredRoles.sort((a, b) => b.score - a.score);

  // 返回得分最高的角色，如果所有角色得分为0，则随机返回一个
  return scoredRoles[0].score > 0 ? scoredRoles[0].role :
    roleList[Math.floor(Math.random() * roleList.length)];
}

/**
 * 检测情感变化并提供角色切换建议
 * @param {object} prevEmotion 之前的情感
 * @param {object} currentEmotion 当前情感
 * @param {Array} roleList 角色列表
 * @returns {object} 切换建议
 */
function checkEmotionChangeAndSuggestRoleSwitch(prevEmotion, currentEmotion, roleList) {
  if (!prevEmotion || !currentEmotion || !roleList || roleList.length === 0) {
    return { shouldSwitch: false };
  }

  // 计算情感变化幅度
  const prevType = prevEmotion.primary_emotion || prevEmotion.type || 'neutral';
  const currentType = currentEmotion.primary_emotion || currentEmotion.type || 'neutral';
  const typeChanged = prevType !== currentType;

  // 获取情感强度，处理可能的空值
  const prevIntensity = prevEmotion.intensity || 0.5;
  const currentIntensity = currentEmotion.intensity || 0.5;
  const intensityChange = Math.abs(prevIntensity - currentIntensity);

  // 判断是否需要切换角色
  if (typeChanged || intensityChange > 0.3) {
    const suggestedRole = matchRoleByEmotion(currentEmotion, roleList);
    return {
      shouldSwitch: true,
      suggestedRole: suggestedRole,
      reason: typeChanged ? '情绪类型发生变化' : '情绪强度变化显著'
    };
  }

  return { shouldSwitch: false };
}

/**
 * 格式化聊天历史记录为情感分析所需的格式
 * @param {Array} chatHistory 聊天历史记录
 * @param {number} maxItems 最大条目数
 * @returns {Array} 格式化后的历史记录
 */
function formatChatHistoryForAnalysis(chatHistory, maxItems = 5) {
  if (!Array.isArray(chatHistory) || chatHistory.length === 0) {
    return [];
  }

  // 获取最近的消息
  const recentMessages = chatHistory.slice(-maxItems);

  // 转换为情感分析所需的格式
  return recentMessages.map(msg => {
    return {
      role: msg.isUser ? 'user' : 'assistant',
      content: msg.content || ''
    };
  });
}

/**
 * 计算情绪波动指数
 * 根据情绪记录计算用户的情绪波动指数
 * @param {Array} records 情绪记录数组
 * @returns {Number} 情绪波动指数（0-100）
 */
function calculateEmotionalVolatility(records) {
  if (!records || records.length < 2) {
    return 0; // 记录不足，无法计算波动指数
  }

  // 标准差计算
  const intensities = records.map(record => {
    // 尝试从不同字段获取情绪强度
    return record.analysis?.intensity ||
      record.analysis?.arousal ||
      (record.analysis?.radar_dimensions?.intensity) || 0.5;
  });

  const mean = intensities.reduce((sum, val) => sum + val, 0) / intensities.length;
  const squareDiffs = intensities.map(val => Math.pow(val - mean, 2));
  const stdDev = Math.sqrt(squareDiffs.reduce((sum, val) => sum + val, 0) / squareDiffs.length);

  // 标准差归一化到0-1范围（假设最大标准差为0.5）
  const normalizedStdDev = Math.min(stdDev / 0.5, 1);

  // 情绪类型变化
  const typeChanges = countEmotionTypeChanges(records);

  // 情绪类型多样性
  const typeDiversity = calculateEmotionTypeDiversity(records);

  // 时间加权
  const timeWeightedChanges = calculateTimeWeightedChanges(records);

  // 综合波动指数 (0-100)
  const volatility = (normalizedStdDev * 40) + (typeChanges * 30) + (typeDiversity * 20) + (timeWeightedChanges * 10);

  return Math.min(Math.round(volatility), 100);
}

/**
 * 计算情绪类型变化次数
 * @param {Array} records 情绪记录数组
 * @returns {Number} 归一化的情绪类型变化频率（0-1）
 */
function countEmotionTypeChanges(records) {
  if (!records || records.length < 2) return 0;

  let changes = 0;
  let prevType = getEmotionType(records[0]);

  for (let i = 1; i < records.length; i++) {
    const currentType = getEmotionType(records[i]);
    if (currentType !== prevType) {
      changes++;
      prevType = currentType;
    }
  }

  // 归一化：变化次数除以可能的最大变化次数（记录数-1）
  return Math.min(changes / (records.length - 1), 1);
}

/**
 * 计算情绪类型多样性
 * @param {Array} records 情绪记录数组
 * @returns {Number} 归一化的情绪类型多样性（0-1）
 */
function calculateEmotionTypeDiversity(records) {
  if (!records || records.length === 0) return 0;

  // 统计各情绪类型出现次数
  const typeCounts = {};
  records.forEach(record => {
    const type = getEmotionType(record);
    typeCounts[type] = (typeCounts[type] || 0) + 1;
  });

  // 计算香农熵作为多样性指标
  const typeCount = Object.keys(typeCounts).length;

  // 简单方法：使用类型数量除以最大可能类型数（假设为8）
  return Math.min(typeCount / 8, 1);
}

/**
 * 计算时间加权变化
 * @param {Array} records 情绪记录数组
 * @returns {Number} 归一化的时间加权变化（0-1）
 */
function calculateTimeWeightedChanges(records) {
  if (!records || records.length < 2) return 0;

  // 按时间排序
  const sortedRecords = [...records].sort((a, b) => {
    const timeA = new Date(a.createTime || a.timestamp || 0);
    const timeB = new Date(b.createTime || b.timestamp || 0);
    return timeA - timeB;
  });

  let weightedChanges = 0;
  let totalWeight = 0;

  for (let i = 1; i < sortedRecords.length; i++) {
    const prevRecord = sortedRecords[i - 1];
    const currRecord = sortedRecords[i];

    // 计算时间差（小时）
    const prevTime = new Date(prevRecord.createTime || prevRecord.timestamp || 0);
    const currTime = new Date(currRecord.createTime || currRecord.timestamp || 0);
    const hoursDiff = Math.max(1, (currTime - prevTime) / (1000 * 60 * 60));

    // 时间权重：时间间隔越短，权重越大
    const timeWeight = 1 / Math.sqrt(hoursDiff);

    // 情绪变化
    const prevType = getEmotionType(prevRecord);
    const currType = getEmotionType(currRecord);
    const typeChanged = prevType !== currType ? 1 : 0;

    // 情绪强度变化
    const prevIntensity = prevRecord.analysis?.intensity || 0.5;
    const currIntensity = currRecord.analysis?.intensity || 0.5;
    const intensityChange = Math.abs(currIntensity - prevIntensity);

    // 加权变化
    weightedChanges += (typeChanged * 0.7 + intensityChange * 0.3) * timeWeight;
    totalWeight += timeWeight;
  }

  // 归一化
  return totalWeight > 0 ? Math.min(weightedChanges / totalWeight, 1) : 0;
}

/**
 * 获取情绪类型
 * @param {Object} record 情绪记录
 * @returns {String} 情绪类型
 */
function getEmotionType(record) {
  // 尝试从不同字段获取情绪类型
  return record.analysis?.primary_emotion ||
    record.analysis?.type ||
    record.type ||
    'neutral';
}

/**
 * 获取情绪波动级别
 * @param {Number} volatilityIndex 情绪波动指数
 * @returns {String} 波动级别描述
 */
function getVolatilityLevel(volatilityIndex) {
  if (volatilityIndex <= 20) return '非常稳定';
  if (volatilityIndex <= 40) return '稳定';
  if (volatilityIndex <= 60) return '中等';
  if (volatilityIndex <= 80) return '波动';
  return '剧烈波动';
}

/**
 * 计算情绪波动变化百分比
 * @param {Number} current 当前波动指数
 * @param {Number} previous 上一时段波动指数
 * @returns {Number} 变化百分比
 */
function calculateVolatilityChangePercent(current, previous) {
  if (previous === 0) return 0;
  return Math.round(((current - previous) / previous) * 100);
}

/**
 * 分析情绪波动原因
 * @param {Array} currentRecords 当前时段情绪记录
 * @param {Array} previousRecords 上一时段情绪记录
 * @returns {String} 波动原因描述
 */
function analyzeVolatilityReason(currentRecords, previousRecords) {
  if (!currentRecords || currentRecords.length === 0) {
    return '数据不足，无法分析波动原因';
  }

  // 获取主导情绪
  const emotionCounts = {};
  currentRecords.forEach(record => {
    const type = getEmotionType(record);
    emotionCounts[type] = (emotionCounts[type] || 0) + 1;
  });

  // 找出出现次数最多的情绪
  let dominantEmotion = 'neutral';
  let maxCount = 0;

  for (const [emotion, count] of Object.entries(emotionCounts)) {
    if (count > maxCount) {
      maxCount = count;
      dominantEmotion = emotion;
    }
  }

  // 情绪类型映射表（英文到中文）
  const emotionTypeMap = {
    'joy': '喜悦',
    'sadness': '伤感',
    'anger': '愤怒',
    'anxiety': '焦虑',
    'neutral': '平静',
    'tired': '疲惫',
    'surprise': '惊讶',
    'calm': '平静',
    'happy': '开心',
    'sad': '难过',
    'angry': '生气',
    'fear': '恐惧',
    'disgust': '厌恶',
    'anticipation': '期待',
    'trust': '信任',
    'curious': '好奇',
    'caring': '关心',
    'grateful': '感激',
    'inquisitive': '好奇心',
    'concerned': '关切',
    'compassionate': '关怀',
    'thankful': '感恩',
    'appreciative': '感激不尽'
  };

  // 获取中文情绪名称
  const dominantEmotionCN = emotionTypeMap[dominantEmotion] || dominantEmotion;

  // 计算情绪强度平均值
  const intensities = currentRecords.map(record =>
    record.analysis?.intensity || record.analysis?.arousal || 0.5
  );
  const avgIntensity = intensities.reduce((sum, val) => sum + val, 0) / intensities.length;

  // 情绪强度描述
  let intensityDesc = '';
  if (avgIntensity < 0.3) intensityDesc = '较低';
  else if (avgIntensity < 0.6) intensityDesc = '中等';
  else intensityDesc = '较高';

  // 情绪变化频率
  const changeRate = countEmotionTypeChanges(currentRecords);
  let changeDesc = '';
  if (changeRate < 0.3) changeDesc = '较少';
  else if (changeRate < 0.6) changeDesc = '适中';
  else changeDesc = '频繁';

  // 生成波动原因描述
  let reason = `这可能与你最近${dominantEmotionCN}情绪为主，情绪强度${intensityDesc}，且情绪变化${changeDesc}有关`;

  // 如果有上一时段数据，进行对比分析
  if (previousRecords && previousRecords.length > 0) {
    const prevDominantEmotion = getMainEmotionType(previousRecords);
    const prevDominantEmotionCN = emotionTypeMap[prevDominantEmotion] || prevDominantEmotion;

    if (dominantEmotion !== prevDominantEmotion) {
      reason += `。相比之前的${prevDominantEmotionCN}情绪，情绪类型发生了变化`;
    }
  }

  return reason;
}

/**
 * 获取主要情绪类型
 * @param {Array} records 情绪记录数组
 * @returns {String} 主要情绪类型
 */
function getMainEmotionType(records) {
  if (!records || records.length === 0) return 'neutral';

  const emotionCounts = {};
  records.forEach(record => {
    const type = getEmotionType(record);
    emotionCounts[type] = (emotionCounts[type] || 0) + 1;
  });

  let mainType = 'neutral';
  let maxCount = 0;

  for (const [type, count] of Object.entries(emotionCounts)) {
    if (count > maxCount) {
      maxCount = count;
      mainType = type;
    }
  }

  return mainType;
}

/**
 * 按时间段分组情绪记录
 * @param {Array} records 情绪记录数组
 * @returns {Object} 分组后的记录
 */
function groupRecordsByTimeRange(records) {
  if (!records || records.length === 0) {
    return {
      currentWeek: [],
      lastWeek: [],
      twoWeeksAgo: []
    };
  }

  // 获取当前时间
  const now = new Date();

  // 计算时间范围
  const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const twoWeeksAgoDate = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
  const threeWeeksAgo = new Date(now.getTime() - 21 * 24 * 60 * 60 * 1000);

  // 分组
  const currentWeek = [];
  const lastWeek = [];
  const twoWeeksAgoRecords = [];

  records.forEach(record => {
    // 获取记录时间
    let recordTime;

    if (record.createTime) {
      // 处理不同的时间格式
      if (typeof record.createTime === 'object' && record.createTime.$date) {
        recordTime = new Date(record.createTime.$date);
      } else {
        recordTime = new Date(record.createTime);
      }
    } else if (record.timestamp) {
      recordTime = new Date(record.timestamp);
    } else {
      // 如果没有时间字段，跳过该记录
      return;
    }

    // 分组
    if (recordTime >= oneWeekAgo) {
      currentWeek.push(record);
    } else if (recordTime >= twoWeeksAgoDate) {
      lastWeek.push(record);
    } else if (recordTime >= threeWeeksAgo) {
      twoWeeksAgoRecords.push(record);
    }
  });

  return {
    currentWeek,
    lastWeek,
    twoWeeksAgo: twoWeeksAgoRecords
  };
}

/**
 * 计算并返回情绪波动指数数据
 * @param {Array} records 情绪记录数组
 * @returns {Object} 情绪波动指数数据
 */
function getEmotionalVolatilityData(records) {
  // 按时间段分组
  const groupedRecords = groupRecordsByTimeRange(records);

  // 计算各时间段的波动指数
  const currentVolatility = calculateEmotionalVolatility(groupedRecords.currentWeek);
  const lastVolatility = calculateEmotionalVolatility(groupedRecords.lastWeek);
  const twoWeeksAgoVolatility = calculateEmotionalVolatility(groupedRecords.twoWeeksAgo);

  // 计算变化百分比
  const changePercent = calculateVolatilityChangePercent(currentVolatility, lastVolatility);

  // 获取波动级别
  const volatilityLevel = getVolatilityLevel(currentVolatility);

  // 分析波动原因
  const volatilityReason = analyzeVolatilityReason(groupedRecords.currentWeek, groupedRecords.lastWeek);

  // 返回结果
  return {
    volatilityIndex: {
      current: currentVolatility,
      previous: lastVolatility,
      twoWeeksAgo: twoWeeksAgoVolatility,
      changePercent: changePercent
    },
    volatilityLevel: volatilityLevel,
    volatilityReason: volatilityReason,
    chartData: [
      {
        value: twoWeeksAgoVolatility,
        label: '上上周'
      },
      {
        value: lastVolatility,
        label: '上周'
      },
      {
        value: currentVolatility,
        label: '本周'
      }
    ]
  };
}


/**
 * 获取关键词情感统计
 * @param {string} userId 用户ID
 * @returns {Promise<Object>} 关键词情感统计数据
 */
async function getKeywordEmotionStats(userId) {
  try {
    if (!userId) {
      console.warn('获取关键词情感统计失败: 用户ID不能为空');
      return { positive: [], negative: [], neutral: [] };
    }

    // 调用云函数获取关键词情感统计
    const result = await wx.cloud.callFunction({
      name: 'analysis',
      data: {
        type: 'get_keyword_emotion_stats',
        userId: userId
      }
    });

    if (result && result.result && result.result.success && result.result.data) {
      console.log('获取关键词情感统计成功:', result.result.data);
      return result.result.data;
    } else {
      console.warn('获取关键词情感统计失败:', result?.result?.error || '未知错误');
      return { positive: [], negative: [], neutral: [] };
    }
  } catch (error) {
    console.error('获取关键词情感统计异常:', error);
    return { positive: [], negative: [], neutral: [] };
  }
}

/**
 * 关联关键词与情感
 * @param {string} userId 用户ID
 * @param {Array} keywords 关键词数组
 * @param {Object} emotionResult 情感分析结果
 * @returns {Promise<boolean>} 是否关联成功
 */
async function linkKeywordsToEmotion(userId, keywords, emotionResult) {
  try {
    if (!userId || !Array.isArray(keywords) || keywords.length === 0 || !emotionResult) {
      console.warn('关联关键词与情感失败: 参数不完整');
      return false;
    }

    // 调用云函数关联关键词与情感
    const result = await wx.cloud.callFunction({
      name: 'analysis',
      data: {
        type: 'link_keywords_emotion',
        userId: userId,
        keywords: keywords,
        emotionResult: emotionResult
      }
    });

    if (result && result.result && result.result.success) {
      console.log('关联关键词与情感成功');
      return true;
    } else {
      console.warn('关联关键词与情感失败:', result?.result?.error || '未知错误');
      return false;
    }
  } catch (error) {
    console.error('关联关键词与情感异常:', error);
    return false;
  }
}

/**
 * 获取最新的情绪分析结果
 * @returns {Object|null} 最新的情绪分析结果，如果没有则返回null
 */
function getLatestEmotionAnalysis() {
  try {
    // 从本地缓存中获取最新的情绪分析结果
    const cachedResult = wx.getStorageSync('latestEmotionAnalysis');

    // 检查缓存是否存在且有效
    if (cachedResult && cachedResult.success && cachedResult.data) {
      // 检查缓存是否过期（24小时）
      const now = new Date().getTime();
      const cacheTime = cachedResult.data.timestamp || 0;
      const cacheAge = now - cacheTime;

      // 如果缓存不超过24小时，则返回缓存的结果
      if (cacheAge < 24 * 60 * 60 * 1000) {
        console.log('使用缓存的情绪分析结果，缓存时间：', new Date(cacheTime).toLocaleString());
        return cachedResult;
      } else {
        console.log('缓存的情绪分析结果已过期');
      }
    } else {
      console.log('本地缓存中没有有效的情绪分析结果');
    }

    return null;
  } catch (error) {
    console.error('获取缓存的情绪分析结果失败:', error);
    return null;
  }
}

// 创建服务对象
const emotionService = {
  EmotionTypes,
  EmotionTypeLabels,
  EmotionTypeColors,
  analyzeEmotion,
  saveEmotionRecord,
  getEmotionHistory,
  matchRoleByEmotion,
  checkEmotionChangeAndSuggestRoleSwitch,
  formatChatHistoryForAnalysis,
  // 情绪波动指数相关函数
  calculateEmotionalVolatility,
  getVolatilityLevel,
  analyzeVolatilityReason,
  getEmotionalVolatilityData,
  // 关键词情感相关函数
  getKeywordEmotionStats,
  linkKeywordsToEmotion,
  // 缓存相关函数
  getLatestEmotionAnalysis
};

// 导出服务对象
module.exports = emotionService;



*#*#*end*#*#*

*#*#*miniprogram\services\eventBus.js*#*#*begin*#*#*
/**
 * 事件总线模块
 * 提供事件发布/订阅功能，用于实现事件驱动架构
 */

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 事件处理器映射
const eventHandlers = {};

// 事件类型枚举
const EventTypes = {
  // 消息相关事件
  MESSAGE_CREATED: 'message_created',
  MESSAGE_UPDATED: 'message_updated',
  MESSAGE_DELETED: 'message_deleted',

  // 情感分析相关事件
  EMOTION_ANALYZED: 'emotion_analyzed',
  EMOTION_RECORD_CREATED: 'emotion_record_created',

  // 用户兴趣相关事件
  INTEREST_UPDATED: 'interest_updated',
  INTEREST_BATCH_UPDATED: 'interest_batch_updated',

  // 用户画像相关事件
  PERCEPTION_UPDATED: 'perception_updated',
  PERCEPTION_GENERATED: 'perception_generated',

  // 角色相关事件
  ROLE_SELECTED: 'role_selected',
  ROLE_CREATED: 'role_created',
  ROLE_UPDATED: 'role_updated',

  // 聊天相关事件
  CHAT_STARTED: 'chat_started',
  CHAT_ENDED: 'chat_ended',

  // 系统相关事件
  USER_LOGGED_IN: 'user_logged_in',
  USER_LOGGED_OUT: 'user_logged_out',
  SYSTEM_ERROR: 'system_error'
};

/**
 * 订阅事件
 * @param {string} eventType 事件类型
 * @param {Function} handler 事件处理函数
 * @returns {Function} 取消订阅的函数
 */
function subscribe(eventType, handler) {
  if (!eventType || typeof handler !== 'function') {
    console.error('订阅事件失败: 参数无效');
    return () => {};
  }

  // 初始化事件类型的处理器数组
  if (!eventHandlers[eventType]) {
    eventHandlers[eventType] = [];
  }

  // 添加处理器
  eventHandlers[eventType].push(handler);

  // 返回取消订阅的函数
  return () => {
    unsubscribe(eventType, handler);
  };
}

/**
 * 取消订阅事件
 * @param {string} eventType 事件类型
 * @param {Function} handler 事件处理函数
 */
function unsubscribe(eventType, handler) {
  if (!eventType || !eventHandlers[eventType]) {
    return;
  }

  // 如果没有提供处理器，清除该事件类型的所有处理器
  if (!handler) {
    eventHandlers[eventType] = [];
    return;
  }

  // 移除特定处理器
  const index = eventHandlers[eventType].indexOf(handler);
  if (index !== -1) {
    eventHandlers[eventType].splice(index, 1);
  }
}

/**
 * 发布事件
 * @param {string} eventType 事件类型
 * @param {Object} eventData 事件数据
 */
function publish(eventType, eventData = {}) {
  if (!eventType) {
    console.error('发布事件失败: 事件类型不能为空');
    return;
  }

  // 如果没有该事件类型的处理器，直接返回
  if (!eventHandlers[eventType] || eventHandlers[eventType].length === 0) {
    if (isDev) {
      console.log(`没有处理器订阅事件: ${eventType}`);
    }
    return;
  }

  // 添加事件元数据
  const event = {
    type: eventType,
    timestamp: Date.now(),
    ...eventData
  };

  if (isDev) {
    console.log(`发布事件: ${eventType}`, event);
  }

  // 调用所有处理器
  eventHandlers[eventType].forEach(handler => {
    try {
      handler(event);
    } catch (error) {
      console.error(`事件处理器异常: ${eventType}`, error.message || error);
    }
  });
}

/**
 * 异步发布事件
 * @param {string} eventType 事件类型
 * @param {Object} eventData 事件数据
 * @returns {Promise<void>}
 */
async function publishAsync(eventType, eventData = {}) {
  if (!eventType) {
    console.error('异步发布事件失败: 事件类型不能为空');
    return;
  }

  // 如果没有该事件类型的处理器，直接返回
  if (!eventHandlers[eventType] || eventHandlers[eventType].length === 0) {
    if (isDev) {
      console.log(`没有处理器订阅事件: ${eventType}`);
    }
    return;
  }

  // 添加事件元数据
  const event = {
    type: eventType,
    timestamp: Date.now(),
    ...eventData
  };

  if (isDev) {
    console.log(`异步发布事件: ${eventType}`, event);
  }

  // 异步调用所有处理器
  const promises = eventHandlers[eventType].map(handler => {
    return new Promise(resolve => {
      try {
        const result = handler(event);
        if (result instanceof Promise) {
          result.then(resolve).catch(error => {
            console.error(`异步事件处理器异常: ${eventType}`, error.message || error);
            resolve();
          });
        } else {
          resolve();
        }
      } catch (error) {
        console.error(`事件处理器异常: ${eventType}`, error.message || error);
        resolve();
      }
    });
  });

  await Promise.all(promises);
}

/**
 * 清除所有事件处理器
 */
function clear() {
  Object.keys(eventHandlers).forEach(eventType => {
    eventHandlers[eventType] = [];
  });
}

// 导出模块
module.exports = {
  EventTypes,
  subscribe,
  unsubscribe,
  publish,
  publishAsync,
  clear
};

*#*#*end*#*#*

*#*#*miniprogram\services\focusAnalysisService.js*#*#*begin*#*#*
/**
 * 关注点分析服务
 * 提供用户关注点分析相关功能
 */

// 引入云函数调用工具
const cloudFuncCaller = require('./cloudFuncCaller');
const userService = require('./userService');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

/**
 * 分析用户关注点
 * @param {string} userId 用户ID，默认为当前登录用户
 * @param {Array} keywords 关键词数组，可选
 * @param {Array} emotionRecords 情绪记录数组，可选
 * @param {Date} date 指定日期，可选
 * @returns {Promise<Object>} 分析结果
 */
async function analyzeFocusPoints(userId = null, keywords = null, emotionRecords = null, date = null) {
  try {
    // 如果没有提供用户ID，获取当前登录用户
    if (!userId) {
      const userInfo = await userService.getUserInfo();
      userId = userInfo.openId;
    }

    // 验证用户ID
    if (!userId) {
      if (isDev) {
        console.warn('分析用户关注点失败: 用户ID为空');
      }
      return {
        success: false,
        error: '用户ID不能为空'
      };
    }

    // 准备参数
    const params = {
      type: 'focus_points',
      userId: userId
    };

    // 如果提供了关键词，添加到参数中
    if (keywords && Array.isArray(keywords) && keywords.length > 0) {
      params.keywords = keywords;
    }

    // 如果提供了情绪记录，添加到参数中
    if (emotionRecords && Array.isArray(emotionRecords) && emotionRecords.length > 0) {
      params.emotionRecords = emotionRecords;
    }

    // 如果提供了日期，添加到参数中
    if (date) {
      params.date = date;
    }

    // 调用云函数
    if (isDev) {
      console.log('调用云函数分析用户关注点:', params);
    }
    const result = await cloudFuncCaller.callCloudFunc('analysis', params);

    // 返回结果
    return result;
  } catch (error) {
    console.error('分析用户关注点异常:', error.message || error);
    return {
      success: false,
      error: error.message || '分析用户关注点失败'
    };
  }
}

/**
 * 获取用户关注点分析结果
 * @param {string} userId 用户ID，默认为当前登录用户
 * @param {Date} date 指定日期，默认为当天
 * @param {boolean} forceRefresh 是否强制刷新，默认为false
 * @returns {Promise<Object>} 分析结果
 */
async function getUserFocusPoints(userId = null, date = null, forceRefresh = false) {
  try {
    // 如果没有提供用户ID，获取当前登录用户
    if (!userId) {
      const userInfo = await userService.getUserInfo();
      userId = userInfo.openId;
    }

    // 验证用户ID
    if (!userId) {
      if (isDev) {
        console.warn('获取用户关注点失败: 用户ID为空');
      }
      return {
        success: false,
        error: '用户ID不能为空'
      };
    }

    // 检查缓存
    if (!forceRefresh) {
      const cachedData = getCachedFocusPoints(userId, date);
      if (cachedData) {
        if (isDev) {
          console.log('使用缓存的用户关注点数据');
        }
        return cachedData;
      }
    }

    // 分析用户关注点
    const result = await analyzeFocusPoints(userId, null, null, date);

    // 如果分析成功，缓存结果
    if (result.success && result.data) {
      cacheFocusPoints(userId, result.data, date);
    }

    // 返回结果
    return result;
  } catch (error) {
    console.error('获取用户关注点异常:', error.message || error);
    return {
      success: false,
      error: error.message || '获取用户关注点失败'
    };
  }
}

// 缓存相关函数
const CACHE_KEY_PREFIX = 'user_focus_points_cache_';
const CACHE_EXPIRY = 30 * 60 * 1000; // 30分钟

/**
 * 获取缓存的关注点数据
 * @param {string} userId 用户ID
 * @param {Date} date 日期
 * @returns {Object|null} 缓存的数据或null
 */
function getCachedFocusPoints(userId, date) {
  // 生成缓存键
  const dateStr = date ? new Date(date).toISOString().split('T')[0] : 'latest';
  const cacheKey = `${CACHE_KEY_PREFIX}${userId}_${dateStr}`;

  const cacheString = wx.getStorageSync(cacheKey);
  if (!cacheString) return null;

  try {
    const cache = JSON.parse(cacheString);

    // 检查缓存是否过期
    const now = Date.now();
    if (now - cache.timestamp > CACHE_EXPIRY) return null;

    return {
      success: true,
      data: cache.data
    };
  } catch (e) {
    console.error('解析缓存数据失败:', e.message || e);
    return null;
  }
}

/**
 * 缓存关注点数据
 * @param {string} userId 用户ID
 * @param {Object} data 数据
 * @param {Date} date 日期
 */
function cacheFocusPoints(userId, data, date) {
  // 生成缓存键
  const dateStr = date ? new Date(date).toISOString().split('T')[0] : 'latest';
  const cacheKey = `${CACHE_KEY_PREFIX}${userId}_${dateStr}`;

  const cacheData = {
    timestamp: Date.now(),
    data: data
  };

  try {
    wx.setStorageSync(cacheKey, JSON.stringify(cacheData));
  } catch (e) {
    console.error('缓存关注点数据失败:', e.message || e);
  }
}

/**
 * 清除关注点缓存
 * @param {string} userId 用户ID
 * @param {Date} date 日期，如果不提供则清除所有日期的缓存
 */
function clearFocusPointsCache(userId, date) {
  if (date) {
    // 清除指定日期的缓存
    const dateStr = new Date(date).toISOString().split('T')[0];
    const cacheKey = `${CACHE_KEY_PREFIX}${userId}_${dateStr}`;
    wx.removeStorageSync(cacheKey);
  } else {
    // 清除所有日期的缓存
    try {
      const keys = wx.getStorageInfoSync().keys;
      const prefix = `${CACHE_KEY_PREFIX}${userId}_`;
      keys.forEach(key => {
        if (key.startsWith(prefix)) {
          wx.removeStorageSync(key);
        }
      });
    } catch (e) {
      console.error('清除关注点缓存失败:', e.message || e);
    }
  }
}

// 导出模块
module.exports = {
  analyzeFocusPoints,
  getUserFocusPoints,
  clearFocusPointsCache
};

*#*#*end*#*#*

*#*#*miniprogram\services\imageService.js*#*#*begin*#*#*
// 图片资源服务

// 云环境ID
const ENV_ID = 'cloud1-9gpfk3ie94d8630a'; // 云环境ID

// 图片资源映射表
const IMAGE_MAP = {
  // 图标
  'icons/back': 'cloud://'+ENV_ID+'.icons/back.png',
  'icons/emotion': 'cloud://'+ENV_ID+'.icons/emotion.png',
  'icons/voice': 'cloud://'+ENV_ID+'.icons/voice.png',
  'icons/send': 'cloud://'+ENV_ID+'.icons/send.png',
  'icons/close': 'cloud://'+ENV_ID+'.icons/close.png',
  'icons/personality': 'cloud://'+ENV_ID+'.icons/personality.png',
  'icons/user-info': 'cloud://'+ENV_ID+'.icons/user-info.png',
  'icons/interests': 'cloud://'+ENV_ID+'.icons/interests.png',
  'icons/settings': 'cloud://'+ENV_ID+'.icons/settings.png',
  'icons/dark-mode': 'cloud://'+ENV_ID+'.icons/dark-mode.png',
  'icons/clear-history': 'cloud://'+ENV_ID+'.icons/clear-history.png',
  'icons/arrow-right': 'cloud://'+ENV_ID+'.icons/arrow-right.png',
  'icons/about': 'cloud://'+ENV_ID+'.icons/about.png',

  // 头像
  'avatars/default-avatar': 'cloud://'+ENV_ID+'.avatars/default-avatar.png',

};

// 本地图片映射表（作为备用）
const LOCAL_IMAGE_MAP = {
  'icons/back': '/images/icons/back.png',
  'icons/emotion': '/images/icons/emotion.png',
  'icons/voice': '/images/icons/voice.png',
  'icons/send': '/images/icons/send.png',
  'icons/close': '/images/icons/close.png',
  'avatars/default-avatar': '/images/avatars/default-avatar.png',
  'icons/personality': '/images/icons/personality.png',
  'icons/user-info': '/images/icons/user-info.png',
  'icons/interests': '/images/icons/interests.png',
  'icons/settings': '/images/icons/settings.png',
  'icons/dark-mode': '/images/icons/dark-mode.png',
  'icons/clear-history': '/images/icons/clear-history.png',
  'icons/arrow-right': '/images/icons/arrow-right.png',
  'icons/about': '/images/icons/about.png',
};

// 默认头像
const DEFAULT_AVATARS = {
  user: '/images/system/default-avatar.png',
  role: '/images/avatars/default-avatar.png'
};

// 图片缓存
let imageCache = {};

/**
 * 获取图片URL
 * @param {string} key 图片键名
 * @param {boolean} useLocal 是否使用本地图片（默认false）
 * @returns {string} 图片URL
 */
function getImageUrl(key, useLocal = false) {
  // 如果键名不存在，返回空字符串
  if (!key) {
    console.warn('图片键名不能为空');
    return '';
  }

  try {
    // 获取app实例
    const app = getApp();

    // 如果指定使用本地图片或者app未初始化或云环境未初始化，则使用本地图片
    if (useLocal || !app || !app.globalData || !app.globalData.cloudInit) {
      return LOCAL_IMAGE_MAP[key] || '';
    }

    // 否则使用云存储图片
    return IMAGE_MAP[key] || LOCAL_IMAGE_MAP[key] || '';
  } catch (error) {
    console.error('获取图片URL失败:', error);
    return LOCAL_IMAGE_MAP[key] || '';
  }
}

/**
 * 预加载常用图片
 * @param {Array<string>} keys 图片键名数组
 * @returns {Promise<void>}
 */
async function preloadImages(keys = []) {
  const promises = keys.map(key => {
    const url = getImageUrl(key);
    return new Promise((resolve, reject) => {
      wx.getImageInfo({
        src: url,
        success: resolve,
        fail: reject
      });
    });
  });

  try {
    await Promise.all(promises);
    console.log('图片预加载完成');
  } catch (error) {
    console.error('图片预加载失败:', error);
  }
}

/**
 * 初始化图片服务
 * @returns {Promise<void>}
 */
async function initImageService() {
  // 获取app实例
  const app = getApp();

  // 检查app和云环境是否初始化
  if (!app || !app.globalData || !app.globalData.cloudInit) {
    console.warn('应用或云环境未初始化，将使用本地图片');
    return;
  }

  // 从本地存储加载缓存的图片URL
  try {
    const cachedImages = wx.getStorageSync('imageCache');
    if (cachedImages) {
      imageCache = JSON.parse(cachedImages);
    }
  } catch (error) {
    console.error('Failed to load image cache:', error);
    imageCache = {};
  }

  // 预加载常用图片
  const commonImages = [
    'icons/back',
    'icons/emotion',
    'icons/voice',
    'icons/send',
    'icons/close',
    'avatars/default-avatar'
  ];

  await preloadImages(commonImages);
}

/**
 * 上传图片到云存储
 * @param {string} filePath 本地文件路径
 * @param {string} folder 存储文件夹，如 'users', 'roles'
 * @param {string} userId 用户ID，可选
 * @returns {Promise<{fileID: string, tempFileURL: string}>} 上传结果
 */
async function uploadImage(filePath, folder = 'images', userId = '') {
  try {
    // 获取app实例
    const app = getApp();

    // 检查app和云环境是否初始化
    if (!app || !app.globalData || !app.globalData.cloudInit) {
      throw new Error('应用或云环境未初始化，无法上传图片');
    }
    // 生成唯一文件名
    const timestamp = new Date().getTime();
    const randomStr = Math.random().toString(36).substring(2, 8);
    const extension = filePath.split('.').pop();

    // 构建云存储路径
    let cloudPath = `${folder}/`;
    if (userId) {
      cloudPath += `${userId}/`;
    }
    cloudPath += `${timestamp}_${randomStr}.${extension}`;

    // 显示加载提示
    wx.showLoading({ title: '上传中...' });

    // 添加重试机制
    let retryCount = 3;
    let success = false;
    let uploadResult = null;
    let error = null;

    while (retryCount >= 0 && !success) {
      try {
        // 上传文件
        uploadResult = await wx.cloud.uploadFile({
          cloudPath,
          filePath
        });

        if (uploadResult && uploadResult.fileID) {
          success = true;
        } else {
          throw new Error('上传返回结果无效');
        }
      } catch (uploadError) {
        error = uploadError;
        console.warn(`上传尝试失败，剩余重试次数: ${retryCount}`, uploadError);
        retryCount--;

        if (retryCount < 0) {
          break;
        }

        // 等待一段时间再重试
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    if (!success) {
      throw error || new Error('上传失败');
    }

    // 获取文件链接
    const { fileList } = await wx.cloud.getTempFileURL({
      fileList: [uploadResult.fileID]
    });

    wx.hideLoading();

    if (fileList[0].status === 0) {
      // 缓存图片URL
      cacheImage(uploadResult.fileID, fileList[0].tempFileURL);

      return {
        fileID: uploadResult.fileID,
        tempFileURL: fileList[0].tempFileURL
      };
    } else {
      throw new Error(fileList[0].errMsg || '获取文件链接失败');
    }
  } catch (error) {
    wx.hideLoading();
    console.error('Upload image failed:', error);

    // 提供更具体的错误信息
    let errorMsg = '上传文件失败';
    if (error.errMsg) {
      if (error.errMsg.includes('TLS connection')) {
        errorMsg = '网络连接不稳定，请检查网络';
      } else if (error.errMsg.includes('timeout')) {
        errorMsg = '上传超时，请重试';
      }
    }

    wx.showToast({
      title: errorMsg,
      icon: 'none',
      duration: 2000
    });

    throw error;
  }
}

/**
 * 上传头像
 * @param {string} filePath 本地文件路径
 * @param {string} userId 用户ID
 * @param {string} type 头像类型，'user'或'role'
 * @returns {Promise<string>} 文件ID
 */
async function uploadAvatar(filePath, userId, type = 'user') {
  try {
    const folder = type === 'user' ? 'users' : 'roles';
    const result = await uploadImage(filePath, folder, userId);
    return result.fileID;
  } catch (error) {
    console.error('Upload avatar failed:', error);
    throw error;
  }
}

/**
 * 缓存图片URL
 * @param {string} fileID 文件ID
 * @param {string} url 临时URL
 */
function cacheImage(fileID, url) {
  if (!fileID || !url) return;

  imageCache[fileID] = url;

  // 保存到本地存储
  try {
    wx.setStorageSync('imageCache', JSON.stringify(imageCache));
  } catch (error) {
    console.error('Failed to save image cache:', error);
  }
}

/**
 * 获取图片临时URL
 * @param {string} fileID 文件ID
 * @returns {Promise<string>} 临时URL
 */
async function getImageTempURL(fileID) {
  // 如果是本地路径，直接返回
  if (!fileID || fileID.startsWith('/') || fileID.startsWith('http')) {
    return fileID;
  }

  // 获取app实例
  const app = getApp();

  // 检查app和云环境是否初始化
  if (!app || !app.globalData || !app.globalData.cloudInit) {
    console.warn('应用或云环境未初始化，无法获取云存储图片');
    return fileID;
  }

  // 检查缓存
  if (imageCache[fileID]) {
    return imageCache[fileID];
  }

  try {
    const { fileList } = await wx.cloud.getTempFileURL({
      fileList: [fileID]
    });

    if (fileList[0].status === 0) {
      const url = fileList[0].tempFileURL;
      cacheImage(fileID, url);
      return url;
    }
    return null;
  } catch (error) {
    console.error('Get image URL failed:', error);
    return null;
  }
}

/**
 * 获取默认头像
 * @param {string} type 头像类型，'user'或'role'
 * @returns {string} 默认头像路径
 */
function getDefaultAvatar(type = 'user') {
  return DEFAULT_AVATARS[type] || DEFAULT_AVATARS.user;
}

/**
 * 清除图片缓存
 */
function clearImageCache() {
  imageCache = {};
  try {
    wx.removeStorageSync('imageCache');
  } catch (error) {
    console.error('Failed to clear image cache:', error);
  }
}

// 导出图片服务
export default {
  getImageUrl,
  preloadImages,
  initImageService,
  uploadImage,
  uploadAvatar,
  getImageTempURL,
  getDefaultAvatar,
  clearImageCache
};


*#*#*end*#*#*

*#*#*miniprogram\services\keywordService.js*#*#*begin*#*#*
/**
 * 关键词服务模块
 * 提供关键词提取、存储和检索功能
 */

// 引入云函数调用工具
const cloudFuncCaller = require('./cloudFuncCaller');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

/**
 * 从文本中提取关键词
 * @param {string} text 待分析文本
 * @param {number} topK 返回关键词数量，默认10个
 * @returns {Promise<Array>} 关键词数组，每个元素包含word和weight字段
 */
async function extractKeywords(text, topK = 10) {
  try {
    if (!text || typeof text !== 'string' || text.trim() === '') {
      if (isDev) {
        console.warn('提取关键词失败: 文本为空');
      }
      return [];
    }

    // 调用云函数提取关键词
    const result = await cloudFuncCaller.callCloudFunc('analysis', {
      type: 'keywords',
      text,
      topK
    });

    if (result.success && result.data && result.data.keywords) {
      return result.data.keywords;
    } else {
      if (isDev) {
        console.warn('提取关键词失败:', result.error || '未知错误');
      }
      return [];
    }
  } catch (error) {
    console.error('提取关键词异常:', error.message || error);
    return [];
  }
}

/**
 * 获取词向量
 * @param {Array<string>} texts 文本数组
 * @returns {Promise<Array>} 词向量数组
 */
async function getWordVectors(texts) {
  try {
    if (!Array.isArray(texts) || texts.length === 0) {
      if (isDev) {
        console.warn('获取词向量失败: 文本数组为空');
      }
      return [];
    }

    // 调用云函数获取词向量
    const result = await cloudFuncCaller.callCloudFunc('analysis', {
      type: 'word_vectors',
      texts
    });

    if (result.success && result.data && result.data.vectors) {
      return result.data.vectors;
    } else {
      if (isDev) {
        console.warn('获取词向量失败:', result.error || '未知错误');
      }
      return [];
    }
  } catch (error) {
    console.error('获取词向量异常:', error.message || error);
    return [];
  }
}

/**
 * 聚类分析关键词
 * @param {string} text 待分析文本
 * @param {number} threshold 聚类阈值，默认0.7
 * @param {number} minClusterSize 最小簇大小，默认2
 * @returns {Promise<Array>} 聚类结果数组
 */
async function clusterKeywords(text, threshold = 0.7, minClusterSize = 2) {
  try {
    if (!text || typeof text !== 'string' || text.trim() === '') {
      if (isDev) {
        console.warn('聚类分析失败: 文本为空');
      }
      return [];
    }

    // 调用云函数进行聚类分析
    const result = await cloudFuncCaller.callCloudFunc('analysis', {
      type: 'cluster',
      text,
      threshold,
      minClusterSize
    });

    if (result.success && result.data && result.data.clusters) {
      return result.data.clusters;
    } else {
      if (isDev) {
        console.warn('聚类分析失败:', result.error || '未知错误');
      }
      return [];
    }
  } catch (error) {
    console.error('聚类分析异常:', error.message || error);
    return [];
  }
}

/**
 * 分析用户兴趣
 * @param {Array<string>} messages 用户消息数组
 * @returns {Promise<Object>} 用户兴趣分析结果
 */
async function analyzeUserInterests(messages) {
  try {
    if (!Array.isArray(messages) || messages.length === 0) {
      if (isDev) {
        console.warn('分析用户兴趣失败: 消息数组为空');
      }
      return { interests: [], summary: '' };
    }

    // 调用云函数分析用户兴趣
    const result = await cloudFuncCaller.callCloudFunc('analysis', {
      type: 'user_interests',
      messages
    });

    if (result.success && result.data) {
      return result.data;
    } else {
      if (isDev) {
        console.warn('分析用户兴趣失败:', result.error || '未知错误');
      }
      return { interests: [], summary: '' };
    }
  } catch (error) {
    console.error('分析用户兴趣异常:', error.message || error);
    return { interests: [], summary: '' };
  }
}

/**
 * 获取用户兴趣数据
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Object>} 用户兴趣数据
 */
async function getUserInterests(userId, forceRefresh = false) {
  try {
    if (!userId) {
      if (isDev) {
        console.warn('获取用户兴趣数据失败: 用户ID为空');
      }
      return { keywords: [] };
    }

    // 检查缓存
    if (!forceRefresh) {
      const cachedData = getCachedInterests(userId);
      if (cachedData) {
        if (isDev) {
          console.log('使用缓存的用户兴趣数据');
        }
        return cachedData;
      }
    }

    // 调用云函数获取用户兴趣数据
    const result = await cloudFuncCaller.callCloudFunc('user', {
      action: 'getUserInterests',
      userId
    });

    if (result.success && result.data) {
      // 更新缓存
      cacheInterests(userId, result.data);
      return result.data;
    } else {
      if (isDev) {
        console.warn('获取用户兴趣数据失败:', result.error || '未知错误');
      }
      return { keywords: [] };
    }
  } catch (error) {
    console.error('获取用户兴趣数据异常:', error.message || error);
    return { keywords: [] };
  }
}

/**
 * 更新用户兴趣数据
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @param {number} weightDelta 权重变化值
 * @returns {Promise<boolean>} 是否更新成功
 */
async function updateUserInterest(userId, keyword, weightDelta = 0.1) {
  try {
    if (!userId || !keyword) {
      if (isDev) {
        console.warn('更新用户兴趣数据失败: 参数不完整');
      }
      return false;
    }

    // 调用云函数更新用户兴趣数据
    const result = await cloudFuncCaller.callCloudFunc('user', {
      action: 'updateUserInterest',
      userId,
      keyword,
      weightDelta
    });

    if (result.success) {
      // 清除缓存
      clearInterestsCache(userId);
      return true;
    } else {
      if (isDev) {
        console.warn('更新用户兴趣数据失败:', result.error || '未知错误');
      }
      return false;
    }
  } catch (error) {
    console.error('更新用户兴趣数据异常:', error.message || error);
    return false;
  }
}

/**
 * 批量更新用户兴趣数据
 * @param {string} userId 用户ID
 * @param {Array} keywords 关键词数组，每个元素包含word和weight字段
 * @param {boolean} autoClassify 是否自动分类关键词
 * @param {Object} categoryStats 分类统计数据，可选
 * @param {Array} categoriesArray 分类数组，可选
 * @returns {Promise<boolean>} 是否更新成功
 */
async function batchUpdateUserInterests(userId, keywords, autoClassify = true, categoryStats = null, categoriesArray = null) {
  try {
    if (!userId || !Array.isArray(keywords) || keywords.length === 0) {
      if (isDev) {
        console.warn('批量更新用户兴趣数据失败: 参数不完整');
      }
      return false;
    }

    // 调用云函数批量更新用户兴趣数据
    const result = await cloudFuncCaller.callCloudFunc('user', {
      action: 'batchUpdateUserInterests',
      userId,
      keywords,
      autoClassify,
      categoryStats,
      categoriesArray
    });

    if (result.success) {
      // 清除缓存
      clearInterestsCache(userId);
      return true;
    } else {
      if (isDev) {
        console.warn('批量更新用户兴趣数据失败:', result.error || '未知错误');
      }
      return false;
    }
  } catch (error) {
    console.error('批量更新用户兴趣数据异常:', error.message || error);
    return false;
  }
}

/**
 * 从对话中提取关键词并更新用户兴趣
 * @param {string} userId 用户ID
 * @param {string} text 对话文本
 * @returns {Promise<boolean>} 是否更新成功
 */
async function processDialogueAndUpdateInterests(userId, text) {
  try {
    if (!userId || !text) {
      if (isDev) {
        console.warn('处理对话并更新兴趣失败: 参数不完整');
      }
      return false;
    }

    // 提取关键词
    const keywords = await extractKeywords(text, 5);
    if (keywords.length === 0) {
      if (isDev) {
        console.log('未从对话中提取到关键词');
      }
      return false;
    }

    // 引入用户兴趣服务
    const userInterestsService = require('./userInterestsService');

    // 尝试分类关键词
    try {
      // 调用云函数分类关键词
      const result = await wx.cloud.callFunction({
        name: 'analysis',
        data: {
          type: 'classify_keywords',
          keywords: keywords.map(k => k.word),
          batch: true
        }
      });

      if (result.result && result.result.success &&
          result.result.data && Array.isArray(result.result.data.classifications)) {

        // 将分类结果转换为映射
        const categoryMap = {};
        result.result.data.classifications.forEach(item => {
          categoryMap[item.keyword] = item.category;
        });

        // 将分类结果合并到关键词中
        const classifiedKeywords = keywords.map(keyword => ({
          word: keyword.word,
          weight: keyword.weight,
          category: categoryMap[keyword.word] || '未分类',
          emotionScore: 0
        }));

        // 创建分类统计数据
        const categoryStats = {};
        classifiedKeywords.forEach(keyword => {
          if (keyword.category) {
            categoryStats[keyword.category] = (categoryStats[keyword.category] || 0) + 1;
          }
        });

        // 创建分类数组
        const categoriesArray = Object.entries(categoryStats).map(([name, count]) => ({
          name,
          count,
          firstSeen: new Date(),
          lastUpdated: new Date()
        }));

        // 批量更新用户兴趣
        return await userInterestsService.batchUpdateUserInterests(
          userId,
          classifiedKeywords,
          true, // 自动分类
          categoryStats, // 传递分类统计
          categoriesArray // 传递分类数组
        );
      }
    } catch (classifyError) {
      console.error('分类关键词失败:', classifyError.message || classifyError);
      // 分类失败不影响主流程
    }

    // 如果分类失败，使用默认分类
    const defaultKeywords = keywords.map(keyword => ({
      word: keyword.word,
      weight: keyword.weight,
      category: '未分类',
      emotionScore: 0
    }));

    // 创建默认分类统计数据
    const categoryStats = {
      '未分类': defaultKeywords.length
    };

    // 创建分类数组
    const categoriesArray = [{
      name: '未分类',
      count: defaultKeywords.length,
      firstSeen: new Date(),
      lastUpdated: new Date()
    }];

    // 批量更新用户兴趣
    return await userInterestsService.batchUpdateUserInterests(
      userId,
      defaultKeywords,
      true, // 自动分类
      categoryStats, // 传递分类统计
      categoriesArray // 传递分类数组
    );
  } catch (error) {
    console.error('处理对话并更新兴趣异常:', error.message || error);
    return false;
  }
}

// 缓存相关函数
const CACHE_KEY_PREFIX = 'user_interests_cache_';
const CACHE_EXPIRY = 30 * 60 * 1000; // 30分钟

/**
 * 获取缓存的兴趣数据
 * @param {string} userId 用户ID
 * @returns {Object|null} 缓存的数据或null
 */
function getCachedInterests(userId) {
  const cacheKey = CACHE_KEY_PREFIX + userId;
  const cacheString = wx.getStorageSync(cacheKey);
  if (!cacheString) return null;

  try {
    const cache = JSON.parse(cacheString);

    // 检查缓存是否过期
    const now = Date.now();
    if (now - cache.timestamp > CACHE_EXPIRY) return null;

    return cache.data;
  } catch (e) {
    console.error('解析缓存数据失败:', e.message || e);
    return null;
  }
}

/**
 * 缓存兴趣数据
 * @param {string} userId 用户ID
 * @param {Object} data 要缓存的数据
 */
function cacheInterests(userId, data) {
  const cacheKey = CACHE_KEY_PREFIX + userId;
  const cacheData = {
    timestamp: Date.now(),
    data
  };

  wx.setStorageSync(cacheKey, JSON.stringify(cacheData));
}

/**
 * 清除兴趣数据缓存
 * @param {string} userId 用户ID，如果不提供则清除所有用户的缓存
 */
function clearInterestsCache(userId) {
  if (userId) {
    const cacheKey = CACHE_KEY_PREFIX + userId;
    wx.removeStorageSync(cacheKey);
  } else {
    // 获取所有storage keys
    const keys = wx.getStorageInfoSync().keys;
    // 清除所有以CACHE_KEY_PREFIX开头的缓存
    keys.forEach(key => {
      if (key.startsWith(CACHE_KEY_PREFIX)) {
        wx.removeStorageSync(key);
      }
    });
  }
}

// 导出模块
module.exports = {
  extractKeywords,
  getWordVectors,
  clusterKeywords,
  analyzeUserInterests,
  getUserInterests,
  updateUserInterest,
  batchUpdateUserInterests,
  processDialogueAndUpdateInterests,
  clearInterestsCache
};

*#*#*end*#*#*

*#*#*miniprogram\services\modelService.js*#*#*begin*#*#*
/**
 * 模型服务
 * 提供AI模型选择和管理功能
 *
 * @architecture 该模块实现了AI模型的选择和管理功能，支持在不同AI模型之间切换
 * @dependency cloudFuncCaller 云函数调用工具
 * @history 2025-05-01 初始版本
 * @history 2025-05-10 添加OpenAI模型支持
 * @history 2025-05-15 添加Crond和CloseAI模型支持，实现动态模型列表
 */

// 导入云函数调用工具
const cloudFuncCaller = require('./cloudFuncCaller');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 模型类型常量
const MODEL_TYPES = {
  ZHIPU: 'zhipu',     // 智谱AI
  GEMINI: 'gemini',   // Google Gemini
  OPENAI: 'openai',   // OpenAI
  CROND: 'crond',     // Crond API
  CLOSEAI: 'closeai'  // CloseAI API
};

// 默认模型类型
const DEFAULT_MODEL_TYPE = MODEL_TYPES.GEMINI; // 默认使用Google Gemini

// 本地缓存键
const MODEL_TYPE_KEY = 'selected_model_type';
const MODEL_LIST_KEY = 'model_list';
const MODEL_LIST_EXPIRY_KEY = 'model_list_expiry';

/**
 * 获取当前选择的模型类型
 * @returns {string} 模型类型
 */
function getSelectedModelType() {
  try {
    // 从本地缓存获取
    const modelType = wx.getStorageSync(MODEL_TYPE_KEY);
    return modelType || DEFAULT_MODEL_TYPE;
  } catch (error) {
    console.error('获取模型类型失败:', error.message || error);
    return DEFAULT_MODEL_TYPE;
  }
}

/**
 * 设置当前选择的模型类型
 * @param {string} modelType 模型类型
 * @returns {boolean} 是否设置成功
 */
function setSelectedModelType(modelType) {
  try {
    // 验证模型类型
    if (!Object.values(MODEL_TYPES).includes(modelType)) {
      console.error('无效的模型类型:', modelType);
      return false;
    }

    // 保存到本地缓存
    wx.setStorageSync(MODEL_TYPE_KEY, modelType);

    if (isDev) {
      console.log('设置模型类型成功:', modelType);
    }

    return true;
  } catch (error) {
    console.error('设置模型类型失败:', error.message || error);
    return false;
  }
}

/**
 * 获取所有可用的模型类型
 * @returns {Array} 模型类型数组
 */
function getAvailableModelTypes() {
  return Object.values(MODEL_TYPES);
}

/**
 * 获取模型类型的显示名称
 * @param {string} modelType 模型类型
 * @returns {string} 显示名称
 */
function getModelDisplayName(modelType) {
  switch (modelType) {
    case MODEL_TYPES.ZHIPU:
      return '智谱AI';
    case MODEL_TYPES.GEMINI:
      return 'Google Gemini';
    case MODEL_TYPES.OPENAI:
      return 'OpenAI';
    case MODEL_TYPES.CROND:
      return 'Crond API';
    case MODEL_TYPES.CLOSEAI:
      return 'CloseAI';
    default:
      return '未知模型';
  }
}

/**
 * 测试模型连接
 * @param {string} modelType 模型类型
 * @returns {Promise<Object>} 测试结果
 */
async function testModelConnection(modelType) {
  try {
    // 验证模型类型
    if (!Object.values(MODEL_TYPES).includes(modelType)) {
      return {
        success: false,
        error: '无效的模型类型'
      };
    }

    // 调用云函数测试连接
    const result = await cloudFuncCaller.callCloudFunc('chat', {
      action: 'testConnection',
      modelType: modelType
    });

    return result;
  } catch (error) {
    console.error('测试模型连接失败:', error.message || error);
    return {
      success: false,
      error: error.message || '测试模型连接失败'
    };
  }
}

/**
 * 获取模型配置信息
 * @param {string} modelType 模型类型
 * @returns {Object} 模型配置信息
 */
function getModelConfig(modelType) {
  switch (modelType) {
    case MODEL_TYPES.ZHIPU:
      return {
        name: '智谱AI',
        models: ['glm-4-flash', 'glm-4'],
        features: ['情感分析', '关键词提取', '用户画像'],
        description: '智谱AI提供高质量的对话生成和情感分析功能，支持中文语境的深度理解。'
      };
    case MODEL_TYPES.GEMINI:
      return {
        name: 'Google Gemini',
        models: ['gemini-2.5-flash-preview-04-17'],
        features: ['情感分析', '关键词提取', '多模态理解'],
        description: 'Google Gemini是一个强大的多模态AI模型，支持文本、图像等多种输入，提供高质量的对话生成和分析功能。'
      };
    case MODEL_TYPES.OPENAI:
      return {
        name: 'OpenAI',
        models: ['gpt-3.5-turbo', 'gpt-4', 'gpt-4-turbo'],
        features: ['情感分析', '关键词提取', '用户画像', '高级推理'],
        description: 'OpenAI提供业界领先的大语言模型，具有强大的理解能力和生成能力，支持多种语言和复杂任务。'
      };
    case MODEL_TYPES.CROND:
      return {
        name: 'Crond API',
        models: ['gpt-4o-mini', 'deepseek-v3', 'o3-mini'],
        features: ['对话生成', '高级推理'],
        description: 'Crond API提供多种大语言模型，支持高质量的对话生成和推理能力。'
      };
    case MODEL_TYPES.CLOSEAI:
      return {
        name: 'CloseAI',
        models: ['deepseek-ai/DeepSeek-V3-0324'],
        features: ['对话生成', '中文理解'],
        description: 'CloseAI提供DeepSeek系列模型，具有出色的中文理解能力和对话生成能力。'
      };
    default:
      return {
        name: '未知模型',
        models: [],
        features: [],
        description: '未知模型类型'
      };
  }
}

/**
 * 获取模型列表
 * @param {string} modelType 模型类型
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Array<string>>} 模型列表
 */
async function getModelList(modelType, forceRefresh = false) {
  try {
    // 验证模型类型
    if (!Object.values(MODEL_TYPES).includes(modelType)) {
      console.error('无效的模型类型:', modelType);
      return [];
    }

    // 检查缓存
    if (!forceRefresh) {
      const cachedList = wx.getStorageSync(`${MODEL_LIST_KEY}_${modelType}`);
      const expiry = wx.getStorageSync(`${MODEL_LIST_EXPIRY_KEY}_${modelType}`);

      // 如果缓存存在且未过期（24小时有效期）
      if (cachedList && expiry && Date.now() < expiry) {
        if (isDev) {
          console.log(`使用缓存的模型列表 (${modelType}):`, cachedList);
        }
        return cachedList;
      }
    }

    // 调用云函数获取模型列表
    const result = await cloudFuncCaller.callCloudFunc('chat', {
      action: 'getModelList',
      modelType: modelType
    });

    if (result && result.success && Array.isArray(result.models)) {
      // 缓存结果，24小时有效期
      wx.setStorageSync(`${MODEL_LIST_KEY}_${modelType}`, result.models);
      wx.setStorageSync(`${MODEL_LIST_EXPIRY_KEY}_${modelType}`, Date.now() + 24 * 60 * 60 * 1000);

      if (isDev) {
        console.log(`获取模型列表成功 (${modelType}):`, result.models);
      }

      return result.models;
    }

    // 如果API调用失败，返回默认配置中的模型列表
    const config = getModelConfig(modelType);
    return config.models || [];
  } catch (error) {
    console.error('获取模型列表失败:', error.message || error);

    // 出错时返回默认配置中的模型列表
    const config = getModelConfig(modelType);
    return config.models || [];
  }
}

/**
 * 获取当前选择的模型
 * @param {string} modelType 模型类型
 * @returns {string} 模型名称
 */
function getSelectedModel(modelType) {
  try {
    // 从本地缓存获取
    const modelName = wx.getStorageSync(`selected_model_${modelType}`);

    // 如果没有缓存，返回该类型的默认模型
    if (!modelName) {
      const config = getModelConfig(modelType);
      return config.models && config.models.length > 0 ? config.models[0] : '';
    }

    return modelName;
  } catch (error) {
    console.error('获取选择的模型失败:', error.message || error);

    // 出错时返回该类型的默认模型
    const config = getModelConfig(modelType);
    return config.models && config.models.length > 0 ? config.models[0] : '';
  }
}

/**
 * 设置当前选择的模型
 * @param {string} modelType 模型类型
 * @param {string} modelName 模型名称
 * @returns {boolean} 是否设置成功
 */
function setSelectedModel(modelType, modelName) {
  try {
    // 验证模型类型
    if (!Object.values(MODEL_TYPES).includes(modelType)) {
      console.error('无效的模型类型:', modelType);
      return false;
    }

    // 保存到本地缓存
    wx.setStorageSync(`selected_model_${modelType}`, modelName);

    if (isDev) {
      console.log(`设置模型成功: ${modelType} - ${modelName}`);
    }

    return true;
  } catch (error) {
    console.error('设置选择的模型失败:', error.message || error);
    return false;
  }
}

// 导出模块
module.exports = {
  MODEL_TYPES,
  DEFAULT_MODEL_TYPE,
  getSelectedModelType,
  setSelectedModelType,
  getAvailableModelTypes,
  getModelDisplayName,
  testModelConnection,
  getModelConfig,
  getModelList,
  getSelectedModel,
  setSelectedModel
};

*#*#*end*#*#*

*#*#*miniprogram\services\personalityService.js*#*#*begin*#*#*
/**
 * 用户画像服务模块
 * 提供用户画像生成、存储和检索功能
 */

// 引入云函数调用工具
const cloudFuncCaller = require('./cloudFuncCaller');

/**
 * 获取用户画像
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Object>} 用户画像数据
 */
async function getUserPerception(userId, forceRefresh = false) {
  try {
    if (!userId) {
      console.warn('获取用户画像失败: 用户ID为空');
      return null;
    }

    // 检查缓存
    if (!forceRefresh) {
      const cachedData = getCachedPerception(userId);
      if (cachedData) {
        console.log('使用缓存的用户画像数据');
        return cachedData;
      }
    }

    // 调用云函数获取用户画像
    const result = await cloudFuncCaller.callCloudFunc('user', {
      action: 'getUserPerception',
      userId
    });

    if (result.success && result.data) {
      // 更新缓存
      cachePerception(userId, result.data);
      return result.data;
    } else {
      console.warn('获取用户画像失败:', result.error || '未知错误');
      return null;
    }
  } catch (error) {
    console.error('获取用户画像异常:', error);
    return null;
  }
}

/**
 * 生成用户画像
 * @param {string} userId 用户ID
 * @param {boolean} useAI 是否使用AI增强
 * @returns {Promise<Object>} 生成结果
 */
async function generateUserPerception(userId, useAI = true) {
  try {
    if (!userId) {
      console.warn('生成用户画像失败: 用户ID为空');
      return { success: false, error: '用户ID不能为空' };
    }

    // 调用云函数生成用户画像
    const result = await cloudFuncCaller.callCloudFunc('user', {
      action: 'generateUserPerception',
      userId,
      useAI
    }, {
      showLoading: true,
      loadingText: '正在生成用户画像...'
    });

    if (result.success && result.data) {
      // 更新缓存
      cachePerception(userId, result.data);
      return { success: true, data: result.data };
    } else {
      console.warn('生成用户画像失败:', result.error || '未知错误');
      return { success: false, error: result.error || '生成用户画像失败' };
    }
  } catch (error) {
    console.error('生成用户画像异常:', error);
    return { success: false, error: error.message || '生成用户画像异常' };
  }
}

/**
 * 获取用户个性特征
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Array>} 个性特征数组
 */
async function getPersonalityTraits(userId, forceRefresh = false) {
  try {
    const perception = await getUserPerception(userId, forceRefresh);
    if (!perception || !perception.personalityTraits) {
      console.warn('获取用户个性特征失败: 用户画像数据不完整');
      return [];
    }

    return perception.personalityTraits;
  } catch (error) {
    console.error('获取用户个性特征异常:', error);
    return [];
  }
}

/**
 * 获取用户兴趣标签
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Array>} 兴趣标签数组
 */
async function getUserInterests(userId, forceRefresh = false) {
  try {
    const perception = await getUserPerception(userId, forceRefresh);
    if (!perception || !perception.interests) {
      console.warn('获取用户兴趣标签失败: 用户画像数据不完整');
      return [];
    }

    return perception.interests;
  } catch (error) {
    console.error('获取用户兴趣标签异常:', error);
    return [];
  }
}

/**
 * 获取用户情感模式
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Object>} 情感模式数据
 */
async function getEmotionPatterns(userId, forceRefresh = false) {
  try {
    const perception = await getUserPerception(userId, forceRefresh);
    if (!perception || !perception.emotionPatterns) {
      console.warn('获取用户情感模式失败: 用户画像数据不完整');
      return null;
    }

    return perception.emotionPatterns;
  } catch (error) {
    console.error('获取用户情感模式异常:', error);
    return null;
  }
}

/**
 * 获取用户个性总结
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<string>} 个性总结文本
 */
async function getPersonalitySummary(userId, forceRefresh = false) {
  try {
    const perception = await getUserPerception(userId, forceRefresh);
    if (!perception || !perception.personalitySummary) {
      console.warn('获取用户个性总结失败: 用户画像数据不完整');
      return '';
    }

    return perception.personalitySummary;
  } catch (error) {
    console.error('获取用户个性总结异常:', error);
    return '';
  }
}

/**
 * 生成用户画像系统提示词
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<string>} 系统提示词
 */
async function generateUserSystemPrompt(userId, forceRefresh = false) {
  try {
    const perception = await getUserPerception(userId, forceRefresh);
    if (!perception) {
      console.warn('生成用户系统提示词失败: 无法获取用户画像');
      return '';
    }

    // 构建系统提示词
    let prompt = '以下是关于用户的信息，请在回复中考虑这些特点：\n\n';

    // 添加个性总结
    if (perception.personalitySummary) {
      prompt += `用户个性：${perception.personalitySummary}\n\n`;
    }

    // 添加个性特征
    if (perception.personalityTraits && perception.personalityTraits.length > 0) {
      prompt += '用户个性特征：\n';
      perception.personalityTraits.forEach(trait => {
        const score = Math.round(trait.score * 100);
        prompt += `- ${trait.trait}：${score}%\n`;
      });
      prompt += '\n';
    }

    // 添加兴趣标签
    if (perception.interests && perception.interests.length > 0) {
      prompt += `用户兴趣：${perception.interests.join('、')}\n\n`;
    }

    // 添加情感模式
    if (perception.emotionPatterns) {
      const patterns = perception.emotionPatterns;
      
      if (patterns.dominantEmotions && patterns.dominantEmotions.length > 0) {
        prompt += '用户主要情绪：';
        patterns.dominantEmotions.forEach((emotion, index) => {
          prompt += `${emotion.emotion}(${emotion.percentage}%)`;
          if (index < patterns.dominantEmotions.length - 1) {
            prompt += '、';
          }
        });
        prompt += '\n';
      }
      
      if (patterns.emotionTrends && patterns.emotionTrends.trend) {
        prompt += `情绪趋势：${patterns.emotionTrends.trend}\n`;
      }
    }

    return prompt;
  } catch (error) {
    console.error('生成用户系统提示词异常:', error);
    return '';
  }
}

// 缓存相关函数
const PERCEPTION_CACHE_KEY = 'user_perception_cache_';
const CACHE_EXPIRY = 60 * 60 * 1000; // 1小时

/**
 * 获取缓存的用户画像数据
 * @param {string} userId 用户ID
 * @returns {Object|null} 缓存的数据或null
 */
function getCachedPerception(userId) {
  const cacheKey = PERCEPTION_CACHE_KEY + userId;
  const cacheString = wx.getStorageSync(cacheKey);
  if (!cacheString) return null;
  
  try {
    const cache = JSON.parse(cacheString);
    
    // 检查缓存是否过期
    const now = Date.now();
    if (now - cache.timestamp > CACHE_EXPIRY) return null;
    
    return cache.data;
  } catch (e) {
    console.error('解析缓存数据失败:', e);
    return null;
  }
}

/**
 * 缓存用户画像数据
 * @param {string} userId 用户ID
 * @param {Object} data 要缓存的数据
 */
function cachePerception(userId, data) {
  const cacheKey = PERCEPTION_CACHE_KEY + userId;
  const cacheData = {
    timestamp: Date.now(),
    data
  };
  
  wx.setStorageSync(cacheKey, JSON.stringify(cacheData));
}

/**
 * 清除用户画像缓存
 * @param {string} userId 用户ID，如果不提供则清除所有用户的缓存
 */
function clearPerceptionCache(userId) {
  if (userId) {
    const cacheKey = PERCEPTION_CACHE_KEY + userId;
    wx.removeStorageSync(cacheKey);
  } else {
    // 获取所有storage keys
    const keys = wx.getStorageInfoSync().keys;
    // 清除所有以PERCEPTION_CACHE_KEY开头的缓存
    keys.forEach(key => {
      if (key.startsWith(PERCEPTION_CACHE_KEY)) {
        wx.removeStorageSync(key);
      }
    });
  }
}

// 导出模块
module.exports = {
  getUserPerception,
  generateUserPerception,
  getPersonalityTraits,
  getUserInterests,
  getEmotionPatterns,
  getPersonalitySummary,
  generateUserSystemPrompt,
  clearPerceptionCache
};

*#*#*end*#*#*

*#*#*miniprogram\services\reportService.js*#*#*begin*#*#*
/**
 * 每日心情报告服务
 */

/**
 * 获取用户每日报告
 * @param {string} date 日期字符串 (YYYY-MM-DD)
 * @param {boolean} forceRegenerate 是否强制重新生成
 * @returns {Promise<object>} 报告数据
 */
async function getDailyReport(date, forceRegenerate = false) {
    try {
        // 验证日期
        const reportDate = date ? new Date(date) : new Date();

        // 调用云函数
        const { result } = await wx.cloud.callFunction({
            name: 'analysis',
            data: {
                type: 'daily_report',
                date: reportDate,
                forceRegenerate
            }
        });

        if (!result.success) {
            throw new Error(result.error || '获取报告失败');
        }

        return {
            success: true,
            report: result.report,
            isNew: result.isNew
        };
    } catch (error) {
        console.error('获取每日报告失败:', error);
        return {
            success: false,
            error: error.message || '获取报告失败'
        };
    }
}

/**
 * 获取用户报告列表
 * @param {number} limit 限制数量
 * @param {number} skip 跳过数量
 * @returns {Promise<object>} 报告列表
 */
async function getReportList(limit = 10, skip = 0) {
    try {
        // 调用云函数
        const { result } = await wx.cloud.callFunction({
            name: 'user',
            data: {
                action: 'getReportList',
                limit,
                skip
            }
        });

        if (!result.success) {
            throw new Error(result.error || '获取报告列表失败');
        }

        return {
            success: true,
            reports: result.reports,
            total: result.total
        };
    } catch (error) {
        console.error('获取报告列表失败:', error);
        return {
            success: false,
            error: error.message || '获取报告列表失败'
        };
    }
}

/**
 * 标记报告为已读
 * @param {string} reportId 报告ID
 * @returns {Promise<object>} 操作结果
 */
async function markReportAsRead(reportId) {
    try {
        // 调用云函数
        const { result } = await wx.cloud.callFunction({
            name: 'user',
            data: {
                action: 'markReportAsRead',
                reportId
            }
        });

        if (!result.success) {
            throw new Error(result.error || '标记报告失败');
        }

        return {
            success: true
        };
    } catch (error) {
        console.error('标记报告为已读失败:', error);
        return {
            success: false,
            error: error.message || '标记报告失败'
        };
    }
}

/**
 * 获取用户兴趣数据
 * @returns {Promise<object>} 兴趣数据
 */
async function getUserInterests() {
    try {
        // 调用云函数
        const { result } = await wx.cloud.callFunction({
            name: 'user',
            data: {
                action: 'getUserInterests'
            }
        });

        if (!result.success) {
            throw new Error(result.error || '获取兴趣数据失败');
        }

        return {
            success: true,
            interests: result.interests
        };
    } catch (error) {
        console.error('获取用户兴趣数据失败:', error);
        return {
            success: false,
            error: error.message || '获取兴趣数据失败'
        };
    }
}

// 导出服务
module.exports = {
    getDailyReport,
    getReportList,
    markReportAsRead,
    getUserInterests
};
*#*#*end*#*#*

*#*#*miniprogram\services\userInterestsService.js*#*#*begin*#*#*
/**
 * 用户兴趣服务
 * 提供用户兴趣数据的获取和更新功能
 */

// 引入事件总线
const eventBus = require('./eventBus');
const { EventTypes } = eventBus;

// 缓存相关常量
const CACHE_KEY_PREFIX = 'user_interests_cache_';
const CACHE_EXPIRY = 30 * 60 * 1000; // 30分钟

/**
 * 获取用户兴趣数据
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Object>} 用户兴趣数据
 */
async function getUserInterests(userId, forceRefresh = false) {
  try {
    if (!userId) {
      console.warn('获取用户兴趣数据失败: 用户ID为空');
      return { keywords: [] };
    }

    // 检查缓存
    if (!forceRefresh) {
      const cachedData = getCachedInterests(userId);
      if (cachedData) {
        console.log('使用缓存的用户兴趣数据');
        return cachedData;
      }
    }

    // 调用云函数
    console.log('调用云函数获取用户兴趣数据');
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'getUserInterests',
        userId
      }
    });

    console.log('云函数返回结果:', result);

    if (result.result && result.result.success) {
      const interestsData = result.result.data || { keywords: [] };

      // 更新缓存
      cacheInterests(userId, interestsData);

      return interestsData;
    } else {
      console.warn('获取用户兴趣数据失败:', result.result ? result.result.error : '未知错误');
      return { keywords: [] };
    }
  } catch (error) {
    console.error('获取用户兴趣数据异常:', error);
    return { keywords: [] };
  }
}

/**
 * 更新用户兴趣关键词
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @param {number} weightDelta 权重变化值
 * @returns {Promise<boolean>} 是否更新成功
 */
async function updateUserInterest(userId, keyword, weightDelta = 0.1) {
  try {
    if (!userId || !keyword) {
      console.warn('更新用户兴趣关键词失败: 参数不完整');
      return false;
    }

    // 调用云函数
    console.log('调用云函数更新用户兴趣关键词');
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'updateUserInterest',
        userId,
        keyword,
        weightDelta
      }
    });

    console.log('云函数返回结果:', result);

    if (result.result && result.result.success) {
      // 清除缓存
      clearInterestsCache(userId);

      // 发布事件
      eventBus.publish(EventTypes.INTEREST_UPDATED, {
        userId,
        keyword,
        weightDelta
      });

      return true;
    } else {
      console.warn('更新用户兴趣关键词失败:', result.result ? result.result.error : '未知错误');
      return false;
    }
  } catch (error) {
    console.error('更新用户兴趣关键词异常:', error);
    return false;
  }
}

/**
 * 批量更新用户兴趣关键词
 * @param {string} userId 用户ID
 * @param {Array} keywords 关键词数组，每个元素包含word和weight字段
 * @param {boolean} autoClassify 是否自动分类关键词
 * @param {Object} categoryStats 分类统计数据，可选
 * @param {Array} categoriesArray 分类数组，可选
 * @returns {Promise<boolean>} 是否更新成功
 */
async function batchUpdateUserInterests(userId, keywords, autoClassify = true, categoryStats = null, categoriesArray = null) {
  try {
    if (!userId || !Array.isArray(keywords) || keywords.length === 0) {
      console.warn('批量更新用户兴趣关键词失败: 参数不完整');
      return {
        success: false,
        error: '参数不完整',
        data: null
      };
    }

    // 处理关键词数据，确保每个关键词都有分类和情感分数
    const processedKeywords = keywords.map(keyword => {
      // 确保关键词对象包含必要字段
      return {
        word: keyword.word,
        weight: keyword.weight || 1,
        category: keyword.category || '未分类',
        emotionScore: keyword.emotionScore || 0,
        lastUpdated: new Date()
      };
    });

    console.log('处理后的关键词数据:', JSON.stringify(processedKeywords, null, 2));

    // 如果没有提供分类统计，则生成分类统计
    if (!categoryStats) {
      categoryStats = {};
      processedKeywords.forEach(keyword => {
        const category = keyword.category || '未分类';
        categoryStats[category] = (categoryStats[category] || 0) + 1;
      });
    }

    console.log('分类统计数据:', JSON.stringify(categoryStats, null, 2));

    // 调用云函数
    console.log('调用云函数批量更新用户兴趣关键词');
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'batchUpdateUserInterests',
        userId,
        keywords: processedKeywords,
        autoClassify,
        categoryStats,
        categoriesArray
      }
    });

    console.log('云函数返回结果:', result);

    if (result.result && result.result.success) {
      // 清除缓存
      clearInterestsCache(userId);

      // 发布事件
      eventBus.publish(EventTypes.INTEREST_BATCH_UPDATED, {
        userId,
        keywords: processedKeywords,
        categoryStats,
        categoriesArray
      });

      return {
        success: true,
        message: '批量更新用户兴趣关键词成功',
        data: {
          userId,
          keywords: processedKeywords,
          categoryStats,
          categoriesArray,
          result: result.result
        }
      };
    } else {
      const errorMsg = result.result ? result.result.error : '未知错误';
      console.warn('批量更新用户兴趣关键词失败:', errorMsg);
      return {
        success: false,
        error: errorMsg,
        data: null
      };
    }
  } catch (error) {
    console.error('批量更新用户兴趣关键词异常:', error);
    return {
      success: false,
      error: error.message || '批量更新用户兴趣关键词异常',
      data: null
    };
  }
}

/**
 * 删除用户兴趣关键词
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @returns {Promise<boolean>} 是否删除成功
 */
async function deleteUserInterest(userId, keyword) {
  try {
    if (!userId || !keyword) {
      console.warn('删除用户兴趣关键词失败: 参数不完整');
      return false;
    }

    // 调用云函数
    console.log('调用云函数删除用户兴趣关键词');
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'deleteUserInterest',
        userId,
        keyword
      }
    });

    console.log('云函数返回结果:', result);

    if (result.result && result.result.success) {
      // 清除缓存
      clearInterestsCache(userId);

      // 发布事件
      eventBus.publish(EventTypes.INTEREST_UPDATED, {
        userId,
        keyword,
        deleted: true
      });

      return true;
    } else {
      console.warn('删除用户兴趣关键词失败:', result.result ? result.result.error : '未知错误');
      return false;
    }
  } catch (error) {
    console.error('删除用户兴趣关键词异常:', error);
    return false;
  }
}

/**
 * 更新关键词分类
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @param {string} category 分类
 * @returns {Promise<boolean>} 是否更新成功
 */
async function updateKeywordCategory(userId, keyword, category) {
  try {
    if (!userId || !keyword || !category) {
      console.warn('更新关键词分类失败: 参数不完整');
      return false;
    }

    // 调用云函数
    console.log('调用云函数更新关键词分类');
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'updateKeywordCategory',
        userId,
        keyword,
        category
      }
    });

    console.log('云函数返回结果:', result);

    if (result.result && result.result.success) {
      // 清除缓存
      clearInterestsCache(userId);

      // 发布事件
      eventBus.publish(EventTypes.INTEREST_UPDATED, {
        userId,
        keyword,
        category
      });

      return true;
    } else {
      console.warn('更新关键词分类失败:', result.result ? result.result.error : '未知错误');
      return false;
    }
  } catch (error) {
    console.error('更新关键词分类异常:', error);
    return false;
  }
}

/**
 * 批量更新关键词分类
 * @param {string} userId 用户ID
 * @param {Array} categorizations 分类数组，每个元素包含keyword和category字段
 * @returns {Promise<boolean>} 是否更新成功
 */
async function batchUpdateKeywordCategories(userId, categorizations) {
  try {
    if (!userId || !Array.isArray(categorizations) || categorizations.length === 0) {
      console.warn('批量更新关键词分类失败: 参数不完整');
      return false;
    }

    // 调用云函数
    console.log('调用云函数批量更新关键词分类');
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'batchUpdateKeywordCategories',
        userId,
        categorizations
      }
    });

    console.log('云函数返回结果:', result);

    if (result.result && result.result.success) {
      // 清除缓存
      clearInterestsCache(userId);

      // 发布事件
      eventBus.publish(EventTypes.INTEREST_BATCH_UPDATED, {
        userId,
        categorizations
      });

      return true;
    } else {
      console.warn('批量更新关键词分类失败:', result.result ? result.result.error : '未知错误');
      return false;
    }
  } catch (error) {
    console.error('批量更新关键词分类异常:', error);
    return false;
  }
}

/**
 * 更新关键词情感分数
 * @param {string} userId 用户ID
 * @param {string} keyword 关键词
 * @param {number} emotionScore 情感分数
 * @returns {Promise<boolean>} 是否更新成功
 */
async function updateKeywordEmotionScore(userId, keyword, emotionScore) {
  try {
    if (!userId || !keyword || typeof emotionScore !== 'number') {
      console.warn('更新关键词情感分数失败: 参数不完整');
      return false;
    }

    // 调用云函数
    console.log('调用云函数更新关键词情感分数');
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'updateKeywordEmotionScore',
        userId,
        keyword,
        emotionScore
      }
    });

    console.log('云函数返回结果:', result);

    if (result.result && result.result.success) {
      // 清除缓存
      clearInterestsCache(userId);

      // 发布事件
      eventBus.publish(EventTypes.INTEREST_UPDATED, {
        userId,
        keyword,
        emotionScore
      });

      return true;
    } else {
      console.warn('更新关键词情感分数失败:', result.result ? result.result.error : '未知错误');
      return false;
    }
  } catch (error) {
    console.error('更新关键词情感分数异常:', error);
    return false;
  }
}

/**
 * 从对话中提取关键词并更新用户兴趣
 * @param {string} userId 用户ID
 * @param {string} text 对话文本
 * @returns {Promise<boolean>} 是否更新成功
 */
async function processDialogueAndUpdateInterests(userId, text) {
  try {
    if (!userId || !text) {
      console.warn('处理对话并更新兴趣失败: 参数不完整');
      return false;
    }

    // 调用关键词服务提取关键词
    const keywordService = require('./keywordService');
    const keywords = await keywordService.extractKeywords(text, 5);

    if (!keywords || keywords.length === 0) {
      console.log('未从对话中提取到关键词');
      return false;
    }

    // 批量更新用户兴趣
    return await batchUpdateUserInterests(userId, keywords);
  } catch (error) {
    console.error('处理对话并更新兴趣异常:', error);
    return false;
  }
}

/**
 * 获取用户兴趣标签云数据
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @param {boolean} useCategories 是否使用分类数据而不是关键词数据
 * @returns {Promise<Array>} 标签云数据数组
 */
async function getInterestTagCloudData(userId, forceRefresh = false, useCategories = true) {
  try {
    // 获取用户兴趣数据
    const interestsData = await getUserInterests(userId, forceRefresh);

    if (!interestsData) {
      console.log('用户兴趣数据为空');
      return [];
    }

    // 如果使用分类数据
    if (useCategories) {
      // 检查分类数据是否存在
      if (!interestsData.categories || !Array.isArray(interestsData.categories) || interestsData.categories.length === 0) {
        console.log('用户兴趣分类数据为空');
        return [];
      }

      // 将分类数据转换为标签云格式
      const tagCloudData = interestsData.categories.map(category => ({
        name: category.name,
        value: category.count || 0,
        category: category.name,
        isCategory: true
      }));

      // 按计数排序
      tagCloudData.sort((a, b) => b.value - a.value);

      return tagCloudData;
    } else {
      // 使用关键词数据
      if (!interestsData.keywords || interestsData.keywords.length === 0) {
        console.log('用户兴趣关键词数据为空');
        return [];
      }

      // 转换为标签云数据格式
      const tagCloudData = interestsData.keywords.map(item => ({
        name: item.word,
        value: Math.round(item.weight * 100),
        category: item.category || '未分类',
        emotionScore: item.emotionScore || 0,
        isCategory: false
      }));

      // 按权重排序
      tagCloudData.sort((a, b) => b.value - a.value);

      return tagCloudData;
    }
  } catch (error) {
    console.error('获取用户兴趣标签云数据异常:', error);
    return [];
  }
}

/**
 * 获取用户兴趣分类统计
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Object>} 分类统计数据
 */
async function getInterestCategoryStats(userId, forceRefresh = false) {
  try {
    // 获取用户兴趣数据
    const interestsData = await getUserInterests(userId, forceRefresh);

    if (!interestsData || !interestsData.keywords || interestsData.keywords.length === 0) {
      console.log('用户兴趣数据为空');
      return {};
    }

    // 统计各分类的关键词数量
    const categoryStats = {};

    interestsData.keywords.forEach(item => {
      const category = item.category || '未分类';
      categoryStats[category] = (categoryStats[category] || 0) + 1;
    });

    return categoryStats;
  } catch (error) {
    console.error('获取用户兴趣分类统计异常:', error);
    return {};
  }
}

// 缓存相关函数

/**
 * 获取缓存的兴趣数据
 * @param {string} userId 用户ID
 * @returns {Object|null} 缓存的数据或null
 */
function getCachedInterests(userId) {
  const cacheKey = CACHE_KEY_PREFIX + userId;
  const cacheString = wx.getStorageSync(cacheKey);
  if (!cacheString) return null;

  try {
    const cache = JSON.parse(cacheString);

    // 检查缓存是否过期
    const now = Date.now();
    if (now - cache.timestamp > CACHE_EXPIRY) return null;

    return cache.data;
  } catch (e) {
    console.error('解析缓存数据失败:', e);
    return null;
  }
}

/**
 * 缓存兴趣数据
 * @param {string} userId 用户ID
 * @param {Object} data 要缓存的数据
 */
function cacheInterests(userId, data) {
  const cacheKey = CACHE_KEY_PREFIX + userId;
  const cacheData = {
    timestamp: Date.now(),
    data
  };

  wx.setStorageSync(cacheKey, JSON.stringify(cacheData));
}

/**
 * 清除兴趣数据缓存
 * @param {string} userId 用户ID，如果不提供则清除所有用户的缓存
 */
function clearInterestsCache(userId) {
  if (userId) {
    const cacheKey = CACHE_KEY_PREFIX + userId;
    wx.removeStorageSync(cacheKey);
  } else {
    // 获取所有storage keys
    const keys = wx.getStorageInfoSync().keys;
    // 清除所有以CACHE_KEY_PREFIX开头的缓存
    keys.forEach(key => {
      if (key.startsWith(CACHE_KEY_PREFIX)) {
        wx.removeStorageSync(key);
      }
    });
  }
}

// 导出模块
module.exports = {
  getUserInterests,
  updateUserInterest,
  batchUpdateUserInterests,
  deleteUserInterest,
  updateKeywordCategory,
  batchUpdateKeywordCategories,
  updateKeywordEmotionScore,
  processDialogueAndUpdateInterests,
  getInterestTagCloudData,
  getInterestCategoryStats,
  clearInterestsCache
};

*#*#*end*#*#*

*#*#*miniprogram\services\userService.js*#*#*begin*#*#*
/**
 * 用户服务模块
 * 负责用户资料的获取和保存
 */

const cloudFuncCaller = require('./cloudFuncCaller');

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 缓存相关常量
const USER_PROFILE_CACHE_KEY = 'user_profile_cache_';
const CACHE_EXPIRY = 60 * 60 * 1000; // 1小时

/**
 * 获取用户资料
 * @param {string} userId 用户ID
 * @param {boolean} forceRefresh 是否强制刷新
 * @returns {Promise<Object>} 用户资料
 */
async function getUserProfile(userId, forceRefresh = false) {
  try {
    if (!userId) {
      if (isDev) {
        console.warn('获取用户资料失败: 用户ID为空');
      }
      return null;
    }

    // 检查缓存
    if (!forceRefresh) {
      const cachedData = getCachedUserProfile(userId);
      if (cachedData) {
        if (isDev) {
          console.log('使用缓存的用户资料数据');
        }
        return cachedData;
      }
    }

    // 调用云函数获取用户资料
    const result = await cloudFuncCaller.callCloudFunc('user', {
      action: 'getInfo',
      userId
    });

    if (result.success && result.data && result.data.user) {
      // 获取用户详细资料
      const userProfileResult = await getUserProfileFromDB(userId);

      // 合并基本信息和详细资料
      const profileData = {
        ...result.data.user,
        ...userProfileResult
      };

      // 更新缓存
      cacheUserProfile(userId, profileData);
      return profileData;
    } else {
      if (isDev) {
        console.warn('获取用户资料失败:', result.error || '未知错误');
      }
      return null;
    }
  } catch (error) {
    console.error('获取用户资料异常:', error.message || error);
    return null;
  }
}

/**
 * 从数据库获取用户详细资料
 * @param {string} userId 用户ID
 * @returns {Promise<Object>} 用户详细资料
 */
async function getUserProfileFromDB(userId) {
  try {
    const db = wx.cloud.database();

    // 获取用户详细资料
    const profileResult = await db.collection('user_profile')
      .where({ user_id: userId })
      .get();

    // 获取用户基本信息
    const userBaseResult = await db.collection('user_base')
      .where({ user_id: userId })
      .get();

    // 合并结果
    const profileData = profileResult.data && profileResult.data.length > 0 ? profileResult.data[0] : {};
    const userBaseData = userBaseResult.data && userBaseResult.data.length > 0 ? userBaseResult.data[0] : {};

    // 构建完整的用户资料
    return {
      ...profileData,
      username: userBaseData.username,
      avatarUrl: userBaseData.avatar_url,
      userId: userBaseData.user_id,
      // 将数据库字段名转换为前端使用的字段名
      nickName: userBaseData.username,
      gender: profileData.gender,
      age: profileData.age || '',
      bio: profileData.bio || ''
    };
  } catch (error) {
    console.error('从数据库获取用户详细资料失败:', error.message || error);
    return {};
  }
}

/**
 * 保存用户资料
 * @param {string} userId 用户ID
 * @param {Object} profileData 用户资料数据
 * @returns {Promise<boolean>} 是否保存成功
 */
async function saveUserProfile(userId, profileData) {
  try {
    if (!userId || !profileData) {
      if (isDev) {
        console.warn('保存用户资料失败: 参数不完整');
      }
      return false;
    }

    // 提取基本信息和详细资料
    const { nickName, avatarUrl } = profileData;
    const { gender, age, bio } = profileData;

    // 调用云函数保存用户资料
    const result = await cloudFuncCaller.callCloudFunc('user', {
      action: 'updateProfile',
      userId,
      username: nickName,
      avatarUrl,
      gender,
      bio,
      // 添加其他可能的字段
      country: profileData.country || '',
      province: profileData.province || '',
      city: profileData.city || '',
      settings: {
        darkMode: profileData.darkMode || false,
        notificationEnabled: profileData.notificationEnabled || true,
        language: profileData.language || 'zh_CN'
      }
    });

    if (result.success) {
      // 更新缓存
      cacheUserProfile(userId, profileData);

      // 更新本地存储的userInfo
      updateLocalUserInfo(profileData);

      return true;
    } else {
      if (isDev) {
        console.warn('保存用户资料失败:', result.error || '未知错误');
      }
      return false;
    }
  } catch (error) {
    console.error('保存用户资料异常:', error.message || error);
    return false;
  }
}

/**
 * 更新本地存储的userInfo
 * @param {Object} profileData 用户资料数据
 */
function updateLocalUserInfo(profileData) {
  try {
    // 获取当前存储的用户信息
    const userInfo = wx.getStorageSync('userInfo') || {};

    // 更新用户信息
    const updatedUserInfo = {
      ...userInfo,
      nickName: profileData.nickName || userInfo.nickName,
      avatarUrl: profileData.avatarUrl || userInfo.avatarUrl,
      gender: profileData.gender || userInfo.gender,
      age: profileData.age || userInfo.age,
      bio: profileData.bio || userInfo.bio
    };

    // 保存到本地存储
    wx.setStorageSync('userInfo', updatedUserInfo);

    // 更新全局状态
    const app = getApp();
    if (app && app.globalData) {
      app.globalData.userInfo = {
        ...app.globalData.userInfo,
        ...updatedUserInfo
      };
    }
  } catch (error) {
    console.error('更新本地用户信息失败:', error.message || error);
  }
}

/**
 * 获取缓存的用户资料
 * @param {string} userId 用户ID
 * @returns {Object|null} 缓存的数据或null
 */
function getCachedUserProfile(userId) {
  const cacheKey = USER_PROFILE_CACHE_KEY + userId;
  const cacheString = wx.getStorageSync(cacheKey);
  if (!cacheString) return null;

  try {
    const cache = JSON.parse(cacheString);

    // 检查缓存是否过期
    const now = Date.now();
    if (now - cache.timestamp > CACHE_EXPIRY) return null;

    return cache.data;
  } catch (e) {
    console.error('解析缓存数据失败:', e.message || e);
    return null;
  }
}

/**
 * 缓存用户资料
 * @param {string} userId 用户ID
 * @param {Object} data 要缓存的数据
 */
function cacheUserProfile(userId, data) {
  const cacheKey = USER_PROFILE_CACHE_KEY + userId;
  const cacheData = {
    timestamp: Date.now(),
    data
  };

  wx.setStorageSync(cacheKey, JSON.stringify(cacheData));
}

/**
 * 清除用户资料缓存
 * @param {string} userId 用户ID，如果不提供则清除所有用户的缓存
 */
function clearUserProfileCache(userId) {
  if (userId) {
    const cacheKey = USER_PROFILE_CACHE_KEY + userId;
    wx.removeStorageSync(cacheKey);
  } else {
    // 获取所有storage keys
    const keys = wx.getStorageInfoSync().keys;
    // 清除所有以USER_PROFILE_CACHE_KEY开头的缓存
    keys.forEach(key => {
      if (key.startsWith(USER_PROFILE_CACHE_KEY)) {
        wx.removeStorageSync(key);
      }
    });
  }
}

/**
 * 从用户信息中获取用户ID
 * @param {Object} userInfo - 用户信息对象
 * @returns {String|null} 用户ID
 */
function getUserId(userInfo) {
  if (!userInfo) return null;

  // 优先使用userId，其次是user_id，再次是_id，最后是openid
  return userInfo.userId || userInfo.user_id || userInfo._id || userInfo.openid || null;
}

/**
 * 从用户信息中获取openid
 * @param {Object} userInfo - 用户信息对象
 * @param {Boolean} tryCache - 是否尝试从缓存中获取
 * @returns {String|null} openid
 */
function getOpenId(userInfo, tryCache = true) {
  if (!userInfo) return null;

  // 先检查顶层
  let openid = userInfo.openid;

  // 再检查stats对象
  if (!openid && userInfo.stats && userInfo.stats.openid) {
    openid = userInfo.stats.openid;
  }

  // 如果还是没有，尝试从本地缓存中获取
  if (!openid && tryCache) {
    try {
      const cachedOpenid = wx.getStorageSync('openId');
      if (cachedOpenid) {
        openid = cachedOpenid;
      }
    } catch (e) {
      console.error('从缓存获取openid失败:', e.message || e);
    }
  }

  return openid || null;
}

/**
 * 获取用户ID和openid
 * @param {Object} userInfo - 用户信息对象
 * @param {Boolean} tryCache - 是否尝试从缓存中获取openid
 * @returns {Object} 包含userId和openid的对象
 */
function getUserIdentifiers(userInfo, tryCache = true) {
  if (!userInfo) return { userId: null, openid: null };

  const userId = getUserId(userInfo);
  const openid = getOpenId(userInfo, tryCache);

  return { userId, openid };
}

/**
 * 构建数据库查询条件
 * @param {Object} userInfo - 用户信息对象
 * @param {Boolean} tryCache - 是否尝试从缓存中获取openid
 * @returns {Object} 查询条件对象
 */
function buildUserQuery(userInfo, tryCache = true) {
  const { userId, openid } = getUserIdentifiers(userInfo, tryCache);

  // 优先使用openid查询
  if (openid) {
    return { openId: openid };
  }
  // 如果没有openid，则使用userId
  else if (userId) {
    return { userId: userId };
  }

  // 如果都没有，返回空对象
  return {};
}

/**
 * 检查用户是否有效
 * @param {Object} userInfo - 用户信息对象
 * @param {Boolean} tryCache - 是否尝试从缓存中获取openid
 * @returns {Boolean} 用户是否有效
 */
function isValidUser(userInfo, tryCache = true) {
  if (!userInfo) return false;

  const { userId, openid } = getUserIdentifiers(userInfo, tryCache);
  return !!(userId || openid);
}

module.exports = {
  getUserProfile,
  saveUserProfile,
  clearUserProfileCache,
  getUserId,
  getOpenId,
  getUserIdentifiers,
  buildUserQuery,
  isValidUser
};

*#*#*end*#*#*

*#*#*miniprogram\services\voiceService.js*#*#*begin*#*#*
/**
 * 语音服务模块
 * 提供基于讯飞语音听写的语音识别功能
 */

// 是否为开发环境，控制日志输出
const isDev = true; // 设置为true可以开启详细日志

// 录音管理器实例
let recorderManager = null;
// WebSocket连接实例
let socketTask = null;
// 讯飞APPID
let IFLYTEK_APPID = '';
// 识别结果
let recognitionResult = '';
// 回调函数
let resultCallback = null;
let errorCallback = null;
let finalResultCallback = null;
// 录音状态
let isRecording = false;

/**
 * 初始化录音管理器
 * @private
 */
function initRecorderManager() {
  // 如果已经初始化过，直接返回
  if (recorderManager) {
    console.log('录音管理器已初始化，直接使用');
    return recorderManager;
  }

  try {
    // 获取录音管理器
    recorderManager = wx.getRecorderManager();
    console.log('初始化录音管理器成功');

    // 监听录音开始事件
    recorderManager.onStart(() => {
      console.log('录音开始事件触发');
      isRecording = true;
      recognitionResult = ''; // 重置识别结果

      // 立即发送业务参数帧，不等待WebSocket连接成功
      if (socketTask && socketTask.readyState === 1) {
        sendBusinessParamsFrame();
      }
    });

    // 监听录音结束事件
    recorderManager.onStop((res) => {
      console.log('录音结束事件触发', res);
      isRecording = false;

      // 发送结束帧
      if (socketTask && socketTask.readyState === 1) {
        sendEndFrame();
      }
    });

    // 监听录音错误事件
    recorderManager.onError((err) => {
      console.error('录音错误事件触发', err);
      isRecording = false;

      if (errorCallback) {
        errorCallback(err);
      }

      // 关闭WebSocket连接
      closeSocketConnection();
    });

    // 监听录音帧数据事件
    recorderManager.onFrameRecorded((res) => {
      if (!socketTask || socketTask.readyState !== 1) return;

      // 将音频数据发送到讯飞服务器
      if (res.frameBuffer && res.frameBuffer.byteLength > 0) {
        // 立即发送音频数据
        sendAudioFrame(res.frameBuffer);
      }
    });

    return recorderManager;
  } catch (err) {
    console.error('初始化录音管理器失败', err);
    throw err;
  }
}

// 提前初始化录音管理器，减少首次使用时的延迟
initRecorderManager();

/**
 * 获取讯飞WebSocket URL
 * @returns {Promise<string>} WebSocket URL
 * @private
 */
async function getWebSocketUrl() {
  try {
    const result = await wx.cloud.callFunction({
      name: 'getIflytekSttUrl'
    });

    if (result.result && result.result.success) {
      IFLYTEK_APPID = result.result.appid;
      return result.result.wssUrl;
    } else {
      throw new Error(result.result.error || '获取语音服务连接失败');
    }
  } catch (error) {
    console.error('获取WebSocket URL失败', error);
    throw error;
  }
}

/**
 * 建立WebSocket连接
 * @param {string} url WebSocket URL
 * @private
 */
function connectWebSocket(url) {
  // 关闭已有连接
  closeSocketConnection();

  // 创建新连接，使用更高优先级
  socketTask = wx.connectSocket({
    url: url,
    header: {
      'content-type': 'application/json'
    },
    tcpNoDelay: true, // 启用TCP_NODELAY，减少延迟
    perMessageDeflate: false, // 禁用消息压缩，减少处理时间
    success: () => {
      if (isDev) console.log('WebSocket连接创建成功');
    },
    fail: (err) => {
      console.error('WebSocket连接创建失败', err);
      if (errorCallback) {
        errorCallback(err);
      }
    }
  });

  // 监听连接打开事件
  socketTask.onOpen(() => {
    if (isDev) console.log('WebSocket连接已打开');
    // 发送业务参数帧
    sendBusinessParamsFrame();

    // 发送一些静音帧，帮助语音识别系统预热
    // 这样可以确保开头的内容不会被截断
    sendSilentFrames();
  });

  // 监听连接关闭事件
  socketTask.onClose(() => {
    if (isDev) console.log('WebSocket连接已关闭');
    socketTask = null;
  });

  // 监听连接错误事件
  socketTask.onError((err) => {
    console.error('WebSocket连接错误', err);
    if (errorCallback) {
      errorCallback(err);
    }
  });

  // 监听消息事件，优化处理逻辑
  socketTask.onMessage((res) => {
    // 立即处理识别结果
    if (res.data) {
      handleRecognitionResult(res.data);
    }
  });
}

/**
 * 发送业务参数帧
 * @private
 */
function sendBusinessParamsFrame() {
  if (!socketTask || socketTask.readyState !== 1) return;

  const frame = {
    common: {
      app_id: IFLYTEK_APPID
    },
    business: {
      language: 'zh_cn',
      domain: 'iat',
      accent: 'mandarin',
      vad_eos: 3000,
      dwa: 'wpgs',
      ptt: 1 // 添加标点
    },
    data: {
      status: 0,
      format: 'audio/L16;rate=16000',
      encoding: 'raw',
      audio: ''
    }
  };

  socketTask.send({
    data: JSON.stringify(frame),
    fail: (err) => {
      console.error('发送业务参数帧失败', err);
    }
  });
}

/**
 * 发送音频数据帧
 * @param {ArrayBuffer} buffer 音频数据
 * @private
 */
function sendAudioFrame(buffer) {
  if (!socketTask || socketTask.readyState !== 1) return;

  // 将ArrayBuffer转换为Base64
  const base64Audio = wx.arrayBufferToBase64(buffer);

  const frame = {
    data: {
      status: 1,
      format: 'audio/L16;rate=16000',
      encoding: 'raw',
      audio: base64Audio
    }
  };

  socketTask.send({
    data: JSON.stringify(frame),
    fail: (err) => {
      console.error('发送音频数据帧失败', err);
    }
  });
}

/**
 * 发送静音帧，帮助语音识别系统预热
 * @private
 */
function sendSilentFrames() {
  if (!socketTask || socketTask.readyState !== 1) return;

  console.log('发送静音帧预热');

  // 创建一个包含500ms静音的音频帧
  // 16000采样率 * 0.5秒 * 2字节/样本 = 16000字节
  const frameSize = 16000;
  const silentBuffer = new ArrayBuffer(frameSize);
  const silentView = new Uint8Array(silentBuffer);

  // 填充静音数据（PCM格式的静音是0）
  for (let i = 0; i < frameSize; i++) {
    silentView[i] = 0;
  }

  // 发送静音帧
  const frame = {
    data: {
      status: 1, // 1表示还有后续帧
      format: 'audio/L16;rate=16000',
      encoding: 'raw',
      audio: wx.arrayBufferToBase64(silentBuffer)
    }
  };

  socketTask.send({
    data: JSON.stringify(frame),
    fail: (err) => {
      console.error('发送静音帧失败', err);
    }
  });

  console.log('静音帧发送完成');
}

/**
 * 发送结束帧
 * @private
 */
function sendEndFrame() {
  if (!socketTask || socketTask.readyState !== 1) return;

  const frame = {
    data: {
      status: 2,
      format: 'audio/L16;rate=16000',
      encoding: 'raw',
      audio: ''
    }
  };

  socketTask.send({
    data: JSON.stringify(frame),
    fail: (err) => {
      console.error('发送结束帧失败', err);
    }
  });
}

/**
 * 处理识别结果
 * @param {string} data 识别结果数据
 * @private
 */
function handleRecognitionResult(data) {
  try {
    const result = JSON.parse(data);

    // 检查是否有错误
    if (result.code !== 0) {
      console.error('讯飞返回错误', result);
      if (errorCallback) {
        errorCallback(new Error(result.message || '语音识别失败'));
      }
      return;
    }

    // 提取识别文本
    let text = '';
    if (result.data && result.data.result && result.data.result.ws) {
      // 遍历每个词
      for (const word of result.data.result.ws) {
        // 取每个词的第一个候选结果
        if (word.cw && word.cw.length > 0) {
          text += word.cw[0].w;
        }
      }
    }

    // 根据讯飞的协议，处理不同类型的结果
    if (result.data && result.data.result) {
      if (result.data.result.pgs === 'rpl') {
        // 替换前一个结果
        recognitionResult = text;
      } else {
        // 追加结果
        recognitionResult += text;
      }

      // 立即回调中间结果，不等待
      if (resultCallback && recognitionResult) {
        resultCallback(recognitionResult);
      }

      // 如果是最终结果
      if (result.data.status === 2) {
        // 确保有最终结果再回调
        if (finalResultCallback && recognitionResult) {
          // 延迟回调最终结果，确保所有数据都已处理
          setTimeout(() => {
            finalResultCallback(recognitionResult);

            // 进一步延迟关闭连接，确保数据都已处理
            setTimeout(() => {
              closeSocketConnection();
            }, 200);
          }, 200);
        } else {
          // 延迟关闭连接
          setTimeout(() => {
            closeSocketConnection();
          }, 200);
        }
      }
    }
  } catch (error) {
    console.error('处理识别结果失败', error, data);
    if (errorCallback) {
      errorCallback(error);
    }
  }
}

/**
 * 关闭WebSocket连接
 * @private
 */
function closeSocketConnection() {
  if (socketTask) {
    try {
      socketTask.close();
    } catch (error) {
      console.error('关闭WebSocket连接失败', error);
    }
    socketTask = null;
  }
}

/**
 * 开始语音识别
 * @param {Function} onResult 识别结果回调
 * @param {Function} onError 错误回调
 * @param {Function} onFinalResult 最终结果回调
 */
async function startRecognition(onResult, onError, onFinalResult) {
  try {
    console.log('开始语音识别流程');

    // 保存回调函数
    resultCallback = onResult;
    errorCallback = onError;
    finalResultCallback = onFinalResult;

    // 重置识别结果
    recognitionResult = '';

    // 确保录音管理器已初始化
    if (!recorderManager) {
      initRecorderManager();
    }

    // 获取WebSocket URL
    const url = await getWebSocketUrl();
    console.log('获取WebSocket URL成功');

    // 建立WebSocket连接
    connectWebSocket(url);

    // 添加前置静音缓冲区
    // 在实际开始录音前，先添加一段静音，给语音识别系统预热时间
    // 这样可以确保开头的内容不会被截断
    console.log('准备开始录音');

    // 开始录音，优化参数确保捕获完整语音
    recorderManager.start({
      duration: 60000, // 最长录音时间，单位ms
      sampleRate: 16000, // 采样率
      numberOfChannels: 1, // 录音通道数
      encodeBitRate: 48000, // 编码码率，必须在24000-96000之间
      format: 'pcm', // 音频格式
      frameSize: 1, // 使用最小帧大小，提高响应速度和捕获率
      audioSource: 'auto', // 自动选择音频源
    });

    console.log('录音启动命令已发送');
  } catch (error) {
    console.error('开始语音识别失败', error);
    if (errorCallback) {
      errorCallback(error);
    }
  }
}

/**
 * 停止语音识别
 */
function stopRecognition() {
  console.log('停止语音识别函数被调用');

  // 先关闭WebSocket连接，避免继续处理音频数据
  closeSocketConnection();

  // 重置录音状态
  isRecording = false;

  // 检查录音管理器是否存在
  if (recorderManager) {
    console.log('停止录音');

    try {
      // 直接停止录音，不再添加额外延迟
      recorderManager.stop();
      console.log('录音停止命令已发送');
    } catch (err) {
      console.error('停止录音失败', err);
    }
  } else {
    console.warn('录音管理器不存在，无法停止录音');
  }
}

// 导出模块
module.exports = {
  startRecognition,
  stopRecognition
};

*#*#*end*#*#*

*#*#*miniprogram\styles\iconfont.wxss*#*#*begin*#*#*
@font-face {
  font-family: "iconfont";
  src: url('data:font/woff2;charset=utf-8;base64,d09GMgABAAAAAANMAAsAAAAAB2gAAAL+AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFQGYACDHAqCIIIKATYCJAMQCwoABCAFhGcHShtpBhEVlL1kPw9sN+NFQlQkWnWioyMaHYmGRvL9P/zN/a+qSYw02U10s5pJNJFJJolEh0QoFbLEu539D+z2tpNoXoKEJHiCR/VUvsqHTWfZOTwKIIAF7P9zzHRpDZbf2uYyxqK9AY4SGtjYBS3BAgl6w9iVF3E/gWbTBhGHl1fXMVCgdoF4VJQVAwWhlCpkocFXC9YW8QZVTfqUXgFe/c/HfxgRBZJKBnXi8qFcBgd/Tn6eQcb/jGYuAjiejgJsETKWgELcKvSdIwO0JZlmqbPyuqBB0JT8Of/fYOevRjT/8pAIUdHUbgCHkCR+TiJT4OcUMiV+ntnUDMrNwDPgHojnQFGUZFqt0Wi3RyPXdTfaKGcjk9XtjDfb7fFWR7nqjJfcYJPVGR9udTfb3WZn2Bm1uw/7/VG/fzwYnAyHp6PR2Xh8Ph5fTCaXk8nVdHo9nd7MZrez2d18/nA8Pp9OL2ez6/n8Zj6/XSxuF4u7g/J+sXg4HJ6Ox5fz+dVicTOfXy8W14vF1WJxuVicLxani8XJYnE8nx/NZoez2cFsdjCdHkynB5PJ/nh8MBodTSZH4/HhZHI4mRxMJvvj8d5otDca7Q5HO8Ph9mCw1e9v9Pub/f5Gv7/e7691u6ud9kqnvdxuL7fbS+3WYqu10GrON5vzzeZcszlTr07XqtPV6lS1OlmpTFQqE+XyeLk8Vi6PlsvD5fJwqTRUKg0Wi4PFYn+h0Jcv9uULvbl8Ty7fncv35HLd2Wx3NtuVyXRmMh2ZTHs63ZZOt6bTLel0czrdlE43ptMN6XR9Jl2XSdekM9WZTFUmU5nJVGQy5ZlMWSZTmsmUZDLFmUxRJlOYyRRkMvmZTF4mk5vJ5GQy2ZlMVjqTkc6kp9Np6XRqOp2STiel00npdGI6nZBOx6fT8el0XDodm07HpNPR6XRUOh2ZTkek0+HpdFg6HZpOh6TToelUcDoVlE4FplMB6ZR/OuWXTvmmUz7plHc65ZVOeaZTHumUezrlnk65pVNu6ZRrOuWSTjmnU07plGM65ZBOOaRTdumUTTpllU5ZpFNm6ZRJOmWUThmkk//plE865Z1OeaVTnumUezrlkU55pVPe6ZRPOuWbTvmlU/7pVEA6FZhOBaVTwelUSDoVmk6FpVPh6VREOhWZTkWlU9HpVEw6FZtOxaVT8elUQjqVmE4lpVPJ6VRKOpWaTqWlU+npVEY6lZlOZaVT2elUTjqVm07lpVP56VRBOlWYThWlU8XpVEk6VZpOlaVT5elURTpVmU5VpVPV6VRNOlWbTtWlU/XpVEM61ZhONaVTzelUSzrVmk61pVPt6VRHOtWZTnWlU93pVE861ZtO9aVT/enUQDo1mE4NpVPD6dRIOjWaTo2lU+Pp1EQ6NZlOTaVT0+nUTDo1m07NpVPz6dRCOrWYTi2lU8vp1Eo6tZpOraVT6+nURjq1mU5tpVPb6dROOrWbTu2lU/vp1EE6dZhOHaVTx+nUSTp1mk6dpVPn6dRFOnWZTl2lU9fp1E06dZtO3aVT9+nUQzr1mE49pVPP6dRLOvWaTr2lU+/p1Ec69ZlOfaVT3+nUTzr1m079pVP/6dQgOjWMTo2gU6Po1Bg6NY5OTaBTk+jUFDo1jU7NoFOz6NQcOjWPTi2gU4vo1BI6tYxOraD/A3icUFUAeJxjYGRgYOABYjEgZmJgBEIBIGYB8xgABGgAOAAAAHicY2BmYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGBwYKp5tYW7438AQw9zAMBUozAiSAwDhkgwbeJzFkMENgDAMAy9t6QMxCA8G4sUcnbhrFBPKgwlqybHiWEoUYAFSeIgZ7MF4cMlyLXzPGn7kVs+ksUBTq3d7/6oq0j36EOn0rATaLwbdt7Jv1N/y+X4PJd6V02fAJ+0C/T8eMgAAeJxjYGRgYADiF78rVOP5bb4ycLMwgMC1F8IfEPT/AywMzA1ALgcDE0gUAEFcC6cAeJxjYGRgYG7438AQw8IAAkCSkQEVsAEARwwCb3icY2FgYGBhAQMAGAAjAAAAAAAAADIAVACSALYAAHicY2BkYGBgYVBhYGYAASYg5gJCBob/YD4DAA3dAVAAeJxlj01OwzAQhV/6B6QSqqhgh+QFYgEo/RGrblhUavdddN+mTpsqiSPHrdQDcB6OwAk4AtyAO/BIJ5s2lsffvHljTwDc4Acejt8t95E9XDI7cg0XuBeuU38QbpBfhJto41W4Rf1N2MczpsJtdGF5g9e4YvaEd2EPHXwI13CNT+E69S/hBvlbuIk7/Aq30PHqwj7mXle4jUcv9sdWL5xeqeVBxaHJIpM5v4KZXu+Sha3S6pxrW8QmU4OgX0lTnWlb3VPs10PnIhVZk6oJqzpJjMqt2erQBRvn8lGvF4kehCblWGP+tsYCjnEFhSUOjDFCGGSIyujoO1Vm9K+xQ8Jee1Y9zed0WxTU/3OFAQL0z1xTurLSeTpPgT1fG1J1dCtuy56UNJFezUkSskJe1rZUQuoBNmVXjhF6XNGJPyhnSP8ACVpuyAAAAHicY2BigAAuBuyAhZGJkZmRhZGVkY2RnYGxgjUzNzE9lYEBABIwA0EAAAA=') format('woff2');
}

.iconfont {
  font-family: "iconfont" !important;
  font-size: 16px;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.icon-edit:before {
  content: "\e649";
}

.icon-right:before {
  content: "\e6a3";
}

*#*#*end*#*#*

*#*#*miniprogram\utils\auth.js*#*#*begin*#*#*
// 存储相关的key常量
const TOKEN_KEY = 'token'
const USER_INFO_KEY = 'userInfo'

// 保存登录信息
function saveLoginInfo(data) {
  try {
    // 分别存储token和userInfo
    wx.setStorageSync(TOKEN_KEY, data.token)
    wx.setStorageSync(USER_INFO_KEY, data.userInfo)

    // 如果执行到这里说明保存成功
    return true
  } catch (error) {
    console.error('保存登录信息失败:', error)
    return false
  }
}

// 获取登录信息
function getLoginInfo() {
  try {
    // 分别获取token和userInfo
    const token = wx.getStorageSync(TOKEN_KEY)
    const userInfo = wx.getStorageSync(USER_INFO_KEY)

    return {
      token,
      userInfo
    }
  } catch (error) {
    console.error('获取登录信息失败:', error)
    return {}
  }
}

// 清除登录信息
function clearLoginInfo() {
  try {
    // 分别清除token和userInfo
    wx.removeStorageSync(TOKEN_KEY)
    wx.removeStorageSync(USER_INFO_KEY)
    return true
  } catch (error) {
    console.error('清除登录信息失败:', error)
    return false
  }
}

// 检查是否登录
function checkLogin() {
  try {
    const token = wx.getStorageSync(TOKEN_KEY)
    const userInfo = wx.getStorageSync(USER_INFO_KEY)
    return !!(token && userInfo)
  } catch (error) {
    console.error('检查登录状态失败:', error)
    return false
  }
}

// 导出模块
module.exports = {
  saveLoginInfo,
  getLoginInfo,
  clearLoginInfo,
  checkLogin
};

*#*#*end*#*#*

*#*#*miniprogram\utils\date.js*#*#*begin*#*#*
/**
 * 日期工具函数
 */

/**
 * 格式化日期为 YYYY-MM-DD 格式
 * @param {Date} date 日期对象
 * @returns {string} 格式化后的日期字符串
 */
function formatDate(date) {
  if (!date || !(date instanceof Date)) {
    date = new Date();
  }
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * 格式化时间为 HH:MM 格式
 * @param {Date} date 日期对象
 * @returns {string} 格式化后的时间字符串
 */
function formatTime(date) {
  if (!date || !(date instanceof Date)) {
    date = new Date();
  }
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${hours}:${minutes}`;
}

/**
 * 格式化日期时间为 YYYY-MM-DD HH:MM:SS 格式
 * @param {Date} date 日期对象
 * @returns {string} 格式化后的日期时间字符串
 */
function formatDateTime(date) {
  if (!date || !(date instanceof Date)) {
    date = new Date();
  }
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

/**
 * 获取相对日期（如：今天、昨天、前天）
 * @param {Date} date 日期对象
 * @returns {string} 相对日期字符串
 */
function getRelativeDate(date) {
  if (!date || !(date instanceof Date)) {
    return '未知日期';
  }
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const targetDate = new Date(date);
  targetDate.setHours(0, 0, 0, 0);
  
  const diffDays = Math.floor((today - targetDate) / (24 * 60 * 60 * 1000));
  
  if (diffDays === 0) {
    return '今天';
  } else if (diffDays === 1) {
    return '昨天';
  } else if (diffDays === 2) {
    return '前天';
  } else if (diffDays > 2 && diffDays <= 7) {
    return `${diffDays}天前`;
  } else {
    return formatDate(date);
  }
}

/**
 * 获取日期范围
 * @param {number} days 天数
 * @param {Date} endDate 结束日期，默认为今天
 * @returns {Object} 包含开始日期和结束日期的对象
 */
function getDateRange(days, endDate = new Date()) {
  const end = new Date(endDate);
  const start = new Date(end);
  start.setDate(end.getDate() - days + 1);
  
  return {
    startDate: formatDate(start),
    endDate: formatDate(end)
  };
}

/**
 * 解析日期字符串为Date对象
 * @param {string} dateStr 日期字符串 (YYYY-MM-DD 或 YYYY/MM/DD)
 * @returns {Date} 日期对象
 */
function parseDate(dateStr) {
  if (!dateStr) return new Date();
  
  // 处理不同的日期分隔符
  const normalizedDateStr = dateStr.replace(/\//g, '-');
  
  // 尝试解析日期
  const date = new Date(normalizedDateStr);
  
  // 检查是否为有效日期
  if (isNaN(date.getTime())) {
    console.error('无效的日期字符串:', dateStr);
    return new Date();
  }
  
  return date;
}

/**
 * 获取两个日期之间的天数
 * @param {Date|string} startDate 开始日期
 * @param {Date|string} endDate 结束日期
 * @returns {number} 天数
 */
function getDaysBetween(startDate, endDate) {
  // 确保输入是Date对象
  const start = startDate instanceof Date ? startDate : parseDate(startDate);
  const end = endDate instanceof Date ? endDate : parseDate(endDate);
  
  // 设置为当天的开始时间
  start.setHours(0, 0, 0, 0);
  end.setHours(0, 0, 0, 0);
  
  // 计算天数差
  const diffTime = Math.abs(end - start);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  return diffDays;
}

/**
 * 获取当月的天数
 * @param {Date} date 日期对象
 * @returns {number} 当月天数
 */
function getDaysInMonth(date = new Date()) {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return new Date(year, month, 0).getDate();
}

module.exports = {
  formatDate,
  formatTime,
  formatDateTime,
  getRelativeDate,
  getDateRange,
  parseDate,
  getDaysBetween,
  getDaysInMonth
};

*#*#*end*#*#*

*#*#*miniprogram\utils\emotion.js*#*#*begin*#*#*
/**
 * 情感分析工具
 * 提供情感分析相关的功能，包括云函数调用和本地分析
 */

// 情感类型枚举
const EmotionTypes = {
  JOY: 'joy',
  SADNESS: 'sadness',
  ANGER: 'anger',
  ANXIETY: 'anxiety',
  NEUTRAL: 'neutral'
};

// 情感类型中文映射
const EmotionTypeLabels = {
  [EmotionTypes.JOY]: '喜悦',
  [EmotionTypes.SADNESS]: '伤感',
  [EmotionTypes.ANGER]: '愤怒',
  [EmotionTypes.ANXIETY]: '焦虑',
  [EmotionTypes.NEUTRAL]: '平静'
};

// 情感类型颜色映射
const EmotionTypeColors = {
  [EmotionTypes.JOY]: '#2ECC71',     // 绿色
  [EmotionTypes.SADNESS]: '#3498DB', // 蓝色
  [EmotionTypes.ANGER]: '#E74C3C',   // 红色
  [EmotionTypes.ANXIETY]: '#F1C40F', // 黄色
  [EmotionTypes.NEUTRAL]: '#95A5A6'  // 灰色
};

/**
 * 分析文本情感
 * @param {string} text 待分析文本
 * @returns {Promise<object>} 情感分析结果
 */
async function analyzeEmotion(text) {
  try {
    // 验证参数
    if (!text || typeof text !== 'string' || text.trim() === '') {
      console.warn('情感分析文本为空');
      return createDefaultResult();
    }

    // 调用云函数进行情感分析
    const result = await wx.cloud.callFunction({
      name: 'analysis',
      data: {
        type: 'emotion',
        text
      }
    });

    // 验证结果
    if (!result || !result.result || !result.result.success) {
      console.error('情感分析云函数返回错误:', result?.result?.error || '未知错误');
      return createDefaultResult();
    }

    // 处理结果
    const analysisResult = result.result.result;

    // 添加历史记录
    const history = getEmotionHistory();
    const newHistory = updateEmotionHistory(history, analysisResult);

    // 返回完整的情感分析结果
    return {
      type: analysisResult.type || EmotionTypes.NEUTRAL,
      intensity: analysisResult.intensity || 0.5,
      report: analysisResult.report || '无法生成情感报告',
      suggestions: analysisResult.suggestions || ['继续保持对话'],
      history: newHistory
    };
  } catch (err) {
    console.error('情感分析失败:', err);
    return createDefaultResult();
  }
}

/**
 * 使用本地简单算法进行情感分析（备选方案）
 * 当云函数不可用时使用
 * @param {string} text 待分析文本
 * @returns {object} 情感分析结果
 */
function analyzeEmotionLocal(text) {
  try {
    // 简单的关键词匹配
    const joyWords = ['开心', '高兴', '快乐', '喜悦', '兴奋', '愉快', '满意', '幸福', '欣喜', '欢乐'];
    const sadnessWords = ['伤心', '难过', '悲伤', '痛苦', '失落', '沮丧', '忧郁', '哀伤', '遗憾', '悲痛'];
    const angerWords = ['生气', '愤怒', '恼火', '烦躁', '暴怒', '不满', '恨', '怒火', '气愤', '恼怒'];
    const anxietyWords = ['焦虑', '担心', '紧张', '不安', '恐惧', '害怕', '忧虑', '惊慌', '惶恐', '慌张'];

    // 计算情绪得分
    const scores = {
      [EmotionTypes.JOY]: 0,
      [EmotionTypes.SADNESS]: 0,
      [EmotionTypes.ANGER]: 0,
      [EmotionTypes.ANXIETY]: 0,
      [EmotionTypes.NEUTRAL]: 0.2 // 默认有一点中性情绪
    };

    // 简单的关键词匹配
    joyWords.forEach(word => {
      if (text.includes(word)) scores[EmotionTypes.JOY] += 0.2;
    });

    sadnessWords.forEach(word => {
      if (text.includes(word)) scores[EmotionTypes.SADNESS] += 0.2;
    });

    angerWords.forEach(word => {
      if (text.includes(word)) scores[EmotionTypes.ANGER] += 0.2;
    });

    anxietyWords.forEach(word => {
      if (text.includes(word)) scores[EmotionTypes.ANXIETY] += 0.2;
    });

    // 找出得分最高的情绪
    let maxScore = 0;
    let maxType = EmotionTypes.NEUTRAL;

    for (const type in scores) {
      if (scores[type] > maxScore) {
        maxScore = scores[type];
        maxType = type;
      }
    }

    // 计算情绪强度（0-1之间）
    const intensity = Math.min(1, maxScore);

    // 生成情感报告
    const report = generateEmotionReport(maxType, intensity, text);

    // 生成建议
    const suggestions = generateSuggestions(maxType, intensity);

    // 添加历史记录
    const history = getEmotionHistory();
    const newHistory = updateEmotionHistory(history, { type: maxType, intensity });

    // 返回分析结果
    return {
      type: maxType,
      intensity: intensity,
      report: report,
      suggestions: suggestions,
      history: newHistory
    };
  } catch (error) {
    console.error('本地情感分析失败:', error);
    return createDefaultResult();
  }
}

/**
 * 生成情感报告
 * @param {string} emotionType 情绪类型
 * @param {number} intensity 情绪强度
 * @param {string} text 原始文本
 * @returns {string} 情感报告
 */
function generateEmotionReport(emotionType, intensity, text) {
  const intensityDesc = getIntensityDescription(intensity);
  const emotionLabel = getEmotionLabel(emotionType);
  
  let report = `您的情绪状态显示为${intensityDesc}的${emotionLabel}。`;
  
  switch (emotionType) {
    case EmotionTypes.JOY:
      report += '积极的情绪有助于提高生活质量和工作效率。';
      if (intensity > 0.7) {
        report += '您现在的心情非常愉快，这种状态对身心健康都很有益。';
      }
      break;
      
    case EmotionTypes.SADNESS:
      report += '感到悲伤是正常的情绪反应，允许自己感受这种情绪。';
      if (intensity > 0.7) {
        report += '如果这种情绪持续时间较长，建议寻求亲友或专业人士的支持。';
      }
      break;
      
    case EmotionTypes.ANGER:
      report += '愤怒是一种保护机制，但需要健康地表达和管理。';
      if (intensity > 0.7) {
        report += '强烈的愤怒可能影响判断，建议先冷静下来再做决定。';
      }
      break;
      
    case EmotionTypes.ANXIETY:
      report += '适度的焦虑是正常的，它可以帮助我们保持警觉。';
      if (intensity > 0.7) {
        report += '过度的焦虑可能影响日常生活，尝试一些放松技巧可能会有所帮助。';
      }
      break;
      
    default: // neutral
      report += '平静的情绪状态有助于理性思考和决策。';
  }
  
  return report;
}

/**
 * 根据情绪类型和强度生成建议
 * @param {string} emotionType 情绪类型
 * @param {number} intensity 情绪强度
 * @returns {string[]} 建议数组
 */
function generateSuggestions(emotionType, intensity) {
  const suggestions = [];
  
  switch (emotionType) {
    case EmotionTypes.JOY:
      suggestions.push('分享你的快乐，它会让你感觉更好');
      suggestions.push('记录这一刻，创建积极情绪的记忆库');
      if (intensity > 0.7) {
        suggestions.push('利用这种积极情绪，尝试一些平时不敢尝试的事情');
      }
      suggestions.push('感恩当下的美好，这会让快乐持续更久');
      break;
      
    case EmotionTypes.SADNESS:
      suggestions.push('允许自己感到悲伤，不要压抑情绪');
      suggestions.push('与亲友交流，分享你的感受');
      if (intensity > 0.7) {
        suggestions.push('如果悲伤持续较长时间，考虑寻求专业帮助');
      }
      suggestions.push('进行一些让你感到舒适的活动，如听音乐或散步');
      break;
      
    case EmotionTypes.ANGER:
      suggestions.push('深呼吸，数到10，给自己一点冷静的时间');
      suggestions.push('尝试换个角度思考问题');
      if (intensity > 0.7) {
        suggestions.push('暂时离开引起愤怒的环境，等情绪平静后再处理');
      }
      suggestions.push('通过运动或写作等方式释放情绪');
      break;
      
    case EmotionTypes.ANXIETY:
      suggestions.push('专注于当下，尝试一些简单的冥想或呼吸练习');
      suggestions.push('将担忧写下来，区分哪些是可以控制的，哪些是不可控的');
      if (intensity > 0.7) {
        suggestions.push('考虑与专业人士交流，学习更多应对焦虑的技巧');
      }
      suggestions.push('保持规律的作息和健康的生活方式');
      break;

    default: // neutral
      suggestions.push('尝试分享更多个人感受，增加交流深度');
      suggestions.push('提出开放性问题，促进对话');
      suggestions.push('关注对方的情绪变化，及时调整交流方式');
  }

  return suggestions;
}

/**
 * 创建默认的情感分析结果
 * @returns {object} 默认情感分析结果
 */
function createDefaultResult() {
  return {
    type: EmotionTypes.NEUTRAL,
    intensity: 0.5,
    report: '无法分析您当前的情绪状态，您的情绪似乎比较平稳。',
    suggestions: ['继续保持对话'],
    history: getEmotionHistory()
  };
}

/**
 * 获取情感历史记录
 * @returns {Array} 情感历史记录
 */
function getEmotionHistory() {
  try {
    const history = wx.getStorageSync('emotionHistory') || [];
    // 最多保留最近10条记录
    return Array.isArray(history) ? history.slice(-9) : [];
  } catch (err) {
    console.error('获取情感历史记录失败:', err);
    return [];
  }
}

/**
 * 更新情感历史记录
 * @param {Array} history 现有历史记录
 * @param {object} newEmotion 新的情感分析结果
 * @returns {Array} 更新后的历史记录
 */
function updateEmotionHistory(history, newEmotion) {
  try {
    // 创建新的历史记录项
    const historyItem = {
      type: newEmotion.type,
      intensity: newEmotion.intensity,
      timestamp: Date.now()
    };

    // 添加到历史记录
    const newHistory = [...history, historyItem];

    // 最多保留最近10条记录
    const limitedHistory = newHistory.slice(-10);

    // 保存到本地存储
    wx.setStorageSync('emotionHistory', limitedHistory);

    return limitedHistory;
  } catch (err) {
    console.error('更新情感历史记录失败:', err);
    return history;
  }
}

/**
 * 获取情感类型的中文标签
 * @param {string} type 情感类型
 * @returns {string} 情感类型中文标签
 */
function getEmotionLabel(type) {
  return EmotionTypeLabels[type] || '未知';
}

/**
 * 获取情感类型的颜色
 * @param {string} type 情感类型
 * @returns {string} 情感类型颜色
 */
function getEmotionColor(type) {
  return EmotionTypeColors[type] || '#95A5A6';
}

/**
 * 根据情感强度获取描述
 * @param {number} intensity 情感强度 (0-1)
 * @returns {string} 情感强度描述
 */
function getIntensityDescription(intensity) {
  if (intensity < 0.3) return '轻微';
  if (intensity < 0.6) return '中等';
  if (intensity < 0.8) return '较强';
  return '强烈';
}

module.exports = {
  analyzeEmotion,
  analyzeEmotionLocal,
  getEmotionLabel,
  getEmotionColor,
  getIntensityDescription,
  EmotionTypes,
  EmotionTypeLabels,
  EmotionTypeColors
};

*#*#*end*#*#*

*#*#*miniprogram\utils\format.js*#*#*begin*#*#*
class Format {
  /**
   * 格式化时间戳为日期时间字符串
   * @param {number} timestamp 时间戳
   * @param {string} format 格式化模板，默认 'YYYY-MM-DD HH:mm:ss'
   * @returns {string} 格式化后的字符串
   */
  static datetime(timestamp, format = 'YYYY-MM-DD HH:mm:ss') {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes();
    const second = date.getSeconds();

    return format
      .replace('YYYY', year.toString())
      .replace('MM', month.toString().padStart(2, '0'))
      .replace('DD', day.toString().padStart(2, '0'))
      .replace('HH', hour.toString().padStart(2, '0'))
      .replace('mm', minute.toString().padStart(2, '0'))
      .replace('ss', second.toString().padStart(2, '0'));
  }

  /**
   * 格式化时间戳为相对时间
   * @param {number} timestamp 时间戳
   * @returns {string} 相对时间字符串
   */
  static relativeTime(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const minute = 60 * 1000;
    const hour = 60 * minute;
    const day = 24 * hour;
    const week = 7 * day;
    const month = 30 * day;
    const year = 365 * day;

    if (diff < minute) {
      return '刚刚';
    } else if (diff < hour) {
      return `${Math.floor(diff / minute)}分钟前`;
    } else if (diff < day) {
      return `${Math.floor(diff / hour)}小时前`;
    } else if (diff < week) {
      return `${Math.floor(diff / day)}天前`;
    } else if (diff < month) {
      return `${Math.floor(diff / week)}周前`;
    } else if (diff < year) {
      return `${Math.floor(diff / month)}个月前`;
    } else {
      return `${Math.floor(diff / year)}年前`;
    }
  }

  /**
   * 格式化文件大小
   * @param {number} bytes 字节数
   * @param {number} decimals 小数位数，默认2
   * @returns {string} 格式化后的字符串
   */
  static fileSize(bytes, decimals = 2) {
    if (bytes === 0) return '0 B';

    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`;
  }

  /**
   * 格式化数字（添加千分位）
   * @param {number} num 数字
   * @param {number} decimals 小数位数，默认2
   * @returns {string} 格式化后的字符串
   */
  static number(num, decimals = 2) {
    return num.toLocaleString('en-US', {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
  }

  /**
   * 格式化金额
   * @param {number} amount 金额
   * @param {string} symbol 货币符号，默认'¥'
   * @param {number} decimals 小数位数，默认2
   * @returns {string} 格式化后的字符串
   */
  static currency(amount, symbol = '¥', decimals = 2) {
    return `${symbol}${Format.number(amount, decimals)}`;
  }

  /**
   * 格式化百分比
   * @param {number} value 值（0-1）
   * @param {number} decimals 小数位数，默认0
   * @returns {string} 格式化后的字符串
   */
  static percentage(value, decimals = 0) {
    return `${(value * 100).toFixed(decimals)}%`;
  }

  /**
   * 格式化手机号
   * @param {string} phone 手机号
   * @returns {string} 格式化后的字符串
   */
  static phone(phone) {
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }

  /**
   * 格式化身份证号
   * @param {string} idCard 身份证号
   * @returns {string} 格式化后的字符串
   */
  static idCard(idCard) {
    return idCard.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
  }

  /**
   * 格式化银行卡号
   * @param {string} cardNo 银行卡号
   * @returns {string} 格式化后的字符串
   */
  static bankCard(cardNo) {
    return cardNo.replace(/(\d{4})\d+(\d{4})/, '$1 **** **** $2');
  }

  /**
   * 格式化文本长度
   * @param {string} text 文本
   * @param {number} maxLength 最大长度
   * @param {string} suffix 后缀，默认'...'
   * @returns {string} 格式化后的字符串
   */
  static textLength(text, maxLength, suffix = '...') {
    if (text.length <= maxLength) return text;
    return text.slice(0, maxLength) + suffix;
  }
}

module.exports = Format;

*#*#*end*#*#*

*#*#*miniprogram\utils\imageService.js*#*#*begin*#*#*
/**
 * 图片服务工具类
 * 提供图片上传、获取、缓存等功能
 */

const request = require('./request');

class ImageService {
  constructor() {
    this.defaultAvatars = {
      user: '/images/system/default-avatar.png',
      role: '/images/avatars/default-avatar.png'
    };
    this.imageCache = {};
    this.initialized = false;
  }

  /**
   * 初始化图片服务
   */
  initImageService() {
    if (this.initialized) return;
    
    // 从本地存储加载缓存的图片URL
    try {
      const cachedImages = wx.getStorageSync('imageCache');
      if (cachedImages) {
        this.imageCache = JSON.parse(cachedImages);
      }
    } catch (error) {
      console.error('Failed to load image cache:', error);
      this.imageCache = {};
    }
    
    this.initialized = true;
  }

  /**
   * 上传图片到云存储
   * @param {string} filePath 本地文件路径
   * @param {string} folder 存储文件夹，如 'users', 'roles'
   * @param {string} userId 用户ID，可选
   * @param {object} options 上传选项
   * @returns {Promise<{fileID: string, tempFileURL: string}>} 上传结果
   */
  async uploadImage(filePath, folder = 'images', userId = '', options = {}) {
    try {
      // 生成唯一文件名
      const timestamp = new Date().getTime();
      const randomStr = Math.random().toString(36).substring(2, 8);
      const extension = filePath.split('.').pop();
      
      // 构建云存储路径
      let cloudPath = `${folder}/`;
      if (userId) {
        cloudPath += `${userId}/`;
      }
      cloudPath += `${timestamp}_${randomStr}.${extension}`;
      
      // 使用request工具类上传文件
      const result = await request.constructor.uploadFile(filePath, cloudPath, options);
      
      // 缓存图片URL
      if (result && result.fileID) {
        this.cacheImage(result.fileID, result.tempFileURL);
      }
      
      return result;
    } catch (error) {
      console.error('Upload image failed:', error);
      throw error;
    }
  }

  /**
   * 上传头像
   * @param {string} filePath 本地文件路径
   * @param {string} userId 用户ID
   * @param {string} type 头像类型，'user'或'role'
   * @returns {Promise<string>} 文件ID
   */
  async uploadAvatar(filePath, userId, type = 'user') {
    try {
      const folder = type === 'user' ? 'users' : 'roles';
      const result = await this.uploadImage(filePath, folder, userId, {
        showLoading: true,
        retryCount: 3,
        retryDelay: 1000
      });
      
      return result.fileID;
    } catch (error) {
      console.error('Upload avatar failed:', error);
      
      // 提供更友好的错误提示
      let errorMsg = '上传头像失败';
      if (error.errMsg) {
        if (error.errMsg.includes('TLS connection')) {
          errorMsg = '网络连接不稳定，请检查网络';
        } else if (error.errMsg.includes('timeout')) {
          errorMsg = '上传超时，请重试';
        }
      }
      
      wx.showToast({
        title: errorMsg,
        icon: 'none',
        duration: 2000
      });
      
      throw error;
    }
  }

  /**
   * 获取图片临时URL
   * @param {string} fileID 文件ID
   * @returns {Promise<string>} 临时URL
   */
  async getImageURL(fileID) {
    // 如果是本地路径，直接返回
    if (!fileID || fileID.startsWith('/') || fileID.startsWith('http')) {
      return fileID;
    }
    
    // 检查缓存
    if (this.imageCache[fileID]) {
      return this.imageCache[fileID];
    }
    
    try {
      const result = await request.constructor.getTempFileURLs([fileID]);
      if (result && result.length > 0) {
        const url = result[0];
        this.cacheImage(fileID, url);
        return url;
      }
      return null;
    } catch (error) {
      console.error('Get image URL failed:', error);
      return null;
    }
  }

  /**
   * 缓存图片URL
   * @param {string} fileID 文件ID
   * @param {string} url 临时URL
   */
  cacheImage(fileID, url) {
    if (!fileID || !url) return;
    
    this.imageCache[fileID] = url;
    
    // 保存到本地存储
    try {
      wx.setStorageSync('imageCache', JSON.stringify(this.imageCache));
    } catch (error) {
      console.error('Failed to save image cache:', error);
    }
  }

  /**
   * 获取默认头像
   * @param {string} type 头像类型，'user'或'role'
   * @returns {string} 默认头像路径
   */
  getDefaultAvatar(type = 'user') {
    return this.defaultAvatars[type] || this.defaultAvatars.user;
  }

  /**
   * 清除图片缓存
   */
  clearImageCache() {
    this.imageCache = {};
    try {
      wx.removeStorageSync('imageCache');
    } catch (error) {
      console.error('Failed to clear image cache:', error);
    }
  }
}

module.exports = new ImageService();

*#*#*end*#*#*

*#*#*miniprogram\utils\request.js*#*#*begin*#*#*
const { getToken, refreshToken } = require('./auth');

const DEFAULT_OPTIONS = {
  loading: true,
  retry: true,
  retryCount: 3
};

class Request {
  /**
   * 调用云函数
   * @param {string} name 云函数名称
   * @param {object} data 请求参数
   * @param {object} options 请求选项
   * @returns {Promise<any>}
   */
  async callFunction(name, data = {}, options = {}) {
    const finalOptions = { ...DEFAULT_OPTIONS, ...options };

    if (finalOptions.loading) {
      wx.showLoading({ title: '加载中...' });
    }

    try {
      // 添加token到请求中
      const token = getToken();
      if (token) {
        data.token = token;
      }

      const { result } = await wx.cloud.callFunction({
        name,
        data
      });

      if (!result.success) {
        // token过期,尝试刷新
        if (result.error === 'TOKEN_EXPIRED' && finalOptions.retry) {
          const refreshSuccess = await refreshToken();
          if (refreshSuccess) {
            // 重试请求
            return this.callFunction(name, data, {
              ...finalOptions,
              retry: false
            });
          }
        }
        throw new Error(result.error || '请求失败');
      }

      return result.data;
    } catch (error) {
      console.error(`[${name}]请求失败:`, error);

      // 请求重试
      if (finalOptions.retry && finalOptions.retryCount > 0) {
        return this.callFunction(name, data, {
          ...finalOptions,
          retryCount: finalOptions.retryCount - 1
        });
      }

      throw error;
    } finally {
      if (finalOptions.loading) {
        wx.hideLoading();
      }
    }
  }

  /**
   * GET请求
   * @param {string} url 请求地址
   * @param {object} data 请求参数
   * @returns {Promise<any>}
   */
  async get(url, data) {
    return this.request('GET', url, data);
  }

  /**
   * POST请求
   * @param {string} url 请求地址
   * @param {object} data 请求参数
   * @returns {Promise<any>}
   */
  async post(url, data) {
    return this.request('POST', url, data);
  }

  /**
   * 发起HTTP请求
   * @param {string} method 请求方法
   * @param {string} url 请求地址
   * @param {object} data 请求参数
   * @returns {Promise<any>}
   */
  async request(method, url, data) {
    return new Promise((resolve, reject) => {
      wx.request({
        url,
        method,
        data,
        success: (res) => {
          if (res.statusCode === 200) {
            resolve(res.data);
          } else {
            reject(new Error(`请求失败: ${res.statusCode}`));
          }
        },
        fail: reject
      });
    });
  }

  /**
   * 上传文件到云存储
   * @param {string} filePath 本地文件路径
   * @param {string} cloudPath 云存储路径
   * @param {object} options 上传选项
   * @param {boolean} options.showLoading 是否显示加载提示，默认true
   * @param {number} options.retryCount 重试次数，默认3
   * @param {number} options.retryDelay 重试间隔（毫秒），默认1000
   * @returns {Promise<{fileID: string, tempFileURL: string}>} 文件ID和访问链接
   */
  static async uploadFile(filePath, cloudPath, options = {}) {
    const {
      showLoading = true,
      retryCount = 3,
      retryDelay = 1000
    } = options;

    if (showLoading) {
      wx.showLoading({ title: '上传中...' });
    }

    try {
      // 添加重试机制
      let remainingRetries = retryCount;
      let success = false;
      let fileID = null;
      let error = null;

      while (remainingRetries >= 0 && !success) {
        try {
          // 上传文件
          const uploadResult = await wx.cloud.uploadFile({
            cloudPath,
            filePath,
          });

          if (uploadResult && uploadResult.fileID) {
            fileID = uploadResult.fileID;
            success = true;
          } else {
            throw new Error('上传返回结果无效');
          }
        } catch (uploadError) {
          error = uploadError;
          console.warn(`上传尝试失败，剩余重试次数: ${remainingRetries}`, uploadError);
          remainingRetries--;

          if (remainingRetries < 0) {
            break;
          }

          // 等待一段时间再重试
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }

      if (!success) {
        throw error || new Error('上传失败');
      }

      // 获取文件链接
      const { fileList } = await wx.cloud.getTempFileURL({
        fileList: [fileID],
      });

      if (fileList[0].status === 0) {
        if (showLoading) {
          wx.hideLoading();
        }
        return {
          fileID,
          tempFileURL: fileList[0].tempFileURL
        };
      } else {
        throw new Error(fileList[0].errMsg || '获取文件链接失败');
      }
    } catch (error) {
      console.error('Upload file failed:', error);

      if (showLoading) {
        wx.hideLoading();
      }

      // 提供更具体的错误信息
      let errorMsg = '上传文件失败';
      if (error.errMsg) {
        if (error.errMsg.includes('TLS connection')) {
          errorMsg = '网络连接不稳定，请检查网络';
        } else if (error.errMsg.includes('timeout')) {
          errorMsg = '上传超时，请重试';
        }
      }

      error.message = errorMsg;
      throw error;
    }
  }

  /**
   * 从云存储下载文件
   * @param {string} fileID 文件ID
   * @returns {Promise<string>} 本地文件路径
   */
  static async downloadFile(fileID) {
    try {
      const { tempFilePath } = await wx.cloud.downloadFile({
        fileID,
      });
      return tempFilePath;
    } catch (error) {
      console.error('Download file failed:', error);
      throw error;
    }
  }

  /**
   * 删除云存储文件
   * @param {string|string[]} fileID 文件ID或ID数组
   * @returns {Promise<void>}
   */
  static async deleteFile(fileID) {
    try {
      const { fileList } = await wx.cloud.deleteFile({
        fileList: Array.isArray(fileID) ? fileID : [fileID],
      });

      const failedFiles = fileList.filter(file => file.status !== 0);
      if (failedFiles.length > 0) {
        throw new Error(
          `Failed to delete files: ${failedFiles
            .map(file => file.errMsg)
            .join(', ')}`
        );
      }
    } catch (error) {
      console.error('Delete file failed:', error);
      throw error;
    }
  }

  /**
   * 批量获取文件临时链接
   * @param {string[]} fileIDs 文件ID数组
   * @returns {Promise<string[]>} 临时链接数组
   */
  static async getTempFileURLs(fileIDs) {
    try {
      const { fileList } = await wx.cloud.getTempFileURL({
        fileList: fileIDs,
      });

      const failedFiles = fileList.filter(file => file.status !== 0);
      if (failedFiles.length > 0) {
        throw new Error(
          `Failed to get temp URLs: ${failedFiles
            .map(file => file.errMsg)
            .join(', ')}`
        );
      }

      return fileList.map(file => file.tempFileURL);
    } catch (error) {
      console.error('Get temp file URLs failed:', error);
      throw error;
    }
  }
}

module.exports = new Request();

*#*#*end*#*#*

*#*#*miniprogram\utils\stats.js*#*#*begin*#*#*
/**
 * 用户统计工具类
 */
const auth = require('./auth');

/**
 * 更新用户统计数据
 * @param {string} statsType 统计类型: chatCount, solvedCount, rating, activeDay
 * @param {number} value 统计值
 * @returns {Promise<object>} 更新结果
 */
const updateUserStats = async (statsType, value = 1) => {
  try {
    // 获取用户信息
    const { userInfo } = auth.getLoginInfo()
    if (!userInfo || !userInfo.userId) {
      console.error('用户未登录或登录信息不完整')
      return { success: false, error: '用户未登录' }
    }

    // 调用云函数更新统计
    const result = await wx.cloud.callFunction({
      name: 'user',
      data: {
        action: 'updateStats',
        userId: userInfo.userId,
        statsType,
        value
      }
    })

    console.log('更新用户统计结果:', result)
    return result.result
  } catch (error) {
    console.error('更新用户统计失败:', error)
    return { success: false, error }
  }
}

/**
 * 更新对话次数
 * @param {number} count 增加的次数，默认为1
 */
const updateChatCount = (count = 1) => {
  return updateUserStats('chatCount', count)
}

/**
 * 更新已解决问题数
 * @param {number} count 增加的次数，默认为1
 */
const updateSolvedCount = (count = 1) => {
  return updateUserStats('solvedCount', count)
}

/**
 * 更新用户评分
 * @param {number} rating 评分，1-5
 */
const updateRating = (rating = 5) => {
  return updateUserStats('rating', rating)
}

/**
 * 更新活跃天数
 */
const updateActiveDay = () => {
  return updateUserStats('activeDay')
}

// 导出模块
module.exports = {
  updateUserStats,
  updateChatCount,
  updateSolvedCount,
  updateRating,
  updateActiveDay
}

*#*#*end*#*#*

*#*#*miniprogram\utils\storage.js*#*#*begin*#*#*
class Storage {
  /**
   * 设置缓存
   * @param {string} key 缓存键
   * @param {any} data 缓存数据
   * @param {number} expire 过期时间（毫秒），可选
   */
  static set(key, data, expire) {
    try {
      const storage = {
        data,
        expire: expire ? Date.now() + expire : null,
      };
      wx.setStorageSync(key, storage);
    } catch (error) {
      console.error('Set storage failed:', error);
    }
  }

  /**
   * 获取缓存
   * @param {string} key 缓存键
   * @param {any} defaultValue 默认值
   * @returns {any} 缓存数据或默认值
   */
  static get(key, defaultValue) {
    try {
      const storage = wx.getStorageSync(key);
      
      // 缓存不存在
      if (!storage) {
        return defaultValue;
      }

      // 判断是否过期
      if (storage.expire && storage.expire < Date.now()) {
        this.remove(key);
        return defaultValue;
      }

      return storage.data;
    } catch (error) {
      console.error('Get storage failed:', error);
      return defaultValue;
    }
  }

  /**
   * 移除缓存
   * @param {string} key 缓存键
   */
  static remove(key) {
    try {
      wx.removeStorageSync(key);
    } catch (error) {
      console.error('Remove storage failed:', error);
    }
  }

  /**
   * 清空缓存
   */
  static clear() {
    try {
      wx.clearStorageSync();
    } catch (error) {
      console.error('Clear storage failed:', error);
    }
  }

  /**
   * 获取缓存信息
   * @returns {object} 缓存信息
   */
  static info() {
    try {
      return wx.getStorageInfoSync();
    } catch (error) {
      console.error('Get storage info failed:', error);
      return {
        keys: [],
        currentSize: 0,
        limitSize: 0,
      };
    }
  }

  /**
   * 检查缓存是否存在
   * @param {string} key 缓存键
   * @returns {boolean} 是否存在
   */
  static has(key) {
    try {
      const storage = wx.getStorageSync(key);
      if (!storage) {
        return false;
      }
      if (storage.expire && storage.expire < Date.now()) {
        this.remove(key);
        return false;
      }
      return true;
    } catch (error) {
      console.error('Check storage failed:', error);
      return false;
    }
  }
}

module.exports = Storage;

*#*#*end*#*#*

*#*#*miniprogram\app.js*#*#*begin*#*#*
// app.js
import { checkLogin, saveLoginInfo, getLoginInfo, clearLoginInfo } from './utils/auth';
import * as echarts from './components/ec-canvas/echarts';
import imageService from './services/imageService';
import config from './config/index';

App({
  globalData: {
    userInfo: null,
    systemInfo: null,
    darkMode: false,
    isLoggedIn: false,
    cloudEnv: config.cloud.ENV_ID, // 从配置文件获取云环境ID
    roleList: [], // 添加角色列表
    cloudInit: false, // 云环境是否初始化
    imageService: null, // 图片服务
    config: config // 全局配置对象
  },

  onLaunch() {
    // 将 echarts 挂载到 wx 对象上，方便全局使用
    wx.echarts = echarts;

    // 初始化云开发
    if (!wx.cloud) {
      console.error('请使用 2.2.3 或以上的基础库以使用云能力');
    } else {
      this.initCloudEnvironment();
    }

    // 获取系统信息
    try {
      const systemInfo = wx.getSystemInfoSync();
      this.globalData.systemInfo = systemInfo;

      // 优先使用本地缓存中的 darkMode 设置
      const localDarkMode = wx.getStorageSync('darkMode');
      if (localDarkMode !== undefined && localDarkMode !== null) {
        // 确保 localDarkMode 是布尔值
        const darkModeValue = typeof localDarkMode === 'boolean' ? localDarkMode : localDarkMode === 'true';
        this.globalData.darkMode = darkModeValue;
        console.log('从本地缓存读取暗黑模式设置:', darkModeValue, '原始值:', localDarkMode, '类型:', typeof localDarkMode);

        // 将布尔值存回缓存，确保类型一致
        wx.setStorageSync('darkMode', darkModeValue);

        // 根据本地缓存设置主题
        this.updateTheme(darkModeValue);
      } else {
        // 如果本地缓存中没有设置，则使用系统主题
        this.globalData.darkMode = systemInfo.theme === 'dark';
        console.log('使用系统主题设置暗黑模式:', this.globalData.darkMode);

        // 将系统主题设置存入缓存
        wx.setStorageSync('darkMode', this.globalData.darkMode);

        // 根据系统主题设置主题
        this.updateTheme(this.globalData.darkMode);
      }
    } catch (e) {
      console.error('获取系统信息失败:', e);
    }

    // 监听主题变化
    wx.onThemeChange && wx.onThemeChange((result) => {
      // 检查本地缓存中是否有手动设置的暗黑模式
      const localDarkMode = wx.getStorageSync('darkMode');
      if (localDarkMode !== undefined && localDarkMode !== null) {
        // 如果有手动设置，则不响应系统主题变化
        console.log('存在手动设置的暗黑模式，不响应系统主题变化');
        return;
      }

      // 如果没有手动设置，则响应系统主题变化
      const darkModeValue = result.theme === 'dark';
      this.globalData.darkMode = darkModeValue;
      console.log('系统主题变化，更新暗黑模式为:', darkModeValue);

      // 将系统主题设置存入缓存
      wx.setStorageSync('darkMode', darkModeValue);

      // 更新主题
      this.updateTheme(darkModeValue);
    });

    // 检查登录状态
    this.checkLoginStatus();
  },

  onShow() {
    // 检查更新
    const updateManager = wx.getUpdateManager();
    updateManager.onCheckForUpdate(function(res) {
      if (res.hasUpdate) {
        updateManager.onUpdateReady(function() {
          wx.showModal({
            title: '更新提示',
            content: '新版本已经准备好，是否重启应用？',
            success: function(res) {
              if (res.confirm) {
                updateManager.applyUpdate();
              }
            }
          });
        });
      }
    });
  },

  // 全局登录方法
  async login(userInfo) {
    try {
      // 获取登录凭证
      const { code } = await wx.login();

      // 调用登录云函数
      const { result } = await wx.cloud.callFunction({
        name: 'login',
        data: {
          code,
          userInfo
        }
      });

      if (!result.success) {
        throw new Error(result.error || '登录失败');
      }

      // 保存登录信息并更新全局状态
      const loginData = {
        token: result.data.token,
        userInfo: result.data.userInfo
      };

      if(saveLoginInfo(loginData)) {
        this.globalData.isLoggedIn = true;
        this.globalData.userInfo = result.data.userInfo;

        // 将openid存储到本地缓存中，便于其他页面使用
        this.saveOpenIdToStorage(result.data.userInfo);

        return true;
      }
      throw new Error('保存登录信息失败');

    } catch (error) {
      console.error('Login failed:', error);
      wx.showToast({
        title: error.message || '登录失败',
        icon: 'none'
      });
      return false;
    }
  },

  // 全局登出方法
  logout() {
    try {
      if (clearLoginInfo()) {
        this.globalData.isLoggedIn = false;
        this.globalData.userInfo = null;
        return true;
      } else {
        throw new Error('清除登录信息失败');
      }
    } catch (e) {
      console.error('清除登录信息失败:', e);
      return false;
    }
  },

  // 检查登录状态
  async checkLoginStatus() {
    try {
      const isLoggedIn = checkLogin();
      this.globalData.isLoggedIn = isLoggedIn;

      if (isLoggedIn) {
        const { userInfo } = getLoginInfo();
        if (userInfo) {
          this.globalData.userInfo = userInfo;

          // 将openid存储到本地缓存中，便于其他页面使用
          this.saveOpenIdToStorage(userInfo);
        }
      }

      return isLoggedIn;
    } catch (error) {
      console.error('Check login status failed:', error);
      return false;
    }
  },

  /**
   * 将用户的openId保存到本地缓存
   * @param {Object} userInfo - 用户信息对象
   */
  saveOpenIdToStorage(userInfo) {
    try {
      if (userInfo && userInfo.stats && userInfo.stats.openid) {
        wx.setStorageSync('openId', userInfo.stats.openid);
        console.log('存储openId到本地缓存:', userInfo.stats.openid);
      } else {
        console.warn('用户信息中没有openId，无法保存到本地缓存');
      }
    } catch (error) {
      console.error('保存openId到本地缓存失败:', error);
    }
  },

  /**
   * 初始化云环境
   * @returns {boolean} 初始化是否成功
   */
  initCloudEnvironment() {
    try {
      // 检查是否已经初始化
      if (!wx.cloud.inited) {
        wx.cloud.init({
          env: this.globalData.cloudEnv,
          traceUser: true,
        });
      }
      this.globalData.cloudInit = true;
      console.log('云环境初始化成功:', this.globalData.cloudEnv);

      // 初始化图片服务
      this.globalData.imageService = imageService;
      imageService.initImageService();
      return true;
    } catch (error) {
      console.error('云环境初始化失败:', error);
      // 尝试使用动态环境ID
      try {
        wx.cloud.init({
          env: wx.cloud.DYNAMIC_CURRENT_ENV,
          traceUser: true,
        });
        this.globalData.cloudInit = true;
        console.log('使用动态环境ID初始化云环境成功');

        // 初始化图片服务
        this.globalData.imageService = imageService;
        imageService.initImageService();
        return true;
      } catch (retryError) {
        console.error('使用动态环境ID初始化云环境失败:', retryError);
        return false;
      }
    }
  },

  /**
   * 更新主题设置
   * @param {boolean} isDarkMode - 是否为暗黑模式
   */
  updateTheme(isDarkMode) {
    try {
      // 更新全局状态
      this.globalData.darkMode = isDarkMode;

      // 尝试更新当前页面的主题
      this.updateCurrentPageTheme(isDarkMode);

      // 设置TabBar样式
      this.updateTabBarStyle(isDarkMode);
    } catch (error) {
      console.error('更新主题设置失败:', error);
    }
  },

  /**
   * 更新当前页面的主题
   * @param {boolean} isDarkMode - 是否为暗黑模式
   */
  updateCurrentPageTheme(isDarkMode) {
    try {
      // 获取当前页面
      const pages = getCurrentPages();
      if (pages.length === 0) {
        console.log('当前没有页面，不更新页面主题');
        return;
      }

      // 遍历所有页面，更新主题
      pages.forEach(page => {
        if (page && page.setData) {
          page.setData({ darkMode: isDarkMode });
          console.log(`更新页面 ${page.route} 的主题为:`, isDarkMode ? '暗黑模式' : '亮色模式');
        }
      });
    } catch (error) {
      console.error('更新当前页面主题失败:', error);
    }
  },

  /**
   * 更新TabBar样式
   * @param {boolean} isDarkMode - 是否为暗黑模式
   */
  updateTabBarStyle(isDarkMode) {
    try {
      // 获取当前页面路径
      const pages = getCurrentPages();
      if (pages.length === 0) {
        console.log('当前没有页面，不设置TabBar样式');
        return;
      }

      const currentPage = pages[pages.length - 1];
      const currentRoute = currentPage.route;

      // 检查当前页面是否是TabBar页面
      const tabBarPages = this.globalData.config.theme.TAB_BAR_PAGES;
      const isTabBarPage = tabBarPages.some(page => currentRoute === page);

      if (!isTabBarPage) {
        console.log('当前页面不是TabBar页面，不设置TabBar样式:', currentRoute);
        return;
      }

      // 设置TabBar样式
      wx.setTabBarStyle({
        color: isDarkMode ? '#8a9aa9' : '#6c757d',
        selectedColor: isDarkMode ? '#4dabf7' : '#007bff',
        backgroundColor: isDarkMode ? '#1a1d20' : '#ffffff',
        borderStyle: isDarkMode ? 'black' : 'white',
        success: () => {
          console.log('设置TabBar样式成功，暗黑模式:', isDarkMode);
        },
        fail: (error) => {
          console.error('设置TabBar样式失败:', error);
        }
      });
    } catch (error) {
      console.error('更新TabBar样式失败:', error);
    }
  }
});

*#*#*end*#*#*

*#*#*miniprogram\app.json*#*#*begin*#*#*
{
  "pages": [
    "pages/welcome/welcome",
    "pages/home/home",
    "pages/role-select/role-select",
    "pages/user/user",
    "pages/user/profile/profile",
    "pages/keywordTest/keywordTest",
    "pages/agreement/service",
    "pages/agreement/privacy",
    "pages/role-editor/index",
    "pages/prompt-editor/prompt-editor",
    "pages/test-gemini/test-gemini"
  ],
  "subpackages": [
    {
      "root": "packageEmotion",
      "name": "emotionPackage",
      "pages": [
        "pages/daily-report/daily-report",
        "pages/emotion-history/emotion-history"
      ]
    },
    {
      "root": "packageChat",
      "name": "chatPackage",
      "pages": [
        "pages/chat/chat",
        "pages/emotion-analysis/emotion-analysis"
      ]
    }
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "HeartChat",
    "navigationBarTextStyle": "black"
  },
  "tabBar": {
    "custom": false,
    "color": "@tabFontColor",
    "selectedColor": "@tabSelectedColor",
    "backgroundColor": "@tabBgColor",
    "borderStyle": "@tabBorderStyle",
    "list": [
      {
        "pagePath": "pages/home/home",
        "text": "首页",
        "iconPath": "images/tabbar/home.png",
        "selectedIconPath": "images/tabbar/home-active.png"
      },
      {
        "pagePath": "pages/role-select/role-select",
        "text": "心情树洞",
        "iconPath": "images/tabbar/emotion.png",
        "selectedIconPath": "images/tabbar/emotion-active.png"
      },
      {
        "pagePath": "pages/user/user",
        "text": "我的",
        "iconPath": "images/tabbar/user.png",
        "selectedIconPath": "images/tabbar/user-active.png"
      }
    ]
  },
  "usingComponents": {
    "emotion-card": "/components/emotion-card/index",
    "emotion-pie": "/components/emotion-pie/emotion-pie",
    "emotion-panel": "/components/emotion-panel/emotion-panel",
    "emotion-history": "/components/emotion-history/emotion-history",
    "emotion-analysis": "/components/emotion-analysis/emotion-analysis",
    "role-card": "/components/role-card/role-card",
    "ec-canvas": "/components/ec-canvas/ec-canvas"
  },
  "requiredPrivateInfos": [],
  "requiredBackgroundModes": [
    "audio"
  ],
  "lazyCodeLoading": "requiredComponents",
  "style": "v2",
  "sitemapLocation": "sitemap.json",
  "darkmode": true,
  "themeLocation": "theme.json",
  "debug": false
}
*#*#*end*#*#*

*#*#*miniprogram\app.wxss*#*#*begin*#*#*
/**app.wxss**/
page {
  --primary-color: #07c160;
  --danger-color: #ee0a24;
  --warning-color: #ff976a;
  --info-color: #1989fa;
  --text-color: #333333;
  --text-color-gray: #999999;
  --border-color: #ebedf0;
  --active-color: #f2f3f5;
  --background-color: #ededed;
  
  background: var(--background-color);
  font-size: 28rpx;
  color: var(--text-color);
  font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica,
    Segoe UI, Arial, Roboto, 'PingFang SC', 'miui', 'Hiragino Sans GB', 'Microsoft Yahei',
    sans-serif;
}

/* 通用容器 */
.container {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  box-sizing: border-box;
}

/* 安全区适配 */
.safe-area-bottom {
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}

/* 通用动画 */
.fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

.fade-out {
  animation: fadeOut 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* 通用过渡 */
.transition {
  transition: all 0.3s ease-in-out;
}

/* 文本溢出省略 */
.ellipsis {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.ellipsis-2 {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
}

/* 通用间距 */
.margin-xs { margin: 10rpx; }
.margin-sm { margin: 20rpx; }
.margin { margin: 30rpx; }
.margin-lg { margin: 40rpx; }
.margin-xl { margin: 50rpx; }

.padding-xs { padding: 10rpx; }
.padding-sm { padding: 20rpx; }
.padding { padding: 30rpx; }
.padding-lg { padding: 40rpx; }
.padding-xl { padding: 50rpx; }

/* 通用flex布局 */
.flex { display: flex; }
.flex-column { flex-direction: column; }
.flex-row { flex-direction: row; }
.flex-wrap { flex-wrap: wrap; }
.justify-start { justify-content: flex-start; }
.justify-end { justify-content: flex-end; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }
.justify-around { justify-content: space-around; }
.align-start { align-items: flex-start; }
.align-end { align-items: flex-end; }
.align-center { align-items: center; }

/* 通用按钮样式重置 */
button {
  background: initial;
  line-height: inherit;
  border-radius: inherit;
  box-sizing: border-box;
  padding: 0;
  margin: 0;
  font-size: inherit;
  color: inherit;
}

button:focus { outline: 0; }
button::after { border: none; }

/* 去除button的默认边框 */
button[plain] { border: 0; }

/* 隐藏滚动条 */
::-webkit-scrollbar {
  display: none;
  width: 0;
  height: 0;
  color: transparent;
}
*#*#*end*#*#*

*#*#*miniprogram\sitemap.json*#*#*begin*#*#*
{
  "desc": "配置小程序页面是否允许被索引",
  "rules": [
    {
      "action": "allow",
      "page": "pages/user/user"
    },
    {
      "action": "allow",
      "page": "packageEmotion/pages/emotion-history/emotion-history"
    },
    {
      "action": "allow",
      "page": "packageChat/pages/emotion-analysis/emotion-analysis"
    },
    {
      "action": "disallow",
      "page": "*"
    }
  ]
}
*#*#*end*#*#*

*#*#*miniprogram\theme.json*#*#*begin*#*#*
{
  "light": {
    "backgroundColor": "#f8f9fa",
    "backgroundColorTop": "#ffffff",
    "backgroundColorBottom": "#f8f9fa",
    "backgroundTextStyle": "dark",
    "navigationBarBackgroundColor": "#007bff",
    "navigationBarTextStyle": "white",
    "navigationBarTitleText": "心情对话",

    "tabFontColor": "#6c757d",
    "tabSelectedColor": "#007bff",
    "tabBgColor": "#ffffff",
    "tabBorderStyle": "white",

    "color-primary": "#007bff",
    "color-success": "#28a745",
    "color-warning": "#ffc107",
    "color-danger": "#dc3545",
    "color-info": "#17a2b8",

    "color-text-base": "#212529",
    "color-text-secondary": "#6c757d",
    "color-text-placeholder": "#adb5bd",
    "color-text-disabled": "#dee2e6",

    "color-bg-base": "#ffffff",
    "color-bg-light": "#f8f9fa",
    "color-bg-mask": "rgba(0, 0, 0, 0.45)",

    "color-border-base": "#dee2e6",
    "color-border-light": "#e9ecef",
    "color-border-split": "#f8f9fa",

    "shadow-sm": "0 2rpx 12rpx rgba(0, 0, 0, 0.1)",
    "shadow-md": "0 4rpx 24rpx rgba(0, 0, 0, 0.1)",
    "shadow-lg": "0 8rpx 48rpx rgba(0, 0, 0, 0.1)"
  },
  "dark": {
    "backgroundColor": "#1a1d20",
    "backgroundColorTop": "#212529",
    "backgroundColorBottom": "#1a1d20",
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#212529",
    "navigationBarTextStyle": "white",
    "navigationBarTitleText": "心情对话",

    "tabFontColor": "#8a9aa9",
    "tabSelectedColor": "#4dabf7",
    "tabBgColor": "#1a1d20",
    "tabBorderStyle": "black",

    "color-primary": "#0d6efd",
    "color-success": "#198754",
    "color-warning": "#ffc107",
    "color-danger": "#dc3545",
    "color-info": "#0dcaf0",

    "color-text-base": "#f8f9fa",
    "color-text-secondary": "#adb5bd",
    "color-text-placeholder": "#6c757d",
    "color-text-disabled": "#495057",

    "color-bg-base": "#212529",
    "color-bg-light": "#343a40",
    "color-bg-mask": "rgba(0, 0, 0, 0.75)",

    "color-border-base": "#495057",
    "color-border-light": "#343a40",
    "color-border-split": "#212529",

    "shadow-sm": "0 2rpx 12rpx rgba(0, 0, 0, 0.2)",
    "shadow-md": "0 4rpx 24rpx rgba(0, 0, 0, 0.2)",
    "shadow-lg": "0 8rpx 48rpx rgba(0, 0, 0, 0.2)"
  }
}
*#*#*end*#*#*

*#*#*package.json*#*#*begin*#*#*
{
  "name": "heart-chat",
  "version": "1.0.0",
  "description": "情商提升助手小程序",
  "main": "app.js",
  "scripts": {
    "start": "npm run dev",
    "dev": "cross-env NODE_ENV=development",
    "build": "cross-env NODE_ENV=production && npm run build:npm",
    "build:npm": "node ./build/build-npm.js",
    "test": "jest",
    "lint": "eslint . --ext .js,.ts",
    "lint:fix": "eslint . --ext .js,.ts --fix",
    "format": "prettier --write \"**/*.{js,ts,json,md,wxml,wxss}\"",
    "prepare": "husky install",
    "clean": "rimraf miniprogram_npm"
  },
  "keywords": [
    "wechat",
    "miniprogram",
    "emotion",
    "chat",
    "ai"
  ],
  "author": "Your Name <your.email@example.com>",
  "license": "MIT",
  "dependencies": {
    "@vant/weapp": "^1.11.1",
    "dayjs": "^1.11.10",
    "echarts": "^5.6.0"
  },
  "devDependencies": {
    "@types/wechat-miniprogram": "^3.4.7",
    "@typescript-eslint/eslint-plugin": "^6.17.0",
    "@typescript-eslint/parser": "^6.17.0",
    "cross-env": "^7.0.3",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.2",
    "husky": "^8.0.3",
    "lint-staged": "^15.2.0",
    "prettier": "^3.1.1",
    "rimraf": "^5.0.5",
    "typescript": "^5.3.3"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{js,ts}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md,wxml,wxss}": [
      "prettier --write"
    ]
  }
}

*#*#*end*#*#*

*#*#*project.config.json*#*#*begin*#*#*
{
  "description": "项目配置文件",
  "packOptions": {
    "ignore": [],
    "include": []
  },
  "miniprogramRoot": "miniprogram/",
  "compileType": "miniprogram",
  "libVersion": "3.7.8",
  "projectname": "HeartChat",
  "setting": {
    "urlCheck": true,
    "es6": true,
    "enhance": true,
    "postcss": true,
    "preloadBackgroundData": false,
    "minified": true,
    "newFeature": false,
    "coverView": true,
    "nodeModules": true,
    "autoAudits": false,
    "showShadowRootInWxmlPanel": true,
    "scopeDataCheck": false,
    "uglifyFileName": true,
    "checkInvalidKey": true,
    "checkSiteMap": true,
    "uploadWithSourceMap": true,
    "compileHotReLoad": false,
    "lazyloadPlaceholderEnable": false,
    "useMultiFrameRuntime": true,
    "useApiHook": true,
    "useApiHostProcess": true,
    "ignoreDevUnusedFiles": false,
    "ignoreUploadUnusedFiles": true,
    "babelSetting": {
      "ignore": [],
      "disablePlugins": [],
      "outputPath": ""
    },
    "enableEngineNative": false,
    "useIsolateContext": false,
    "userConfirmedBundleSwitch": false,
    "packNpmManually": true,
    "packNpmRelationList": [
      {
        "packageJsonPath": "./package.json",
        "miniprogramNpmDistDir": "./miniprogram/"
      }
    ],
    "minifyWXSS": true,
    "showES6CompileOption": false,
    "minifyWXML": true,
    "useStaticServer": true,
    "disableUseStrict": false,
    "useCompilerPlugins": [
      "typescript"
    ]
  },
  "appid": "wx3b23ed9a8ff5f5c6",
  "condition": {},
  "cloudfunctionRoot": "cloudfunctions/",
  "cloud": true,
  "envId": "cloud1-9gpfk3ie94d8630a",
  "cloudfunctionTemplateRoot": "cloudfunctionTemplate/",
  "srcMiniprogramRoot": "miniprogram/",
  "editorSetting": {
    "tabIndent": "insertSpaces",
    "tabSize": 2
  }
}
*#*#*end*#*#*


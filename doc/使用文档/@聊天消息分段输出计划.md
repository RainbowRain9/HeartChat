# HeartChat 聊天消息分段输出计划

## 一、需求分析

### 当前状态
- 目前AI回复是一次性完整输出的，缺乏真实聊天的节奏感
- 长文本一次性显示，用户体验不够自然
- 缺少类似"正在输入..."的实时反馈

### 需要实现的功能
- 将AI回复按自然段落或句子拆分，形成多个消息气泡
- 在每个气泡之间添加适当的时间间隔，模拟真实打字的节奏
- 优化"正在输入..."的状态提示，增强交互的真实感
- 确保分段后的消息在数据库中正确存储和显示

## 二、技术方案

### 1. 消息分段处理

#### 1.1 分段策略
- **自然段落分段**：按照段落（通过`\n\n`识别）进行分段
- **句子分段**：对于没有明显段落的长文本，按照句号、问号、感叹号等标点符号进行分段
- **长度限制**：设置单条消息的最大长度（如200字），超过则在适当位置分段

#### 1.2 分段算法
```javascript
function splitMessage(message) {
  // 首先尝试按段落分割
  let segments = message.split(/\n\s*\n/);
  
  // 如果只有一个段落且较长，则按句子分割
  if (segments.length === 1 && segments[0].length > 200) {
    segments = segments[0].split(/(?<=[。！？.!?])\s*/);
  }
  
  // 处理过长的句子
  const result = [];
  for (const segment of segments) {
    if (segment.length > 200) {
      // 将长句子按照逗号、分号等次要标点分割
      const subSegments = segment.split(/(?<=[，；、,;])\s*/);
      result.push(...subSegments);
    } else if (segment.trim()) {
      result.push(segment.trim());
    }
  }
  
  return result;
}
```

### 2. 云函数修改

#### 2.1 修改 `generateAIReply` 函数
在 `cloudfunctions/chat/index.js` 中修改 `generateAIReply` 函数，增加消息分段处理：

```javascript
async function generateAIReply(event, context) {
  // ... 现有代码 ...
  
  // 调用智谱AI生成回复
  const aiResult = await bigModelModule.generateChatReply(
    message,
    history,
    roleInfo,
    includeEmotionAnalysis
  );
  
  if (!aiResult.success) {
    throw new Error(aiResult.error || 'AI回复生成失败');
  }
  
  // 分段处理AI回复
  const segments = splitMessage(aiResult.reply);
  
  // 返回分段后的回复
  return {
    success: true,
    content: aiResult.reply,  // 保留完整回复用于存储
    segments: segments,       // 添加分段数组
    emotionAnalysis: aiResult.emotionAnalysis,
    usage: aiResult.usage,
    timestamp: Date.now()
  };
}
```

#### 2.2 修改 `sendMessage` 函数
在 `cloudfunctions/chat/index.js` 中修改 `sendMessage` 函数，处理分段消息的存储：

```javascript
async function sendMessage(event, context) {
  // ... 现有代码 ...
  
  // 生成AI回复
  const aiReplyResult = await generateAIReply({
    message: content,
    history: historyMessages,
    roleInfo: roleInfo,
    includeEmotionAnalysis: true
  });
  
  if (!aiReplyResult.success) {
    throw new Error(aiReplyResult.error || 'AI回复生成失败');
  }
  
  // 获取分段消息
  const segments = aiReplyResult.segments || [aiReplyResult.content];
  const aiMessages = [];
  
  // 保存每个分段消息
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    
    // 创建消息对象
    const aiMessage = {
      chatId: currentChatId,
      roleId: roleId,
      openId: OPENID,
      content: segment,
      sender_type: 'ai',
      createTime: db.serverDate(),
      status: 'sent',
      isSegment: true,           // 标记为分段消息
      segmentIndex: i,           // 分段索引
      totalSegments: segments.length, // 总分段数
      originalMessageId: i === 0 ? null : aiMessages[0]._id // 关联到第一条消息
    };
    
    // 保存消息
    const aiMsgResult = await db.collection('messages').add({
      data: aiMessage
    });
    
    // 记录消息ID
    aiMessage._id = aiMsgResult._id;
    aiMessages.push(aiMessage);
    
    // 更新会话信息
    await db.collection('chats').doc(currentChatId).update({
      data: {
        messageCount: _.inc(1),
        lastMessage: segment,
        updateTime: db.serverDate()
      }
    });
  }
  
  // ... 情绪分析处理 ...
  
  // 返回结果
  return {
    success: true,
    chatId: currentChatId,
    isNewChat: isNewChat,
    message: userMessageComplete.data,
    aiMessages: aiMessages,      // 返回所有分段消息
    emotionAnalysis: emotionAnalysis
  };
}
```

### 3. 小程序端修改

#### 3.1 修改聊天页面处理逻辑
在 `miniprogram/packageChat/pages/chat/chat.js` 中修改 `handleSendMessage` 函数：

```javascript
async handleSendMessage(e) {
  // ... 现有代码 ...
  
  try {
    // 调用云函数发送消息
    const result = await wx.cloud.callFunction({
      name: 'chat',
      data: {
        action: 'sendMessage',
        chatId: this.data.chatId,
        roleId: this.data.roleId,
        content
      }
    });
    
    if (result && result.result && result.result.success) {
      const { chatId, message, aiMessages, emotionAnalysis } = result.result;
      
      // 更新用户消息
      const updatedMessages = [...this.data.messages];
      const userMessageIndex = updatedMessages.findIndex(msg => msg._id === userMessage._id);
      
      if (userMessageIndex !== -1) {
        updatedMessages[userMessageIndex] = message;
      }
      
      // 设置初始状态
      this.setData({
        chatId,
        messages: updatedMessages,
        sending: true,
        pendingAiMessages: aiMessages,
        currentAiMessageIndex: 0
      });
      
      // 逐个显示AI消息，模拟打字效果
      this.showNextAiMessage();
      
      // ... 情绪分析处理 ...
    }
  } catch (error) {
    // ... 错误处理 ...
  }
},

/**
 * 显示下一条AI消息
 */
showNextAiMessage() {
  const { pendingAiMessages, currentAiMessageIndex, messages } = this.data;
  
  if (!pendingAiMessages || currentAiMessageIndex >= pendingAiMessages.length) {
    // 所有消息已显示完毕
    this.setData({ 
      sending: false,
      pendingAiMessages: null,
      currentAiMessageIndex: 0
    });
    return;
  }
  
  // 获取当前要显示的消息
  const aiMessage = pendingAiMessages[currentAiMessageIndex];
  
  // 计算显示延迟（根据消息长度）
  const delay = Math.min(1000, 300 + aiMessage.content.length * 10);
  
  // 添加消息到列表
  setTimeout(() => {
    this.setData({
      messages: [...this.data.messages, aiMessage],
      currentAiMessageIndex: currentAiMessageIndex + 1
    });
    
    // 滚动到底部
    this.scrollToBottom();
    
    // 显示下一条消息
    if (currentAiMessageIndex + 1 < pendingAiMessages.length) {
      // 在消息之间添加一个短暂的延迟，模拟打字间隔
      setTimeout(() => {
        this.showNextAiMessage();
      }, 500);
    } else {
      // 所有消息已显示完毕
      this.setData({ 
        sending: false,
        pendingAiMessages: null,
        currentAiMessageIndex: 0
      });
    }
  }, delay);
}
```

#### 3.2 优化"正在输入..."状态显示
在 `miniprogram/packageChat/pages/chat/chat.wxml` 中优化输入状态显示：

```html
<!-- 角色名称，当发送消息时显示"对方正在输入..." -->
<view class="role-title">
  <text wx:if="{{!sending}}">{{role.name || '未知角色'}}</text>
  <text wx:else class="typing-text">对方正在输入<text class="typing-dots">...</text></text>
</view>

<!-- 添加CSS动画 -->
<style>
.typing-dots {
  display: inline-block;
  animation: typingDots 1.5s infinite;
}

@keyframes typingDots {
  0% { opacity: 0.3; }
  50% { opacity: 1; }
  100% { opacity: 0.3; }
}
</style>
```

## 三、数据库设计调整

### 1. 消息表结构调整
在 `messages` 集合中添加以下字段：

- `isSegment`: 布尔值，标识是否为分段消息
- `segmentIndex`: 数字，分段消息的索引
- `totalSegments`: 数字，总分段数
- `originalMessageId`: 字符串，分段消息关联的原始消息ID

### 2. 缓存服务调整
修改 `chatCacheService.js` 以支持分段消息：

```javascript
// 保存消息到缓存
saveMessagesToCache(chatId, messages, isLatest = true, page = null, roleInfo = null) {
  // ... 现有代码 ...
  
  // 处理分段消息的关联
  const messageMap = {};
  messages.forEach(msg => {
    messageMap[msg._id] = msg;
  });
  
  // 将分段消息按照索引排序
  const sortedMessages = [...messages].sort((a, b) => {
    // 如果都是分段消息且来自同一原始消息
    if (a.isSegment && b.isSegment && a.originalMessageId === b.originalMessageId) {
      return a.segmentIndex - b.segmentIndex;
    }
    // 否则按时间戳排序
    return a.timestamp - b.timestamp;
  });
  
  // ... 保存排序后的消息 ...
}
```

## 四、实现步骤

### 1. 云函数修改
1. 在 `cloudfunctions/chat/index.js` 中添加消息分段函数
2. 修改 `generateAIReply` 函数，增加分段处理
3. 修改 `sendMessage` 函数，处理分段消息的存储
4. 更新返回结果格式，包含分段消息数组

### 2. 小程序端修改
1. 修改 `miniprogram/packageChat/pages/chat/chat.js` 中的消息处理逻辑
2. 添加分段消息显示的延迟效果
3. 优化"正在输入..."状态显示
4. 调整消息缓存服务，支持分段消息

### 3. 测试与优化
1. 测试不同类型文本的分段效果
2. 调整分段算法和显示延迟，优化用户体验
3. 确保分段消息在历史记录中正确显示
4. 验证消息缓存和加载功能正常工作

## 五、预期效果

1. AI回复将按照自然段落或句子分段显示，形成多个消息气泡
2. 消息气泡将按照一定的时间间隔依次显示，模拟真实打字的节奏
3. "正在输入..."状态提示更加生动，增强交互的真实感
4. 整体聊天体验更加自然，接近真实人类对话

## 六、注意事项

1. 确保分段消息在数据库中正确关联，便于历史记录查询
2. 优化显示延迟算法，避免过长或过短的等待时间
3. 考虑网络延迟和失败情况的处理
4. 确保消息分段不影响情绪分析功能
5. 保持向后兼容性，确保旧版本的消息仍能正常显示

---
description: 微信小程序 API 使用规范
globs: 
alwaysApply: false
---
# 微信小程序 API 使用规范

## API 调用基本原则

1. 使用 Promise 封装异步 API
2. 处理 API 调用的错误情况
3. 避免频繁调用相同的 API
4. 使用缓存减少不必要的 API 调用
5. 遵循微信小程序的调用频率限制

## 网络请求

### wx.request

```javascript
// 基本用法
wx.request({
  url: 'https://api.example.com/data',
  method: 'GET',
  data: {
    id: 1
  },
  header: {
    'content-type': 'application/json'
  },
  success(res) {
    console.log(res.data);
  },
  fail(err) {
    console.error('Request failed', err);
  },
  complete() {
    // 请求完成后执行
  }
});

// Promise 封装
function request(options) {
  return new Promise((resolve, reject) => {
    wx.request({
      ...options,
      success(res) {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(res.data);
        } else {
          reject(new Error(`Request failed with status ${res.statusCode}`));
        }
      },
      fail(err) {
        reject(err);
      }
    });
  });
}

// 使用封装的函数
async function fetchData() {
  try {
    const data = await request({
      url: 'https://api.example.com/data',
      method: 'GET'
    });
    return data;
  } catch (error) {
    console.error('Failed to fetch data:', error);
    wx.showToast({
      title: '获取数据失败',
      icon: 'none'
    });
    return null;
  }
}
```

### 请求任务管理

```javascript
// 创建请求任务
const requestTask = wx.request({
  url: 'https://api.example.com/data',
  method: 'GET',
  success(res) {
    console.log(res.data);
  }
});

// 中断请求任务
function cancelRequest() {
  if (requestTask) {
    requestTask.abort();
  }
}
```

## 数据缓存

### 存储数据

```javascript
// 同步存储
try {
  wx.setStorageSync('key', 'value');
} catch (e) {
  console.error('Storage failed:', e);
}

// 异步存储
wx.setStorage({
  key: 'key',
  data: 'value',
  success() {
    console.log('Storage successful');
  },
  fail(err) {
    console.error('Storage failed:', err);
  }
});

// Promise 封装
function setStorage(key, data) {
  return new Promise((resolve, reject) => {
    wx.setStorage({
      key,
      data,
      success: resolve,
      fail: reject
    });
  });
}

// 使用封装的函数
async function saveUserInfo(userInfo) {
  try {
    await setStorage('userInfo', userInfo);
    return true;
  } catch (error) {
    console.error('Failed to save user info:', error);
    return false;
  }
}
```

### 获取数据

```javascript
// 同步获取
try {
  const value = wx.getStorageSync('key');
  if (value) {
    console.log(value);
  }
} catch (e) {
  console.error('Get storage failed:', e);
}

// 异步获取
wx.getStorage({
  key: 'key',
  success(res) {
    console.log(res.data);
  },
  fail(err) {
    console.error('Get storage failed:', err);
  }
});

// Promise 封装
function getStorage(key) {
  return new Promise((resolve, reject) => {
    wx.getStorage({
      key,
      success(res) {
        resolve(res.data);
      },
      fail(err) {
        reject(err);
      }
    });
  });
}

// 使用封装的函数
async function getUserInfo() {
  try {
    return await getStorage('userInfo');
  } catch (error) {
    console.error('Failed to get user info:', error);
    return null;
  }
}
```

### 清除数据

```javascript
// 清除特定数据
wx.removeStorage({
  key: 'key',
  success() {
    console.log('Remove successful');
  }
});

// 清除所有数据
wx.clearStorage({
  success() {
    console.log('Clear successful');
  }
});
```

## 界面交互

### 导航栏

```javascript
// 设置导航栏标题
wx.setNavigationBarTitle({
  title: '页面标题'
});

// 设置导航栏颜色
wx.setNavigationBarColor({
  frontColor: '#ffffff',
  backgroundColor: '#000000',
  animation: {
    duration: 400,
    timingFunc: 'easeIn'
  }
});

// 显示导航栏加载动画
wx.showNavigationBarLoading();

// 隐藏导航栏加载动画
wx.hideNavigationBarLoading();
```

### 加载提示

```javascript
// 显示加载提示
wx.showLoading({
  title: '加载中',
  mask: true
});

// 隐藏加载提示
wx.hideLoading();

// 显示消息提示框
wx.showToast({
  title: '操作成功',
  icon: 'success',
  duration: 2000
});

// 隐藏消息提示框
wx.hideToast();
```

### 模态对话框

```javascript
// 显示模态对话框
wx.showModal({
  title: '提示',
  content: '确定要删除吗？',
  showCancel: true,
  cancelText: '取消',
  cancelColor: '#999999',
  confirmText: '确定',
  confirmColor: '#3CC51F',
  success(res) {
    if (res.confirm) {
      console.log('用户点击确定');
      // 执行删除操作
    } else if (res.cancel) {
      console.log('用户点击取消');
    }
  }
});

// Promise 封装
function showModal(options) {
  return new Promise((resolve) => {
    wx.showModal({
      ...options,
      success(res) {
        resolve(res);
      },
      fail() {
        resolve({ confirm: false, cancel: true });
      }
    });
  });
}

// 使用封装的函数
async function confirmDelete() {
  const res = await showModal({
    title: '提示',
    content: '确定要删除吗？'
  });
  
  if (res.confirm) {
    // 执行删除操作
    return true;
  }
  return false;
}
```

### 操作菜单

```javascript
// 显示操作菜单
wx.showActionSheet({
  itemList: ['选项一', '选项二', '选项三'],
  success(res) {
    console.log(res.tapIndex);
    // 根据选择执行操作
  },
  fail(err) {
    console.log(err.errMsg);
  }
});

// Promise 封装
function showActionSheet(options) {
  return new Promise((resolve, reject) => {
    wx.showActionSheet({
      ...options,
      success(res) {
        resolve(res);
      },
      fail(err) {
        reject(err);
      }
    });
  });
}

// 使用封装的函数
async function showOptions() {
  try {
    const res = await showActionSheet({
      itemList: ['选项一', '选项二', '选项三']
    });
    return res.tapIndex;
  } catch (error) {
    console.log('用户取消操作');
    return -1;
  }
}
```

## 路由导航

### 页面跳转

```javascript
// 保留当前页面，跳转到应用内的某个页面
wx.navigateTo({
  url: '/pages/detail/detail?id=1',
  events: {
    // 接收被打开页面传送回来的数据
    acceptDataFromOpenedPage(data) {
      console.log(data);
    }
  },
  success(res) {
    // 通过 eventChannel 向被打开页面传送数据
    res.eventChannel.emit('acceptDataFromOpenerPage', { data: 'test' });
  }
});

// 关闭当前页面，跳转到应用内的某个页面
wx.redirectTo({
  url: '/pages/result/result'
});

// 关闭所有页面，打开到应用内的某个页面
wx.reLaunch({
  url: '/pages/index/index'
});

// 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
wx.switchTab({
  url: '/pages/home/home'
});

// 关闭当前页面，返回上一页面或多级页面
wx.navigateBack({
  delta: 1
});
```

### 页面参数处理

```javascript
// 在目标页面的 onLoad 中获取参数
Page({
  onLoad(options) {
    const { id } = options;
    console.log('Received id:', id);
    
    // 获取 eventChannel
    const eventChannel = this.getOpenerEventChannel();
    
    // 监听 acceptDataFromOpenerPage 事件，获取上一页面通过 eventChannel 传送的数据
    eventChannel.on('acceptDataFromOpenerPage', (data) => {
      console.log('Received data:', data);
    });
  }
});
```

## 用户信息

### 获取用户信息

```javascript
// 获取用户信息
wx.getUserProfile({
  desc: '用于完善会员资料',
  success(res) {
    const userInfo = res.userInfo;
    console.log(userInfo);
  },
  fail(err) {
    console.error('Get user info failed:', err);
  }
});

// Promise 封装
function getUserProfile(desc) {
  return new Promise((resolve, reject) => {
    wx.getUserProfile({
      desc,
      success(res) {
        resolve(res.userInfo);
      },
      fail(err) {
        reject(err);
      }
    });
  });
}

// 使用封装的函数
async function getUser() {
  try {
    const userInfo = await getUserProfile('用于完善会员资料');
    return userInfo;
  } catch (error) {
    console.error('Failed to get user profile:', error);
    return null;
  }
}
```

## 位置信息

### 获取位置

```javascript
// 获取当前位置
wx.getLocation({
  type: 'gcj02',
  success(res) {
    const { latitude, longitude } = res;
    console.log('Current location:', latitude, longitude);
  },
  fail(err) {
    console.error('Get location failed:', err);
  }
});

// Promise 封装
function getLocation(type = 'gcj02') {
  return new Promise((resolve, reject) => {
    wx.getLocation({
      type,
      success(res) {
        resolve(res);
      },
      fail(err) {
        reject(err);
      }
    });
  });
}

// 使用封装的函数
async function getCurrentLocation() {
  try {
    return await getLocation();
  } catch (error) {
    console.error('Failed to get location:', error);
    return null;
  }
}
```

## 图片处理

### 选择图片

```javascript
// 从相册选择图片
wx.chooseImage({
  count: 1,
  sizeType: ['original', 'compressed'],
  sourceType: ['album', 'camera'],
  success(res) {
    const tempFilePaths = res.tempFilePaths;
    console.log('Selected images:', tempFilePaths);
  }
});

// Promise 封装
function chooseImage(options = {}) {
  return new Promise((resolve, reject) => {
    wx.chooseImage({
      count: options.count || 1,
      sizeType: options.sizeType || ['original', 'compressed'],
      sourceType: options.sourceType || ['album', 'camera'],
      success(res) {
        resolve(res);
      },
      fail(err) {
        reject(err);
      }
    });
  });
}

// 使用封装的函数
async function selectImage() {
  try {
    const res = await chooseImage({ count: 1 });
    return res.tempFilePaths[0];
  } catch (error) {
    console.error('Failed to select image:', error);
    return null;
  }
}
```

### 预览图片

```javascript
// 预览图片
wx.previewImage({
  current: 'https://example.com/images/1.jpg',
  urls: [
    'https://example.com/images/1.jpg',
    'https://example.com/images/2.jpg'
  ]
});
```

## 文件操作

### 保存文件

```javascript
// 保存文件
wx.saveFile({
  tempFilePath: tempFilePath,
  success(res) {
    const savedFilePath = res.savedFilePath;
    console.log('File saved at:', savedFilePath);
  },
  fail(err) {
    console.error('Save file failed:', err);
  }
});

// Promise 封装
function saveFile(tempFilePath) {
  return new Promise((resolve, reject) => {
    wx.saveFile({
      tempFilePath,
      success(res) {
        resolve(res.savedFilePath);
      },
      fail(err) {
        reject(err);
      }
    });
  });
}

// 使用封装的函数
async function saveImageFile(tempFilePath) {
  try {
    return await saveFile(tempFilePath);
  } catch (error) {
    console.error('Failed to save file:', error);
    return null;
  }
}
```

## 设备信息

### 获取系统信息

```javascript
// 获取系统信息
wx.getSystemInfo({
  success(res) {
    console.log('System info:', res);
  }
});

// 同步获取系统信息
try {
  const systemInfo = wx.getSystemInfoSync();
  console.log('System info:', systemInfo);
} catch (e) {
  console.error('Get system info failed:', e);
}
```

## 最佳实践

1. 使用 Promise 封装异步 API，简化异步操作
2. 处理 API 调用的错误情况，提供友好的错误提示
3. 避免频繁调用相同的 API，合理使用缓存
4. 使用 try/catch 捕获同步 API 的异常
5. 遵循微信小程序的调用频率限制，避免触发限流
6. 使用 async/await 简化异步代码，提高可读性
7. 合理使用 loading 和 toast 提示，优化用户体验
8. 在合适的生命周期函数中调用 API，避免不必要的调用
9. 使用节流或防抖处理频繁触发的 API 调用
10. 定期检查和优化 API 调用，提高应用性能

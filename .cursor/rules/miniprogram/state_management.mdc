---
description: 状态管理模式规范
globs: 
alwaysApply: false
---
# 状态管理模式规范

## 状态管理基本原则

1. 保持状态的单一来源
2. 状态应该是只读的，只能通过特定方法修改
3. 状态修改应该是可预测的
4. 避免状态的重复存储
5. 合理划分全局状态和局部状态

## 全局状态管理

### App 全局数据

```javascript
// app.js
App({
  globalData: {
    userInfo: null,
    theme: 'light',
    settings: {
      // 应用设置
    }
  },
  
  // 更新全局数据的方法
  updateUserInfo(userInfo) {
    this.globalData.userInfo = userInfo;
    // 通知页面更新
    this._notifyUserInfoChanged();
  },
  
  // 通知机制
  _userInfoListeners: [],
  
  // 添加监听器
  onUserInfoChanged(callback) {
    this._userInfoListeners.push(callback);
  },
  
  // 移除监听器
  offUserInfoChanged(callback) {
    this._userInfoListeners = this._userInfoListeners.filter(
      listener => listener !== callback
    );
  },
  
  // 通知监听器
  _notifyUserInfoChanged() {
    const { userInfo } = this.globalData;
    this._userInfoListeners.forEach(callback => {
      callback(userInfo);
    });
  }
});

// 页面中使用
Page({
  onLoad() {
    // 获取 App 实例
    const app = getApp();
    
    // 初始化数据
    this.setData({
      userInfo: app.globalData.userInfo
    });
    
    // 添加监听器
    app.onUserInfoChanged(this.handleUserInfoChanged.bind(this));
  },
  
  onUnload() {
    // 移除监听器
    const app = getApp();
    app.offUserInfoChanged(this.handleUserInfoChanged);
  },
  
  handleUserInfoChanged(userInfo) {
    this.setData({ userInfo });
  },
  
  updateUserInfo() {
    const app = getApp();
    app.updateUserInfo({
      // 新的用户信息
    });
  }
});
```

### 事件总线

```javascript
// utils/eventBus.js
class EventBus {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
  }
  
  // 取消订阅
  off(eventName, callback) {
    if (!this.events[eventName]) return;
    
    if (callback) {
      this.events[eventName] = this.events[eventName].filter(
        cb => cb !== callback
      );
    } else {
      delete this.events[eventName];
    }
  }
  
  // 触发事件
  emit(eventName, ...args) {
    if (!this.events[eventName]) return;
    
    this.events[eventName].forEach(callback => {
      callback(...args);
    });
  }
  
  // 只订阅一次
  once(eventName, callback) {
    const wrapper = (...args) => {
      callback(...args);
      this.off(eventName, wrapper);
    };
    
    this.on(eventName, wrapper);
  }
}

// 导出单例
export default new EventBus();

// 页面中使用
import eventBus from '../../utils/eventBus';

Page({
  onLoad() {
    // 订阅事件
    this.handleThemeChanged = (theme) => {
      this.setData({ theme });
    };
    
    eventBus.on('themeChanged', this.handleThemeChanged);
  },
  
  onUnload() {
    // 取消订阅
    eventBus.off('themeChanged', this.handleThemeChanged);
  },
  
  changeTheme() {
    // 触发事件
    eventBus.emit('themeChanged', 'dark');
  }
});
```

### 简易 Store 模式

```javascript
// utils/store.js
class Store {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = [];
  }
  
  // 获取状态
  getState() {
    return this.state;
  }
  
  // 更新状态
  setState(partialState) {
    this.state = { ...this.state, ...partialState };
    this._notifyListeners();
  }
  
  // 添加监听器
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  // 通知监听器
  _notifyListeners() {
    this.listeners.forEach(listener => {
      listener(this.state);
    });
  }
}

// 创建 store 实例
const store = new Store({
  userInfo: null,
  theme: 'light',
  cart: []
});

export default store;

// 页面中使用
import store from '../../utils/store';

Page({
  onLoad() {
    // 初始化数据
    const state = store.getState();
    this.setData({
      userInfo: state.userInfo,
      theme: state.theme
    });
    
    // 订阅状态变化
    this.unsubscribe = store.subscribe(this.handleStateChanged.bind(this));
  },
  
  onUnload() {
    // 取消订阅
    this.unsubscribe();
  },
  
  handleStateChanged(state) {
    this.setData({
      userInfo: state.userInfo,
      theme: state.theme
    });
  },
  
  updateUserInfo() {
    store.setState({
      userInfo: {
        // 新的用户信息
      }
    });
  }
});
```

## 组件状态管理

### 组件内部状态

```javascript
Component({
  // 组件的内部数据
  data: {
    count: 0,
    isActive: false
  },
  
  methods: {
    // 更新状态的方法
    increment() {
      this.setData({
        count: this.data.count + 1
      });
    },
    
    toggleActive() {
      this.setData({
        isActive: !this.data.isActive
      });
    }
  }
});
```

### 组件间通信

#### 父组件向子组件传递数据

```javascript
// 父组件
Component({
  data: {
    message: 'Hello from parent'
  },
  
  methods: {
    updateMessage() {
      this.setData({
        message: 'Updated message'
      });
    }
  }
});

<!-- 父组件模板 -->
<child-component message="{{message}}" />

// 子组件
Component({
  properties: {
    message: {
      type: String,
      value: ''
    }
  },
  
  observers: {
    'message': function(newVal) {
      console.log('Message changed:', newVal);
    }
  }
});
```

#### 子组件向父组件传递数据

```javascript
// 子组件
Component({
  methods: {
    sendData() {
      // 触发自定义事件
      this.triggerEvent('datachange', {
        value: 'Data from child'
      });
    }
  }
});

<!-- 父组件模板 -->
<child-component bind:datachange="handleDataChange" />

// 父组件
Component({
  methods: {
    handleDataChange(e) {
      const { value } = e.detail;
      console.log('Received from child:', value);
    }
  }
});
```

#### 跨组件通信

```javascript
// 使用事件总线
import eventBus from '../../utils/eventBus';

// 组件 A
Component({
  methods: {
    sendMessage() {
      eventBus.emit('message', {
        from: 'ComponentA',
        content: 'Hello from A'
      });
    }
  }
});

// 组件 B
Component({
  lifetimes: {
    attached() {
      // 订阅事件
      this.handleMessage = (data) => {
        console.log('B received:', data);
      };
      
      eventBus.on('message', this.handleMessage);
    },
    
    detached() {
      // 取消订阅
      eventBus.off('message', this.handleMessage);
    }
  }
});
```

## 页面状态管理

### 页面内部状态

```javascript
Page({
  data: {
    list: [],
    loading: false,
    error: null,
    page: 1,
    hasMore: true
  },
  
  onLoad() {
    this.loadData();
  },
  
  async loadData() {
    this.setData({ loading: true, error: null });
    
    try {
      const res = await this.fetchData(this.data.page);
      
      this.setData({
        list: [...this.data.list, ...res.data],
        page: this.data.page + 1,
        hasMore: res.hasMore,
        loading: false
      });
    } catch (err) {
      this.setData({
        error: err.message,
        loading: false
      });
    }
  },
  
  async fetchData(page) {
    // 获取数据的逻辑
  }
});
```

### 页面间通信

#### URL 参数传递

```javascript
// 页面 A
Page({
  navigateToB() {
    wx.navigateTo({
      url: '/pages/b/b?id=123&type=test'
    });
  }
});

// 页面 B
Page({
  onLoad(options) {
    const { id, type } = options;
    console.log('Received params:', id, type);
  }
});
```

#### 事件通道

```javascript
// 页面 A
Page({
  navigateToB() {
    wx.navigateTo({
      url: '/pages/b/b',
      events: {
        // 接收被打开页面传送回来的数据
        acceptDataFromB(data) {
          console.log('Received from B:', data);
        }
      },
      success(res) {
        // 通过 eventChannel 向被打开页面传送数据
        res.eventChannel.emit('acceptDataFromA', { data: 'From page A' });
      }
    });
  }
});

// 页面 B
Page({
  onLoad() {
    const eventChannel = this.getOpenerEventChannel();
    
    // 监听从页面 A 传来的数据
    eventChannel.on('acceptDataFromA', (data) => {
      console.log('Received from A:', data);
    });
    
    // 向页面 A 发送数据
    eventChannel.emit('acceptDataFromB', { data: 'From page B' });
  }
});
```

## 持久化状态管理

### 本地存储

```javascript
// 保存状态到本地存储
function saveState(key, state) {
  try {
    wx.setStorageSync(key, state);
    return true;
  } catch (e) {
    console.error('Save state failed:', e);
    return false;
  }
}

// 从本地存储加载状态
function loadState(key) {
  try {
    return wx.getStorageSync(key);
  } catch (e) {
    console.error('Load state failed:', e);
    return null;
  }
}

// 使用示例
const userStore = {
  state: {
    userInfo: null,
    settings: {}
  },
  
  // 初始化状态
  init() {
    const savedState = loadState('userState');
    if (savedState) {
      this.state = savedState;
    }
  },
  
  // 更新状态
  updateUserInfo(userInfo) {
    this.state.userInfo = userInfo;
    this._saveState();
  },
  
  updateSettings(settings) {
    this.state.settings = { ...this.state.settings, ...settings };
    this._saveState();
  },
  
  // 保存状态
  _saveState() {
    saveState('userState', this.state);
  }
};

// 初始化
userStore.init();
```

### 云数据库同步

```javascript
// 使用云数据库同步状态
const userStore = {
  state: {
    userInfo: null,
    settings: {}
  },
  
  // 从云数据库加载状态
  async loadFromCloud(userId) {
    try {
      const db = wx.cloud.database();
      const res = await db.collection('users').doc(userId).get();
      
      if (res.data) {
        this.state.userInfo = res.data.userInfo;
        this.state.settings = res.data.settings;
      }
      
      return true;
    } catch (e) {
      console.error('Load from cloud failed:', e);
      return false;
    }
  },
  
  // 保存状态到云数据库
  async saveToCloud(userId) {
    try {
      const db = wx.cloud.database();
      await db.collection('users').doc(userId).update({
        data: {
          userInfo: this.state.userInfo,
          settings: this.state.settings,
          updateTime: db.serverDate()
        }
      });
      
      return true;
    } catch (e) {
      console.error('Save to cloud failed:', e);
      return false;
    }
  },
  
  // 更新状态
  async updateUserInfo(userId, userInfo) {
    this.state.userInfo = userInfo;
    return this.saveToCloud(userId);
  },
  
  async updateSettings(userId, settings) {
    this.state.settings = { ...this.state.settings, ...settings };
    return this.saveToCloud(userId);
  }
};
```

## 最佳实践

1. 根据状态的作用范围选择合适的管理方式
   - 组件内部状态：使用组件的 data
   - 父子组件共享状态：使用属性和事件
   - 跨组件共享状态：使用事件总线或全局状态
   - 全局状态：使用 App.globalData 或状态管理库

2. 避免状态重复存储，保持单一数据源

3. 合理划分状态
   - 临时状态（如 UI 状态）：保存在组件或页面的 data 中
   - 持久状态：保存在本地存储或云数据库中
   - 共享状态：保存在全局状态中

4. 使用不可变数据模式更新状态
   ```javascript
   // 正确的方式
   this.setData({
     list: [...this.data.list, newItem]
   });
   
   // 错误的方式
   const list = this.data.list;
   list.push(newItem);
   this.setData({ list });
   ```

5. 避免频繁更新状态，合并状态更新
   ```javascript
   // 合并更新
   this.setData({
     name: 'New Name',
     age: 30,
     address: 'New Address'
   });
   
   // 避免多次调用
   this.setData({ name: 'New Name' });
   this.setData({ age: 30 });
   this.setData({ address: 'New Address' });
   ```

6. 使用计算属性减少状态数量
   ```javascript
   Page({
     data: {
       items: [],
       filter: 'all'
     },
     
     getFilteredItems() {
       const { items, filter } = this.data;
       
       if (filter === 'all') {
         return items;
       }
       
       return items.filter(item => item.status === filter);
     }
   });
   ```

7. 使用状态管理库处理复杂状态
   - 对于复杂应用，考虑使用第三方状态管理库
   - 确保状态管理方案与小程序架构兼容

8. 定期清理不再使用的状态，避免内存泄漏

9. 使用 TypeScript 定义状态类型，提高代码可维护性

10. 为状态变更添加日志，便于调试和追踪问题

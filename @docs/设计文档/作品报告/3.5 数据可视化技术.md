3.5 数据可视化技术
数据可视化是心语精灵的重要功能之一，通过直观的图表展示用户的情绪变化、兴趣分布等数据，帮助用户更好地理解自己的情感状态。本节详细介绍心语精灵采用的数据可视化技术方案。

3.5.1 ECharts图表库集成
心语精灵选择ECharts作为数据可视化的核心技术，通过微信小程序的自定义组件方式进行集成，实现了高度可定制、交互性强的数据可视化效果。

ECharts选型分析
在选择数据可视化库时，我们对比了多种可选方案，包括ECharts、F2、wx-charts等。最终选择ECharts主要基于以下考虑：

功能丰富性：ECharts提供了丰富的图表类型，包括折线图、饼图、雷达图、热力图等，能够满足情感数据多维度可视化的需求。
定制灵活性：ECharts具有高度的可定制性，支持主题定制、动画效果、交互事件等，能够实现符合应用风格的可视化效果。
微信小程序兼容性：ECharts提供了专门的微信小程序版本（ec-canvas），确保了在小程序环境中的兼容性和性能。
社区支持：ECharts拥有活跃的社区和完善的文档，便于开发和问题解决。
性能表现：ECharts在移动端的性能优化较好，能够处理较大规模的数据集而不影响用户体验。
相比之下，F2虽然专为移动端设计，但图表类型和定制能力有限；wx-charts虽然针对小程序优化，但功能相对简单，难以满足复杂的可视化需求。

ECharts集成实现
心语精灵通过以下步骤实现了ECharts在微信小程序中的集成：
// 在项目中引入ec-canvas组件
import * as echarts from '../../components/ec-canvas/echarts';
引入ec-canvas组件：
创建图表组件：
// chart.js
Component({
  properties: {
    chartData: {
      type: Object,
      value: {},
      observer: function(newVal, oldVal) {
        if (newVal && this.isReady) {
          this.initChart();
        }
      }
    },
    chartType: {
      type: String,
      value: 'line'
    },
    darkMode: {
      type: Boolean,
      value: false,
      observer: function(newVal, oldVal) {
        if (this.isReady) {
          this.initChart();
        }
      }
    }
  },
  
  data: {
    ec: {
      lazyLoad: true
    },
    isReady: false
  },
  
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    }
  },
  
  methods: {
    // 初始化图表
    initChart: function() {
      this.ecComponent = this.selectComponent('#mychart-dom');
      this.ecComponent.init((canvas, width, height, dpr) => {
        const chart = echarts.init(canvas, null, {
          width: width,
          height: height,
          devicePixelRatio: dpr
        });
        
        // 设置图表配置
        const option = this.getChartOption();
        chart.setOption(option);
        
        // 保存图表实例
        this.chart = chart;
        return chart;
      });
    },
    
    // 获取图表配置
    getChartOption: function() {
      // 根据chartType和chartData生成不同类型的图表配置
      switch (this.properties.chartType) {
        case 'line':
          return this.getLineChartOption();
        case 'pie':
          return this.getPieChartOption();
        case 'radar':
          return this.getRadarChartOption();
        default:
          return this.getLineChartOption();
      }
    },
    
    // 折线图配置
    getLineChartOption: function() {
      const darkMode = this.properties.darkMode;
      const textColor = darkMode ? '#e0e0e0' : '#333333';
      const axisLineColor = darkMode ? '#555555' : '#cccccc';
      const splitLineColor = darkMode ? '#333333' : '#eeeeee';
      
      return {
        backgroundColor: 'transparent',
        textStyle: {
          color: textColor
        },
        grid: {
          left: '5%',
          right: '5%',
          bottom: '10%',
          top: '10%',
          containLabel: true
        },
        tooltip: {
          trigger: 'axis',
          confine: true,
          formatter: '{b}: {c}'
        },
        xAxis: {
          type: 'category',
          data: this.properties.chartData.xAxis || [],
          axisLine: {
            lineStyle: {
              color: axisLineColor
            }
          },
          axisLabel: {
            color: textColor
          },
          axisTick: {
            alignWithLabel: true
          }
        },
        yAxis: {
          type: 'value',
          min: 0,
          max: 1,
          axisLine: {
            lineStyle: {
              color: axisLineColor
            }
          },
          axisLabel: {
            color: textColor
          },
          splitLine: {
            lineStyle: {
              color: splitLineColor
            }
          }
        },
        series: [{
          type: 'line',
          smooth: true,
          data: this.properties.chartData.series || [],
          itemStyle: {
            color: this.properties.chartData.color || '#4A90E2'
          },
          lineStyle: {
            width: 3
          },
          areaStyle: {
            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
              offset: 0,
              color: darkMode ? 'rgba(74, 144, 226, 0.6)' : 'rgba(74, 144, 226, 0.6)'
            }, {
              offset: 1,
              color: darkMode ? 'rgba(74, 144, 226, 0.1)' : 'rgba(74, 144, 226, 0.1)'
            }])
          }
        }]
      };
    },
    
    // 饼图配置
    getPieChartOption: function() {
      const darkMode = this.properties.darkMode;
      const textColor = darkMode ? '#e0e0e0' : '#333333';
      
      return {
        backgroundColor: 'transparent',
        textStyle: {
          color: textColor
        },
        tooltip: {
          trigger: 'item',
          formatter: '{b}: {c} ({d}%)'
        },
        legend: {
          orient: 'vertical',
          right: '5%',
          top: 'center',
          textStyle: {
            color: textColor
          }
        },
        series: [{
          type: 'pie',
          radius: ['40%', '70%'],
          center: ['40%', '50%'],
          avoidLabelOverlap: false,
          label: {
            show: false
          },
          emphasis: {
            label: {
              show: true,
              fontSize: '14',
              fontWeight: 'bold'
            }
          },
          labelLine: {
            show: false
          },
          data: this.properties.chartData.data || []
        }]
      };
    },
    
    // 雷达图配置
    getRadarChartOption: function() {
      const darkMode = this.properties.darkMode;
      const textColor = darkMode ? '#e0e0e0' : '#333333';
      const axisLineColor = darkMode ? '#555555' : '#cccccc';
      
      return {
        backgroundColor: 'transparent',
        textStyle: {
          color: textColor
        },
        tooltip: {
          trigger: 'item'
        },
        radar: {
          indicator: this.properties.chartData.indicator || [],
          splitArea: {
            areaStyle: {
              color: darkMode ? 
                ['rgba(50, 50, 50, 0.3)', 'rgba(60, 60, 60, 0.3)'] : 
                ['rgba(250, 250, 250, 0.3)', 'rgba(240, 240, 240, 0.3)']
            }
          },
          axisLine: {
            lineStyle: {
              color: axisLineColor
            }
          },
          splitLine: {
            lineStyle: {
              color: axisLineColor
            }
          },
          name: {
            textStyle: {
              color: textColor
            }
          }
        },
        series: [{
          type: 'radar',
          data: this.properties.chartData.series || [],
          symbol: 'circle',
          symbolSize: 6,
          lineStyle: {
            width: 2
          },
          areaStyle: {
            opacity: 0.3
          }
        }]
      };
    },
    
    // 图表准备完成回调
    onChartReady: function() {
      this.isReady = true;
      if (this.properties.chartData) {
        this.initChart();
      }
    }
  }
});
组件模板定义：
<!-- chart.wxml -->
<view class="chart-container {{darkMode ? 'dark' : 'light'}}">
  <ec-canvas id="mychart-dom" canvas-id="mychart" ec="{{ ec }}" bind:init="onChartReady"></ec-canvas>
</view>
组件样式设计：
/* chart.wxss */
.chart-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

.chart-container.dark {
  background-color: transparent;
}

.chart-container.light {
  background-color: transparent;
}

ec-canvas {
  width: 100%;
  height: 100%;
}

3.5.2 情绪数据可视化设计
心语精灵的情绪数据可视化设计旨在帮助用户直观了解自己的情绪状态和变化趋势，通过多种图表类型展示不同维度的情感数据。

情绪数据可视化类型
心语精灵实现了以下几种情绪数据可视化类型：

情绪变化趋势图：使用折线图展示用户情绪强度随时间的变化趋势，帮助用户了解情绪波动规律。
情绪分布饼图：使用饼图展示不同情绪类型的分布比例，帮助用户了解自己的主要情绪倾向。
情绪特征雷达图：使用雷达图展示用户在不同情绪维度上的特征，提供多维度的情绪画像。
情绪关键词云：使用标签云展示与情绪相关的关键词，帮助用户了解情绪触发因素。
情绪日历热力图：使用热力图展示情绪强度在日历上的分布，帮助用户发现情绪与时间的关联。
情绪变化趋势图实现
情绪变化趋势图是心语精灵最核心的可视化图表之一，通过折线图展示用户情绪强度随时间的变化：
// 情绪变化趋势图实现
function renderEmotionTrendChart(container, emotionRecords, options = {}) {
  // 数据预处理
  const processedData = preprocessEmotionTrendData(emotionRecords, options);
  
  // 构建图表数据
  const chartData = {
    xAxis: processedData.dates,
    series: processedData.intensities,
    color: getEmotionColor(processedData.primaryEmotion)
  };
  
  // 设置组件属性
  container.setData({
    chartData: chartData,
    chartType: 'line',
    darkMode: options.darkMode || false
  });
}

// 情绪数据预处理
function preprocessEmotionTrendData(records, options) {
  // 时间范围过滤
  let filteredRecords = records;
  if (options.timeRange) {
    const startTime = new Date();
    startTime.setDate(startTime.getDate() - options.timeRange);
    
    filteredRecords = records.filter(record => 
      new Date(record.timestamp) >= startTime
    );
  }
  
  // 按日期分组
  const groupedData = {};
  filteredRecords.forEach(record => {
    const date = new Date(record.timestamp);
    const dateStr = formatDate(date, options.dateFormat || 'MM/DD');
    
    if (!groupedData[dateStr]) {
      groupedData[dateStr] = [];
    }
    
    groupedData[dateStr].push(record);
  });
  
  // 计算每日情绪数据
  const dates = [];
  const intensities = [];
  const emotionCounts = {};
  
  Object.keys(groupedData).sort().forEach(date => {
    const records = groupedData[date];
    
    // 计算平均情绪强度
    const totalIntensity = records.reduce((sum, record) => sum + record.intensity, 0);
    const avgIntensity = totalIntensity / records.length;
    
    // 统计情绪类型
    records.forEach(record => {
      const emotion = record.primary;
      emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
    });
    
    dates.push(date);
    intensities.push(parseFloat(avgIntensity.toFixed(2)));
  });
  
  // 确定主要情绪
  let primaryEmotion = 'neutral';
  let maxCount = 0;
  
  Object.keys(emotionCounts).forEach(emotion => {
    if (emotionCounts[emotion] > maxCount) {
      maxCount = emotionCounts[emotion];
      primaryEmotion = emotion;
    }
  });
  
  return {
    dates,
    intensities,
    primaryEmotion
  };
}

// 格式化日期
function formatDate(date, format) {
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  format = format.replace('YYYY', year);
  format = format.replace('MM', month < 10 ? `0${month}` : month);
  format = format.replace('DD', day < 10 ? `0${day}` : day);
  
  return format;
}

// 获取情绪对应的颜色
function getEmotionColor(emotion, darkMode = false) {
  const emotionColors = {
    joy: darkMode ? '#FFD700' : '#FFD700',
    sadness: darkMode ? '#6495ED' : '#6495ED',
    anger: darkMode ? '#FF6347' : '#FF6347',
    fear: darkMode ? '#9370DB' : '#9370DB',
    surprise: darkMode ? '#00CED1' : '#00CED1',
    disgust: darkMode ? '#8FBC8F' : '#8FBC8F',
    neutral: darkMode ? '#A9A9A9' : '#A9A9A9'
  };
  
  return emotionColors[emotion] || emotionColors.neutral;
}情绪分布饼图实现
情绪分布饼图通过饼图展示不同情绪类型的分布比例：
// 情绪分布饼图实现
function renderEmotionDistributionChart(container, emotionRecords, options = {}) {
  // 数据预处理
  const processedData = preprocessEmotionDistributionData(emotionRecords);
  
  // 构建图表数据
  const chartData = {
    data: processedData.map(item => ({
      name: getEmotionName(item.emotion),
      value: item.count,
      itemStyle: {
        color: getEmotionColor(item.emotion, options.darkMode)
      }
    }))
  };
  
  // 设置组件属性
  container.setData({
    chartData: chartData,
    chartType: 'pie',
    darkMode: options.darkMode || false
   });
}

// 情绪分布数据预处理
function preprocessEmotionDistributionData(records) {
  // 统计各情绪类型出现次数
  const emotionCounts = {
    joy: 0,
    sadness: 0,
    anger: 0,
    fear: 0,
    surprise: 0,
    disgust: 0,
    neutral: 0
  };
  
  records.forEach(record => {
    const emotion = record.primary;
    if (emotionCounts[emotion] !== undefined) {
      emotionCounts[emotion]++;
    }
  });
  
  // 转换为数组格式
  const result = [];
  Object.keys(emotionCounts).forEach(emotion => {
    if (emotionCounts[emotion] > 0) {
      result.push({
        emotion: emotion,
        count: emotionCounts[emotion]
      });
    }
  });
  
  // 按数量排序
  result.sort((a, b) => b.count - a.count);
  
  return result;
}

// 获取情绪中文名称
function getEmotionName(emotion) {
  const emotionNames = {
    joy: '喜悦',
    sadness: '悲伤',
    anger: '愤怒',
    fear: '恐惧',
    surprise: '惊讶',
    disgust: '厌恶',
    neutral: '中性'
  };
  
  return emotionNames[emotion] || emotion;
}情绪特征雷达图实现
情绪特征雷达图通过雷达图展示用户在不同情绪维度上的特征：// 情绪特征雷达图实现
function renderEmotionRadarChart(container, emotionRecords, options = {}) {
  // 数据预处理
  const processedData = preprocessEmotionRadarData(emotionRecords);
  
  // 构建图表数据
  const chartData = {
    indicator: [
      { name: '喜悦', max: 1 },
      { name: '惊讶', max: 1 },
      { name: '中性', max: 1 },
      { name: '恐惧', max: 1 },
      { name: '悲伤', max: 1 },
      { name: '愤怒', max: 1 },
      { name: '厌恶', max: 1 }
    ],
    series: [{
      name: '情绪特征',
      value: [
        processedData.joy,
        processedData.surprise,
        processedData.neutral,
        processedData.fear,
        processedData.sadness,
        processedData.anger,
        processedData.disgust
      ],
      itemStyle: {
        color: options.darkMode ? '#3A7BC8' : '#4A90E2'
      },
      areaStyle: {
        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
          offset: 0,
          color: options.darkMode ? 'rgba(58, 123, 200, 0.6)' : 'rgba(74, 144, 226, 0.6)'
        }, {
          offset: 1,
          color: options.darkMode ? 'rgba(58, 123, 200, 0.1)' : 'rgba(74, 144, 226, 0.1)'
        }])
      }
    }]
  };
  
  // 设置组件属性
  container.setData({
    chartData: chartData,
    chartType: 'radar',
    darkMode: options.darkMode || false
  });
}

// 情绪雷达图数据预处理
function preprocessEmotionRadarData(records) {
  // 初始化情绪数据
  const emotionData = {
    joy: 0,
    sadness: 0,
    anger: 0,
    fear: 0,
    surprise: 0,
    disgust: 0,
    neutral: 0
  };
  
  // 统计各情绪类型的总强度
  const emotionCounts = { ...emotionData };
  
  records.forEach(record => {
    Object.keys(record.emotions).forEach(emotion => {
      if (emotionData[emotion] !== undefined) {
        emotionData[emotion] += record.emotions[emotion];
        emotionCounts[emotion]++;
      }
    });
  });
  
  // 计算各情绪类型的平均强度
  Object.keys(emotionData).forEach(emotion => {
    if (emotionCounts[emotion] > 0) {
      emotionData[emotion] = emotionData[emotion] / emotionCounts[emotion];
    }
  });
  
  return emotionData;
}情绪关键词云实现
情绪关键词云通过标签云展示与情绪相关的关键词：// 情绪关键词云实现
function renderEmotionKeywordCloud(container, emotionRecords, options = {}) {
  // 数据预处理
  const keywords = preprocessEmotionKeywords(emotionRecords);
  
  // 设置组件属性
  container.setData({
    keywords: keywords,
    darkMode: options.darkMode || false
  });
}

// 情绪关键词预处理
function preprocessEmotionKeywords(records) {
  // 提取所有关键词
  const keywordMap = {};
  
  records.forEach(record => {
    if (record.keywords && record.keywords.length > 0) {
      record.keywords.forEach(keyword => {
        const word = keyword.word;
        
        if (!keywordMap[word]) {
          keywordMap[word] = {
            word: word,
            weight: 0,
            count: 0,
            emotion: keyword.emotion || record.primary
          };
        }
        
        keywordMap[word].weight += keyword.weight || 0.5;
        keywordMap[word].count++;
      });
    }
  });
  
  // 转换为数组并计算最终权重
  const result = Object.values(keywordMap).map(item => ({
    text: item.word,
    weight: item.weight / item.count,
    count: item.count,
    emotion: item.emotion
  }));
  
  // 按权重排序
  result.sort((a, b) => b.weight - a.weight);
  
  // 限制关键词数量
  return result.slice(0, 30);
}情绪日历热力图实现
情绪日历热力图通过热力图展示情绪强度在日历上的分布：// 情绪日历热力图实现
function renderEmotionCalendarChart(container, emotionRecords, options = {}) {
  // 数据预处理
  const calendarData = preprocessEmotionCalendarData(emotionRecords);
  
  // 构建图表数据
  const currentYear = new Date().getFullYear();
  const chartData = {
    visualMap: {
      min: 0,
      max: 1,
      calculable: true,
      orient: 'horizontal',
      left: 'center',
      bottom: '15%',
      textStyle: {
        color: options.darkMode ? '#e0e0e0' : '#333333'
      },
      inRange: {
        color: options.darkMode ? 
          ['#1a237e', '#283593', '#3949ab', '#3f51b5', '#5c6bc0'] : 
          ['#e3f2fd', '#bbdefb', '#90caf9', '#64b5f6', '#42a5f5']
      }
    },
    calendar: {
      top: 80,
      left: 30,
      right: 30,
      cellSize: ['auto', 13],
      range: currentYear,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: options.darkMode ? '#333333' : '#eeeeee'
      },
      yearLabel: { show: false },
      dayLabel: {
        color: options.darkMode ? '#aaaaaa' : '#666666'
      },
      monthLabel: {
        color: options.darkMode ? '#e0e0e0' : '#333333'
      }
    },
    series: {
      type: 'heatmap',
      coordinateSystem: 'calendar',
      data: calendarData
    }
  };
  
  // 设置组件属性
  container.setData({
    chartData: chartData,
    chartType: 'calendar',
    darkMode: options.darkMode || false
  });
}

// 情绪日历数据预处理
function preprocessEmotionCalendarData(records) {
  // 按日期分组
  const dailyData = {};
  
  records.forEach(record => {
    const date = new Date(record.timestamp);
    const dateStr = formatDate(date, 'YYYY-MM-DD');
    
    if (!dailyData[dateStr]) {
      dailyData[dateStr] = {
        intensities: [],
        emotions: {}
      };
    }
    
    dailyData[dateStr].intensities.push(record.intensity);
    
    const emotion = record.primary;
    dailyData[dateStr].emotions[emotion] = (dailyData[dateStr].emotions[emotion] || 0) + 1;
  });
  
  // 计算每日数据
  const result = [];
  
  Object.keys(dailyData).forEach(dateStr => {
    const data = dailyData[dateStr];
    
    // 计算平均情绪强度
    const avgIntensity = data.intensities.reduce((sum, val) => sum + val, 0) / data.intensities.length;
    
    // 确定主要情绪
    let primaryEmotion = 'neutral';
    let maxCount = 0;
    
    Object.keys(data.emotions).forEach(emotion => {
      if (data.emotions[emotion] > maxCount) {
        maxCount = data.emotions[emotion];
        primaryEmotion = emotion;
      }
    });
    
    result.push([
      dateStr,
      avgIntensity,
      primaryEmotion
    ]);
  });
  
  return result;
}暗夜模式适配
为了提供更好的用户体验，心语精灵的数据可视化组件全面支持暗夜模式，通过动态调整图表配色和样式，实现了在不同主题下的最佳显示效果：// 获取主题配置
function getThemeConfig(darkMode) {
  if (darkMode) {
    return {
      backgroundColor: 'transparent',
      textStyle: {
        color: '#e0e0e0'
      },
      axisLineColor: '#555555',
      splitLineColor: '#333333',
      tooltipBackgroundColor: 'rgba(50, 50, 50, 0.9)',
      tooltipBorderColor: '#555555',
      tooltipTextColor: '#e0e0e0',
      legendTextColor: '#aaaaaa',
      colors: [
        '#3A7BC8', // 蓝色
        '#CF6679', // 红色
        '#F57C00', // 橙色
        '#9C64A6', // 紫色
        '#00B8A9', // 青色
        '#58B19F', // 绿色
        '#777777'  // 灰色
      ]
    };
  } else {
    return {
      backgroundColor: 'transparent',
      textStyle: {
        color: '#333333'
      },
      axisLineColor: '#cccccc',
      splitLineColor: '#eeeeee',
      tooltipBackgroundColor: 'rgba(255, 255, 255, 0.9)',
      tooltipBorderColor: '#cccccc',
      tooltipTextColor: '#333333',
      legendTextColor: '#666666',
      colors: [
        '#4A90E2', // 蓝色
        '#F44336', // 红色
        '#FFC107', // 橙色
        '#9C27B0', // 紫色
        '#00BCD4', // 青色
        '#4CAF50', // 绿色
        '#9E9E9E'  // 灰色
      ]
    };
  }
}

// 应用主题配置
function applyThemeConfig(option, themeConfig) {
  // 设置背景色
  option.backgroundColor = themeConfig.backgroundColor;
  
  // 设置文本样式
  option.textStyle = {
    color: themeConfig.textStyle.color
  };
  
  // 设置图例样式
  if (option.legend) {
    option.legend.textStyle = {
      color: themeConfig.legendTextColor
    };
  }
  
  // 设置提示框样式
  if (option.tooltip) {
    option.tooltip.backgroundColor = themeConfig.tooltipBackgroundColor;
    option.tooltip.borderColor = themeConfig.tooltipBorderColor;
    option.tooltip.textStyle = {
      color: themeConfig.tooltipTextColor
    };
  }
  
  // 设置坐标轴样式
  if (option.xAxis) {
    option.xAxis.axisLine = {
      lineStyle: {
        color: themeConfig.axisLineColor
      }
    };
    option.xAxis.axisLabel = {
      color: themeConfig.textStyle.color
    };
    option.xAxis.splitLine = {
      lineStyle: {
        color: themeConfig.splitLineColor
      }
    };
  }
  
  if (option.yAxis) {
    option.yAxis.axisLine = {
      lineStyle: {
        color: themeConfig.axisLineColor
      }
    };
    option.yAxis.axisLabel = {
      color: themeConfig.textStyle.color
    };
    option.yAxis.splitLine = {
      lineStyle: {
        color: themeConfig.splitLineColor
      }
    };
  }
  
  // 设置雷达图样式
  if (option.radar) {
    option.radar.axisLine = {
      lineStyle: {
        color: themeConfig.axisLineColor
      }
    };
    option.radar.splitLine = {
      lineStyle: {
        color: themeConfig.splitLineColor
      }
    };
    option.radar.name = {
      textStyle: {
        color: themeConfig.textStyle.color
      }
    };
  }
  
  return option;
}交互式图表设计
为了增强用户体验，心语精灵实现了交互式图表设计，支持缩放、点击、长按等交互操作：// 图表交互事件处理
function setupChartEvents(chart, options = {}) {
  // 点击事件
  chart.on('click', function(params) {
    if (options.onClick) {
      options.onClick(params);
    }
  });
  
  // 长按事件（移动端）
  let touchStartTime;
  let touchEndTime;
  
  chart.getZr().on('touchstart', function() {
    touchStartTime = Date.now();
  });
  
  chart.getZr().on('touchend', function() {
    touchEndTime = Date.now();
    if (touchEndTime - touchStartTime > 800) { // 长按阈值800ms
      if (options.onLongPress) {
        options.onLongPress();
      }
    }
  });
  
  // 数据区域缩放完成事件
  chart.on('datazoom', function(params) {
    if (options.onDataZoom) {
      options.onDataZoom(params);
    }
  });
  
  // 图例选择事件
  chart.on('legendselectchanged', function(params) {
    if (options.onLegendSelect) {
      options.onLegendSelect(params);
    }
  });
}

// 图表交互功能实现示例
Page({
  data: {
    // 页面数据
  },
  
  onLoad: function() {
    // 页面加载时执行
  },
  
  // 图表初始化完成回调
  onChartInit: function(chart) {
    this.chart = chart;
    
    // 设置图表交互事件
    setupChartEvents(chart, {
      onClick: this.handleChartClick,
      onLongPress: this.handleChartLongPress,
      onDataZoom: this.handleChartDataZoom,
      onLegendSelect: this.handleChartLegendSelect
    });
  },
  
  // 图表点击事件处理
  handleChartClick: function(params) {
    // 获取点击的数据项
    const dataIndex = params.dataIndex;
    const seriesIndex = params.seriesIndex;
    const data = params.data;
    
    // 根据图表类型处理点击事件
    if (params.componentType === 'series') {
      if (params.seriesType === 'line') {
        // 处理折线图点击
        this.showDayDetail(this.data.dateList[dataIndex]);
      } else if (params.seriesType === 'pie') {
        // 处理饼图点击
        this.showEmotionDetail(params.name);
      } else if (params.seriesType === 'radar') {
        // 处理雷达图点击
        this.showDimensionDetail(params.name);
      }
    }
  },
  
  // 图表长按事件处理
  handleChartLongPress: function() {
    // 显示保存图表选项
    wx.showActionSheet({
      itemList: ['保存图表到相册', '分享图表'],
      success: (res) => {
        if (res.tapIndex === 0) {
          this.saveChartImage();
        } else if (res.tapIndex === 1) {
          this.shareChart();
        }
      }
    });
  },
  
  // 数据缩放事件处理
  handleChartDataZoom: function(params) {
    // 获取缩放后的范围
    const startValue = params.start;
    const endValue = params.end;
    
    // 更新数据显示范围
    this.updateDataRange(startValue, endValue);
  },
  
  // 图例选择事件处理
  handleChartLegendSelect: function(params) {
    // 获取选中的图例项
    const selected = params.selected;
    
    // 更新数据显示
    this.updateDataDisplay(selected);
  },
  
  // 保存图表为图片
  saveChartImage: function() {
    // 获取图表canvas上下文
    const ecComponent = this.selectComponent('#chart-container');
    
    // 生成图片
    ecComponent.canvasToTempFilePath({
      success: (res) => {
        // 保存图片到相册
        wx.saveImageToPhotosAlbum({
          filePath: res.tempFilePath,
          success: () => {
            wx.showToast({
              title: '保存成功',
              icon: 'success'
            });
          },
          fail: (error) => {
            console.error('保存图片失败:', error);
            wx.showToast({
              title: '保存失败',
              icon: 'none'
            });
          }
        });
      },
      fail: (error) => {
        console.error('生成图片失败:', error);
      }
    });
  },
  
  // 分享图表
  shareChart: function() {
    // 实现分享功能
  },
  
  // 显示某天的详细情绪数据
  showDayDetail: function(date) {
    // 实现日期详情展示
  },
  
  // 显示某种情绪的详细数据
  showEmotionDetail: function(emotionName) {
    // 实现情绪详情展示
  },
    // 显示某天的详细情绪数据
  showDayDetail: function(date) {
    // 查询指定日期的情绪记录
    const db = wx.cloud.database();
    const _ = db.command;
    
    // 构建日期范围
    const startDate = new Date(date);
    startDate.setHours(0, 0, 0, 0);
    
    const endDate = new Date(date);
    endDate.setHours(23, 59, 59, 999);
    
    // 查询数据
    db.collection('emotionRecords')
      .where({
        userId: this.data.userId,
        timestamp: _.gte(startDate).and(_.lte(endDate))
      })
      .orderBy('timestamp', 'asc')
      .get()
      .then(res => {
        // 显示详情弹窗
        this.setData({
          dayDetailVisible: true,
          dayDetailDate: date,
          dayDetailRecords: res.data
        });
      })
      .catch(err => {
        console.error('查询日期详情失败:', err);
        wx.showToast({
          title: '查询失败',
          icon: 'none'
        });
      });
  },
  
  // 显示某种情绪的详细数据
  showEmotionDetail: function(emotionName) {
    // 将中文情绪名称转换为英文键名
    const emotionKey = getEmotionKeyByName(emotionName);
    
    // 查询指定情绪类型的记录
    const db = wx.cloud.database();
    
    db.collection('emotionRecords')
      .where({
        userId: this.data.userId,
        primary: emotionKey
      })
      .orderBy('timestamp', 'desc')
      .limit(20)
      .get()
      .then(res => {
        // 显示详情弹窗
        this.setData({
          emotionDetailVisible: true,
          emotionDetailType: emotionName,
          emotionDetailRecords: res.data
        });
      })
      .catch(err => {
        console.error('查询情绪详情失败:', err);
        wx.showToast({
          title: '查询失败',
          icon: 'none'
        });
      });
  },
  
  // 显示维度详情
  showDimensionDetail: function(dimensionName) {
    // 实现维度详情展示
  }
});

// 根据情绪中文名获取英文键名
function getEmotionKeyByName(name) {
  const emotionMap = {
    '喜悦': 'joy',
    '悲伤': 'sadness',
    '愤怒': 'anger',
    '恐惧': 'fear',
    '惊讶': 'surprise',
    '厌恶': 'disgust',
    '中性': 'neutral'
  };
  
  return emotionMap[name] || 'neutral';
}通过以上数据可视化技术的设计与实现，心语精灵为用户提供了直观、交互性强的情绪数据可视化体验，帮助用户更好地理解自己的情感状态和变化趋势，实现了情感陪伴和情商提升的核心功能。</div>

以上是完整的3.5数据可视化技术部分的内容，包括ECharts图表库集成和情绪数据可视化设计两个小节。这部分内容详细介绍了心语精灵在数据可视化方面的技术实现，从图表库的选型分析、集成实现、性能优化，到各种情绪数据可视化类型的具体实现，以及暗夜模式适配和交互式图表设计等方面。
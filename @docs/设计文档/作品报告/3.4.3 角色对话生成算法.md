3.4.3 角色对话生成算法
角色对话生成是心语精灵的核心功能，通过精心设计的角色提示词和对话生成算法，实现了具有独特性格和专业背景的AI角色与用户的自然对话。本节详细介绍角色对话生成算法的设计与实现。

角色模型设计
心语精灵的角色模型包含多个维度的特性，共同构成一个完整、立体的AI角色形象。

角色属性定义
每个AI角色包含以下核心属性：

基本信息：包括角色名称、头像、简介等基本信息
背景设定：角色的背景故事、经历、身份等
性格特征：角色的性格、行为模式、情感表达方式等
专业领域：角色的专业知识、技能、特长等
语言风格：角色的说话方式、用词习惯、表达特点等
互动模式：角色与用户互动的方式、态度、关系定位等
角色数据结构设计如下：

// 角色数据结构
const roleSchema = {
  _id: "string",           // 角色ID
  name: "string",          // 角色名称
  avatar: "string",        // 角色头像URL
  description: "string",   // 角色简介
  background: "string",    // 背景故事
  personality: "string",   // 性格特征
  expertise: "string",     // 专业领域
  speaking_style: "string", // 语言风格
  interaction_mode: "string", // 互动模式
  prompt: "string",        // 角色提示词
  system_prompt: "string", // 系统提示词
  welcome: "string",       // 欢迎语
  creator: "string",       // 创建者ID
  is_system: boolean,      // 是否为系统角色
  is_public: boolean,      // 是否公开
  usage_count: number,     // 使用次数
  tags: ["string"],        // 角色标签
  category: "string",      // 角色类别
  createTime: Date,        // 创建时间
  updateTime: Date         // 更新时间
};    
const result = await callZhipuAI({
      model: "glm-4",
      messages: [
        {
          role: "system",
          content: "你是一个角色提示词生成专家，能够根据用户提供的角色信息生成高质量的角色扮演提示词。"
        },
        {
          role: "user",
          content: `请根据以下角色信息生成一个详细的角色扮演提示词：

          ${roleDescription}

          提示词应包含：
          1. 角色的自我认知和身份定位
          2. 与用户的关系定位和互动方式
          3. 说话风格、语气和表达方式的具体指导
          4. 应该避免的行为和表达
          5. 如何根据角色特点回应用户的情感需求（如何安慰、鼓励或适当批评用户）
          6. 如何自然地了解用户的兴趣和偏好
          7. 对话风格指导：
             - 使用非常简短的对话方式，尽量模仿真实手机聊天
             - 每条消息不超过1-2句话，尽量保持简洁
             - 将长回复拆分成多条非常短小的消息，就像真实人类在聊天软件中发消息一样
             - 避免使用长句和复杂句式，使用简单直接的表达
             - 当需要表达复杂想法时，将内容分成多个非常简短的消息，每条消息只表达一个简单观点

          8. 格式要求：
             - 绝对不要使用Markdown语法，如双星号加粗、单星号斜体、反引号代码等
             - 不要使用标题格式如#或##
             - 列表项直接使用数字或文字开头，不要使用特殊符号如-或*
             - 当需要列举多个要点时，直接使用“1.”“2.”等编号，不要使用特殊格式
             - 尽量使用简单的纯文本格式，就像在手机聊天软件中发送消息一样

          请直接给出提示词内容，不要包含解释。提示词应该简洁有效，不超过800字。`
        }
      ],
      temperature: 0.7,
      top_p: 0.8,
      max_tokens: 2000
    });
这一模板通过填充具体的角色属性，生成完整的角色提示词，引导大语言模型生成符合角色设定的回复。

对话生成算法流程
心语精灵的对话生成算法包括以下核心步骤：

1. 角色初始化
在开始对话前，首先需要初始化角色信息// 角色初始化
async function initializeRole(roleId) {
  try {
    const db = cloud.database();
    
    // 查询角色信息
    const roleResult = await db.collection('roles')
      .doc(roleId)
      .get();
    
    if (!roleResult.data) {
      throw new Error('角色不存在');
    }
    
    const role = roleResult.data;
    
    // 生成角色提示词
    let systemPrompt = role.system_prompt || '';
    
    if (!systemPrompt) {
      // 如果没有预设的系统提示词，使用模板生成
      systemPrompt = rolePromptTemplate
        .replace('{name}', role.name)
        .replace('{background}', role.background || '无特定背景')
        .replace('{personality}', role.personality || '友好、耐心')
        .replace('{expertise}', role.expertise || '日常交流')
        .replace('{speaking_style}', role.speaking_style || '自然、流畅')
        .replace('{interaction_mode}', role.interaction_mode || '平等、支持性的交流');
    }
    
    // 更新角色使用次数
    await db.collection('roles').doc(roleId).update({
      data: {
        usage_count: db.command.inc(1)
      }
    });
    
    return {
      roleInfo: role,
      systemPrompt: systemPrompt
    };
  } catch (error) {
    console.error('初始化角色失败:', error);
    throw error;
  }
}角色初始化步骤获取角色信息并生成角色提示词，为后续的对话生成做准备。

2. 对话上下文管理
为了保持对话的连贯性，需要管理对话上下文：// 对话上下文管理
async function getDialogueContext(chatId, maxMessages = 20) {
  try {
    const db = cloud.database();
    
    // 查询最近的消息记录
    const messagesResult = await db.collection('messages')
      .where({ chatId: chatId })
      .orderBy('createTime', 'desc')
      .limit(maxMessages)
      .get();
    
    // 按时间正序排列
    const messages = messagesResult.data.reverse();
    
    // 转换为大语言模型所需的格式
    return messages.map(msg => ({
      role: msg.sender === 'user' ? 'user' : 'assistant',
      content: msg.content
    }));
  } catch (error) {
    console.error('获取对话上下文失败:', error);
    return [];
  }
}

// 上下文长度管理
function manageContextLength(messages, maxTokens = 4000) {
  // 如果消息数量少，直接返回
  if (messages.length <= 4) return messages;
  
  // 估算token数量（简化估算：中文每字约1.5个token，英文每单词约1个token）
  let totalTokens = 0;
  const tokenCounts = messages.map(msg => {
    // 简单估算：中文字符数 * 1.5 + 英文单词数
    const chineseChars = (msg.content.match(/[\u4e00-\u9fa5]/g) || []).length;
    const englishWords = (msg.content.replace(/[\u4e00-\u9fa5]/g, '').match(/\b\w+\b/g) || []).length;
    const tokenCount = chineseChars * 1.5 + englishWords;
    totalTokens += tokenCount;
    return tokenCount;
  });
  
  // 如果总token数在限制范围内，直接返回
  if (totalTokens <= maxTokens) return messages;
  
  // 保留system消息（如果有）
  const systemMessage = messages.find(msg => msg.role === 'system');
  let result = systemMessage ? [systemMessage] : [];
  
  // 保留最近的消息
  let currentTokens = systemMessage ? tokenCounts[0] : 0;
  
  // 从最新消息开始添加，直到接近token限制
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];
    if (msg.role === 'system') continue; // 系统消息已处理
    
    if (currentTokens + tokenCounts[i] <= maxTokens * 0.9) { // 留10%的余量
      result.unshift(msg);
      currentTokens += tokenCounts[i];
    } else {
      break;
    }
  }
  
  return result;
}对话上下文管理步骤获取历史消息并进行上下文长度管理，确保对话的连贯性和模型输入的有效性。

3. 用户画像集成
为了使对话更加个性化，需要集成用户画像信息：// 用户画像集成
async function integrateUserProfile(userId, systemPrompt) {
  try {
    // 获取用户画像
    const userProfile = await getUserProfile(userId);
    if (!userProfile) return systemPrompt;
    
    // 提取用户兴趣
    let interestsText = '';
    if (userProfile.categories && userProfile.categories.length > 0) {
      const topCategories = userProfile.categories.slice(0, 3);
      interestsText = `用户的主要兴趣领域：${topCategories.map(c => c.name).join('、')}。`;
      
      // 添加具体兴趣点
      const interestDetails = topCategories.map(category => {
        const topKeywords = category.keywords.slice(0, 5).join('、');
        return `在${category.name}方面，用户关注：${topKeywords}`;
      }).join('；');
      
      if (interestDetails) {
        interestsText += interestDetails + '。';
      }
    }
    
    // 提取性格特征
    let personalityText = '';
    if (userProfile.personality) {
      const p = userProfile.personality;
      
      // 情感倾向
      if (p.emotionalTendency) {
        const et = p.emotionalTendency;
        personalityText += `用户的情感倾向：主要表现${et.dominant}情绪，`;
        personalityText += et.stability > 0.7 ? '情绪较为稳定，' : '情绪波动较大，';
        personalityText += et.positivity > 0.7 ? '倾向于表达积极情绪。' : 
                          et.positivity < 0.3 ? '倾向于表达消极情绪。' : '积极消极情绪表达平衡。';
      }
      
      // 表达风格
      if (p.expressionStyle) {
        const es = p.expressionStyle;
        personalityText += `用户的表达风格：`;
        personalityText += es.verbosity > 0.7 ? '表达详细，' : es.verbosity < 0.3 ? '表达简洁，' : '表达适中，';
        personalityText += es.formality > 0.7 ? '语言较为正式，' : es.formality < 0.3 ? '语言较为随意，' : '语言正式度适中，';
        personalityText += es.creativity > 0.7 ? '表达富有创造性。' : '表达较为常规。';
      }
    }
    
    // 增强提示词
    let enhancedPrompt = systemPrompt;
    
    if (interestsText || personalityText) {
      enhancedPrompt += '\n\n用户画像信息：\n';
      if (interestsText) enhancedPrompt += interestsText + '\n';
      if (personalityText) enhancedPrompt += personalityText;
    }
    
    return enhancedPrompt;
  } catch (error) {
    console.error('集成用户画像失败:', error);
    return systemPrompt;
  }
}

// 获取用户画像
async function getUserProfile(userId) {
  try {
    // 先从缓存获取
    const cachedProfile = userProfileCache.get(userId);
    if (cachedProfile) return cachedProfile;
    
    // 缓存未命中，从数据库获取
    const db = cloud.database();
    const profileResult = await db.collection('userInterests')
      .where({ userId: userId })
      .get();
    
    if (profileResult.data.length > 0) {
      const profile = profileResult.data[0];
      
      // 更新缓存
      userProfileCache.set(userId, profile);
      
      return profile;
    }
    
    return null;
  } catch (error) {
    console.error('获取用户画像失败:', error);
    return null;
  }
}用户画像集成步骤将用户的兴趣和性格特征信息添加到角色提示词中，使AI角色能够根据用户特点进行个性化回复。

4. 对话生成请求构建
基于角色提示词、对话上下文和用户消息，构建对话生成请求：// 对话生成请求构建
function buildChatRequest(systemPrompt, dialogueContext, userMessage, parameters = {}) {
  // 构建消息数组
  const messages = [
    { role: 'system', content: systemPrompt }
  ];
  
  // 添加对话上下文
  if (dialogueContext && dialogueContext.length > 0) {
    messages.push(...dialogueContext);
  }
  
  // 添加当前用户消息
  messages.push({ role: 'user', content: userMessage });
  
  // 默认参数
  const defaultParams = {
    temperature: 0.7,
    top_p: 0.9,
    max_tokens: 2000,
    presence_penalty: 0.6,
    frequency_penalty: 0.5
  };
  
  // 合并自定义参数
  const mergedParams = { ...defaultParams, ...parameters };
  
  // 构建请求
  return {
    model: 'glm-4-flash',
    messages: messages,
    ...mergedParams
  };
}对话生成请求构建步骤将角色提示词、对话上下文和用户消息组合成完整的请求，并设置适当的生成参数。

5. 回复生成与处理
调用大语言模型生成回复，并进行后处理：// 回复生成
async function generateReply(request) {
  try {
    // 调用智谱AI API
    const response = await callZhipuAPI('chat/completions', request);
    
    // 提取回复内容
    const reply = response.choices[0].message.content;
    
    // 后处理回复
    return postprocessReply(reply);
  } catch (error) {
    console.error('生成回复失败:', error);
    throw error;
  }
}

// 回复后处理
function postprocessReply(reply) {
  // 移除可能的角色前缀
  let processed = reply.replace(/^(AI|助手|我)[:：]\s*/g, '');
  
  // 移除多余的换行
  processed = processed.replace(/\n{3,}/g, '\n\n');
  
  // 修复不完整的标点
  processed = fixIncompleteMarks(processed);
  
  return processed;
}

// 修复不完整的标点
function fixIncompleteMarks(text) {
  // 修复不成对的引号
  const quoteCount = (text.match(/["]/g) || []).length;
  if (quoteCount % 2 !== 0) {
    text += '"';
  }
  
  // 修复不成对的括号
  const leftParenCount = (text.match(/[（(]/g) || []).length;
  const rightParenCount = (text.match(/[）)]/g) || []).length;
  if (leftParenCount > rightParenCount) {
    text += '）'.repeat(leftParenCount - rightParenCount);
  }
  
  return text;
}回复生成与处理步骤调用大语言模型API生成回复，并对回复进行后处理，确保回复的质量和完整性。

6. 对话保存与更新
将用户消息和AI回复保存到数据库，并更新对话信息：// 对话保存
async function saveDialogue(chatId, userId, roleId, userMessage, aiReply) {
  try {
    const db = cloud.database();
    const _ = db.command;
    
    // 开始事务
    const transaction = await db.startTransaction();
    
    try {
      // 保存用户消息
      const userMsgResult = await transaction.collection('messages').add({
        data: {
          chatId: chatId,
          userId: userId,
          roleId: roleId,
          content: userMessage,
          sender: 'user',
          createTime: db.serverDate()
        }
      });
      
      // 保存AI回复
      const aiMsgResult = await transaction.collection('messages').add({
        data: {
          chatId: chatId,
          userId: userId,
          roleId: roleId,
          content: aiReply,
          sender: 'assistant',
          createTime: db.serverDate()
        }
      });
      
      // 更新会话信息
      await transaction.collection('chats').doc(chatId).update({
        data: {
          last_message: aiReply.substring(0, 50) + (aiReply.length > 50 ? '...' : ''),
          message_count: _.inc(2),
          updateTime: db.serverDate()
        }
      });
      
      // 提交事务
      await transaction.commit();
      
      return {
        userMessageId: userMsgResult._id,
        aiMessageId: aiMsgResult._id
      };
    } catch (error) {
      // 回滚事务
      await transaction.rollback();
      throw error;
    }
  } catch (error) {
    console.error('保存对话失败:', error);
    throw error;
  }
}对话保存与更新步骤将用户消息和AI回复保存到数据库，并更新会话信息，确保对话数据的完整性和一致性。

角色对话生成优化
为提高对话生成质量，心语精灵实现了以下优化策略：

1. 角色记忆机制
实现了角色记忆机制，使AI角色能够记住用户的重要信息和偏好：// 角色记忆机制
class RoleMemory {
  constructor(roleId, userId) {
    this.roleId = roleId;
    this.userId = userId;
    this.memories = null;
  }
  
  // 初始化记忆
  async initialize() {
    try {
      const db = cloud.database();
      
      // 查询现有记忆
      const memoryResult = await db.collection('role_memories')
        .where({
          roleId: this.roleId,
          userId: this.userId
        })
        .get();
      
      if (memoryResult.data.length > 0) {
        this.memories = memoryResult.data[0].memories || {};
        this.memoryId = memoryResult.data[0]._id;
      } else {
        // 创建新记忆
        const result = await db.collection('role_memories').add({
          data: {
            roleId: this.roleId,
            userId: this.userId,
            memories: {},
            createTime: db.serverDate(),
            updateTime: db.serverDate()
          }
        });
        
        this.memoryId = result._id;
        this.memories = {};
      }
      
      return true;
    } catch (error) {
      console.error('初始化角色记忆失败:', error);
      this.memories = {};
      return false;
    }
  }
  
  // 获取记忆
  get(key) {
    if (!this.memories) return null;
    return this.memories[key] || null;
  }
  
  // 设置记忆
  async set(key, value) {
    try {
      if (!this.memories) await this.initialize();
      
      this.memories[key] = value;
      
      const db = cloud.database();
      
      // 更新数据库
      await db.collection('role_memories').doc(this.memoryId).update({
        data: {
          [`memories.${key}`]: value,
          updateTime: db.serverDate()
        }
      });
      
      return true;
    } catch (error) {
      console.error('设置角色记忆失败:', error);
      return false;
    }
  }
  
  // 删除记忆
  async remove(key) {
    try {
      if (!this.memories) await this.initialize();
      
      if (!(key in this.memories)) return true;
      
      delete this.memories[key];
      
      const db = cloud.database();
      
      // 更新数据库
      await db.collection('role_memories').doc(this.memoryId).update({
        data: {
          [`memories.${key}`]: db.command.remove(),
          updateTime: db.serverDate()
        }
      });
      
      return true;
    } catch (error) {
      console.error('删除角色记忆失败:', error);
      return false;
    }
  }
  
  // 获取所有记忆
  getAllMemories() {
    return this.memories || {};
  }
  
  // 生成记忆提示词
  generateMemoryPrompt() {
    if (!this.memories || Object.keys(this.memories).length === 0) {
      return '';
    }
    
    let prompt = '\n\n关于用户的重要记忆：\n';
    
    for (const [key, value] of Object.entries(this.memories)) {
      prompt += `- ${key}: ${value}\n`;
    }
    
    return prompt;
  }
}

// 提取需要记忆的信息
async function extractMemoryInfo(chatId, userId, roleId) {
  try {
    const db = cloud.database();
    
    // 获取最近的对话
    const messagesResult = await db.collection('messages')
      .where({ chatId: chatId })
      .orderBy('createTime', 'desc')
      .limit(10)
      .get();
    
    const messages = messagesResult.data.reverse();
    
    // 构建提示词
    const prompt = `
分析以下对话，提取需要记住的重要信息，如用户的偏好、习惯、重要事件、关系等。
只提取确定的、明确的信息，不要推测。

对话内容：
${messages.map(msg => `${msg.sender === 'user' ? '用户' : 'AI'}: ${msg.content}`).join('\n')}

请返回JSON格式：
{
  "memories": [
    {"key": "记忆名称1", "value": "记忆内容1"},
    {"key": "记忆名称2", "value": "记忆内容2"},
    ...
  ]
}

如果没有需要记住的重要信息，返回空数组。
`;

    // 调用大语言模型提取记忆
    const response = await callZhipuAPI('chat/completions', {
      model: 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一个专注于提取重要信息的助手。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      response_format: { type: 'json_object' }
    });
    
    // 解析结果
    const content = response.choices[0].message.content;
    const result = JSON.parse(content);
    
    // 更新记忆
    if (result.memories && result.memories.length > 0) {
      const roleMemory = new RoleMemory(roleId, userId);
      await roleMemory.initialize();
      
      for (const memory of result.memories) {
        await roleMemory.set(memory.key, memory.value);
      }
    }
    
    return true;
  } catch (error) {
    console.error('提取记忆信息失败:', error);
    return false;
  }
}角色记忆机制使AI角色能够记住用户的重要信息和偏好，提高对话的连贯性和个性化程度。

2. 情感响应增强
实现了情感响应增强机制，使AI角色能够更好地理解和回应用户的情感：// 情感响应增强
async function enhanceEmotionalResponse(userMessage, dialogueContext, systemPrompt) {
  try {
    // 分析用户消息的情感
    const emotionResult = await analyzeMessageEmotion(userMessage);
    if (!emotionResult.success) return systemPrompt;
    
    const emotion = emotionResult.result;
    
    // 根据情感类型增强提示词
    let emotionPrompt = '\n\n当前用户情感状态：\n';
    emotionPrompt += `主要情绪：${emotion.type}，强度：${emotion.intensity}`;
    
    if (emotion.secondary) {
      emotionPrompt += `，次要情绪：${emotion.secondary}`;
    }
    
    emotionPrompt += '\n';
    
    // 添加情感关键词
    if (emotion.keywords && emotion.keywords.length > 0) {
      emotionPrompt += `情感关键词：${emotion.keywords.map(k => k.word).join('、')}\n`;
    }
    
    // 添加情感响应指导
    emotionPrompt += '情感响应指导：\n';
    
    switch (emotion.type) {
      case 'joy':
        emotionPrompt += '- 分享用户的喜悦，给予积极回应\n- 可以适当表达赞美和祝贺\n- 鼓励用户分享更多积极体验';
        break;
      case 'sadness':
        emotionPrompt += '- 表达理解和同理心，不要试图立即解决问题\n- 给予情感支持和安慰\n- 耐心倾听，避免过度乐观或轻视用户的感受';
        break;
      case 'anger':
        emotionPrompt += '- 保持冷静，不要对抗或防御\n- 承认用户的感受是有效的\n- 提供情绪宣泄的空间，然后再探讨解决方案';
        break;
      case 'fear':
        emotionPrompt += '- 提供安全感和支持\n- 帮助用户理性分析恐惧来源\n- 避免轻视用户的担忧，同时提供平衡的视角';
        break;
      case 'surprise':
        emotionPrompt += '- 对用户的惊讶反应表示认同\n- 帮助用户处理意外信息\n- 根据惊讶是积极还是消极调整回应';
        break;
      case 'disgust':
        emotionPrompt += '- 承认用户的厌恶感受\n- 避免评判或否定这些感受\n- 提供理解和支持，必要时提供新的视角';
        break;
      default:
        emotionPrompt += '- 保持中性、客观的回应\n- 根据对话内容提供相关信息和支持\n- 关注用户可能未明确表达的潜在情绪';
    }
    
    // 增强提示词
    return systemPrompt + emotionPrompt;
  } catch (error) {
    console.error('增强情感响应失败:', error);
    return systemPrompt;
  }
}

// 分析消息情感
async function analyzeMessageEmotion(message) {
  try {
    // 构建情感分析提示词
    const prompt = `
分析以下文本中表达的情感，返回JSON格式：
文本：${message}

请返回以下字段：
1. primary_emotion: 主要情绪类型 (喜悦、悲伤、愤怒、恐惧、惊讶、厌恶、中性)
2. secondary_emotion: 次要情绪类型 (如果有)
3. intensity: 情绪强度 (0.0-1.0)
4. keywords: 情绪关键词数组，每个元素包含word和weight
5. analysis: 简短的情绪分析描述

确保返回的是有效的JSON格式。
`;

    // 调用大语言模型分析情感
    const response = await callZhipuAPI('chat/completions', {
      model: 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一个专业的情感分析助手。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      response_format: { type: 'json_object' }
    });
    
    // 解析结果
    const content = response.choices[0].message.content;
    const result = JSON.parse(content);
    
    // 标准化情绪类型
    const standardEmotions = {
      '喜悦': 'joy',
      '悲伤': 'sadness',
      '愤怒': 'anger',
      '恐惧': 'fear',
      '惊讶': 'surprise',
      '厌恶': 'disgust',
      '中性': 'neutral'
    };
    
    // 标准化主要情绪
    const primaryEmotion = standardEmotions[result.primary_emotion] || 'neutral';
    
    // 标准化次要情绪
    let secondaryEmotion = null;
    if (result.secondary_emotion && result.secondary_emotion !== result.primary_emotion) {
      secondaryEmotion = standardEmotions[result.secondary_emotion] || null;
    }
    
    return {
      success: true,
      result: {
        type: primaryEmotion,
        secondary: secondaryEmotion,
        intensity: parseFloat(result.intensity) || 0.5,
        keywords: result.keywords || [],
        analysis: result.analysis || ''
      }
    };
  } catch (error) {
    console.error('分析消息情感失败:', error);
    return {
      success: false,
      error: error.message
    };
  }
}情感响应增强机制通过分析用户消息的情感，为AI角色提供情感响应指导，使回复更加共情和有针对性。

3. 对话策略优化
实现了对话策略优化机制，根据对话阶段和用户需求调整回复策略：// 对话策略优化
function optimizeDialogueStrategy(dialogueContext, userMessage) {
  // 分析对话阶段
  const dialogueStage = analyzeDialogueStage(dialogueContext);
  
  // 分析用户需求
  const userNeeds = analyzeUserNeeds(userMessage, dialogueContext);
  
  // 根据对话阶段和用户需求调整参数
  const parameters = {};
  
  // 根据对话阶段调整参数
  switch (dialogueStage) {
    case 'initial': // 初始阶段
      // 提高创造性，增加互动性
      parameters.temperature = 0.8;
      parameters.presence_penalty = 0.7;
      break;
    case 'exploration': // 探索阶段
      // 平衡创造性和一致性
      parameters.temperature = 0.7;
      parameters.presence_penalty = 0.6;
      break;
    case 'deepening': // 深入阶段
      // 降低创造性，增加一致性和相关性
      parameters.temperature = 0.5;
      parameters.presence_penalty = 0.4;
      break;
    case 'conclusion': // 结束阶段
      // 降低创造性，增加总结性
      parameters.temperature = 0.4;
      parameters.presence_penalty = 0.3;
      break;
  }
  
  // 根据用户需求调整参数
  if (userNeeds.includes('information')) {
    // 信息需求：降低创造性，提高准确性
    parameters.temperature = Math.min(parameters.temperature, 0.4);
  }
  
  if (userNeeds.includes('emotional_support')) {
    // 情感支持需求：提高共情性
    parameters.temperature = Math.max(parameters.temperature, 0.7);
  }
  
  if (userNeeds.includes('creative_ideas')) {
    // 创意需求：提高创造性
    parameters.temperature = Math.max(parameters.temperature, 0.8);
  }
  
  if (userNeeds.includes('decision_making')) {
    // 决策需求：平衡创造性和结构性
    parameters.temperature = 0.6;
  }
  
  return parameters;
}

// 分析对话阶段
function analyzeDialogueStage(dialogueContext) {
  // 如果没有上下文或上下文很少，认为是初始阶段
  if (!dialogueContext || dialogueContext.length <= 2) {
    return 'initial';
  }
  
  // 根据对话轮数判断阶段
  const userTurns = dialogueContext.filter(msg => msg.role === 'user').length;
  
  if (userTurns <= 2) {
    return 'initial';
  } else if (userTurns <= 5) {
    return 'exploration';
  } else if (userTurns <= 10) {
    return 'deepening';
  } else {
    return 'conclusion';
  }
}

// 分析用户需求
function analyzeUserNeeds(userMessage, dialogueContext) {
  const needs = [];
  
  // 信息需求特征
  const informationPatterns = [
    /(?:什么是|如何|为什么|怎么|请介绍|能否解释|告诉我关于)/,
    /(?:信息|资料|数据|详情|例子|定义|概念)/
  ];
  
  // 情感支持需求特征
  const emotionalSupportPatterns = [
    /(?:难过|伤心|焦虑|担心|害怕|压力|困扰|烦恼|痛苦|失望)/,
    /(?:感觉|感到|觉得|心情|情绪|心理)/,
    /(?:安慰|支持|理解|倾听|帮助)/
  ];
  
  // 创意需求特征
  const creativeIdeasPatterns = [
    /(?:创意|想法|建议|点子|灵感|新颖|独特|创新)/,
    /(?:能否提供|有什么|可以给我)/
  ];
  
  // 决策需求特征
  const decisionMakingPatterns = [
    /(?:选择|决定|抉择|纠结|犹豫|不确定)/,
    /(?:应该|该不该|是否要|利弊|优缺点|比较)/
  ];
  
  // 检查信息需求
  if (informationPatterns.some(pattern => pattern.test(userMessage))) {
    needs.push('information');
  }
  
  // 检查情感支持需求
  if (emotionalSupportPatterns.some(pattern => pattern.test(userMessage))) {
    needs.push('emotional_support');
  }
  
  // 检查创意需求
  if (creativeIdeasPatterns.some(pattern => pattern.test(userMessage))) {
    needs.push('creative_ideas');
  }
  
  // 检查决策需求
  if (decisionMakingPatterns.some(pattern => pattern.test(userMessage))) {
    needs.push('decision_making');
  }
  
  // 如果没有检测到明确需求，根据上下文推断
  if (needs.length === 0 && dialogueContext && dialogueContext.length > 0) {
    // 获取最近的AI回复
    const lastAiMessage = [...dialogueContext].reverse().find(msg => msg.role === 'assistant');
    
    if (lastAiMessage) {
      // 如果AI提出了问题，用户可能是在回答
      if (/\?|？|吗|呢/.test(lastAiMessage.content)) {
        // 用户可能在回答问题，继续之前的对话主题
        const prevNeeds = inferNeedsFromContext(dialogueContext);
        needs.push(...prevNeeds);
      }
    }
  }
  
  // 如果仍然没有检测到需求，默认为对话交流
  if (needs.length === 0) {
    needs.push('conversation');
  }
  
  return needs;
}

// 从上下文推断需求
function inferNeedsFromContext(dialogueContext) {
  // 简化版：检查最近几轮对话
  const recentMessages = dialogueContext.slice(-4);
  const recentContent = recentMessages.map(msg => msg.content).join(' ');
  
  const needs = [];
  
  // 检查各类需求特征
  if (/(?:什么是|如何|为什么|怎么|请介绍|能否解释|告诉我关于|信息|资料|数据|详情|例子|定义|概念)/.test(recentContent)) {
    needs.push('information');
  }
  
  if (/(?:难过|伤心|焦虑|担心|害怕|压力|困扰|烦恼|痛苦|失望|感觉|感到|觉得|心情|情绪|心理|安慰|支持|理解|倾听|帮助)/.test(recentContent)) {
    needs.push('emotional_support');
  }
  
  if (/(?:创意|想法|建议|点子|灵感|新颖|独特|创新|能否提供|有什么|可以给我)/.test(recentContent)) {
    needs.push('creative_ideas');
  }
  
  if (/(?:选择|决定|抉择|纠结|犹豫|不确定|应该|该不该|是否要|利弊|优缺点|比较)/.test(recentContent)) {
    needs.push('decision_making');
  }
  
  // 如果没有检测到特定需求，默认为对话交流
  if (needs.length === 0) {
    needs.push('conversation');
  }
  
  return needs;
}对话策略优化机制通过分析对话阶段和用户需求，动态调整生成参数，使AI回复更加符合当前对话情境和用户期望。

4. 流式输出优化
实现了流式输出优化机制，提高用户体验：// 流式输出处理
async function streamingOutput(request, onChunk) {
  try {
    // 添加流式输出参数
    const streamingRequest = {
      ...request,
      stream: true
    };
    
    // 调用智谱AI流式API
    const response = await callZhipuAPIStreaming('chat/completions', streamingRequest);
    
    let fullContent = '';
    
    // 处理流式响应
    for await (const chunk of response) {
      // 解析chunk
      const content = parseStreamChunk(chunk);
      
      if (content) {
        fullContent += content;
        
        // 回调函数处理chunk
        if (onChunk) {
          onChunk(content, fullContent);
        }
      }
    }
    
    return fullContent;
  } catch (error) {
    console.error('流式输出处理失败:', error);
    throw error;
  }
}

// 解析流式响应chunk
function parseStreamChunk(chunk) {
  try {
    // 解析JSON
    const data = JSON.parse(chunk);
    
    // 提取内容
    if (data.choices && data.choices[0] && data.choices[0].delta && data.choices[0].delta.content) {
      return data.choices[0].delta.content;
    }
    
    return '';
  } catch (error) {
    console.error('解析流式响应chunk失败:', error);
    return '';
  }
}

// 调用智谱AI流式API
async function callZhipuAPIStreaming(endpoint, data) {
  // 获取API密钥
  const apiKey = process.env.ZHIPU_API_KEY;
  if (!apiKey) {
    throw new Error('未设置ZHIPU_API_KEY环境变量');
  }
  
  // 构建请求
  const url = `https://open.bigmodel.cn/api/paas/v4/${endpoint}`;
  const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${apiKey}`
  };
  
  // 发送请求
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });
  
  // 检查响应状态
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`API请求失败: ${response.status} ${errorText}`);
  }
  
  // 返回可迭代的流
  return streamAsyncIterator(response.body);
}

// 将流转换为异步迭代器
function streamAsyncIterator(stream) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  
  return {
    async *[Symbol.asyncIterator]() {
      try {
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }
          
          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split('\n').filter(line => line.trim() !== '');
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') {
                return;
              }
              yield data;
            } else {
              yield line;
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
    }
  };
}流式输出优化机制通过流式API调用和异步迭代器处理，实现了AI回复的实时输出，提高了用户体验，特别是在长回复场景下。

角色对话生成集成
将以上各个模块集成，实现完整的角色对话生成功能：// 角色对话生成主函数
async function generateRoleDialogue(roleId, userId, chatId, userMessage, options = {}) {
  try {
    // 初始化角色
    const roleData = await initializeRole(roleId);
    let systemPrompt = roleData.systemPrompt;
    
    // 获取对话上下文
    let dialogueContext = await getDialogueContext(chatId);
    
    // 管理上下文长度
    dialogueContext = manageContextLength(dialogueContext);
    
    // 集成用户画像
    systemPrompt = await integrateUserProfile(userId, systemPrompt);
    
    // 集成角色记忆
    const roleMemory = new RoleMemory(roleId, userId);
    await roleMemory.initialize();
    systemPrompt += roleMemory.generateMemoryPrompt();
    
    // 增强情感响应
    systemPrompt = await enhanceEmotionalResponse(userMessage, dialogueContext, systemPrompt);
    
    // 优化对话策略
    const parameters = optimizeDialogueStrategy(dialogueContext, userMessage);
    
    // 构建对话生成请求
    const request = buildChatRequest(systemPrompt, dialogueContext, userMessage, parameters);
    
    // 生成回复
    let aiReply = '';
    
    if (options.streaming) {
      // 流式输出
      aiReply = await streamingOutput(request, options.onChunk);
    } else {
      // 普通输出
      aiReply = await generateReply(request);
    }
    
    // 保存对话
    await saveDialogue(chatId, userId, roleId, userMessage, aiReply);
    
    // 提取记忆信息
    setTimeout(() => {
      extractMemoryInfo(chatId, userId, roleId).catch(console.error);
    }, 100);
    
    return {
      success: true,
      reply: aiReply
    };
  } catch (error) {
    console.error('生成角色对话失败:', error);
    return {
      success: false,
      error: error.message || '生成对话失败',
      reply: '抱歉，我遇到了一些问题，无法正常回复。请稍后再试。'
    };
  }
}角色对话生成主函数集成了角色初始化、对话上下文管理、用户画像集成、角色记忆、情感响应增强、对话策略优化等模块，实现了完整的角色对话生成功能。

角色对话生成应用
心语精灵的角色对话生成算法在以下场景中发挥重要作用：

1. 情感陪伴
通过精心设计的角色和高质量的对话生成，为用户提供情感陪伴和支持：// 情感陪伴角色设计
const emotionalSupportRoles = [
  {
    name: '温暖倾听者',
    background: '一位富有同理心的心理支持者，善于倾听和理解他人的情感需求。',
    personality: '温和、耐心、善解人意，具有很强的共情能力。',
    expertise: '情感支持、积极倾听、情绪管理',
    speaking_style: '温暖亲切，语言简单直接但富有感染力，常使用鼓励和肯定的表达。',
    interaction_mode: '以用户为中心，专注于理解用户的情感需求，提供无条件的积极关注。'
  },
  {
    name: '理性分析师',
    background: '一位逻辑清晰的思考者，擅长帮助他人理清思路和解决问题。',
    personality: '冷静、客观、理性，同时保持适度的温暖和支持。',
    expertise: '逻辑分析、问题解决、理性思考',
    speaking_style: '清晰简洁，条理分明，善于使用类比和比喻来解释复杂概念。',
    interaction_mode: '引导用户进行理性分析，帮助用户看清问题本质，找到解决方案。'
  }
  // 更多角色...
];2. 情商提升
通过角色对话和情感反馈，帮助用户提升情商能力// 情商提升功能
async function provideEQInsights(userId, emotionRecords) {
  try {
    // 分析情绪模式
    const emotionPatterns = analyzeEmotionPatterns(emotionRecords);
    
    // 构建提示词
    const prompt = `
作为一位情商教练，请基于以下用户的情绪模式，提供有助于提升情商的个性化建议：

情绪模式：
${JSON.stringify(emotionPatterns, null, 2)}

请提供以下方面的建议：
1. 情绪识别能力提升
2. 情绪管理技巧
3. 人际关系中的情绪应用
4. 自我激励方法

请确保建议具体、实用、个性化，并以鼓励的语气表达。
`;

    // 调用大语言模型生成建议
    const response = await callZhipuAPI('chat/completions', {
      model: 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一位专业的情商教练，擅长帮助人们提升情绪智能。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.7
    });
    
    // 提取建议
    const insights = response.choices[0].message.content;
    
    return {
      success: true,
      insights: insights
    };
  } catch (error) {
    console.error('生成情商洞察失败:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// 分析情绪模式
function analyzeEmotionPatterns(emotionRecords) {
  // 情绪类型分布
  const emotionTypes = {};
  emotionRecords.forEach(record => {
    const type = record.primary;
    emotionTypes[type] = (emotionTypes[type] || 0) + 1;
  });
  
  // 情绪强度分析
  const intensities = emotionRecords.map(record => record.intensity);
  const avgIntensity = intensities.reduce((sum, val) => sum + val, 0) / intensities.length;
  
  // 情绪波动分析
  const volatility = calculateStandardDeviation(intensities);
  
  // 情绪触发词分析
  const triggerWords = {};
  emotionRecords.forEach(record => {
    if (record.keywords) {
      record.keywords.forEach(keyword => {
        if (!triggerWords[keyword.word]) {
          triggerWords[keyword.word] = {
            count: 0,
            emotions: {}
          };
        }
        
        triggerWords[keyword.word].count++;
        
        const emotion = keyword.emotion || record.primary;
        triggerWords[keyword.word].emotions[emotion] = (triggerWords[keyword.word].emotions[emotion] || 0) + 1;
      });
    }
  });
  
  // 排序触发词
  const sortedTriggers = Object.entries(triggerWords)
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 10)
    .map(([word, data]) => ({
      word,
      count: data.count,
      emotions: data.emotions
    }));
  
  return {
    distribution: emotionTypes,
    averageIntensity: avgIntensity,
    volatility: volatility,
    topTriggers: sortedTriggers
  };
}通过以上角色对话生成算法的设计与实现，心语精灵能够提供高质量的角色对话体验，为用户提供情感陪伴和情商提升服务，实现了应用的核心功能。
# 3.3.2 对话生成与情感分析模型

心语精灵的核心AI能力主要依赖于智谱AI的GLM-4-Flash和Embedding-3模型，实现了高质量的对话生成和精准的情感分析。本节详细介绍这些模型的特性、应用方式和优化策略。

## 对话生成模型

### GLM-4-Flash模型特性

心语精灵选择智谱AI的GLM-4-Flash模型作为对话生成的核心模型，该模型具有以下特性：

**1. 强大的中文理解与生成能力**

GLM-4-Flash模型在中文语料上进行了大规模预训练，具有出色的中文理解和生成能力。相比其他大语言模型，GLM-4-Flash在中文语境下表现更为自然流畅，能够理解复杂的中文表达和文化背景。

**2. 上下文理解能力**

GLM-4-Flash模型支持长上下文理解，能够在多轮对话中保持连贯性和一致性。模型可以记住之前的对话内容，理解对话的发展脉络，从而生成符合上下文的回复。

**3. 角色扮演能力**

GLM-4-Flash模型具有出色的角色扮演能力，能够根据给定的角色设定生成符合角色特性的回复。这一特性对于心语精灵的AI角色扮演功能至关重要，使得AI角色能够展现出独特的性格和专业背景。

**4. 情感理解能力**

GLM-4-Flash模型能够理解文本中的情感表达，识别用户的情绪状态，并给予适当的情感回应。这一能力使得AI角色能够展现出共情能力，为用户提供情感支持。

### 对话生成实现

心语精灵的对话生成功能主要通过`chat`云函数实现，核心流程如下：

**1. 角色提示词设计**

角色提示词是实现AI角色扮演的关键，心语精灵设计了结构化的角色提示词模板：

```javascript
// 角色提示词模板
const rolePromptTemplate = `
你是一个名为"{name}"的AI角色，具有以下特性：

背景：{background}
性格：{personality}
专长：{expertise}
说话风格：{speaking_style}

在对话中，你应该：
1. 始终保持角色一致性，不要暴露你是AI的事实
2. 根据你的性格和背景做出反应
3. 使用你的专长知识来帮助用户
4. 保持你独特的说话风格
5. 展现共情能力，理解并回应用户的情感

用户信息：{user_profile}

请记住，你的目标是为用户提供情感支持和陪伴，帮助用户表达和理解自己的情感。
`;
```

**2. 对话上下文管理**

为了保持对话的连贯性，心语精灵实现了对话上下文管理机制：

```javascript
// 对话上下文管理
async function getDialogueContext(chatId, maxMessages = 10) {
  try {
    // 查询最近的消息记录
    const messagesResult = await db.collection('messages')
      .where({ chatId: chatId })
      .orderBy('createTime', 'desc')
      .limit(maxMessages)
      .get();
    
    // 按时间正序排列
    const messages = messagesResult.data.reverse();
    
    // 转换为GLM-4-Flash模型所需的格式
    return messages.map(msg => ({
      role: msg.sender === 'user' ? 'user' : 'assistant',
      content: msg.content
    }));
  } catch (error) {
    console.error('获取对话上下文失败:', error);
    return [];
  }
}
```

**3. 对话生成请求构建**

基于角色提示词和对话上下文，构建对话生成请求：

```javascript
// 构建对话生成请求
async function buildChatRequest(roleInfo, userMessage, dialogueContext, userProfile) {
  // 填充角色提示词模板
  const systemPrompt = rolePromptTemplate
    .replace('{name}', roleInfo.name)
    .replace('{background}', roleInfo.background || '无特定背景')
    .replace('{personality}', roleInfo.personality || '友好、耐心')
    .replace('{expertise}', roleInfo.expertise || '日常交流')
    .replace('{speaking_style}', roleInfo.speaking_style || '自然、流畅')
    .replace('{user_profile}', userProfile || '无特定信息');
  
  // 构建消息数组
  const messages = [
    { role: 'system', content: systemPrompt }
  ];
  
  // 添加对话上下文
  if (dialogueContext && dialogueContext.length > 0) {
    messages.push(...dialogueContext);
  }
  
  // 添加当前用户消息
  messages.push({ role: 'user', content: userMessage });
  
  return {
    model: 'glm-4-flash',
    messages: messages,
    temperature: 0.7,
    top_p: 0.9,
    max_tokens: 2000
  };
}
```

**4. 对话生成与保存**

调用智谱AI API生成回复，并保存对话记录：

```javascript
// 生成回复并保存对话记录
async function generateAndSaveReply(chatId, userId, roleId, userMessage, aiReply) {
  const db = cloud.database();
  const _ = db.command;
  
  try {
    // 开始事务
    const transaction = await db.startTransaction();
    
    // 保存用户消息
    await transaction.collection('messages').add({
      data: {
        chatId: chatId,
        userId: userId,
        roleId: roleId,
        content: userMessage,
        sender: 'user',
        createTime: db.serverDate()
      }
    });
    
    // 保存AI回复
    await transaction.collection('messages').add({
      data: {
        chatId: chatId,
        userId: userId,
        roleId: roleId,
        content: aiReply,
        sender: 'assistant',
        createTime: db.serverDate()
      }
    });
    
    // 更新会话信息
    await transaction.collection('chats').doc(chatId).update({
      data: {
        last_message: aiReply,
        message_count: _.inc(2),
        updateTime: db.serverDate()
      }
    });
    
    // 提交事务
    await transaction.commit();
    
    return true;
  } catch (error) {
    console.error('保存对话记录失败:', error);
    return false;
  }
}
```

### 对话生成优化

为提高对话生成质量，心语精灵实现了以下优化策略：

**1. 角色记忆机制**

实现了角色记忆机制，使AI角色能够记住用户的重要信息和偏好：

```javascript
// 角色记忆机制
async function updateRoleMemory(roleId, userId, key, value) {
  try {
    const db = cloud.database();
    const _ = db.command;
    
    // 查询现有记忆
    const memoryResult = await db.collection('role_memories')
      .where({
        roleId: roleId,
        userId: userId
      })
      .get();
    
    if (memoryResult.data.length > 0) {
      // 更新现有记忆
      const memoryId = memoryResult.data[0]._id;
      const memories = memoryResult.data[0].memories || {};
      
      memories[key] = value;
      
      await db.collection('role_memories').doc(memoryId).update({
        data: {
          memories: memories,
          updateTime: db.serverDate()
        }
      });
    } else {
      // 创建新记忆
      await db.collection('role_memories').add({
        data: {
          roleId: roleId,
          userId: userId,
          memories: { [key]: value },
          createTime: db.serverDate(),
          updateTime: db.serverDate()
        }
      });
    }
    
    return true;
  } catch (error) {
    console.error('更新角色记忆失败:', error);
    return false;
  }
}
```

**2. 提示词优化**

通过不断测试和优化角色提示词，提高对话生成质量：

- 增加具体的行为指导，如"避免重复"、"提供开放性问题"等
- 添加情感响应指导，如"对悲伤情绪表达共情"、"对积极情绪给予鼓励"等
- 根据用户画像动态调整提示词，使回复更加个性化

**3. 参数调优**

针对不同类型的角色和对话场景，调整模型参数：

- 对于情感支持类角色，使用较高的temperature (0.7-0.8)，增加回复的情感丰富度
- 对于专业咨询类角色，使用较低的temperature (0.3-0.5)，保证回复的准确性和专业性
- 对于创意类角色，使用较高的top_p (0.9-0.95)，增加回复的创造性

## 情感分析模型

### 情感分析模型设计

心语精灵的情感分析功能同样基于GLM-4-Flash模型，通过精心设计的提示词实现了高精度的情感分析。

**1. 情感分类体系**

设计了七类基本情感分类体系：

- 喜悦 (Joy)：包括快乐、满足、兴奋等积极情绪
- 悲伤 (Sadness)：包括伤心、失落、沮丧等消极情绪
- 愤怒 (Anger)：包括生气、恼火、愤怒等攻击性情绪
- 恐惧 (Fear)：包括害怕、担忧、焦虑等威胁感知情绪
- 惊讶 (Surprise)：包括震惊、意外、惊奇等突发情绪
- 厌恶 (Disgust)：包括反感、讨厌、鄙视等排斥情绪
- 中性 (Neutral)：情绪不明显或平静状态

**2. 情感分析提示词**

设计了结构化的情感分析提示词：

```javascript
// 情感分析提示词
const emotionAnalysisPrompt = `
分析以下文本中表达的情感，返回JSON格式：
文本："{text}"

请返回以下字段：
1. primary_emotion: 主要情绪类型 (喜悦、悲伤、愤怒、恐惧、惊讶、厌恶、中性)
2. secondary_emotion: 次要情绪类型 (如果有)
3. intensity: 情绪强度 (0.0-1.0)
4. keywords: 情绪关键词数组，每个元素包含word和weight
5. analysis: 简短的情绪分析描述
6. suggestions: 基于情绪状态的建议数组

确保返回的是有效的JSON格式。
`;
```

### 情感分析实现

情感分析功能主要通过`analysis`云函数实现，核心流程如下：

**1. 文本预处理**

对用户输入的文本进行预处理，包括去除特殊字符、分词等：

```javascript
// 文本预处理
function preprocessText(text) {
  // 去除多余空白字符
  text = text.replace(/\s+/g, ' ').trim();
  
  // 去除特殊字符
  text = text.replace(/[^\w\s\u4e00-\u9fa5]/g, ' ');
  
  // 限制文本长度
  if (text.length > 500) {
    text = text.substring(0, 500);
  }
  
  return text;
}
```

**2. 情感分析请求构建**

构建情感分析请求，包括提示词和参数设置：

```javascript
// 构建情感分析请求
function buildEmotionAnalysisRequest(text) {
  // 填充提示词模板
  const prompt = emotionAnalysisPrompt.replace('{text}', text);
  
  return {
    model: 'glm-4-flash',
    messages: [
      { role: 'system', content: '你是一个专业的情感分析助手，能够准确分析文本中表达的情感。' },
      { role: 'user', content: prompt }
    ],
    temperature: 0.3,
    response_format: { type: 'json_object' }
  };
}
```

**3. 结果解析与标准化**

解析API返回的JSON结果，并进行标准化处理：

```javascript
// 解析和标准化情感分析结果
function parseEmotionResult(content) {
  try {
    // 解析JSON
    const result = JSON.parse(content);
    
    // 标准化情绪类型
    const standardEmotions = {
      '喜悦': 'joy',
      '悲伤': 'sadness',
      '愤怒': 'anger',
      '恐惧': 'fear',
      '惊讶': 'surprise',
      '厌恶': 'disgust',
      '中性': 'neutral'
    };
    
    // 标准化主要情绪
    const primaryEmotion = standardEmotions[result.primary_emotion] || 'neutral';
    
    // 标准化次要情绪
    let secondaryEmotion = null;
    if (result.secondary_emotion && result.secondary_emotion !== result.primary_emotion) {
      secondaryEmotion = standardEmotions[result.secondary_emotion] || null;
    }
    
    // 标准化情绪强度
    const intensity = parseFloat(result.intensity) || 0.5;
    
    // 标准化关键词
    const keywords = Array.isArray(result.keywords) ? result.keywords : [];
    
    return {
      type: primaryEmotion,
      secondary: secondaryEmotion,
      intensity: intensity,
      keywords: keywords,
      analysis: result.analysis || '',
      suggestions: result.suggestions || []
    };
  } catch (error) {
    console.error('解析情感分析结果失败:', error);
    return {
      type: 'neutral',
      intensity: 0.5,
      keywords: [],
      analysis: '无法解析情感分析结果',
      suggestions: []
    };
  }
}
```

### 情感分析优化

为提高情感分析准确性，心语精灵实现了以下优化策略：

**1. 上下文感知分析**

考虑对话上下文进行情感分析，提高分析准确性：

```javascript
// 上下文感知情感分析
async function contextAwareEmotionAnalysis(text, chatId) {
  try {
    // 获取最近的对话历史
    const historyResult = await db.collection('messages')
      .where({ chatId: chatId })
      .orderBy('createTime', 'desc')
      .limit(5)
      .get();
    
    // 提取历史消息文本
    const historyTexts = historyResult.data
      .filter(msg => msg.sender === 'user')
      .map(msg => msg.content)
      .reverse();
    
    // 构建带上下文的分析提示词
    let contextPrompt = '考虑以下对话历史和当前消息，分析用户的情感状态：\n\n';
    
    if (historyTexts.length > 0) {
      contextPrompt += '历史消息：\n';
      historyTexts.forEach((msg, index) => {
        contextPrompt += `[${index + 1}] ${msg}\n`;
      });
      contextPrompt += '\n';
    }
    
    contextPrompt += `当前消息：${text}\n\n`;
    contextPrompt += emotionAnalysisPrompt;
    
    // 构建请求
    const request = {
      model: 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一个专业的情感分析助手，能够准确分析对话中的情感变化。' },
        { role: 'user', content: contextPrompt }
      ],
      temperature: 0.3,
      response_format: { type: 'json_object' }
    };
    
    // 调用API
    const response = await callZhipuAPI('chat/completions', request);
    
    // 解析结果
    const content = response.choices[0].message.content;
    return parseEmotionResult(content);
  } catch (error) {
    console.error('上下文感知情感分析失败:', error);
    // 回退到基础情感分析
    return basicEmotionAnalysis(text);
  }
}
```

**2. 情感变化跟踪**

实现情感变化跟踪机制，分析用户情绪的变化趋势：

```javascript
// 情感变化跟踪
async function trackEmotionChanges(userId, newEmotion) {
  try {
    // 获取用户最近的情感记录
    const recordsResult = await db.collection('emotionRecords')
      .where({ userId: userId })
      .orderBy('timestamp', 'desc')
      .limit(10)
      .get();
    
    const records = recordsResult.data;
    
    // 如果没有历史记录，直接返回当前情感
    if (records.length === 0) {
      return {
        current: newEmotion,
        trend: 'stable',
        changes: []
      };
    }
    
    // 提取情感变化
    const emotionChanges = records.map(record => ({
      type: record.primary,
      intensity: record.emotions[record.primary] || 0.5,
      timestamp: record.timestamp
    }));
    
    // 添加当前情感
    emotionChanges.unshift({
      type: newEmotion.type,
      intensity: newEmotion.intensity,
      timestamp: new Date()
    });
    
    // 分析情感趋势
    const trend = analyzeEmotionTrend(emotionChanges);
    
    return {
      current: newEmotion,
      trend: trend,
      changes: emotionChanges
    };
  } catch (error) {
    console.error('跟踪情感变化失败:', error);
    return {
      current: newEmotion,
      trend: 'unknown',
      changes: []
    };
  }
}

// 分析情感趋势
function analyzeEmotionTrend(emotionChanges) {
  // 情感极性映射
  const polarityMap = {
    'joy': 1,
    'surprise': 0.5,
    'neutral': 0,
    'fear': -0.5,
    'sadness': -1,
    'anger': -1,
    'disgust': -0.8
  };
  
  // 计算情感极性变化
  const polarities = emotionChanges.map(emotion => 
    (polarityMap[emotion.type] || 0) * emotion.intensity
  );
  
  // 计算趋势
  if (polarities.length < 2) {
    return 'stable';
  }
  
  // 计算最近三次情感的平均变化
  const recentChanges = [];
  for (let i = 0; i < Math.min(3, polarities.length - 1); i++) {
    recentChanges.push(polarities[i] - polarities[i + 1]);
  }
  
  const avgChange = recentChanges.reduce((sum, val) => sum + val, 0) / recentChanges.length;
  
  // 判断趋势
  if (avgChange > 0.3) {
    return 'improving';
  } else if (avgChange < -0.3) {
    return 'deteriorating';
  } else if (Math.abs(avgChange) <= 0.1) {
    return 'stable';
  } else if (avgChange > 0) {
    return 'slightly_improving';
  } else {
    return 'slightly_deteriorating';
  }
}
```

**3. 多模态情感分析**

结合文本和用户行为数据进行多模态情感分析：

- 分析用户的输入频率和长度变化
- 考虑用户的点击行为和页面停留时间
- 结合历史情感数据进行综合分析

通过以上对话生成和情感分析模型的设计与实现，心语精灵实现了高质量的AI对话和精准的情感分析，为用户提供了专业、个性化的情感陪伴服务。

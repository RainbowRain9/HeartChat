# 3.4.1 情感分析算法

情感分析是心语精灵的核心功能之一，通过分析用户文本中表达的情绪，为用户提供情感反馈和支持。本节详细介绍心语精灵的情感分析算法设计与实现。

## 情感分析模型设计

心语精灵的情感分析算法基于智谱AI的GLM-4-Flash大语言模型，结合自定义的情感分类体系和提示词工程，实现了高精度的情感识别和分析。

### 情感分类体系

心语精灵设计了一个七维情感分类体系，包括：

1. **喜悦 (Joy)**：包括快乐、满足、兴奋等积极情绪
2. **悲伤 (Sadness)**：包括伤心、失落、沮丧等消极情绪
3. **愤怒 (Anger)**：包括生气、恼火、愤怒等攻击性情绪
4. **恐惧 (Fear)**：包括害怕、担忧、焦虑等威胁感知情绪
5. **惊讶 (Surprise)**：包括震惊、意外、惊奇等突发情绪
6. **厌恶 (Disgust)**：包括反感、讨厌、鄙视等排斥情绪
7. **中性 (Neutral)**：情绪不明显或平静状态

这一分类体系基于心理学中的基本情绪理论[1]，并结合了情感计算领域的研究成果[2]，能够覆盖人类日常交流中的主要情感类型。

### 情感强度量化

除了情感类型外，心语精灵还对情感强度进行量化，使用0.0-1.0的浮点数表示情感强度：

- 0.0-0.2：微弱情绪，几乎不可察觉
- 0.2-0.4：轻度情绪，可以察觉但不明显
- 0.4-0.6：中度情绪，明显但不强烈
- 0.6-0.8：强烈情绪，情感表达明显
- 0.8-1.0：极强情绪，情感表达非常强烈

情感强度的量化使得系统能够更精细地描述用户的情感状态，为后续的情感变化分析提供基础。

## 情感分析算法流程

心语精灵的情感分析算法包括以下核心步骤：

### 1. 文本预处理

在进行情感分析前，首先对用户输入的文本进行预处理，包括：

```javascript
// 文本预处理函数
function preprocessText(text) {
  // 去除多余空白字符
  text = text.replace(/\s+/g, ' ').trim();
  
  // 去除特殊字符，但保留中文、英文、数字和基本标点
  text = text.replace(/[^\w\s\u4e00-\u9fa5.,!?;:'"()-]/g, ' ');
  
  // 限制文本长度，避免超出模型处理能力
  if (text.length > 500) {
    text = text.substring(0, 500);
  }
  
  return text;
}
```

预处理步骤确保了输入文本的规范性，减少了噪声对分析结果的影响。

### 2. 提示词构建

心语精灵设计了专门的情感分析提示词，引导大语言模型进行精准的情感分析：

```javascript
// 情感分析提示词构建
function buildEmotionPrompt(text) {
  return `
分析以下文本中表达的情感，返回JSON格式：
文本：${text}

请返回以下字段：
1. primary_emotion: 主要情绪类型 (喜悦、悲伤、愤怒、恐惧、惊讶、厌恶、中性)
2. secondary_emotion: 次要情绪类型 (如果有)
3. intensity: 情绪强度 (0.0-1.0)
4. keywords: 情绪关键词数组，每个元素包含word和weight
5. analysis: 简短的情绪分析描述
6. suggestions: 基于情绪状态的建议数组

确保返回的是有效的JSON格式。
`;
}
```

提示词设计采用了结构化输出指令，明确要求模型返回JSON格式的结果，包含情绪类型、强度、关键词等关键信息。

### 3. 上下文感知分析

为提高情感分析的准确性，心语精灵实现了上下文感知的情感分析算法，考虑用户的历史消息和对话背景：

```javascript
// 上下文感知情感分析
async function contextAwareEmotionAnalysis(text, chatId) {
  try {
    // 获取最近的对话历史
    const historyResult = await db.collection('messages')
      .where({ chatId: chatId })
      .orderBy('createTime', 'desc')
      .limit(5)
      .get();
    
    // 提取历史消息文本
    const historyTexts = historyResult.data
      .filter(msg => msg.sender === 'user')
      .map(msg => msg.content)
      .reverse();
    
    // 构建带上下文的分析提示词
    let contextPrompt = '考虑以下对话历史和当前消息，分析用户的情感状态：\n\n';
    
    if (historyTexts.length > 0) {
      contextPrompt += '历史消息：\n';
      historyTexts.forEach((msg, index) => {
        contextPrompt += `[${index + 1}] ${msg}\n`;
      });
      contextPrompt += '\n';
    }
    
    contextPrompt += `当前消息：${text}\n\n`;
    contextPrompt += buildEmotionPrompt(text);
    
    // 调用大语言模型进行分析
    const result = await callLLMForAnalysis(contextPrompt);
    return result;
  } catch (error) {
    console.error('上下文感知情感分析失败:', error);
    // 回退到基础情感分析
    return basicEmotionAnalysis(text);
  }
}
```

上下文感知分析通过考虑用户的历史消息，能够更准确地理解用户当前的情感状态，特别是在情感表达含蓄或依赖于前文的情况下。

### 4. 情感关键词提取

心语精灵的情感分析算法不仅识别情感类型和强度，还提取与情感相关的关键词：

```javascript
// 情感关键词提取与权重计算
function extractEmotionKeywords(text, emotion) {
  // 构建关键词提取提示词
  const prompt = `
从以下文本中提取与"${emotion}"情绪相关的关键词或短语，按重要性排序：
文本：${text}

请返回JSON格式：
{
  "keywords": [
    {"word": "关键词1", "weight": 0.9, "emotion": "${emotion}"},
    {"word": "关键词2", "weight": 0.8, "emotion": "${emotion}"},
    ...
  ]
}
`;

  // 调用大语言模型提取关键词
  return callLLMForKeywords(prompt);
}
```

情感关键词提取有助于理解用户情感的具体触发点和表达方式，为后续的用户画像构建和情感反馈提供依据。

### 5. 情感波动指数计算

心语精灵创新性地设计了情感波动指数算法，用于量化用户情感的变化趋势：

```javascript
// 情感波动指数计算
function calculateEmotionFluctuationIndex(emotionRecords, timeWindow = 7) {
  // 如果记录不足，返回默认值
  if (emotionRecords.length < 2) {
    return {
      index: 0,
      trend: 'stable',
      description: '数据不足，无法分析情感波动'
    };
  }
  
  // 情感极性映射
  const polarityMap = {
    'joy': 1,
    'surprise': 0.5,
    'neutral': 0,
    'fear': -0.5,
    'sadness': -1,
    'anger': -1,
    'disgust': -0.8
  };
  
  // 计算情感极性序列
  const polarities = emotionRecords.map(record => {
    const polarity = polarityMap[record.primary] || 0;
    return {
      polarity: polarity * record.intensity,
      timestamp: new Date(record.timestamp)
    };
  });
  
  // 按时间排序
  polarities.sort((a, b) => a.timestamp - b.timestamp);
  
  // 计算相邻时间点的情感变化
  const changes = [];
  for (let i = 1; i < polarities.length; i++) {
    const timeDiff = (polarities[i].timestamp - polarities[i-1].timestamp) / (1000 * 3600 * 24); // 转换为天
    if (timeDiff <= timeWindow) { // 只考虑时间窗口内的变化
      changes.push(Math.abs(polarities[i].polarity - polarities[i-1].polarity));
    }
  }
  
  // 计算情感波动指数
  const fluctuationIndex = changes.length > 0 ? 
    changes.reduce((sum, change) => sum + change, 0) / changes.length : 0;
  
  // 确定波动趋势
  let trend = 'stable';
  let description = '';
  
  if (fluctuationIndex < 0.2) {
    trend = 'stable';
    description = '情绪状态稳定';
  } else if (fluctuationIndex < 0.5) {
    trend = 'moderate';
    description = '情绪波动适中';
  } else {
    trend = 'volatile';
    description = '情绪波动较大';
  }
  
  return {
    index: parseFloat(fluctuationIndex.toFixed(2)),
    trend: trend,
    description: description
  };
}
```

情感波动指数算法通过计算用户情感极性的变化幅度，量化用户情绪的稳定性，为用户提供情绪管理的参考。

## 情感分析结果处理

情感分析的结果需要进行标准化处理，以便于存储和后续使用：

```javascript
// 情感分析结果标准化
function standardizeEmotionResult(result) {
  try {
    // 解析JSON结果
    const parsed = typeof result === 'string' ? JSON.parse(result) : result;
    
    // 标准化情绪类型
    const standardEmotions = {
      '喜悦': 'joy',
      '悲伤': 'sadness',
      '愤怒': 'anger',
      '恐惧': 'fear',
      '惊讶': 'surprise',
      '厌恶': 'disgust',
      '中性': 'neutral'
    };
    
    // 标准化主要情绪
    const primaryEmotion = standardEmotions[parsed.primary_emotion] || 'neutral';
    
    // 标准化次要情绪
    let secondaryEmotion = null;
    if (parsed.secondary_emotion && parsed.secondary_emotion !== parsed.primary_emotion) {
      secondaryEmotion = standardEmotions[parsed.secondary_emotion] || null;
    }
    
    // 标准化情绪强度
    const intensity = parseFloat(parsed.intensity) || 0.5;
    
    // 标准化关键词
    const keywords = Array.isArray(parsed.keywords) ? parsed.keywords : [];
    
    // 构建情绪分布对象
    const emotions = {
      joy: 0,
      sadness: 0,
      anger: 0,
      fear: 0,
      surprise: 0,
      disgust: 0,
      neutral: 0
    };
    
    // 设置主要情绪值
    emotions[primaryEmotion] = intensity;
    
    // 如果有次要情绪，设置次要情绪值
    if (secondaryEmotion) {
      emotions[secondaryEmotion] = Math.max(0, Math.min(intensity * 0.6, 0.8)); // 次要情绪强度为主要情绪的60%，但不超过0.8
    }
    
    // 返回标准化结果
    return {
      primary: primaryEmotion,
      secondary: secondaryEmotion,
      intensity: intensity,
      emotions: emotions,
      keywords: keywords,
      analysis: parsed.analysis || '',
      suggestions: parsed.suggestions || []
    };
  } catch (error) {
    console.error('标准化情感分析结果失败:', error);
    // 返回默认值
    return {
      primary: 'neutral',
      secondary: null,
      intensity: 0.5,
      emotions: { neutral: 0.5 },
      keywords: [],
      analysis: '无法解析情感分析结果',
      suggestions: []
    };
  }
}
```

标准化处理确保了情感分析结果的一致性和可用性，便于在数据库中存储和在前端展示。

## 情感分析数据存储

情感分析结果需要持久化存储，以便于历史回溯和趋势分析：

```javascript
// 情感分析结果存储
async function saveEmotionAnalysis(userId, chatId, messageId, text, result) {
  try {
    const db = cloud.database();
    
    // 构建记录数据
    const recordData = {
      userId: userId,
      chatId: chatId,
      messageId: messageId,
      text: text,
      primary: result.primary,
      secondary: result.secondary,
      intensity: result.intensity,
      emotions: result.emotions,
      keywords: result.keywords,
      analysis: result.analysis,
      suggestions: result.suggestions,
      timestamp: db.serverDate(),
      createTime: db.serverDate()
    };
    
    // 保存到数据库
    await db.collection('emotionRecords').add({
      data: recordData
    });
    
    // 更新消息记录，标记为已分析
    if (messageId) {
      await db.collection('messages').doc(messageId).update({
        data: {
          emotion_analyzed: true,
          emotion_type: result.primary,
          emotion_intensity: result.intensity
        }
      });
    }
    
    return true;
  } catch (error) {
    console.error('保存情感分析结果失败:', error);
    return false;
  }
}
```

情感分析数据的存储不仅支持了情感历史记录功能，还为用户画像构建和情感趋势分析提供了数据基础。

## 情感分析算法优化

为提高情感分析的准确性和效率，心语精灵实现了以下优化策略：

### 1. 提示词优化

通过大量测试和迭代，优化了情感分析提示词，提高了分析准确性：

- 添加具体的情感描述示例，帮助模型理解不同情感类型
- 使用结构化输出指令，确保返回格式一致的JSON结果
- 增加情感强度的量化指导，提高强度评估的准确性

### 2. 批量分析优化

实现了批量情感分析功能，提高处理效率：

```javascript
// 批量情感分析
async function batchEmotionAnalysis(messages, userId) {
  // 分批处理，每批5条消息
  const batchSize = 5;
  const batches = [];
  
  for (let i = 0; i < messages.length; i += batchSize) {
    batches.push(messages.slice(i, i + batchSize));
  }
  
  // 并行处理每批消息
  const results = [];
  for (const batch of batches) {
    const batchPromises = batch.map(msg => 
      basicEmotionAnalysis(msg.content).then(result => ({
        messageId: msg._id,
        chatId: msg.chatId,
        text: msg.content,
        result: result
      }))
    );
    
    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
    
    // 避免API限流，批次间添加延迟
    if (batches.indexOf(batch) < batches.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  // 保存分析结果
  for (const item of results) {
    await saveEmotionAnalysis(
      userId,
      item.chatId,
      item.messageId,
      item.text,
      item.result
    );
  }
  
  return results;
}
```

批量分析功能使得系统能够高效处理历史消息，为用户提供完整的情感历史记录。

### 3. 缓存机制

实现了情感分析结果的缓存机制，避免重复分析：

```javascript
// 情感分析缓存
const emotionCache = {
  cache: new Map(),
  maxSize: 100,
  
  // 获取缓存
  get(text) {
    const key = this.generateKey(text);
    return this.cache.get(key);
  },
  
  // 设置缓存
  set(text, result) {
    const key = this.generateKey(text);
    
    // 如果缓存已满，删除最早的条目
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, result);
  },
  
  // 生成缓存键
  generateKey(text) {
    // 使用文本的前50个字符作为键的一部分
    const prefix = text.substring(0, 50);
    // 使用简单的哈希函数
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
      hash = ((hash << 5) - hash) + text.charCodeAt(i);
      hash |= 0; // 转换为32位整数
    }
    return `${prefix}_${hash}`;
  }
};
```

缓存机制减少了重复分析的计算资源消耗，提高了系统响应速度。

## 情感分析应用场景

心语精灵的情感分析算法在以下场景中发挥重要作用：

### 1. 实时情感反馈

在用户与AI角色对话过程中，系统实时分析用户的情感状态，使AI角色能够给予适当的情感回应。

### 2. 情感历史记录

系统记录用户的情感变化历史，通过图表直观展示情绪波动趋势，帮助用户了解自己的情绪模式。

### 3. 情感洞察报告

基于情感分析结果，系统生成个性化的情感洞察报告，提供情绪管理建议和自我认知提升。

### 4. 用户画像构建

情感分析结果是用户画像构建的重要输入，帮助系统了解用户的情感特征和偏好。

通过以上情感分析算法的设计与实现，心语精灵能够准确识别和分析用户的情感状态，为用户提供有针对性的情感支持和反馈，实现情感陪伴和情商提升的核心功能。

## 参考文献

[1] Ekman, P. (1992). An argument for basic emotions. Cognition & Emotion, 6(3-4), 169-200.

[2] Poria, S., Cambria, E., Bajpai, R., & Hussain, A. (2017). A review of affective computing: From unimodal analysis to multimodal fusion. Information Fusion, 37, 98-125.
